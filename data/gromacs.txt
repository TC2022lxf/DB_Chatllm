

##问题：请问使用什么指令可以设置盒子的尺寸，形状等参数呢？

回答：在GROMACS中，使用`editconf`命令可以设置盒子的尺寸、形状和其他参数。你可以通过指定不同的选项来设置盒子的尺寸和形状。以下是一些常用选项：

1. `-box`: 指定盒子的尺寸。格式为`-box X Y Z`，其中X、Y和Z分别是盒子的长、宽和高。

2. `-d`: 指定溶剂盒子与溶质之间的最小距离。

3. `-angles`: 指定盒子的角度。格式为`-angles α β γ`，其中α、β和γ分别是X、Y和Z轴之间的角度。

4. `-bt`: 指定盒子的形状。常用的选项包括`cubic`（立方体）、`triclinic`（斜方体）和`octahedron`（八面体）。

5. `-center`: 指定盒子的中心位置。

例如，要创建一个立方体盒子，尺寸为10 nm，并将其置于原点处，可以使用以下命令：
```
gmx editconf -f input.gro -o output.gro -box 10 10 10 -c
```
这将把输入文件`input.gro`中的分子放入一个边长为10 nm的立方体盒子中，并将盒子的中心置于原点。输出文件将保存为`output.gro`。
需要注意的是，`editconf`命令只是用来编辑坐标文件和设置盒子参数的工具，并不执行模拟。

一般情况下，我们建议使用`triclinic`（斜方体）
可以参考使用以下命令：
```
gmx editconf -f input.gro -o output.gro -box 10 10 10 -c -bt triclinic
```






##Question: What command can be used to adjust the dimensions and shape of the simulation box?

Answer:In GROMACS, the dimensions and shape of the simulation box can be adjusted using the editconf command. By employing various options, one can specify the size and shape of the box. Here are some commonly utilized options:

1. -box: This option is utilized to define the dimensions of the box. The format is -box X Y Z, where X, Y, and Z represent the length, width, and height of the box, respectively.

2. -d: This option specifies the minimum distance between the solvent box and the solute.

3. -angles: It allows for the specification of the angles of the box. The format is -angles α β γ, where α, β, and γ denote the angles between the X, Y, and Z axes, respectively.

4. -bt: This option determines the shape of the box. Common selections include cubic, triclinic, and octahedron.

5. -center: This option designates the central position of the box.

    For instance, to generate a cubic box with dimensions of 10 nm, centered at the origin, the following command can be employed:

    gmx editconf -f input.gro -o output.gro -box 10 10 10 -c

    This command will position the molecules from the input file input.gro within a cubic box having a side length of 10 nm, centered at the origin. The resulting file will be saved as output.gro.

    It is generally advisable to employ a triclinic box. The following command can be utilized:

    gmx editconf -f input.gro -o output.gro -box 10 10 10 -c -bt triclinic

    It should be noted that the editconf command is specifically designed for editing coordinate files and configuring box parameters, and does not directly engage in simulations.







##问题：请问我如何设置盒子的中心位置？一般系统默认盒子的中心位置在哪里？

回答：在GROMACS中，你可以使用`editconf`命令的`-center`选项来设置盒子的中心位置。你可以指定一个三维坐标，将盒子的中心移动到该位置。

    如果不指定中心位置，默认情况下，盒子的中心位置将会是原子坐标的中心点。这意味着盒子将围绕着体系中所有原子的中心放置，使得体系的质心位于盒子的中心。这通常是为了确保体系位于盒子的中心，以便在模拟中减少边界效应的影响。

    如果你想要将盒子的中心设置为特定的位置，你可以使用`-center`选项并提供所需的坐标值。例如，要将盒子的中心设置为坐标为(5, 5, 5)的点，可以使用以下命令：
```
    gmx editconf -f input.gro -o output.gro -center 5 5 5
```
    这将把输入文件`input.gro`中的分子放入一个以坐标(5, 5, 5)为中心的盒子中，并将盒子的尺寸和形状保持不变。




##Question: How can I set the center position of the simulation box? Where is the default center position of the box in general?

Answer: In GROMACS, you can use the -center option of the editconf command to set the center position of the simulation box. You can specify a three-dimensional coordinate to move the center of the box to that position.

    If you do not specify a center position, by default, the center position of the box will be the center point of the atomic coordinates. This means that the box will be placed around the center of all the atoms in the system, ensuring that the center of mass of the system is located at the center of the box. This is usually done to ensure that the system is positioned at the center of the box and minimize the impact of boundary effects in the simulation.

    If you want to set the center of the box to a specific position, you can use the -center option and provide the desired coordinate values. For example, to set the center of the box to the point with coordinates (5, 5, 5), you can use the following command:

    gmx editconf -f input.gro -o output.gro -center 5 5 5

    This command will place the molecules from the input file input.gro into a box centered at the coordinate (5, 5, 5), while keeping the size and shape of the box unchanged.










##问题：GROMACS是一款做什么的软件？

回答：GROMACS（GROningen MAchine for Chemical Simulations）是一款用于分子动力学模拟的开源软件。它被广泛用于模拟和研究生物分子、蛋白质、脂质体、核酸等在原子级别上的结构和动态行为。

GROMACS提供了一系列功能强大的工具和算法，可以模拟复杂的分子系统在不同环境中的行为。它可以计算分子间相互作用、模拟温度、压力等物理参数的变化，并生成关于分子结构、动力学、热力学性质等方面的详细信息。

GROMACS还提供了用于预处理、后处理和分析模拟结果的丰富工具集。它具有较高的计算效率和扩展性，可以在单个处理器或大规模并行计算机集群上运行，以实现高性能的分子动力学模拟。

该软件在生物物理、生物化学、药物研发和材料科学等领域中被广泛应用，为研究人员提供了深入理解分子级别的结构和动态行为的重要工具。




##Question: What is GROMACS software used for?

Answer: GROMACS (GROningen MAchine for Chemical Simulations) is an open-source software used for molecular dynamics simulations. It is widely employed to simulate and study the atomic-level structures and dynamic behaviors of biomolecules, proteins, lipid bilayers, nucleic acids, and other systems.

GROMACS provides a range of powerful tools and algorithms to simulate the behavior of complex molecular systems in different environments. It can calculate intermolecular interactions, simulate changes in physical parameters such as temperature and pressure, and generate detailed information regarding molecular structures, dynamics, and thermodynamic properties.

GROMACS also offers a rich toolkit for preprocessing, postprocessing, and analyzing simulation results. It exhibits high computational efficiency and scalability, capable of running on single processors or large-scale parallel computing clusters to achieve high-performance molecular dynamics simulations.

This software finds extensive applications in fields such as biophysics, biochemistry, drug discovery, and materials science, providing researchers with a vital tool to gain insights into the molecular-level structures and dynamic behaviors.













##问题：怎么下载GROMACS？

回答：您可以通过GROMACS官方网站下载GROMACS软件。具体步骤如下：

1. 打开GROMACS官方网站（http://www.gromacs.org/）。

2. 点击“Download”选项卡，进入下载页面。

3. 在下载页面中，选择适合您操作系统的版本，并根据您的需要选择下载源码或二进制包。GROMACS支持多种操作系统，如Linux、Mac OS X、Windows等。

4. 如果您下载的是源码包，您需要编译和安装GROMACS软件。请根据官方指南进行操作。

5. 如果您下载的是二进制包，您可以直接解压缩并使用GROMACS软件。

请注意，GROMACS是一款高级的分子动力学模拟软件，需要较高的计算机性能和专业的使用技能。在使用GROMACS前，请仔细阅读相关文献和教程，以了解其基本原理和使用方法。




##Question: How to download GROMACS?

Answer: You can download the GROMACS software from the official GROMACS website. The specific steps are as follows:

1. Open the official GROMACS website (http://www.gromacs.org/).

2. Click on the "Download" tab to access the download page.

3. On the download page, select the version that is compatible with your operating system and choose whether you want to download the source code or binary package, depending on your needs. GROMACS supports various operating systems such as Linux, Mac OS X, and Windows.

4. If you download the source code, you will need to compile and install the GROMACS software. Please refer to the official guide for instructions.

5. If you download the binary package, you can simply extract it and start using the GROMACS software.

    Please note that GROMACS is an advanced molecular dynamics simulation software that requires high computational resources and expertise. Before using GROMACS, it is advisable to read relevant literature and tutorials to understand its basic principles and usage methods.
















##问题：GROMACS一般的操作流程是什么？

回答：GROMACS是一款功能强大的分子动力学模拟软件，其一般的操作流程包括以下几个步骤：

1. 准备输入文件：在进行分子动力学模拟前，需要准备一系列输入文件，包括分子结构文件（如pdb或gro文件）、拓扑文件、模拟参数文件（如mdp文件）等。这些文件中包含了模拟所需的分子信息和模拟参数等。

2. 系统准备：在进行模拟前，需要对系统进行准备，包括将分子结构导入到模拟软件中，生成模拟系统的拓扑文件，定义分子的初始位置和速度等。

3. 模拟运行：设置好模拟条件后，通过执行模拟程序开始进行分子动力学模拟。在此过程中，模拟软件会计算分子间相互作用、模拟温度、压力等物理参数的变化，并输出分子的结构、动力学、热力学性质等信息。

4. 数据处理和分析：模拟结束后，需要对模拟结果进行处理和分析，以提取有用的信息。这些信息可以用于研究分子结构和动态行为，评估分子的稳定性和相互作用等。

    以上是GROMACS的一般操作流程，具体操作步骤会根据具体的模拟系统和研究目的而有所不同。在使用GROMACS进行分子动力学模拟前，需要对软件的基本原理和使用方法有一定的了解，并参考相关文献和教程进行操作。




##Question: What is the general operational workflow for GROMACS?

Answer: GROMACS is a powerful molecular dynamics simulation software, and its general operational workflow includes the following steps:

1. Preparation of input files: Before conducting molecular dynamics simulations, a series of input files need to be prepared, including molecular structure files (such as pdb or gro files), topology files, simulation parameter files (such as mdp files), and others. These files contain essential molecular information and simulation parameters required for the simulation.

2. System preparation: Prior to the simulation, the system needs to be prepared, involving importing the molecular structure into the simulation software, generating the topology file for the simulation system, defining initial positions and velocities of the molecules, and other related tasks.

3. Running the simulation: After setting up the simulation conditions, the molecular dynamics simulation is initiated by executing the simulation program. During this process, the simulation software computes intermolecular interactions, simulates temperature and pressure changes, and outputs structural, dynamic, and thermodynamic properties of the molecules.

4. Data processing and analysis: Upon completion of the simulation, the simulation results need to be processed and analyzed to extract useful information. This information can be utilized to study molecular structure and dynamic behaviors, evaluate the stability and interactions of the molecules, and more.

    The aforementioned steps outline the general operational workflow of GROMACS. Specific operational procedures may vary based on the particular simulation system and research objectives. Prior to conducting molecular dynamics simulations using GROMACS, it is essential to have a fundamental understanding of the software's principles and usage methods, and to refer to relevant literature and tutorials for guidance.











##问题：请问我该如何选定或者构建盒子的形状？

回答：选定和构建盒子的形状是进行分子动力学模拟前的重要步骤，以下是一些常见的方法和建议：

1. 盒子类型：首先确定您希望使用的盒子类型。常见的盒子类型包括正交盒子、三角晶胞（triclinic）、球形盒子等。正交盒子是最常见的盒子类型，适用于大多数模拟系统。
    具体的命令可以参照以下命令来修改：
    -命令：gmx editconf -f complex.gro -o newbox.gro -bt dodecahedron 
                 gmx solvate -cp newbox.gro -cs spc216.gro -p topol.top -o solv.gro

2. 盒子尺寸：根据您的模拟系统和研究目的，选择适当的盒子尺寸。盒子的尺寸应足够大，以确保分子在模拟中有足够的运动空间，并避免周期性边界条件对模拟结果的影响。通常建议在分子周围保留一定的溶剂或缓冲区域。
    具体的命令可以参照以下命令来修改：
    -命令：gmx editconf -f complex.gro -o newbox.gro -bt dodecahedron -d 1.0

3. 盒子形状调整：根据您的模拟系统，您可能需要对盒子形状进行调整。例如，如果您的系统具有非常特殊的形状或对称性，您可以使用GROMACS提供的工具（如gmx editconf）来调整盒子的形状，以符合您的需求。

4. 盒子溶剂：如果您的模拟系统需要与溶剂相互作用，您可以将溶剂添加到盒子中。常见的溶剂包括水（如TIP3P、SPC等模型）、离子溶剂（如NaCl溶液）等。您可以使用GROMACS提供的工具（如gmx solvate）将溶剂添加到盒子中，并确保溶剂与分子之间的相互作用。
    具体的命令可以参照以下命令来修改：
    -命令：gmx solvate -cp newbox.gro -cs spc216.gro -p topol.top -o solv.gro

5. 盒子参数：在进行分子动力学模拟前，您还需要设置盒子的相关参数，如压力、温度等。您可以通过编辑模拟参数文件（如mdp文件）来设置这些参数。

    请注意，在选定和构建盒子形状时，确保您对所研究的系统和模拟条件有充分的了解，并参考相关文献和实验数据。此外，复杂的系统可能需要进行额外的优化和调整，以获得合理的盒子形状和参数设置。



##Question: How should I select or construct the shape of the simulation box?

Answer: Selecting and constructing the shape of the simulation box is a crucial step prior to performing molecular dynamics simulations. Below are some common methods and suggestions:

1. Box type: Begin by determining the type of box you wish to use. Common box types include orthogonal boxes, triclinic cells, spherical boxes, among others. Orthogonal boxes are the most commonly used and are suitable for most simulation systems.
Specific commands can be modified as follows:

    -Command: gmx editconf -f complex.gro -o newbox.gro -bt dodecahedron 
                          gmx solvate -cp newbox.gro -cs spc216.gro -p topol.top -o solv.gro

2. Box size: Choose an appropriate box size based on your simulation system and research objectives. The box size should be sufficiently large to ensure molecules have ample space for motion during the simulation and to avoid the influence of periodic boundary conditions on simulation results. It is generally recommended to include a solvent or buffer region around the molecules.
    Specific commands can be modified as follows:

    -Command: gmx editconf -f complex.gro -o newbox.gro -bt dodecahedron -d 1.0

3. Adjusting box shape: Depending on your simulation system, you may need to adjust the shape of the box. For instance, if your system has a unique shape or symmetry, you can use tools provided by GROMACS (such as gmx editconf) to adjust the box shape to meet your requirements.

4. Solvent in the box: If your simulation system requires interaction with a solvent, you can add the solvent to the box. Common solvents include water (models like TIP3P, SPC, etc.) and ion solvents (e.g., NaCl solution). You can use GROMACS tools (e.g., gmx solvate) to add the solvent to the box and ensure interactions between the solvent and molecules.
Specific commands can be modified as follows:

    -Command: gmx solvate -cp newbox.gro -cs spc216.gro -p topol.top -o solv.gro

5. Box parameters: Before conducting molecular dynamics simulations, you also need to set relevant parameters for the box, such as pressure, temperature, etc. You can set these parameters by editing the simulation parameter file (mdp file).

    When selecting and constructing the shape of the simulation box, ensure you have a comprehensive understanding of your system and simulation conditions, and consult relevant literature and experimental data. Additionally, complex systems may require additional optimization and adjustments to achieve reasonable box shapes and parameter settings.

















##问题：请问我该如何判断盒子构建的大小是否合适？

回答：判断盒子构建的大小是否合适通常需要考虑以下几个方面：

1. 分子尺寸：盒子大小应足够大，以便分子在模拟中有足够的运动空间。通常，建议在分子周围留出至少1 nm的缓冲区域，以确保分子不会与盒子边界相交。

2. 溶剂模型：如果您的系统需要溶剂，您需要根据所选的溶剂模型和密度确定盒子的大小。例如，对于TIP3P水模型，每个水分子大约占据0.3立方纳米的体积，因此，如果您想在盒子中包含1000个水分子，则需要至少使用300立方纳米的盒子。

3. 周期性边界条件（Periodic Boundary Conditions，PBCs）：PBCs是分子动力学模拟中常用的技术，可以在模拟中处理无限重复的空间，从而避免边界效应。在使用PBCs时，盒子的大小还应考虑周期性边界之间的相互作用。通常，建议将盒子的大小设置为周期性边界之间的最小距离的两倍以上。

4. 计算效率：盒子的大小也应考虑计算效率。过大的盒子会增加计算成本，而过小的盒子可能会导致模拟结果不准确。

    综上所述，判断盒子构建的大小是否合适需要综合考虑分子尺寸、溶剂模型、周期性边界条件和计算效率等因素。在选择和调整盒子大小时，建议参考相关文献和实验数据，并进行必要的优化和调整，以获得合理的盒子大小和参数设置。



##Question: How can I determine if the size of the simulation box is appropriate?

Answer: To determine if the size of the simulation box is appropriate, several factors should be considered:

1. Molecular size: The box size should be large enough to provide sufficient space for molecular motion during the simulation. It is generally recommended to leave a buffer region of at least 1 nm around the molecules to ensure they do not interact with the box boundaries.

2. Solvent model: If your system requires a solvent, the size of the box should be determined based on the selected solvent model and density. For example, for the TIP3P water model, each water molecule occupies approximately 0.3 cubic nanometers of volume. Therefore, if you want to include 1000 water molecules in the box, a box size of at least 300 cubic nanometers is required.

3. Periodic boundary conditions (PBCs): PBCs are commonly used in molecular dynamics simulations to handle infinitely repeating space and avoid boundary effects. When using PBCs, the box size should also consider interactions between periodic boundaries. It is generally recommended to set the box size to at least twice the minimum distance between periodic boundaries.

4. Computational efficiency: The box size should also consider computational efficiency. An excessively large box increases computational cost, while a box that is too small may lead to inaccurate simulation results.

    In summary, determining if the size of the simulation box is appropriate requires considering factors such as molecular size, solvent model, PBCs, and computational efficiency. When selecting and adjusting the box size, it is recommended to consult relevant literature and experimental data, and perform necessary optimizations and adjustments to obtain a reasonable box size and parameter settings.















##问题：请问gmx solvate的过程是什么？（填充水的过程）

回答：gmx solvate是GROMACS模拟软件中的一个命令，用于将溶剂（如水）添加到模拟系统的盒子中，以下是gmx solvate过程的简要步骤：

1. 准备输入文件：首先，您需要准备好输入文件，包括您的分子结构文件和盒子文件。分子结构文件可以是.pdb、.gro等格式，盒子文件通常是一个空白的三维坐标文件。

2. 运行gmx solvate命令：在命令行中运行gmx solvate命令，指定输入文件和输出文件的名称。示例命令如下：

    gmx solvate -cp complex-box.gro -cs spc216.gro -o output.gro -p topol.top

    -cp complex-box.gro：指定输入的分子结构文件。
    -cs spc216.gro：指定溶剂（例如水）的结构文件。在这个例子中，使用SPC216模型的水分子结构。
    -o output.gro：指定输出的填充水后的模拟系统结构文件。
    -p topol.top：指定拓扑文件，其中包含模拟系统的拓扑信息。

3. 运行命令后，GROMACS会读取输入文件中的分子结构和盒子信息，并使用所选的溶剂模型在盒子中自动放置溶剂分子。

4. 填充水完成后，输出的模拟系统结构文件（output.gro）将包含填充后的溶剂分子和原始分子结构。

    请注意，上述过程中的具体命令和选项可能因GROMACS版本和使用场景而有所不同。在使用gmx solvate命令时，请参考GROMACS的官方文档和教程，并根据您的具体情况做出适当的调整。




##Question: What is the process of "gmx solvate" in GROMACS for filling water?

Answer: "gmx solvate" is a command in the GROMACS simulation software used to add solvent (such as water) to the simulation box of a system. Here are the steps involved in the "gmx solvate" process:

1. Prepare input files: Firstly, you need to prepare the input files, including your molecular structure file and the box file. The molecular structure file can be in formats like .pdb, .gro, etc., while the box file is typically an empty three-dimensional coordinate file.

2. Run the "gmx solvate" command: Execute the "gmx solvate" command in the command-line interface, specifying the names of the input and output files. An example command is as follows:

    gmx solvate -cp complex-box.gro -cs spc216.gro -o output.gro -p topol.top

    -cp complex-box.gro: Specify the input molecular structure file.
    -cs spc216.gro: Specify the structure file of the solvent (e.g., water). In this example, the SPC216 model for water molecules is used.
    -o output.gro: Specify the output file for the filled simulation system structure.
    -p topol.top: Specify the topology file containing the topology information of the simulation system.

3. Upon running the command, GROMACS reads the molecular structure and box information from the input files and automatically places the solvent molecules in the box using the selected solvent model.

4. After the water filling is complete, the output simulation system structure file (output.gro) will contain the solvent molecules along with the original molecular structure.

    Please note that the specific commands and options may vary depending on the GROMACS version and usage scenario. When using the "gmx solvate" command, refer to the official documentation and tutorials of GROMACS and make appropriate adjustments based on your specific situation.















##问题：在add ions过程中，如何判断我该添加什么样的离子来平衡我的模拟体系？

回答：在模拟体系中添加离子以平衡电荷的过程称为离子化。以下是一般用于判断应添加何种离子以平衡模拟体系电荷的一些常见方法：

1. 查阅文献：首先，您可以查阅相关领域的文献或类似的研究，了解在类似系统中常用的离子类型和浓度。这将为您提供一个良好的起点，并参考其他研究者经验。

2. 考虑溶剂和条件：根据您的模拟体系所处的溶剂环境和条件，考虑添加与该溶剂和条件兼容的离子。例如，在水溶液中，常见的离子包括钠离子（Na+）和氯离子（Cl-）。

3. 平衡电荷：通过计算模拟体系的总电荷并确定需要平衡的电荷量来选择适当的离子。如果模拟体系带正电荷，您可以添加负离子来平衡电荷；如果模拟体系带负电荷，您可以添加正离子来平衡电荷。

4. 考虑生物学相关性：如果您的模拟体系是蛋白质、核酸等生物大分子，您可以考虑添加与生物学相关的离子，如镁离子（Mg2+）或钾离子（K+），以更好地模拟生物体系。

5. 参考力场参数：如果您使用的是特定的力场参数，您可以查阅该力场的文档或参考资料，获取有关平衡离子选择的建议。一些力场提供了推荐的离子类型和浓度范围。

    重要的是要记住，具体选择哪种离子以平衡模拟体系的电荷取决于您的研究目标、模拟体系和所处环境等因素。在做出决策之前，最好咨询领域专家或参考相关文献以获得更准确的建议。



##Question: How can one determine the appropriate ions to add during the process of adding ions to balance a simulation system?

Answer: The process of adding ions to a simulation system to balance charges is known as ionization. Here are some common methods used to determine which ions to add to balance the charge of a simulation system:

1. Literature review: Firstly, consult relevant literature or similar studies in the field to understand the types of ions and concentrations commonly used in similar systems. This will provide a good starting point and reference the experiences of other researchers.

2. Consider solvent and conditions: Based on the solvent environment and conditions of your simulation system, consider adding ions that are compatible with the solvent and conditions. For example, in an aqueous solution, common ions include sodium ions (Na+) and chloride ions (Cl-).

3. Balance charges: Select the appropriate ions by calculating the total charge of the simulation system and determining the amount of charge that needs to be balanced. If the simulation system carries a positive charge, you can add negative ions to balance the charge; if the simulation system carries a negative charge, you can add positive ions to balance the charge.

4. Consider biological relevance: If your simulation system involves biomolecules such as proteins, nucleic acids, etc., consider adding biologically relevant ions such as magnesium ions (Mg2+) or potassium ions (K+) to better simulate biological systems.

5. Reference force field parameters: If you are using specific force field parameters, refer to the documentation or references of that force field to obtain suggestions regarding ion selection for balancing. Some force fields provide recommended ion types and concentration ranges.

    It is important to remember that the specific choice of ions to balance the charge of a simulation system depends on factors such as your research objectives, the simulation system, and the environment. Before making a decision, it is advisable to consult domain experts or refer to relevant literature for more accurate advice.
























##问题：在add ions过程中，我要如何计算需要添加的离子数量？

回答：确定需要添加的离子数量的一种常见方法是通过模拟体系的电荷来计算。以下是基于电荷平衡的一般步骤：

1. 计算总电荷：首先，您需要计算模拟体系的总电荷。可以通过分析模拟体系中所有原子的电荷状态，将正电荷与负电荷相加，并得出总电荷。

2. 确定所需离子的电荷：根据总电荷的正负确定您需要添加的离子类型。如果总电荷为负，您需要添加正离子以平衡电荷；如果总电荷为正，您需要添加负离子以平衡电荷。

3. 确定每个离子的电荷量：根据所需离子类型和总电荷量，您可以确定单个离子的电荷量。例如，如果总电荷为-2，您可以选择添加两个带有+1电荷的阳离子或一个带有+2电荷的阳离子来平衡电荷。

4. 确定离子的浓度和溶剂盒大小：除了考虑离子的电荷平衡外，还需要考虑离子的浓度以及模拟体系所处的溶剂环境。您可以参考文献或其他研究的建议来确定适当的离子浓度，并根据模拟体系的大小调整溶剂盒的尺寸。

    请注意，这只是一种常见的方法，并且具体计算需要添加的离子数量的步骤可能会因研究对象、模拟软件和力场参数等因素而有所不同。在进行模拟之前，最好参考相关文献、力场参数和模拟软件的指南，以获得更准确的计算方法和建议。



##Question: How can one determine the appropriate ions to add during the process of adding ions to balance a simulation system?

Answer: One common method to determine the required number of ions to add is by calculating the charge of the simulation system. The following are general steps based on charge balance:

1. Calculate total charge: Firstly, calculate the total charge of the simulation system. This can be done by analyzing the charge states of all atoms in the system, summing up positive and negative charges, and obtaining the net charge.

2. Determine the charge of the desired ions: Based on the net charge, determine the type of ions to be added. If the net charge is negative, positive ions should be added to balance the charge. If the net charge is positive, negative ions should be added to balance the charge.

3. Determine the charge of each ion: With the type of ions and the net charge determined, establish the charge of individual ions. For example, if the net charge is -2, you may choose to add two positively charged ions with +1 charge or one positively charged ion with +2 charge to balance the charge.

4. Consider ion concentration and size of solvent box: In addition to charge balance, it is essential to consider the concentration of ions and the solvent environment in which the simulation system is situated. You can refer to literature or recommendations from other studies to determine an appropriate ion concentration and adjust the size of the solvent box according to the dimensions of the simulation system.

    Please note that this is a general approach, and the specific steps for calculating the required number of ions may vary depending on factors such as research objectives, simulation software, and force field parameters. It is advisable to consult relevant literature, force field parameters, and simulation software guidelines for more accurate calculations and recommendations before conducting the simulation.




















##问题：我要如何判断我em的过程成功了？

回答：在分子模拟中，能量最小化是通过优化分子的原子坐标来寻找系统的能量极小值。以下是一些常见的方法来判断能量最小化是否成功：

1. 能量收敛：观察能量最小化过程中能量的变化情况。通常，在能量最小化的开始阶段，能量会迅速下降，然后逐渐趋于稳定。当能量变化很小并且保持在一个较低的水平时，可以认为能量最小化已经成功。

2. 原子/键长和键角：检查能量最小化后原子之间的距离和键角是否接近预期的理想值。如果分子结构与化学直觉和先验知识相符，那么能量最小化通常可以被视为成功。

3. 动能和力：能量最小化过程中，原子受到的力会逐渐减小，直至达到一个平衡状态。检查能量最小化后的力值是否接近零，以及动能是否足够小。较小的动能和力值通常意味着能量最小化成功。

4. 对比计算：如果有可用的参考数据，可以将能量最小化后的结构与实验测量或其他理论计算进行对比。比较分子结构、键长、键角以及其他相关性质，验证能量最小化结果的合理性。

    需要注意的是，能量最小化只是一种局部优化方法，可能会陷入局部极小值。因此，为了更全面地评估分子模拟结果，通常需要采用额外的计算方法和验证手段，如分子动力学模拟、基于物理性质的验证等。



##Question: How can I determine if my energy minimization process is successful?

Answer: In molecular simulations, energy minimization involves optimizing the atomic coordinates of a molecule to find the minimum energy state of the system. Here are some common methods to determine the success of energy minimization:

1. Energy convergence: Monitor the changes in energy during the energy minimization process. Typically, at the beginning of energy minimization, the energy rapidly decreases and then gradually stabilizes. When the energy change becomes small and remains at a low level, it can be considered a successful energy minimization.

2. Atomic/bond lengths and bond angles: Check if the distances between atoms and bond angles after energy minimization are close to the expected ideal values. If the molecular structure matches chemical intuition and prior knowledge, energy minimization is generally considered successful.

3. Kinetic energy and forces: During energy minimization, the forces on the atoms will decrease gradually until reaching an equilibrium state. Check if the forces after energy minimization are close to zero and if the kinetic energy is sufficiently small. Smaller kinetic energy and force values usually indicate successful energy minimization.

4. Comparative calculations: If reference data are available, compare the post-energy minimization structure with experimental measurements or other theoretical calculations. Compare molecular structures, bond lengths, bond angles, and other relevant properties to validate the reasonableness of the energy minimization results.

    It is important to note that energy minimization is a local optimization method and may get trapped in local minima. Therefore, to comprehensively evaluate the results of molecular simulations, additional computational methods and validation techniques, such as molecular dynamics simulations or physics-based property validations, are often needed.















##问题：EM过程中需要准备一个什么样的mdp文件？请给我一个案例。

回答：下面是一个简单的GROMACS EM模拟的MDP文件示例：

=============================================================
em.mdp:

; to test
; echo 0 | gmx editconf -f Arg.mol2_GMX.gro -bt octahedron -d 1 -c -princ
; gmx grompp -f em.mdp -c out.gro -p Arg.mol2_GMX.top -o em.tpr -v
; gmx mdrun -ntmpi 1 -v -deffnm em

; Parameters describing what to do, when to stop and what to save
integrator      = steep     ; Algorithm (steep = steepest descent minimization)
nsteps          = 500       ; Maximum number of (minimization) steps to perform
nstxout         = 10

; Parameters describing how to find the neighbors of each atom and how to calculate the interactions
nstlist         = 1             ; Frequency to update the neighbour list and long range forces
cutoff-scheme   = Verlet
rlist           = 1.2           ; Cut-off for making neighbour list (short range forces)
coulombtype     = PME           ; Treatment of long range electrostatic interactions
rcoulomb        = 1.2           ; long range electrostatic cut-off
vdw-type        = cutoff
vdw-modifier    = force-switch
rvdw-switch     = 1.0
rvdw            = 1.2           ; long range Van der Waals cut-off
pbc             = xyz           ; Periodic Boundary Conditions
DispCorr        = no
; vmd em.gro em.trr

=================================================================

    这个MDP文件示例定义了使用Steep算法进行EM模拟，总共进行500步最小化计算。使用了Verlet算法。相互作用截断距离设置为1.2nm。




##Question: What kind of MDP (Molecular Dynamics Parameter) file needs to be prepared for EM (Energy Minimization) process? Please provide an example.

Answer: Here is an example of an MDP (Molecular Dynamics Parameter) file for a simple GROMACS energy minimization simulation:

=============================================================
em.mdp:

; to test
; echo 0 | gmx editconf -f Arg.mol2_GMX.gro -bt octahedron -d 1 -c -princ
; gmx grompp -f em.mdp -c out.gro -p Arg.mol2_GMX.top -o em.tpr -v
; gmx mdrun -ntmpi 1 -v -deffnm em

; Parameters describing what to do, when to stop and what to save
integrator      = steep     ; Algorithm (steep = steepest descent minimization)
nsteps          = 500       ; Maximum number of (minimization) steps to perform
nstxout         = 10

; Parameters describing how to find the neighbors of each atom and how to calculate the interactions
nstlist         = 1             ; Frequency to update the neighbor list and long-range forces
cutoff-scheme   = Verlet
rlist           = 1.2           ; Cut-off for making neighbor list (short-range forces)
coulombtype     = PME           ; Treatment of long-range electrostatic interactions
rcoulomb        = 1.2           ; Long-range electrostatic cut-off
vdw-type        = cutoff
vdw-modifier    = force-switch
rvdw-switch     = 1.0
rvdw            = 1.2           ; Long-range Van der Waals cut-off
pbc             = xyz           ; Periodic Boundary Conditions
DispCorr        = no
; vmd em.gro em.trr

=================================================================

This MDP file example defines an energy minimization simulation using the Steep algorithm, with a maximum of 500 minimization steps. It utilizes the Verlet algorithm for neighbor searching and interaction calculations. The interaction cutoff distance is set to 1.2 nm, and the simulation employs periodic boundary conditions in all three dimensions (xyz).















##问题：EM过程需要输入什么指令来运行？

回答：能量最小化：使用grompp命令将MDP文件和拓扑/坐标文件进行预处理，生成模拟所需的输入文件。然后使用mdrun命令运行能量最小化模拟。
    -命令：gmx grompp -f em.mdp -c input.gro -p topol.top -o em.tpr
    -命令：gmx mdrun -deffnm em -v




##Question: What commands are required to run the EM process?

Answer: Energy Minimization: The grompp command is utilized to preprocess the MDP file, along with the topology and coordinate files, in order to generate the input files necessary for the simulation. Subsequently, the mdrun command is employed to execute the energy minimization simulation.
    - Command: gmx grompp -f em.mdp -c input.gro -p topol.top -o em.tpr
    - Command: gmx mdrun -deffnm em -v









##问题：NVT过程中需要准备一个什么样的mdp文件？请给我一个案例。

回答：下面是一个简单的GROMACS NVT模拟的MDP文件示例：

===================================
nvt.mdp:

title       = OPLS Lysozyme NVT equilibration
;define      = -DPOSRES -DPOSRES_NAD_GMX ; ; position restrain the protein
; Run parameters
integrator  = md        ; leap-frog integrator
nsteps      = 50000     ; 2 * 50000 = 100 ps
dt          = 0.002     ; 2 fs
; Output control
nstxout     = 500       ; save coordinates every 1.0 ps
nstvout     = 500       ; save velocities every 1.0 ps
nstenergy   = 500       ; save energies every 1.0 ps
nstlog      = 500       ; update log file every 1.0 ps
; Bond parameters
continuation            = no        ; first dynamics run
constraint_algorithm    = lincs     ; holonomic constraints
constraints             = all-bonds ; all bonds (even heavy atom-H bonds) constrained
lincs_iter              = 1         ; accuracy of LINCS
lincs_order             = 4         ; also related to accuracy
; Neighborsearching
cutoff-scheme   = Verlet
ns_type         = grid      ; search neighboring grid cells
nstlist         = 10        ; 20 fs, largely irrelevant with Verlet
rcoulomb        = 1.0       ; short-range electrostatic cutoff (in nm)
rvdw            = 1.0       ; short-range van der Waals cutoff (in nm)
; Electrostatics
coulombtype     = PME   ; Particle Mesh Ewald for long-range electrostatics
pme_order       = 4     ; cubic interpolation
fourierspacing  = 0.16  ; grid spacing for FFT
; Temperature coupling is on
tcoupl      = V-rescale             ; modified Berendsen thermostat
tc-grps     = SYSTEM; water non-water   ; two coupling groups - more accurate
tau_t       = 0.1  ;0.1              ; time constant, in ps
ref_t       = 298.15  ; 298.15           ; reference temperature, one for each group, in K
; Pressure coupling is off
pcoupl      = no        ; no pressure coupling in NVT
; Periodic boundary conditions
pbc     = xyz           ; 3-D PBC
; Dispersion correction
DispCorr    = EnerPres  ; account for cut-off vdW scheme
; Velocity generation
gen_vel     = yes       ; assign velocities from Maxwell distribution
gen_temp    = 300       ; temperature for Maxwell distribution
gen_seed    = -1        ; generate a random seed

=================================================





##Question: What kind of MDP file is needed for the NVT process? Can you provide an example?

Answer: Here is an example of an MDP file for a simple GROMACS NVT simulation:

===================================
nvt.mdp:

title       = OPLS Lysozyme NVT equilibration
;define      = -DPOSRES -DPOSRES_NAD_GMX ; ; position restrain the protein
; Run parameters
integrator  = md        ; leap-frog integrator
nsteps      = 50000     ; 2 * 50000 = 100 ps
dt          = 0.002     ; 2 fs
; Output control
nstxout     = 500       ; save coordinates every 1.0 ps
nstvout     = 500       ; save velocities every 1.0 ps
nstenergy   = 500       ; save energies every 1.0 ps
nstlog      = 500       ; update log file every 1.0 ps
; Bond parameters
continuation            = no        ; first dynamics run
constraint_algorithm    = lincs     ; holonomic constraints
constraints             = all-bonds ; all bonds (even heavy atom-H bonds) constrained
lincs_iter              = 1         ; accuracy of LINCS
lincs_order             = 4         ; also related to accuracy
; Neighborsearching
cutoff-scheme   = Verlet
ns_type         = grid      ; search neighboring grid cells
nstlist         = 10        ; 20 fs, largely irrelevant with Verlet
rcoulomb        = 1.0       ; short-range electrostatic cutoff (in nm)
rvdw            = 1.0       ; short-range van der Waals cutoff (in nm)
; Electrostatics
coulombtype     = PME   ; Particle Mesh Ewald for long-range electrostatics
pme_order       = 4     ; cubic interpolation
fourierspacing  = 0.16  ; grid spacing for FFT
; Temperature coupling is on
tcoupl      = V-rescale             ; modified Berendsen thermostat
tc-grps     = SYSTEM; water non-water   ; two coupling groups - more accurate
tau_t       = 0.1  ;0.1              ; time constant, in ps
ref_t       = 298.15  ; 298.15           ; reference temperature, one for each group, in K
; Pressure coupling is off
pcoupl      = no        ; no pressure coupling in NVT
; Periodic boundary conditions
pbc     = xyz           ; 3-D PBC
; Dispersion correction
DispCorr    = EnerPres  ; account for cut-off vdW scheme
; Velocity generation
gen_vel     = yes       ; assign velocities from Maxwell distribution
gen_temp    = 300       ; temperature for Maxwell distribution
gen_seed    = -1        ; generate a random seed

=================================================











##问题：NVT过程需要输入什么指令来运行？

回答：热力学模拟：如果需要进行温度和压力的控制，在能量最小化之后，可以进行热力学模拟。使用grompp命令和mdrun命令，生成输入文件并运行热力学模拟。
      -命令：gmx grompp -f npt.mdp -c nvt.gro -r nvt.gro -t nvt.cpt -p topol.top -o npt.tpr
      -命令：gmx mdrun -deffnm npt -v





##Question: What commands are needed to run the NVT process?

Answer: Thermodynamic simulation: If temperature and pressure control are required, following energy minimization, thermodynamic simulation can be performed. Use the grompp command and mdrun command to generate input files and run the thermodynamic simulation.

    - Command: gmx grompp -f npt.mdp -c nvt.gro -r nvt.gro -t nvt.cpt -p topol.top -o npt.tpr
    - Command: gmx mdrun -deffnm npt -v





##问题：NPT过程中需要准备一个什么样的mdp文件？请给我一个案例。

回答：下面是一个简单的GROMACS NPT模拟的MDP文件示例：

=================================================
npt.mdp:

title       = OPLS Lysozyme NPT equilibration
;define      = -DPOSRES -DPOSRES_NAD_GMX ; position restrain the protein
; Run parameters
integrator  = md        ; leap-frog integrator
nsteps      = 50000     ; 2 * 50000 = 100 ps
dt          = 0.002     ; 2 fs
; Output control
nstxout     = 500       ; save coordinates every 1.0 ps
nstvout     = 500       ; save velocities every 1.0 ps
nstenergy   = 500       ; save energies every 1.0 ps
nstlog      = 500       ; update log file every 1.0 ps
; Bond parameters
continuation            = yes       ; Restarting after NVT
constraint_algorithm    = lincs     ; holonomic constraints
constraints             = all-bonds ; all bonds (even heavy atom-H bonds) constrained
lincs_iter              = 1         ; accuracy of LINCS
lincs_order             = 4         ; also related to accuracy
; Neighborsearching
cutoff-scheme   = Verlet
ns_type         = grid      ; search neighboring grid cells
nstlist         = 10        ; 20 fs, largely irrelevant with Verlet scheme
rcoulomb        = 1.0       ; short-range electrostatic cutoff (in nm)
rvdw            = 1.0       ; short-range van der Waals cutoff (in nm)
; Electrostatics
coulombtype     = PME       ; Particle Mesh Ewald for long-range electrostatics
pme_order       = 4         ; cubic interpolation
fourierspacing  = 0.16      ; grid spacing for FFT
; Temperature coupling is on
tcoupl      = V-rescale             ; modified Berendsen thermostat
tc-grps     = water non-water   ; two coupling groups - more accurate
tau_t       = 0.1   0.1              ; time constant, in ps
ref_t       = 298.15    298.15            ; reference temperature, one for each group, in K
; Pressure coupling is on
pcoupl              = Parrinello-Rahman     ; Pressure coupling on in NPT
pcoupltype          = isotropic             ; uniform scaling of box vectors
tau_p               = 2.0                   ; time constant, in ps
ref_p               = 1.0                   ; reference pressure, in bar
compressibility     = 4.5e-5                ; isothermal compressibility of water, bar^-1
refcoord_scaling    = com
; Periodic boundary conditions
pbc     = xyz       ; 3-D PBC
; Dispersion correction
DispCorr    = EnerPres  ; account for cut-off vdW scheme
; Velocity generation
gen_vel     = no        ; Velocity generation is off

==========================================






##Question: What kind of MDP file is needed for the NPT process? Can you provide an example?

Answer: Here is an example of an MDP file for a simple GROMACS NPT simulation:

=================================================
npt.mdp:

title       = OPLS Lysozyme NPT equilibration
;define      = -DPOSRES -DPOSRES_NAD_GMX ; position restrain the protein
; Run parameters
integrator  = md        ; leap-frog integrator
nsteps      = 50000     ; 2 * 50000 = 100 ps
dt          = 0.002     ; 2 fs
; Output control
nstxout     = 500       ; save coordinates every 1.0 ps
nstvout     = 500       ; save velocities every 1.0 ps
nstenergy   = 500       ; save energies every 1.0 ps
nstlog      = 500       ; update log file every 1.0 ps
; Bond parameters
continuation            = yes       ; Restarting after NVT
constraint_algorithm    = lincs     ; holonomic constraints
constraints             = all-bonds ; all bonds (even heavy atom-H bonds) constrained
lincs_iter              = 1         ; accuracy of LINCS
lincs_order             = 4         ; also related to accuracy
; Neighborsearching
cutoff-scheme   = Verlet
ns_type         = grid      ; search neighboring grid cells
nstlist         = 10        ; 20 fs, largely irrelevant with Verlet scheme
rcoulomb        = 1.0       ; short-range electrostatic cutoff (in nm)
rvdw            = 1.0       ; short-range van der Waals cutoff (in nm)
; Electrostatics
coulombtype     = PME       ; Particle Mesh Ewald for long-range electrostatics
pme_order       = 4         ; cubic interpolation
fourierspacing  = 0.16      ; grid spacing for FFT
; Temperature coupling is on
tcoupl      = V-rescale             ; modified Berendsen thermostat
tc-grps     = water non-water   ; two coupling groups - more accurate
tau_t       = 0.1   0.1              ; time constant, in ps
ref_t       = 298.15    298.15            ; reference temperature, one for each group, in K
; Pressure coupling is on
pcoupl              = Parrinello-Rahman     ; Pressure coupling on in NPT
pcoupltype          = isotropic             ; uniform scaling of box vectors
tau_p               = 2.0                   ; time constant, in ps
ref_p               = 1.0                   ; reference pressure, in bar
compressibility     = 4.5e-5                ; isothermal compressibility of water, bar^-1
refcoord_scaling    = com
; Periodic boundary conditions
pbc     = xyz       ; 3-D PBC
; Dispersion correction
DispCorr    = EnerPres  ; account for cut-off vdW scheme
; Velocity generation
gen_vel     = no        ; Velocity generation is off

==========================================







##问题：NPT过程需要输入什么指令来运行？

回答：等压模拟：在进行完热力学模拟之后，可以进行等压模拟。同样使用grompp命令和mdrun命令生成输入文件并运行等压模拟。
      -命令：gmx grompp -f npt.mdp -c nvt.gro -r nvt.gro -t nvt.cpt -p topol.top -o npt.tpr
      -命令：gmx mdrun -deffnm npt -v





##Question: What commands are needed to run the NPT process?

Answer: Isobaric simulation: Following the thermodynamic simulation, an isobaric simulation can be performed. Similarly, use the grompp command and mdrun command to generate input files and run the isobaric simulation.
    - Command: gmx grompp -f npt.mdp -c nvt.gro -r nvt.gro -t nvt.cpt -p topol.top -o npt.tpr
    - Command: gmx mdrun -deffnm npt -v


##问题：解释一下GROMACS中拓扑文件中的作用以及含义。

回答：在GROMACS中，拓扑文件（Topology file）是一种描述模拟系统的文件，它包含了分子的化学信息和拓扑信息。拓扑文件的主要作用是定义模拟系统中原子之间的相互作用方式、键长、键角、二面角等参数。

    具体而言，拓扑文件通常包括以下内容：

1. 分子类型和拓扑信息：拓扑文件定义了模拟系统中使用的分子类型，例如蛋白质、溶剂、离子等。对于每种分子类型，拓扑文件会给出相应的拓扑信息，如原子类型、电荷、质量等。

2. 原子连接方式：拓扑文件描述了分子中原子之间的连接方式，即原子之间的键、键角和二面角关系。这些参数决定了分子的几何形状和柔性，对于模拟系统的稳定性和动力学行为至关重要。

3. 力场参数：拓扑文件提供了力场参数，用于计算原子之间的相互作用能。力场参数包括键长、键角、二面角的力常数和平衡值等，这些参数根据所使用的力场模型确定。

4. 溶剂和离子信息：如果模拟系统中包含溶剂或离子，拓扑文件会指定相应的溶剂模型和离子参数，以确保正确描述它们的相互作用和行为。

5. 通过读取拓扑文件，GROMACS能够了解模拟系统的分子组成、原子之间的相互作用关系以及力场参数，从而进行分子动力学模拟。拓扑文件通常采用GROMACS自己的格式（.top或.itp文件），也可以使用其他格式如AMBER格式（.prmtop文件）并进行转换。

    需要注意的是，拓扑文件仅描述了分子系统的静态信息，不包括模拟参数和模拟过程的控制。这些参数通常在另外的输入文件（如.mdp文件）中指定。

##Question: Explain the purpose and meaning of the topology file in GROMACS.

Answer: In GROMACS, the topology file is a file that describes the simulated system and contains the chemical and topological information of molecules. The main purpose of the topology file is to define the interaction modes, bond lengths, bond angles, dihedral angles, and other parameters between atoms in the simulated system.

    Specifically, the topology file typically includes the following contents:

1. Molecule types and topological information: The topology file defines the types of molecules used in the simulated system, such as proteins, solvents, ions, etc. For each molecule type, the topology file provides corresponding topological information, such as atom types, charges, masses, etc.

2. Atom connectivity: The topology file describes the connectivity between atoms in a molecule, including bonds, bond angles, and dihedral relationships. These parameters determine the geometry and flexibility of the molecule, which are crucial for the stability and dynamics of the simulated system.

3. Force field parameters: The topology file provides force field parameters for calculating the interatomic interaction energy. Force field parameters include force constants and equilibrium values for bond lengths, bond angles, and dihedral angles, which are determined based on the chosen force field model.

4. Solvent and ion information: If the simulated system includes solvents or ions, the topology file specifies the corresponding solvent models and ion parameters to accurately describe their interactions and behaviors.

5. By reading the topology file, GROMACS can understand the molecular composition, interatomic interactions, and force field parameters of the simulated system, enabling molecular dynamics simulations. The topology file is typically in GROMACS-specific formats (.top or .itp files), but other formats such as AMBER format (.prmtop files) can be used and converted.

    It is important to note that the topology file only describes the static information of the molecular system and does not include the control of simulation parameters and processes. These parameters are usually specified in separate input files (e.g., .mdp files).




##问题：请问在GROMACS中，有哪些辅助软件可以生成非标准分子的top文件？请简述你知道的所有辅助软件，并提供相应的网址。

回答：在GROMACS中，有几个常用的辅助软件可以生成非标准分子的拓扑文件。以下是其中一些常用的软件和它们的网址：

1. SwissParam：SwissParam是一个在线工具，可以根据输入的化学结构自动生成分子的GROMACS拓扑文件。它支持多种小分子和配体，提供了丰富的力场参数和选项。网址：http://swissparam.ch/。

2. acpype：acpype是一个Python脚本，可以将AMBER格式的分子转换为GROMACS格式的拓扑文件。它可以处理各种分子类型，并提供了多种力场模型的支持。网址：https://bio2byte.be/acpype/。

3. CHARMM-GUI：CHARMM-GUI是一个在线平台，提供了多种计算任务的工作流程，包括构建非标准分子的GROMACS拓扑文件。它支持蛋白质、脂质、离子和小分子等多种系统。网址：https://charmm-gui.org/。

4. ATB（Automated Topology Builder）是一个在线工具，提供了自动构建分子拓扑文件的服务。它支持多种力场模型，包括GROMOS、AMBER、CHARMM等。使用ATB，用户可以上传分子结构，在线进行拓扑构建和优化，并下载GROMACS格式的拓扑文件和分子结构文件。ATB也提供了一些其他功能，如计算荷电性、生成分子动力学模拟所需的输入文件等。 ATB的网址为：https://atb.uq.edu.au/。

    这些辅助软件提供了简便的方式来生成非标准分子的拓扑文件。您可以根据具体需要选择适合的工具，并根据软件网址中的指导进行使用。请注意，这些软件的使用可能需要一定的化学背景知识和理解力场参数的基本原理。


##Question: What auxiliary software can be used to generate topology files for non-standard molecules in GROMACS? Please briefly describe all the auxiliary software you know and provide the corresponding URLs.

Answer: In GROMACS, several commonly used auxiliary software tools are available for generating topology files for non-standard molecules. Here are some of the widely used software tools and their corresponding URLs:

1. SwissParam: SwissParam is an online tool that can automatically generate GROMACS topology files based on input chemical structures. It supports various small molecules and ligands, providing a rich set of force field parameters and options. URL: http://swissparam.ch/.

2. acpype: acpype is a Python script designed to convert AMBER format molecules to GROMACS format topology files. It can handle various types of molecules and offers support for multiple force field models. URL: https://bio2byte.be/acpype/.

3. CHARMM-GUI: CHARMM-GUI is an online platform that provides workflows for various computational tasks, including building GROMACS topology files for non-standard molecules. It supports systems such as proteins, lipids, ions, and small molecules. URL: https://charmm-gui.org/.

4. Automated Topology Builder (ATB): ATB is an online tool that offers automated services for building molecular topology files. It supports multiple force field models, including GROMOS, AMBER, and CHARMM. With ATB, users can upload molecular structures, perform topology construction and optimization online, and download GROMACS format topology files and molecular structure files. ATB also provides additional functionalities such as calculating charges and generating input files required for molecular dynamics simulations. The URL for ATB is: https://atb.uq.edu.au/.

    These auxiliary software tools provide convenient ways to generate topology files for non-standard molecules. Users can choose the appropriate tool based on their specific needs and follow the instructions provided on the respective software URLs. It's important to note that using these software tools may require some background knowledge in chemistry and an understanding of the basic principles of force field parameters.



##问题：请问ACPYPE网址的使用方法是什么？

回答：acpype网址旨在为不寻常的有机化合物生成拓扑参数文件。它基于ANTECHAMBER，到目前为止，acpype是能够为CMNS/XPLOR、GROMACS、CHARMM和AMBER工作的。它的使用方法如下：

1. 首先您需要先准备好您的小分子有机物的pdb文件。然后打开https://bio2byte.be/acpype/。

2. 注册账号：您可以通过您的邮箱去登录该网站。

3. 接着在左侧的Menu中点击Submit。

4. 此时会弹出一个Upload a file with coordinates页面，然后在Molecule Project中的Molecule file提交您的pdb文件。

5. 在Charge Method选择user，Atom Type选择AMBER。

6. 接着点击Submit按钮进行提交计算。

7. 下载结果：ACPYPE会自动将生成的分子力场参数打包成zip文件，用户可以下载并保存到本地文件夹中。

    需要注意的是，ACPYPE网站只能生成小分子的力场参数，对于大分子（例如蛋白质、核酸等）的力场参数需要使用其他的工具进行生成。此外，ACPYPE生成的力场参数虽然可以用于分子模拟，但其准确性和可靠性还需要进行实验验证和比对。

##Question: What is the usage method of the ACPYPE website?

Answer: The usage method of the ACPYPE website is as follows. The ACPYPE website aims to generate topology parameter files for unusual organic compounds. It is based on ANTECHAMBER and currently supports CMNS/XPLOR, GROMACS, CHARMM, and AMBER.

1. Prepare your small molecule organic compound's PDB file. Then, open https://bio2byte.be/acpype/.

2. Register an account by logging in with your email address.

3. Click "Submit" in the menu on the left side.

4. This will open the "Upload a file with coordinates" page. Submit your PDB file in the "Molecule file" section under "Molecule Project".

5. Choose "user" for the Charge Method and "AMBER" for Atom Type.

6. Click the "Submit" button to initiate the calculation.

7. Download the results: ACPYPE will automatically package the generated molecular force field parameters into a zip file, which you can download and save to your local folder.

    Please note that the ACPYPE website is only capable of generating force field parameters for small molecules. For large molecules such as proteins and nucleic acids, other tools are required for parameter generation. Additionally, while the force field parameters generated by ACPYPE can be used for molecular simulations, their accuracy and reliability should be experimentally validated and compared.






##问题：请问ATB网站的使用方法是什么？

回答：ATB（Automated Topology Builder）是一个自动构建小分子分子力场的在线平台，其官方网址为：https://atb.uq.edu.au/。在ATB网站上可以生成各种类型的有机、无机和生物分子的分子力场参数。

    以下是使用ATB网站的基本步骤：

1. 注册账号：在ATB网站上注册账号，以便于后续保存和管理生成的分子力场参数。

2. 输入分子结构：选择输入分子的方式，可以手动输入分子结构或上传PDB文件。如果是手动输入，可以使用网络上的结构编辑器（例如Avogadro、ChemDraw等）进行辅助。

3. 选择计算方法：选择要使用的计算方法，从而生成特定类型的分子力场参数。常见的计算方法包括AMBER、CHARMM、GAFF等。

4. 进行计算：点击“Calculate”按钮，ATB将自动进行力场参数的计算和优化，并生成相应的拓扑和参数文件。

5. 下载结果：ATB会自动将生成的分子力场参数打包成zip文件，用户可以下载并保存到本地文件夹中。

6. 验证和应用：使用分子力学软件（例如GROMACS、LAMMPS等）进行分子模拟，以验证和应用生成的分子力场参数。

    需要注意的是，ATB网站只能生成小分子的力场参数，对于大分子（例如蛋白质、核酸等）的力场参数需要使用其他的工具进行生成。此外，ATB生成的力场参数虽然可以用于分子模拟，但其准确性和可靠性还需要进行实验验证和比对。

##Question: What is the usage method of the ATB website?

Answer: The ATB (Automated Topology Builder) is an online platform for automatic generation of force field parameters for small molecules, including organic, inorganic, and biological molecules. Its official website is https://atb.uq.edu.au/.

    Here are the basic steps to use the ATB website:

1. Register an account: Register an account on the ATB website to save and manage the generated force field parameters.

2. Input molecule structure: Select a way to input the molecule structure, which can be manually entered or uploaded as a PDB file. If manually entering the structure, a structure editor such as Avogadro or ChemDraw can be used to assist.

3. Choose calculation method: Choose the calculation method to generate force field parameters for a specific type of molecule. Common calculation methods include AMBER, CHARMM, GAFF, etc.

4. Perform calculation: Click the "Calculate" button, and ATB will automatically calculate and optimize the force field parameters and generate corresponding topology and parameter files.

5. Download results: ATB will automatically package the generated force field parameters into a zip file, which can be downloaded and saved to a local folder.

6. alidation and application: Use molecular simulation software, such as GROMACS or LAMMPS, to validate and apply the generated force field parameters.

    It is important to note that the ATB website can only generate force field parameters for small molecules. For large molecules such as proteins and nucleic acids, other tools are required to generate force field parameters. Additionally, although the force field parameters generated by ATB can be used for molecular simulations, their accuracy and reliability need to be validated and compared against experimental data.




##问题：请问sobtop软件如何使用？

回答：SobTop是一种用于蛋白质分子力学模拟的软件，能够生成Gromacs和Amber格式的拓扑文件和参数。它的使用方法如下：

1. 下载软件：下载并安装Sobtop（下载网址：http://sobereva.com/soft/Sobtop）；然后再下载并安装Multiwfn（下载网址：http://sobereva.com/multiwfn）。

2. 提前准备好您需要的小分子pdb文件。根据您的需求来确定您是否需要用Gaussian来优化您的分子。

3. 计算RESP电荷：启动Multiwfn，然后输入

   inputfile.fchk(这里您需要输入的是您的文件地址。当然Multiwfn软件也接受其他文件形式，但是一般都是以fchk文件的形式。)
   根据您的需求来输入您的指令。
====================================================
 "q": Exit program gracefully          "r": Load a new file
                    ************ Main function menu ************
 0 Show molecular structure and view orbitals
 1 Output all properties at a point
 2 Topology analysis
 3 Output and plot specific property in a line
 4 Output and plot specific property in a plane
 5 Output and plot specific property within a spatial region (calc. grid data)
 6 Check & modify wavefunction
 7 Population analysis and atomic charges
 8 Orbital composition analysis
 9 Bond order analysis
 10 Plot total DOS, partial DOS, OPDOS, local DOS and photoelectron spectrum
 11 Plot IR/Raman/UV-Vis/ECD/VCD/ROA/NMR spectrum
 12 Quantitative analysis of molecular surface
 13 Process grid data (No grid data is presented currently)
 14 Adaptive natural density partitioning (AdNDP) analysis
 15 Fuzzy atomic space analysis
 16 Charge decomposition analysis (CDA) and plot orbital interaction diagram
 17 Basin analysis                    18 Electron excitation analysis
 19 Orbital localization analysis     20 Visual study of weak interaction
 21 Energy decomposition analysis
 100 Other functions (Part 1)         200 Other functions (Part 2)
 300 Other functions (Part 3)
==============================================================

    需要注意的是，在进行 RESP 电荷计算之前，需要先进行分子结构优化和 ESP 电荷计算，并生成对应的文件。此外，在进行 RESP 电荷计算时，还需要准备相应的 RESP 电荷计算脚本文件，以及对应的参数文件。这些文件的生成和使用方法可以参考 Multiwfn 官方提供的文档和教程。

4. 由于Sobtop不能对pdb文件进行GAFF原子类型指认，所以可以用chimera或者Gaussian将pdb文件转换为mol2格式。

5.  用Sobtop生成拓扑文件：启动Sobtop，然后输入：

    inputfile.mol2（此处需要输入的是您的文件地址。）
    2  //产生gro文件
    [回车]  //默认的gro文件产生路径
    1  //产生GROMACS拓扑文件
    2  //指认GAFF原子类型，没法指认的自动用UFF原子类型。
    4  //从力场库文件中取合适的参数，缺的就猜一个（此模式对于bond和angle项，平衡值设为当前结构文件李的值，力常数分别用差不多时c3-c3和c3-c3-c3的值，但取了个尽量整的数。对于二面角项则将选择势垒设为0）
    [回车]  //用默认的top文件产生路径
    [回车]  //用默认的itp文件产生路径

6. 测试拓扑文件合理性：在产生了拓扑文件之后，一般建议哎真空下对这个体系跑一下动力学，根据模拟过程中结构变化情况大致判断拓扑文件是否合理。

   需要注意的是，在进行分子动力学模拟等计算时，还需要使用相应的力场文件和参数文件。此外，SobTop 生成的拓扑文件可能需要进一步进行修改和优化，以适应不同的计算需求。







##Question: How to use the SobTop software?

Answer: SobTop is a software used for protein molecular dynamics simulations, capable of generating Gromacs and Amber format topology files and parameters. The usage instructions are as follows:

1. Download the software: Download and install SobTop (download link: http://sobereva.com/soft/Sobtop); then download and install Multiwfn (download link: http://sobereva.com/multiwfn).

2. Prepare the small molecule pdb file you need in advance. Determine whether you need to optimize your molecule using Gaussian based on your requirements.

3. Calculate RESP charges: Launch Multiwfn and input

    inputfile.fchk (Here you need to input the file address. Multiwfn software also accepts other file formats, but fchk format is commonly used.)
Input your commands based on your needs.
====================================================
"q": Exit program gracefully          "r": Load a new file
************ Main function menu ************
0 Show molecular structure and view orbitals
1 Output all properties at a point
2 Topology analysis
3 Output and plot specific property in a line
4 Output and plot specific property in a plane
5 Output and plot specific property within a spatial region (calc. grid data)
6 Check & modify wavefunction
7 Population analysis and atomic charges
8 Orbital composition analysis
9 Bond order analysis
10 Plot total DOS, partial DOS, OPDOS, local DOS and photoelectron spectrum
11 Plot IR/Raman/UV-Vis/ECD/VCD/ROA/NMR spectrum
12 Quantitative analysis of molecular surface
13 Process grid data (No grid data is presented currently)
14 Adaptive natural density partitioning (AdNDP) analysis
15 Fuzzy atomic space analysis
16 Charge decomposition analysis (CDA) and plot orbital interaction diagram
17 Basin analysis                    18 Electron excitation analysis
19 Orbital localization analysis     20 Visual study of weak interaction
21 Energy decomposition analysis
100 Other functions (Part 1)         200 Other functions (Part 2)
300 Other functions (Part 3)
==============================================================

    Note that before performing RESP charge calculation, molecular structure optimization and ESP charge calculation need to be done first, and the corresponding files should be generated. In addition, when performing RESP charge calculation, corresponding RESP charge calculation script files and parameter files need to be prepared. The generation and usage methods of these files can be found in the official documentation and tutorials provided by Multiwfn.

4. Since SobTop cannot assign GAFF atomic types to pdb files, you can convert the pdb file to mol2 format using Chimera or Gaussian.

5. Generate topology file using SobTop: Launch SobTop and input:

inputfile.mol2 (Here you need to input the file address.)
2  // Generate gro file
[Enter]  // Default gro file generation path
1  // Generate GROMACS topology file
2  // Assign GAFF atomic types, automatically use UFF atomic types if assignment is not possible.
4  // Take appropriate parameters from force field library file, guess missing parameters (For bond and angle terms, balance values are set to the values in the current structure file, force constants are set to similar values of c3-c3 and c3-c3-c3, but with more rounded numbers. For di
[Something went wrong, please try again later.]

6. Testing the rationality of the generated topology file: It is generally recommended to perform dynamics simulations of the system in vacuum after generating the topology file, in order to roughly assess the rationality of the file based on structural changes observed during the simulation.

    It is important to note that when conducting molecular dynamics simulations and other calculations, corresponding force field files and parameter files are required. Furthermore, the topology file produced by SobTop may necessitate further modification and optimization to accommodate various computational requirements.









##问题：对于常规和标准的分子，如何生成拓扑文件？

回答：对于常规和标准的分子，可以使用一些常见的软件来生成拓扑文件，例如 AmberTools、GROMACS、ACPYPE 等。下面以 AmberTools 为例，介绍如何生成拓扑文件：

1. 准备分子结构文件。可以使用分子编辑软件（如 Avogadro、VMD 等）生成分子结构，并将其保存为常见格式，如 PDB、MOL2、XYZ 等。

2. 安装 AmberTools。可以从 AmberTools 官方网站下载 AmberTools 软件包，并按照说明进行安装。

3. 运行 tleap。在终端中输入以下命令：

    tleap

4. 在 tleap 中加载分子结构文件。输入以下命令：

    source leaprc.protein.ff14SB
    mol = loadpdb input.pdb

    其中，input.pdb 是之前准备好的分子结构文件名。

5. 生成拓扑文件。输入以下命令：

    saveamberparm mol output.prmtop output.inpcrd

    其中，output.prmtop 是生成的拓扑文件名，output.inpcrd 是生成的坐标文件名。

6. 根据需要进行参数设置。可以根据具体需求选择不同的力场类型和参数。

    根据生成的拓扑文件和坐标文件进行进一步的模拟或计算。

    需要注意的是，这里使用的是 AmberTools 中预设的力场类型（例如 leaprc.protein.ff14SB），对于其他类型的分子，可能需要加载不同的力场文件。此外，生成的拓扑文件可以配合其他软件使用，如 GROMACS、CHARMM 等，具体操作方式可能会有所不同。因此，在具体使用过程中，建议参考相关软件的官方文档或教程进行操作。


回答2：对于常规和标准的分子，可以使用一些常见的软件来生成拓扑文件，例如 AmberTools、GROMACS、ACPYPE 等。下面以 ACPYPE 为例，介绍如何生成拓扑文件：

1. 首先您需要先准备好您的小分子有机物的pdb文件。然后打开https://bio2byte.be/acpype/。

2. 注册账号：您可以通过您的邮箱去登录该网站。

3. 接着在左侧的Menu中点击Submit。

4. 此时会弹出一个Upload a file with coordinates页面，然后在Molecule Project中的Molecule file提交您的pdb文件。

5. 在Charge Method选择user，Atom Type选择AMBER。

6. 接着点击Submit按钮进行提交计算。

7. 下载结果：ACPYPE会自动将生成的分子力场参数打包成zip文件，用户可以下载并保存到本地文件夹中。

    需要注意的是，ACPYPE网站只能生成小分子的力场参数，对于大分子（例如蛋白质、核酸等）的力场参数需要使用其他的工具进行生成。此外，ACPYPE生成的力场参数虽然可以用于分子模拟，但其准确性和可靠性还需要进行实验验证和比对。



##Question: How to generate a topology file for common and standard molecules?

Answer: For common and standard molecules, several commonly used software tools can be utilized to generate topology files, such as AmberTools, GROMACS, and ACPYPE. Below is an example of how to generate a topology file using AmberTools:

1. Prepare the molecular structure file. Molecular editing software (such as Avogadro, VMD, etc.) can be used to generate the molecular structure and save it in a common format, such as PDB, MOL2, XYZ, etc.

2. Install AmberTools. The AmberTools software package can be downloaded from the official AmberTools website and installed according to the instructions.

3. Run tleap. Enter the following command in the terminal:

    tleap

4. Load the molecular structure file in tleap. Enter the following command:

    source leaprc.protein.ff14SB
    mol = loadpdb input.pdb

    Where input.pdb is the name of the previously prepared molecular structure file.

5. Generate the topology file. Enter the following command:

    saveamberparm mol output.prmtop output.inpcrd

    Where output.prmtop is the name of the generated topology file, and output.inpcrd is the name of the generated coordinate file.

6. Set parameters as needed. Different force field types and parameters can be selected according to specific needs.

    Further simulation or calculation can be conducted based on the generated topology file and coordinate file.

    It should be noted that the force field type used here is preset in AmberTools (such as leaprc.protein.ff14SB), and different force field files may need to be loaded for other types of molecules. In addition, the generated topology file can be used with other software tools such as GROMACS, CHARMM, etc., and the specific operation methods may differ. Therefore, it is recommended to refer to the official documents or tutorials of related software tools for specific operations during use.

Answer 2: For common and standard molecules, several commonly used software tools can be utilized to generate topology files, such as AmberTools, GROMACS, and ACPYPE. Below is an example of how to generate a topology file using ACPYPE:

1. Firstly, prepare the pdb file of your small organic molecule. Then open https://bio2byte.be/acpype/.

2. Register an account: You can log in to the website using your email.

3. Click "Submit" on the left menu.

4. A "Upload a file with coordinates" page will pop up, and you can submit your pdb file under "Molecule Project" in the "Molecule file" section.

5. Choose "user" for the charge method and "AMBER" for the atom type.

6. Click "Submit" to start the calculation.

7. Download the results: ACPYPE will automatically pack the generated molecular force field parameters into a zip file, which can be downloaded and saved to a local folder by the user.

    It should be noted that the ACPYPE website can only generate force field parameters for small molecules, and other tools need to be used to generate force field parameters for large molecules (such as proteins, nucleic acids, etc.). In addition, although the force field parameters generated by ACPYPE can be used for molecular simulations, their accuracy and reliability still need to be experimentally verified and compared.




##问题：请问在gromacs中，如何通过mdp来设置模拟的步长和步数？如何设置模拟时间？

回答：在 GROMACS 中，你可以通过修改 .mdp （分子动力学参数）文件来设置模拟的步长和步数，以及模拟的总时间。

1. 设置模拟的步长和步数：

在 .mdp 文件中，你可以找到以下参数来设置模拟的步长和步数：
- `dt`：模拟的时间步长，以 femtoseconds (fs) 为单位。
- `nsteps`：模拟的总步数。
例如，如果你想要设置时间步长为 2 fs，总步数为 10000 步，你可以这样配置 .mdp 文件：
```
dt = 0.002
nsteps = 10000
```
2. 设置模拟时间：

如果你希望直接设置模拟的总时间而不是总步数，可以使用以下公式来计算总步数：
```
total_time = dt * nsteps
```
然后根据你想要的模拟时间，确定总步数，并将其设置为 `nsteps` 参数的值。


##Question: How can I set the simulation time step and number of steps using an .mdp file in GROMACS? How can I specify the simulation time?

Answer: In GROMACS, you can utilize the .mdp (molecular dynamics parameters) file to define the simulation time step, number of steps, and the overall simulation time.

1. Setting the simulation time step and number of steps:
Within the .mdp file, the following parameters can be adjusted to configure the simulation time step and number of steps:

-dt: The time interval per simulation step, typically expressed in femtoseconds (fs).
-nsteps: The total number of simulation steps. For instance, if you desire a time step of 2 fs and a total of 10,000 steps, you can modify the .mdp file as follows:

    dt = 0.002
    nsteps = 10000

2. Specifying the simulation time:

    If you prefer to specify the simulation time directly instead of the number of steps, you can calculate the total number of steps using the following formula:

    total_time = dt * nsteps

    Subsequently, determine the desired simulation time and compute the corresponding number of steps. Set this value as the nsteps parameter in the .mdp file.












##问题：请问gromacs中的cut-off概念是什么？我们应该如何设置cut-off这个参数？应该如何对cut-off进行取值？

回答：在分子动力学模拟中，cut-off 是用来定义在计算非键相互作用时考虑的最大截断距离。具体来说，它用于定义原子间相互作用的有效范围，超过这个范围的原子间相互作用将被忽略，以加速模拟的计算。cut-off 参数的设置会影响模拟系统的精确性和计算效率。

在 GROMACS 中，你可以通过修改 .mdp 文件来设置 cut-off 参数。常见的 cut-off 参数包括：

- `coulombtype`：用于设置库伦相互作用的处理方式，例如使用 cut-off 或者 PME (Particle Mesh Ewald) 方法。
- `rcoulomb`：用于设置库伦相互作用的截断半径。
- `vdwtype`：用于设置范德华相互作用的处理方式，例如使用 cut-off 或者 PME 方法。
- `rvdw`：用于设置范德华相互作用的截断半径。

对于 cut-off 参数的取值，通常需要在保证模拟精度的前提下尽可能地提高计算效率。一般来说，cut-off 参数的取值应该足够大，以包含模拟系统中所有可能的相互作用，但也不应该过大，以免引入额外的计算开销。

合理设置 cut-off 参数需要考虑以下因素：

1. 模拟系统的特性：包括系统的大小、密度、溶剂等。
2. 模拟的目的：例如是否关注长程相互作用。
3. 计算资源：包括计算机性能、模拟时间等。

一般来说，常见的 cut-off 参数取值范围是 0.8 - 1.4 纳米。但是最佳的 cut-off 参数取值需要通过测试和优化来确定，以保证模拟结果的准确性和计算效率。





##Question: What is the cut-off concept in GROMACS? How should we set this parameter? How do we determine optimal values for cut-off?

Answer: In molecular dynamics simulations, the cut-off is used to define the maximum distance considered when calculating non-bonded interactions. Specifically, it is used to define the effective range of atomic interactions, beyond which they are ignored to accelerate simulation calculations. The setting of the cut-off parameter affects both the accuracy and efficiency of the simulated system.

    In GROMACS, you can modify the .mdp file to set the cut-off parameter. Common cut-off parameters include:

-coulombtype: Used to specify the method of handling Coulombic interactions, such as cut-off or PME (Particle Mesh Ewald) methods.
-rcoulomb: Used to set the cut-off radius for Coulombic interactions.
-vdwtype: Used to specify the method of handling van der Waals interactions, such as cut-off or PME methods.
-rvdw: Used to set the cut-off radius for van der Waals interactions.

    When determining optimal values for cut-off, a balance must be struck between simulation accuracy and computational efficiency. Generally, the cut-off values should be large enough to include all possible interactions in the simulated system, yet not excessively large to introduce additional computational overhead.

    Factors to consider when setting cut-off parameters include:

1. Characteristics of the simulated system, such as its size, density, and solvent.

2. Objectives of the simulation, such as whether long-range interactions are of interest.

3. Computational resources, including computer performance and simulation time.

    Common values for cut-off parameters typically range between 0.8-1.4 nanometers. However, optimal cut-off values need to be determined through testing and optimization to ensure accurate simulation results with high computational efficiency.







##问题：请给我一个在mdp文件中设置cut-off相关参数的案例

回答：下面是一个在 .mdp 文件中设置 cut-off 相关参数的示例：

```plaintext
; 设置库伦相互作用的处理方式为 cut-off
coulombtype           = PME
rcoulomb              = 1.0   ; 库伦相互作用的截断半径为 1.0 纳米

; 设置范德华相互作用的处理方式为 cut-off
vdwtype               = cut-off
rvdw                  = 1.0   ; 范德华相互作用的截断半径为 1.0 纳米
```

    在这个示例中，`coulombtype` 参数设置为 PME 方法，用于处理库伦相互作用；`rcoulomb` 参数设置为 1.0 纳米，表示库伦相互作用的截断半径为 1.0 纳米。同时，`vdwtype` 参数设置为 cut-off，用于处理范德华相互作用；`rvdw` 参数也设置为 1.0 纳米，表示范德华相互作用的截断半径为 1.0 纳米。

请注意，这只是一个示例，实际的参数设置需要根据你的模拟系统和具体需求进行调整。



##Question: Can you provide an example of setting cut-off related parameters in an .mdp file?

Answer: Here is an example of setting cut-off related parameters in an .mdp file:

```plaintext
; Set the method for handling Coulombic interactions to PME
coulombtype           = PME
rcoulomb              = 1.0   ; Cut-off radius for Coulombic interactions is 1.0 nanometers

; Set the method for handling van der Waals interactions to cut-off
vdwtype               = cut-off
rvdw                  = 1.0   ; Cut-off radius for van der Waals interactions is 1.0 nanometers
```
    In this example, the coulombtype parameter is set to the PME method for handling Coulombic interactions, and the rcoulomb parameter is set to 1.0 nanometers, indicating a cut-off radius of 1.0 nanometers for Coulombic interactions. Similarly, the vdwtype parameter is set to cut-off for handling van der Waals interactions, and the rvdw parameter is also set to 1.0 nanometers, representing a cut-off radius of 1.0 nanometers for van der Waals interactions.

    Please note that this is just an example, and the actual parameter settings should be adjusted based on your simulation system and specific requirements.




##问题：请问我可以用gromacs中的什么指令来分析我的模型？

回答：GROMACS提供了一系列的指令和工具来分析模拟模型。以下是一些常用的GROMACS指令和功能，可以用于模型的分析：

1. 输出某个特定时刻的pdb：
    -命令：gmx trjconv -s model_name.tpr -f model_name.xtc -o model_name-pdb_time.pdb -n index-name.ndx -b pdb_time -e pdb_time -tu tu -pbc mol -center
    -描述：输出某些时刻的pdb文件以达到可视化的效果。

2. 计算和输出模拟系统的氢键数目：
   - 命令：gmx hbond -s model_name.tpr -f model_name.xtc -n index-name.ndx -tu tu -b begin_time -e end_time -num area-H-bond-name.xvg
   - 描述：这个命令可以根据你的需求去选择想要输出的原子和原子的氢键数量。

3. 计算密度分布：
   - 命令：gmx density -f model_name.xtc -s model_name.tpr -o density-z-CU3-0ns.xvg -sl 200 -n model_name.ndx -d z -symm -dens mass -b 0 -e 0
   - 描述：根据你的需求可以通过调整时间来计算你需要的密度分布。

4. 计算接触面积（Solvent Accessible Surface Area）：
   - 命令：gmx sasa -surface -output -s model_name.tpr -f model_name-pbc.xtc -n index-name.ndx -tu tu -b begin_time -e end_time -o area-SASA_name.xvg
   - 描述：根据你的需求可以计算原子之间的接触面积。

5.  计算RMSD（Root Mean Square Deviation）：
   - 命令：gmx rms -s model_name.tpr -f model_name-pbc.xtc -o RMSD-item-name-model_name.xvg -n index-name.ndx -tu tu -b begin_time -e end_time
   - 描述：计算每个时间点的蛋白质结构与参考结构之间的RMSD值，以了解蛋白质结构的稳定性和构象变化。

6. 计算RG（Radius of Gyration）：
   - 命令：gmx gyrate -s model_name.tpr -f model_name-pbc.xtc -n index-name.ndx -o Rg-RG_nanme-model_name.xvg
   - 描述：计算聚合物或者蛋白质分子整体结构的紧凑性的指标。

7. 分析能量（LJ/SR Coul/SR）：
   - 命令：gmx energy -s md-rerun.tpr -f md.edr -o md-THR-JQR.xvg
   - 描述：提取模拟中各种能量组分的时间演变曲线，如总能量、动能、势能等。

上述指令只是GROMACS提供的部分功能，具体使用时可以参考GROMACS的官方文档和指南，根据研究需求选择合适的指令进行分析。




##Question: What commands can I use in GROMACS to analyze my model?

Answer: GROMACS provides a range of commands and tools for analyzing simulation models. Here are some commonly used GROMACS commands and functionalities for model analysis:

1. Outputting a specific time frame as a PDB file:

    -Command: gmx trjconv -s model_name.tpr -f model_name.xtc -o model_name-pdb_time.pdb -n index-name.ndx -b pdb_time -e pdb_time -tu tu -pbc mol -center
    -Description: This command outputs PDB files at specific time frames for visualization purposes.

2. Calculating and outputting the number of hydrogen bonds in the simulation system:

    -Command: gmx hbond -s model_name.tpr -f model_name.xtc -n index-name.ndx -tu tu -b begin_time -e end_time -num area-H-bond-name.xvg
    -Description: This command allows you to select atoms and calculate the number of hydrogen bonds based on your requirements.

3. Calculating density distribution:

    -Command: gmx density -f model_name.xtc -s model_name.tpr -o density-z-CU3-0ns.xvg -sl 200 -n model_name.ndx -d z -symm -dens mass -b 0 -e 0
    -Description: Adjust the time frame according to your needs to compute the desired density distribution.

4. Calculating solvent-accessible surface area (SASA):

    -Command: gmx sasa -surface -output -s model_name.tpr -f model_name-pbc.xtc -n index-name.ndx -tu tu -b begin_time -e end_time -o area-SASA_name.xvg
    -Description: This command calculates the contact surface area between atoms based on your requirements.

5. Calculating Root Mean Square Deviation (RMSD):

    -Command: gmx rms -s model_name.tpr -f model_name-pbc.xtc -o RMSD-item-name-model_name.xvg -n index-name.ndx -tu tu -b begin_time -e end_time
    -Description: This command calculates the RMSD values between each time frame of the protein structure and a reference structure to analyze stability and conformational changes.

6. Calculating Radius of Gyration (Rg):

    -Command: gmx gyrate -s model_name.tpr -f model_name-pbc.xtc -n index-name.ndx -o Rg-RG_nanme-model_name.xvg
    -Description: This command calculates the compactness of a polymer or protein molecule's overall structure.

7. Analyzing energy (LJ/SR Coul/SR):

    -Command: gmx energy -s md-rerun.tpr -f md.edr -o md-THR-JQR.xvg
    -Description: This command extracts time-evolution curves of various energy components in the simulation, such as total energy, kinetic energy, potential energy, etc.

    The above commands represent only a subset of the functionalities provided by GROMACS. For specific usage, refer to the official documentation and guides of GROMACS, and choose the appropriate commands based on your research needs.











##问题：请问我可以用那些软件来可视化我的模型？

回答：有多种软件可以用来可视化分子模型和轨迹，以下是其中几个常用的软件：

1. VMD：VMD是一款功能强大的生物分子可视化软件，支持多种分子文件格式，包括PDB、GRO、DCD等。VMD提供了多种可视化功能，包括球棒模型、空间填充模型、表面模型、电子密度图等。

2. PyMOL：PyMOL是一款专业的分子可视化软件，支持多种分子文件格式，包括PDB、GRO、XYZ等。PyMOL提供了丰富的可视化功能，包括球棒模型、线框模型、卡通模型、表面模型等。

3. ChimeraX：ChimeraX是一款功能强大的分子可视化软件，支持多种分子文件格式，包括PDB、GRO、XYZ等。ChimeraX提供了多种可视化功能，包括球棒模型、线框模型、表面模型、密度图等。

4. UCSF Chimera：UCSF Chimera是一款广泛使用的分子可视化软件，支持多种分子文件格式，包括PDB、GRO、XYZ等。UCSF Chimera提供了多种可视化功能，包括球棒模型、线框模型、表面模型、密度图等。

5. Avogadro：Avogadro是一款免费的分子建模和可视化软件，支持多种分子文件格式，包括PDB、GRO、XYZ等。Avogadro提供了多种可视化功能，包括球棒模型、线框模型、表面模型等。

这些软件都非常适合用于可视化分子模型和轨迹，可以根据研究需求和个人喜好选择合适的软件进行使用。



##Question: What software can I use to visualize my model?

Answer: There are several software options available for visualizing molecular models and trajectories. Here are a few commonly used software tools:

1. VMD: VMD is a powerful molecular visualization software that supports various molecular file formats, including PDB, GRO, and DCD. It offers multiple visualization functions such as ball-and-stick models, space-filling models, surface models, and electron density maps.

2. PyMOL: PyMOL is a professional molecular visualization software that supports multiple molecular file formats, including PDB, GRO, and XYZ. It provides rich visualization features including ball-and-stick models, wireframe models, cartoon models, and surface models.

3. ChimeraX: ChimeraX is a powerful molecular visualization software supporting multiple molecular file formats, including PDB, GRO, and XYZ. It offers various visualization features such as ball-and-stick models, wireframe models, surface models, and density maps.

4. UCSF Chimera: UCSF Chimera is widely used molecular visualization software supporting multiple molecular file formats, including PDB, GRO, and XYZ. It provides diverse visualization functions including ball-and-stick models, wireframe models, surface models, and density maps.

5. Avogadro: Avogadro is a free molecular modeling and visualization software supporting multiple molecular file formats, including PDB, GRO, and XYZ. It offers various visualization features such as ball-and-stick models, wireframe models, and surface models.

    These software tools are well-suited for visualizing molecular models and trajectories. Users can choose the appropriate software based on their research needs and personal preferences.



##问题：我们想做一个蛋白和配体相互作用的分子动力学模拟，请给我一个方案。
回答：方案：
1. 准备初始结构：获取蛋白和配体的初始结构文件（通常为PDB格式），确保文件中包含所有所需的原子坐标和拓扑信息。
2. 参数化：对蛋白和配体进行力场参数化，包括分子力场参数（如AMBER、CHARMM等）和溶剂模型参数。
3. 盒子构建：根据模拟系统的大小和形状，使用适当的工具（如GROMACS自带的editconf命令）构建仿真盒子并确定溶剂的种类。
4. 溶剂添加：将水溶剂（如TIP3P水分子）添加到盒子中，以覆盖整个蛋白和配体的结构。
5. 能量最小化：对整个系统进行能量最小化，以消除不良的结构特征和去除能量高峰。
6. 平衡步骤：在最小化后进行一系列的平衡步骤，包括温度和压力的调节，使得系统逐渐达到平衡状态。
7. 生产动力学模拟：进行蛋白和配体的相互作用分子动力学模拟，通过设置适当的模拟时间和时间步长，记录模拟过程中的结构和动力学性质。
8. 数据分析：对模拟结果进行分析，包括构象稳定性、结合自由能、氢键形成等方面的评估，以了解蛋白和配体之间的相互作用。

请注意，以上方案仅作为概述，实际操作中可能需要根据具体情况进行调整和优化。

##Question: We would like to perform a molecular dynamics simulation of protein-ligand interactions. Could you provide a plan for us?

Answer: Plan:

1. Preparation of the initial structure: Obtain the initial structure files of the protein and ligand (usually in PDB format) ensuring that all the necessary atomic coordinates and topology information are included in the file.

2. Parameterization: Perform force field parameterization of the protein and ligand, including molecular force field parameters (such as AMBER, CHARMM, etc.) and solvent model parameters.

3. Box construction: Construct a simulation box using appropriate tools (such as the editconf command provided by GROMACS) based on the size and shape of the simulation system and determine the type of solvent.

4. Solvent addition: Add water solvent (such as TIP3P water molecules) to the box to cover the entire structure of the protein and ligand.

5. Energy minimization: Perform energy minimization of the entire system to eliminate adverse structural features and remove energy peaks.

6. Equilibration steps: Perform a series of equilibration steps after minimization, including temperature and pressure adjustment, to gradually achieve a balanced state of the system.

7. Production molecular dynamics simulation: Perform a molecular dynamics simulation of protein-ligand interactions with appropriate simulation time and time step settings and record the structure and dynamic properties during the simulation process.

8. Data analysis: Analyze the simulation results, including the evaluation of conformational stability, binding free energy, hydrogen bond formation, and other aspects to understand the interaction between the protein and ligand.

    Please note that the above plan is only an overview, and adjustments and optimizations may be required based on specific circumstances during the actual operation.







##问题：我们想做一个蛋白和配体相互作用的分子动力学模拟，请给我一个方案。

回答：方案：
1. 准备初始结构：获取蛋白和配体的初始结构文件（通常为PDB格式），确保文件中包含所有所需的原子坐标和拓扑信息。

2. 参数化：对蛋白和配体进行力场参数化，包括分子力场参数（如AMBER、CHARMM等）和溶剂模型参数。

3. 盒子构建：使用GROMACS中的editconf命令构建仿真盒子，并确定溶剂的种类。示例指令：
```bash
gmx editconf -f protein.pdb -o protein_box.gro -bt cubic -d 1.0
```

4. 溶剂和离子添加：使用GROMACS中的solvate命令将水溶剂添加到盒子中，然后使用genion命令添加离子。示例指令：
```bash
gmx solvate -cp protein_box.gro -cs spc216.gro -o solvated.gro -p topol.top
gmx grompp -f ions.mdp -c solvated.gro -p topol.top -o ions.tpr
gmx genion -s ions.tpr -o solvated_ions.gro -p topol.top -pname NA -nname CL -neutral
```

5. 能量最小化：使用GROMACS中的energy minimization（能量最小化）命令进行系统的能量最小化。示例指令：
```bash
gmx grompp -f em.mdp -c solvated_ions.gro -p topol.top -o em.tpr
gmx mdrun -v -deffnm em
```

6. 平衡步骤：进行温度和压力的调节，使用GROMACS中的NVT（等温）和NPT（等压）模拟步骤。示例指令：
```bash
gmx grompp -f nvt.mdp -c em.gro -p topol.top -o nvt.tpr
gmx mdrun -v -deffnm nvt

gmx grompp -f npt.mdp -c nvt.gro -t nvt.cpt -p topol.top -o npt.tpr
gmx mdrun -v -deffnm npt
```

7. 生产动力学模拟：进行蛋白和配体的相互作用分子动力学模拟。示例指令：
```bash
gmx grompp -f md.mdp -c npt.gro -t npt.cpt -p topol.top -o md.tpr
gmx mdrun -v -deffnm md
```

8. 数据分析：使用GROMACS自带的分析工具（如gmx rmsd、gmx rmsf等）对模拟结果进行分析。

请注意，以上示例指令仅供参考，实际操作中应根据具体情况和需求进行调整。



##Question：We want to perform a molecular dynamics simulation of protein-ligand interactions. Could you provide a plan?

Response:Plan:

1. Prepare initial structures: Obtain initial structure files for the protein and ligand (usually in PDB format), ensuring they contain all necessary atomic coordinates and topology information.

2. Parameterization: Parameterize the protein and ligand using force field parameters, including molecular force field parameters (such as AMBER, CHARMM, etc.) and solvent model parameters.

3. Box construction: Use the `editconf` command in GROMACS to construct a simulation box and determine the solvent type. Example command:
```bash
gmx editconf -f protein.pdb -o protein_box.gro -bt cubic -d 1.0
```

4. Solvent and ion addition: Use the `solvate` command in GROMACS to add water solvent to the box, then use the `genion` command to add ions. Example commands:
```bash
gmx solvate -cp protein_box.gro -cs spc216.gro -o solvated.gro -p topol.top
gmx grompp -f ions.mdp -c solvated.gro -p topol.top -o ions.tpr
gmx genion -s ions.tpr -o solvated_ions.gro -p topol.top -pname NA -nname CL -neutral
```

5. Energy minimization: Perform energy minimization of the system using the energy minimization command in GROMACS. Example commands:
```bash
gmx grompp -f em.mdp -c solvated_ions.gro -p topol.top -o em.tpr
gmx mdrun -v -deffnm em
```

6. Equilibration steps: Conduct temperature and pressure equilibration using NVT (constant volume) and NPT (constant pressure) simulation steps in GROMACS. Example commands:
```bash
gmx grompp -f nvt.mdp -c em.gro -p topol.top -o nvt.tpr
gmx mdrun -v -deffnm nvt

gmx grompp -f npt.mdp -c nvt.gro -t nvt.cpt -p topol.top -o npt.tpr
gmx mdrun -v -deffnm npt
```

7. Production molecular dynamics simulation: Perform molecular dynamics simulations of protein-ligand interactions. Example commands:
```bash
gmx grompp -f md.mdp -c npt.gro -t npt.cpt -p topol.top -o md.tpr
gmx mdrun -v -deffnm md
```

8. Data analysis: Analyze simulation results using built-in analysis tools in GROMACS (e.g., `gmx rmsd`, `gmx rmsf`, etc.).

Please note that the above example commands are for reference only and should be adjusted based on specific circumstances and requirements.






要下载一个蛋白质的结构，可以访问蛋白质数据银行（PDB）网站。蛋白质数据银行的网址是https://www.rcsb.org/。进入网站后，您可以使用搜索栏通过蛋白质的PDB ID进行搜索。然后，您可以下载所需格式的结构文件。





##问题：我需要一个em.mdp的示例文件。

回答：em.mdp文件可以参考以下文件：

===================================
em.mdp:

; to test
; echo 0 | gmx editconf -f Arg.mol2_GMX.gro -bt octahedron -d 1 -c -princ
; gmx grompp -f em.mdp -c out.gro -p Arg.mol2_GMX.top -o em.tpr -v
; gmx mdrun -ntmpi 1 -v -deffnm em

; Parameters describing what to do, when to stop and what to save
integrator      = steep     ; Algorithm (steep = steepest descent minimization)
nsteps          = 500       ; Maximum number of (minimization) steps to perform
nstxout         = 10

; Parameters describing how to find the neighbors of each atom and how to calculate the interactions
nstlist         = 1             ; Frequency to update the neighbour list and long range forces
cutoff-scheme   = Verlet
rlist           = 1.2           ; Cut-off for making neighbour list (short range forces)
coulombtype     = PME           ; Treatment of long range electrostatic interactions
rcoulomb        = 1.2           ; long range electrostatic cut-off
vdw-type        = cutoff
vdw-modifier    = force-switch
rvdw-switch     = 1.0
rvdw            = 1.2           ; long range Van der Waals cut-off
pbc             = xyz           ; Periodic Boundary Conditions
DispCorr        = no
; vmd em.gro em.trr

======================================================


##Question: I need an example file for em.mdp.

Answer: You can refer to the following file for an example of em.mdp:

=============================================================
em.mdp:

; to test
; echo 0 | gmx editconf -f Arg.mol2_GMX.gro -bt octahedron -d 1 -c -princ
; gmx grompp -f em.mdp -c out.gro -p Arg.mol2_GMX.top -o em.tpr -v
; gmx mdrun -ntmpi 1 -v -deffnm em

; Parameters describing what to do, when to stop and what to save
integrator      = steep     ; Algorithm (steep = steepest descent minimization)
nsteps          = 500       ; Maximum number of (minimization) steps to perform
nstxout         = 10

; Parameters describing how to find the neighbors of each atom and how to calculate the interactions
nstlist         = 1             ; Frequency to update the neighbor list and long-range forces
cutoff-scheme   = Verlet
rlist           = 1.2           ; Cut-off for making neighbor list (short-range forces)
coulombtype     = PME           ; Treatment of long-range electrostatic interactions
rcoulomb        = 1.2           ; Long-range electrostatic cut-off
vdw-type        = cutoff
vdw-modifier    = force-switch
rvdw-switch     = 1.0
rvdw            = 1.2           ; Long-range Van der Waals cut-off
pbc             = xyz           ; Periodic Boundary Conditions
DispCorr        = no
; vmd em.gro em.trr

=================================================================

This MDP file example defines an energy minimization simulation using the Steep algorithm, with a maximum of 500 minimization steps. It utilizes the Verlet algorithm for neighbor searching and interaction calculations. The interaction cutoff distance is set to 1.2 nm, and the simulation employs periodic boundary conditions in all three dimensions (xyz).






##问题：如果从protein data bank网站（https://www.rcsb.org/）下载得到的pdb文件有许多错误或者原子确实，怎么办？

回答：如果你从Protein Data Bank（PDB）网站下载的PDB文件存在错误或者缺少原子，你可以尝试以下方法来解决。

1. 首先从Protein Data Bank网站上找到您需要的pdb，然后从网站上取出您需要的蛋白对应序列，然后再去Swissmodel网站做一个同源建模的模板搜索。

2. 然后从Swissmodel下载对应的模板pdb文件下来，此时的文件则是无缺失的文件。

请注意，在进行任何修改或修复PDB文件时，务必小心谨慎，并确保你的操作不会影响结构的准确性和可信度。






##Question: What should I do if the PDB file downloaded from the Protein Data Bank website (https://www.rcsb.org/) contains many errors or missing atoms?

Answer: If you encounter errors or missing atoms in a PDB file downloaded from the Protein Data Bank (PDB) website, you can try the following approaches to address the issue.

1. Firstly, locate the desired PDB file on the Protein Data Bank website and retrieve the corresponding protein sequence from the website. Then, perform a template search using homology modeling on the SwissModel website.

2. Download the corresponding template PDB file from SwissModel. This file will be free of any missing atoms.

    Please note that when making any modifications or fixes to a PDB file, it is essential to proceed with caution and ensure that your actions do not compromise the accuracy and reliability of the structure.












##问题：我们想做一个蛋白和配体相互作用的分子动力学模拟，请给我一个方案。

回答：进行蛋白质和配体相互作用的分子动力学模拟可以参考以下的一个案例：

1. 本案例是蛋白质T4溶菌酶L99A/M102Q（PDB代码3THB），转到RCSB网站，并下载晶体结构的PDB文件；然后我们还需要一个配体的pdb文件。这里我们可以用InDraw去画一个，当然我们同样也可以在RCSB网站上找到我们需要的配体文件（PDB代码为JZ4）。

RCSB网址：https://www.rcsb.org/

在下载好结构后，可以使用查看程序（如VMD、Chimera、PyMOL等）将其可视化。然后查看分子后，去除其中的结晶水、PO4和BME。

2. 接着将删除了水分子的JZ4.pdb文件放去ACPYPE中生成相应的拓扑文件。

ACPYPE网站: https://bio2byte.be/acpype/


===================================================
JZ4.itp：

; JZ4.pdb.mol2_GMX.itp created by acpype (v: 2022.7.21) on Thu May 18 11:10:09 2023

[ atomtypes ]
.....
[ moleculetype ]
.....
[ atoms ]
.....
[ bonds ]
.....
[ pairs ]
.....

[ angles ]
.....

[ dihedrals ] ; propers
.....
[ dihedrals ] ; impropers
.....
========================================================

3. 准备蛋白质的拓扑文件： 
    -命令：gmx pdb2gmx -f 3thb-swissmodel.pdb -o 3thb-swissmodel.gro -water spce 

    选择amber03力场



================================================
3THB-swissmodel.gro:

2 3thb
 5355
    1ALA      N    1   4.505   0.038   5.331
    1ALA     H1    2   4.484  -0.019   5.410
    1ALA     H2    3   4.422   0.057   5.280
    1ALA     H3    4   4.571  -0.010   5.272
 .....
  333LYS      C 5353   2.079  -3.476  -1.895
  333LYS    OC1 5354   2.161  -3.571  -1.890
  333LYS    OC2 5355   1.974  -3.478  -1.964
   8.18148   6.78289   9.05745

===========================================
posre.itp:

; In this topology include file, you will find position restraint
; entries for all the heavy atoms in your original pdb file.
; This means that all the protons which were added by pdb2gmx are
; not restrained.

[ position_restraints ]
......
========================================
topol.top:

......
; Include forcefield parameters
#include "amber03.ff/forcefield.itp"

[ moleculetype ]
......
[ atoms ]
......
[ bonds ]
......
[ pairs ]
......
[ angles ]
......
[ dihedrals ]
......
[ dihedrals ]
......

; Include Position restraint file
#ifdef POSRES
#include "posre.itp"
#endif

; Include water topology
#include "amber03.ff/spce.itp"

#ifdef POSRES_WATER
; Position restraint for each water oxygen
[ position_restraints ]
;  i funct       fcx        fcy        fcz
   1    1       1000       1000       1000
#endif

; Include topology for ions
#include "amber03.ff/ions.itp"

[ system ]
; Name
2 3thb

[ molecules ]
; Compound        #mols
Protein_chain_A     1
================================================

4. 改top文件。同时将原来JZ4.itp文件中的对应部分删掉。

================================================
这是在top文件底部需要做的合并改动：

; Include jz4_GMX.itp topology
#include "jz4_GMX.itp"


; Include Position restraint file
#ifdef POSRES
#include "posre.itp"
#endif

; Include water topology
#include "amber03.ff/spce.itp"

#ifdef POSRES_WATER
; Position restraint for each water oxygen
[ position_restraints ]
;  i funct       fcx        fcy        fcz
   1    1       1000       1000       1000
#endif

; Include topology for ions
#include "amber03.ff/ions.itp"

[ system ]
; Name
2 3thb

[ molecules ]
; Compound        #mols
Protein_chain_A     1
UNK                         1

================================================
这是需要在top文件正开头处添加的内容，然后我们还需要将jz4.itp文件中相应的内容删去。

; Include forcefield parameters
#include "amber03.ff/forcefield.itp"

[ atomtypes ]           （这里来自JZ4.itp应把原文件中的对应部分删掉）
name   bond_type     mass     charge   ptype   sigma         epsilon       Amb
 c3       c3          0.00000  0.00000   A     3.39967e-01   4.57730e-01 ; 1.91  0.1094
 ca       ca          0.00000  0.00000   A     3.39967e-01   3.59824e-01 ; 1.91  0.0860
 oh       oh          0.00000  0.00000   A     3.06647e-01   8.80314e-01 ; 1.72  0.2104
 hc       hc          0.00000  0.00000   A     2.64953e-01   6.56888e-02 ; 1.49  0.0157
 ha       ha          0.00000  0.00000   A     2.59964e-01   6.27600e-02 ; 1.46  0.0150
 ho       ho          0.00000  0.00000   A     0.00000e+00   0.00000e+00 ; 0.00  0.0000

[ moleculetype ]

===================================================

5. 用Pymol打开蛋白和小分子配体，合并保存为一个complex.pdb。

6. 将complex.pdb转为gro形式。
    -命令：gmx editconf -f complex.pdb -o complex.gro

7. 定义单元盒子并填充水分子：
    -命令：gmx editconf -f complex.gro -o newbox.gro -bt dodecahedron -d 1.0 
    -命令：gmx solvate -cp newbox.gro -cs spc216.gro -p topol.top -o solv.gro

8. 使用ions.mdp文件来运行能量最小化，因为它们需要最少的参数，因此最容易维护：
    -命令：gmx grompp -f ions.mdp -c solv.gro -p topol.top -o ions.tpr -maxwarn 3
    -命令：gmx genion -s ions.tpr -o solv_ions.gro -p topol.top -pname NA -nname CL -neutral
    选择15 SOL；随机抽水换成Na离子平衡体系。

===================================
ions.mdp:

; ions.mdp - used as input into grompp to generate ions.tpr
; Parameters describing what to do, when to stop and what to save
integrator  = steep     ; Algorithm (steep = steepest descent minimization)
emtol       = 1000.0    ; Stop minimization when the maximum force < 1000.0 kJ/mol/nm
emstep      = 0.01      ; Energy step size
nsteps      = 50000     ; Maximum number of (minimization) steps to perform

; Parameters describing how to find the neighbors of each atom and how to calculate the interactions
nstlist         = 1         ; Frequency to update the neighbor list and long range forces
cutoff-scheme   = Verlet
ns_type         = grid      ; Method to determine neighbor list (simple, grid)
coulombtype     = PME       ; Treatment of long range electrostatic interactions
rcoulomb        = 1.0       ; Short-range electrostatic cut-off
rvdw            = 1.0       ; Short-range Van der Waals cut-off
pbc             = xyz       ; Periodic Boundary Conditions (yes/no)

===================================

9. 能量最小化（em）：
    -命令：gmx grompp -f em.mdp -c solv_ions.gro -p topol.top -o em.tpr
    -命令：gmx mdrun -deffnm em -v

===================================
em.mdp:

; to test
; echo 0 | gmx editconf -f Arg.mol2_GMX.gro -bt octahedron -d 1 -c -princ
; gmx grompp -f em.mdp -c out.gro -p Arg.mol2_GMX.top -o em.tpr -v
; gmx mdrun -ntmpi 1 -v -deffnm em

; Parameters describing what to do, when to stop and what to save
integrator      = steep     ; Algorithm (steep = steepest descent minimization)
nsteps          = 500       ; Maximum number of (minimization) steps to perform
nstxout         = 10

; Parameters describing how to find the neighbors of each atom and how to calculate the interactions
nstlist         = 1             ; Frequency to update the neighbour list and long range forces
cutoff-scheme   = Verlet
rlist           = 1.2           ; Cut-off for making neighbour list (short range forces)
coulombtype     = PME           ; Treatment of long range electrostatic interactions
rcoulomb        = 1.2           ; long range electrostatic cut-off
vdw-type        = cutoff
vdw-modifier    = force-switch
rvdw-switch     = 1.0
rvdw            = 1.2           ; long range Van der Waals cut-off
pbc             = xyz           ; Periodic Boundary Conditions
DispCorr        = no
; vmd em.gro em.trr

======================================================

10. NVT平衡：
      -命令：gmx grompp -f nvt.mdp -c em.gro -r em.gro -p topol.top -o nvt.tpr
      -命令：gmx mdrun -deffnm nvt

===================================
nvt.mdp:

title       = OPLS Lysozyme NVT equilibration
;define      = -DPOSRES -DPOSRES_NAD_GMX ; ; position restrain the protein
; Run parameters
integrator  = md        ; leap-frog integrator
nsteps      = 50000     ; 2 * 50000 = 100 ps
dt          = 0.002     ; 2 fs
; Output control
nstxout     = 500       ; save coordinates every 1.0 ps
nstvout     = 500       ; save velocities every 1.0 ps
nstenergy   = 500       ; save energies every 1.0 ps
nstlog      = 500       ; update log file every 1.0 ps
; Bond parameters
continuation            = no        ; first dynamics run
constraint_algorithm    = lincs     ; holonomic constraints
constraints             = all-bonds ; all bonds (even heavy atom-H bonds) constrained
lincs_iter              = 1         ; accuracy of LINCS
lincs_order             = 4         ; also related to accuracy
; Neighborsearching
cutoff-scheme   = Verlet
ns_type         = grid      ; search neighboring grid cells
nstlist         = 10        ; 20 fs, largely irrelevant with Verlet
rcoulomb        = 1.0       ; short-range electrostatic cutoff (in nm)
rvdw            = 1.0       ; short-range van der Waals cutoff (in nm)
; Electrostatics
coulombtype     = PME   ; Particle Mesh Ewald for long-range electrostatics
pme_order       = 4     ; cubic interpolation
fourierspacing  = 0.16  ; grid spacing for FFT
; Temperature coupling is on
tcoupl      = V-rescale             ; modified Berendsen thermostat
tc-grps     = SYSTEM; water non-water   ; two coupling groups - more accurate
tau_t       = 0.1  ;0.1              ; time constant, in ps
ref_t       = 298.15  ; 298.15           ; reference temperature, one for each group, in K
; Pressure coupling is off
pcoupl      = no        ; no pressure coupling in NVT
; Periodic boundary conditions
pbc     = xyz           ; 3-D PBC
; Dispersion correction
DispCorr    = EnerPres  ; account for cut-off vdW scheme
; Velocity generation
gen_vel     = yes       ; assign velocities from Maxwell distribution
gen_temp    = 300       ; temperature for Maxwell distribution
gen_seed    = -1        ; generate a random seed

=================================================

11. NPT平衡：
      -命令：gmx grompp -f npt.mdp -c nvt.gro -r nvt.gro -t nvt.cpt -p topol.top -o npt.tpr
      -命令：gmx mdrun -deffnm npt -v

=================================================
npt.mdp:

title       = OPLS Lysozyme NPT equilibration
;define      = -DPOSRES -DPOSRES_NAD_GMX ; position restrain the protein
; Run parameters
integrator  = md        ; leap-frog integrator
nsteps      = 50000     ; 2 * 50000 = 100 ps
dt          = 0.002     ; 2 fs
; Output control
nstxout     = 500       ; save coordinates every 1.0 ps
nstvout     = 500       ; save velocities every 1.0 ps
nstenergy   = 500       ; save energies every 1.0 ps
nstlog      = 500       ; update log file every 1.0 ps
; Bond parameters
continuation            = yes       ; Restarting after NVT
constraint_algorithm    = lincs     ; holonomic constraints
constraints             = all-bonds ; all bonds (even heavy atom-H bonds) constrained
lincs_iter              = 1         ; accuracy of LINCS
lincs_order             = 4         ; also related to accuracy
; Neighborsearching
cutoff-scheme   = Verlet
ns_type         = grid      ; search neighboring grid cells
nstlist         = 10        ; 20 fs, largely irrelevant with Verlet scheme
rcoulomb        = 1.0       ; short-range electrostatic cutoff (in nm)
rvdw            = 1.0       ; short-range van der Waals cutoff (in nm)
; Electrostatics
coulombtype     = PME       ; Particle Mesh Ewald for long-range electrostatics
pme_order       = 4         ; cubic interpolation
fourierspacing  = 0.16      ; grid spacing for FFT
; Temperature coupling is on
tcoupl      = V-rescale             ; modified Berendsen thermostat
tc-grps     = water non-water   ; two coupling groups - more accurate
tau_t       = 0.1   0.1              ; time constant, in ps
ref_t       = 298.15    298.15            ; reference temperature, one for each group, in K
; Pressure coupling is on
pcoupl              = Parrinello-Rahman     ; Pressure coupling on in NPT
pcoupltype          = isotropic             ; uniform scaling of box vectors
tau_p               = 2.0                   ; time constant, in ps
ref_p               = 1.0                   ; reference pressure, in bar
compressibility     = 4.5e-5                ; isothermal compressibility of water, bar^-1
refcoord_scaling    = com
; Periodic boundary conditions
pbc     = xyz       ; 3-D PBC
; Dispersion correction
DispCorr    = EnerPres  ; account for cut-off vdW scheme
; Velocity generation
gen_vel     = no        ; Velocity generation is off

==========================================

12. 成品MD：
      -命令：gmx grompp -f md.mdp -c npt.gro -t npt.cpt -p topol.top -o md.tpr
      -命令：gmx mdrun -deffnm md -v

=========================================
md.mdp:

title       = OPLS Lysozyme MD simulation
; Run parameters
integrator  = md        ; leap-frog integrator
nsteps      = 500000    ; 2 * 500000 = 1000 ps (1 ns)
dt          = 0.002     ; 2 fs
; Output control
nstxout             = 5000      ; save coordinates every 10.0 ps
nstvout             = 5000      ; save velocities every 10.0 ps
nstenergy           = 5000      ; save energies every 10.0 ps
nstlog              = 5000      ; update log file every 10.0 ps
nstxout-compressed  = 5000      ; save compressed coordinates every 10.0 ps
                                ; nstxout-compressed replaces nstxtcout
compressed-x-grps   = System    ; replaces xtc-grps
; Bond parameters
continuation            = yes       ; Restarting after NPT
constraint_algorithm    = lincs     ; holonomic constraints
constraints             = all-bonds ; all bonds (even heavy atom-H bonds) constrained
lincs_iter              = 1         ; accuracy of LINCS
lincs_order             = 4         ; also related to accuracy
; Neighborsearching
cutoff-scheme   = Verlet
ns_type         = grid      ; search neighboring grid cells
nstlist         = 10        ; 20 fs, largely irrelevant with Verlet scheme
rcoulomb        = 0.8       ; short-range electrostatic cutoff (in nm)
rvdw            = 0.8       ; short-range van der Waals cutoff (in nm)
rlist             =0.8
; Electrostatics
coulombtype     = PME       ; Particle Mesh Ewald for long-range electrostatics
pme_order       = 4         ; cubic interpolation
fourierspacing  = 0.16      ; grid spacing for FFT
; Temperature coupling is on
tcoupl      = V-rescale             ; modified Berendsen thermostat
tc-grps     = system   ; one coupling groups - more accurate
tau_t       = 0.1 ; time constant, in ps
ref_t       = 300 ; reference temperature, one for each group, in K
; Pressure coupling is on
pcoupl              = Parrinello-Rahman     ; Pressure coupling on in NPT
pcoupltype          = isotropic             ; uniform scaling of box vectors
tau_p               = 2.0                   ; time constant, in ps
ref_p               = 1.0                   ; reference pressure, in bar
compressibility     = 4.5e-5                ; isothermal compressibility of water, bar^-1
; Periodic boundary conditions
pbc     = xyz       ; 3-D PBC
; Dispersion correction
DispCorr    = EnerPres  ; account for cut-off vdW scheme
; Velocity generation
gen_vel     = no        ; Velocity generation is off


================================================

请注意，以上示例指令仅供参考，实际操作中应根据具体情况和需求进行调整。



##Question: We want to perform a molecular dynamics simulation of protein-ligand interaction. Please provide a protocol for this.

Answer: To perform a molecular dynamics simulation of protein-ligand interaction, you can refer to the following protocol:

1. The case study involves the protein T4 lysozyme L99A/M102Q (PDB code 3THB). First, download the crystal structure PDB file from the RCSB website. Additionally, obtain the PDB file for the ligand, for example, JZ4 (PDB code).

    RCSB website: https://www.rcsb.org/

    After downloading the structures, visualize them using visualization software such as VMD, Chimera, or PyMOL. Subsequently, remove crystalline water, PO4, and BME from the molecules.

2. Generate the topology file for the ligand using ACPYPE.

    ACPYPE website: https://bio2byte.be/acpype/

    After ACPYPE processing, the JZ4.itp file will be generated containing the topology information for the ligand.

===================================================
JZ4.itp：

; JZ4.pdb.mol2_GMX.itp created by acpype (v: 2022.7.21) on Thu May 18 11:10:09 2023

[ atomtypes ]
.....
[ moleculetype ]
.....
[ atoms ]
.....
[ bonds ]
.....
[ pairs ]
.....

[ angles ]
.....

[ dihedrals ] ; propers
.....
[ dihedrals ] ; impropers
.....
========================================================

3. Prepare the topology file for the protein:

    -Command: gmx pdb2gmx -f 3thb-swissmodel.pdb -o 3thb-swissmodel.gro -water spce 

    Select the Amber03 force field.

================================================
3THB-swissmodel.gro:

2 3thb
 5355
    1ALA      N    1   4.505   0.038   5.331
    1ALA     H1    2   4.484  -0.019   5.410
    1ALA     H2    3   4.422   0.057   5.280
    1ALA     H3    4   4.571  -0.010   5.272
 .....
  333LYS      C 5353   2.079  -3.476  -1.895
  333LYS    OC1 5354   2.161  -3.571  -1.890
  333LYS    OC2 5355   1.974  -3.478  -1.964
   8.18148   6.78289   9.05745

===========================================
posre.itp:

; In this topology include file, you will find position restraint
; entries for all the heavy atoms in your original pdb file.
; This means that all the protons which were added by pdb2gmx are
; not restrained.

[ position_restraints ]
......
========================================
topol.top:

......
; Include forcefield parameters
#include "amber03.ff/forcefield.itp"

[ moleculetype ]
......
[ atoms ]
......
[ bonds ]
......
[ pairs ]
......
[ angles ]
......
[ dihedrals ]
......
[ dihedrals ]
......

; Include Position restraint file
#ifdef POSRES
#include "posre.itp"
#endif

; Include water topology
#include "amber03.ff/spce.itp"

#ifdef POSRES_WATER
; Position restraint for each water oxygen
[ position_restraints ]
;  i funct       fcx        fcy        fcz
   1    1       1000       1000       1000
#endif

; Include topology for ions
#include "amber03.ff/ions.itp"

[ system ]
; Name
2 3thb

[ molecules ]
; Compound        #mols
Protein_chain_A     1
================================================

4. To modify the top file, simultaneously remove the corresponding section from the original JZ4.itp file.

===========================================================
Below is the combined modification needed at the bottom of the top file:

plaintext
; Include jz4_GMX.itp topology
#include "jz4_GMX.itp"

; Include Position restraint file
#ifdef POSRES
#include "posre.itp"
#endif

; Include water topology
#include "amber03.ff/spce.itp"

#ifdef POSRES_WATER
; Position restraint for each water oxygen
[ position_restraints ]
;  i funct       fcx        fcy        fcz
   1    1       1000       1000       1000
#endif

; Include topology for ions
#include "amber03.ff/ions.itp"

[ system ]
; Name
2 3thb

[ molecules ]
; Compound        #mols
Protein_chain_A     1
UNK                         1
The following content needs to be added at the beginning of the top file. Additionally, we need to remove the corresponding content from the jz4.itp file:

plaintext
; Include forcefield parameters
#include "amber03.ff/forcefield.itp"

[ atomtypes ]           (The corresponding section from JZ4.itp should be removed in the original file)
name   bond_type     mass     charge   ptype   sigma         epsilon       Amb
 c3       c3          0.00000  0.00000   A     3.39967e-01   4.57730e-01 ; 1.91  0.1094
 ca       ca          0.00000  0.00000   A     3.39967e-01   3.59824e-01 ; 1.91  0.0860
 oh       oh          0.00000  0.00000   A     3.06647e-01   8.80314e-01 ; 1.72  0.2104
 hc       hc          0.00000  0.00000   A     2.64953e-01   6.56888e-02 ; 1.49  0.0157
 ha       ha          0.00000  0.00000   A     2.59964e-01   6.27600e-02 ; 1.46  0.0150
 ho       ho          0.00000  0.00000   A     0.00000e+00   0.00000e+00 ; 0.00  0.0000

[ moleculetype ]
============================================================

5. Use PyMOL to open the protein and ligand and merge and save them as a single complex.pdb file.

6. Convert the complex.pdb file to the .gro format:

    -Command: gmx editconf -f complex.pdb -o complex.gro

7. Define the simulation box and solvate the system with water molecules:

    -Command:gmx editconf -f complex.gro -o newbox.gro -bt dodecahedron -d 1.0
    -Command:gmx solvate -cp newbox.gro -cs spc216.gro -p topol.top -o solv.gro

8. Perform energy minimization using the ions.mdp file:

    -Command:gmx grompp -f ions.mdp -c solv.gro -p topol.top -o ions.tpr -maxwarn 3
    -Command:gmx genion -s ions.tpr -o solv_ions.gro -p topol.top -pname NA -nname CL -neutral

     Select 15 SOL molecules to be randomly replaced with Na ions to neutralize the system.

===================================
ions.mdp:

; ions.mdp - used as input into grompp to generate ions.tpr
; Parameters describing what to do, when to stop and what to save
integrator  = steep     ; Algorithm (steep = steepest descent minimization)
emtol       = 1000.0    ; Stop minimization when the maximum force < 1000.0 kJ/mol/nm
emstep      = 0.01      ; Energy step size
nsteps      = 50000     ; Maximum number of (minimization) steps to perform

; Parameters describing how to find the neighbors of each atom and how to calculate the interactions
nstlist         = 1         ; Frequency to update the neighbor list and long range forces
cutoff-scheme   = Verlet
ns_type         = grid      ; Method to determine neighbor list (simple, grid)
coulombtype     = PME       ; Treatment of long range electrostatic interactions
rcoulomb        = 1.0       ; Short-range electrostatic cut-off
rvdw            = 1.0       ; Short-range Van der Waals cut-off
pbc             = xyz       ; Periodic Boundary Conditions (yes/no)

===================================



9. Perform energy minimization (EM) using the em.mdp file:

    -Command:gmx grompp -f em.mdp -c solv_ions.gro -p topol.top -o em.tpr
    -Command:gmx mdrun -deffnm em -v

===================================
em.mdp:

; to test
; echo 0 | gmx editconf -f Arg.mol2_GMX.gro -bt octahedron -d 1 -c -princ
; gmx grompp -f em.mdp -c out.gro -p Arg.mol2_GMX.top -o em.tpr -v
; gmx mdrun -ntmpi 1 -v -deffnm em

; Parameters describing what to do, when to stop and what to save
integrator      = steep     ; Algorithm (steep = steepest descent minimization)
nsteps          = 500       ; Maximum number of (minimization) steps to perform
nstxout         = 10

; Parameters describing how to find the neighbors of each atom and how to calculate the interactions
nstlist         = 1             ; Frequency to update the neighbour list and long range forces
cutoff-scheme   = Verlet
rlist           = 1.2           ; Cut-off for making neighbour list (short range forces)
coulombtype     = PME           ; Treatment of long range electrostatic interactions
rcoulomb        = 1.2           ; long range electrostatic cut-off
vdw-type        = cutoff
vdw-modifier    = force-switch
rvdw-switch     = 1.0
rvdw            = 1.2           ; long range Van der Waals cut-off
pbc             = xyz           ; Periodic Boundary Conditions
DispCorr        = no
; vmd em.gro em.trr

======================================================

10. Perform NVT equilibration using the nvt.mdp file:

    -Command:gmx grompp -f nvt.mdp -c em.gro -r em.gro -p topol.top -o nvt.tpr
    -Command:gmx mdrun -deffnm nvt

===================================
nvt.mdp:

title       = OPLS Lysozyme NVT equilibration
;define      = -DPOSRES -DPOSRES_NAD_GMX ; ; position restrain the protein
; Run parameters
integrator  = md        ; leap-frog integrator
nsteps      = 50000     ; 2 * 50000 = 100 ps
dt          = 0.002     ; 2 fs
; Output control
nstxout     = 500       ; save coordinates every 1.0 ps
nstvout     = 500       ; save velocities every 1.0 ps
nstenergy   = 500       ; save energies every 1.0 ps
nstlog      = 500       ; update log file every 1.0 ps
; Bond parameters
continuation            = no        ; first dynamics run
constraint_algorithm    = lincs     ; holonomic constraints
constraints             = all-bonds ; all bonds (even heavy atom-H bonds) constrained
lincs_iter              = 1         ; accuracy of LINCS
lincs_order             = 4         ; also related to accuracy
; Neighborsearching
cutoff-scheme   = Verlet
ns_type         = grid      ; search neighboring grid cells
nstlist         = 10        ; 20 fs, largely irrelevant with Verlet
rcoulomb        = 1.0       ; short-range electrostatic cutoff (in nm)
rvdw            = 1.0       ; short-range van der Waals cutoff (in nm)
; Electrostatics
coulombtype     = PME   ; Particle Mesh Ewald for long-range electrostatics
pme_order       = 4     ; cubic interpolation
fourierspacing  = 0.16  ; grid spacing for FFT
; Temperature coupling is on
tcoupl      = V-rescale             ; modified Berendsen thermostat
tc-grps     = SYSTEM; water non-water   ; two coupling groups - more accurate
tau_t       = 0.1  ;0.1              ; time constant, in ps
ref_t       = 298.15  ; 298.15           ; reference temperature, one for each group, in K
; Pressure coupling is off
pcoupl      = no        ; no pressure coupling in NVT
; Periodic boundary conditions
pbc     = xyz           ; 3-D PBC
; Dispersion correction
DispCorr    = EnerPres  ; account for cut-off vdW scheme
; Velocity generation
gen_vel     = yes       ; assign velocities from Maxwell distribution
gen_temp    = 300       ; temperature for Maxwell distribution
gen_seed    = -1        ; generate a random seed

=================================================

11. Perform NPT equilibration using the npt.mdp file:

    -Command:gmx grompp -f npt.mdp -c nvt.gro -r nvt.gro -t nvt.cpt -p topol.top -o npt.tpr
    -Command:gmx mdrun -deffnm npt -v

=================================================
npt.mdp:

title       = OPLS Lysozyme NPT equilibration
;define      = -DPOSRES -DPOSRES_NAD_GMX ; position restrain the protein
; Run parameters
integrator  = md        ; leap-frog integrator
nsteps      = 50000     ; 2 * 50000 = 100 ps
dt          = 0.002     ; 2 fs
; Output control
nstxout     = 500       ; save coordinates every 1.0 ps
nstvout     = 500       ; save velocities every 1.0 ps
nstenergy   = 500       ; save energies every 1.0 ps
nstlog      = 500       ; update log file every 1.0 ps
; Bond parameters
continuation            = yes       ; Restarting after NVT
constraint_algorithm    = lincs     ; holonomic constraints
constraints             = all-bonds ; all bonds (even heavy atom-H bonds) constrained
lincs_iter              = 1         ; accuracy of LINCS
lincs_order             = 4         ; also related to accuracy
; Neighborsearching
cutoff-scheme   = Verlet
ns_type         = grid      ; search neighboring grid cells
nstlist         = 10        ; 20 fs, largely irrelevant with Verlet scheme
rcoulomb        = 1.0       ; short-range electrostatic cutoff (in nm)
rvdw            = 1.0       ; short-range van der Waals cutoff (in nm)
; Electrostatics
coulombtype     = PME       ; Particle Mesh Ewald for long-range electrostatics
pme_order       = 4         ; cubic interpolation
fourierspacing  = 0.16      ; grid spacing for FFT
; Temperature coupling is on
tcoupl      = V-rescale             ; modified Berendsen thermostat
tc-grps     = water non-water   ; two coupling groups - more accurate
tau_t       = 0.1   0.1              ; time constant, in ps
ref_t       = 298.15    298.15            ; reference temperature, one for each group, in K
; Pressure coupling is on
pcoupl              = Parrinello-Rahman     ; Pressure coupling on in NPT
pcoupltype          = isotropic             ; uniform scaling of box vectors
tau_p               = 2.0                   ; time constant, in ps
ref_p               = 1.0                   ; reference pressure, in bar
compressibility     = 4.5e-5                ; isothermal compressibility of water, bar^-1
refcoord_scaling    = com
; Periodic boundary conditions
pbc     = xyz       ; 3-D PBC
; Dispersion correction
DispCorr    = EnerPres  ; account for cut-off vdW scheme
; Velocity generation
gen_vel     = no        ; Velocity generation is off

==========================================

12. Perform production MD simulation using the md.mdp file:

    -Command:gmx grompp -f md.mdp -c npt.gro -t npt.cpt -p topol.top -o md.tpr
    -Command:gmx mdrun -deffnm md -v

=========================================
md.mdp:

title       = OPLS Lysozyme MD simulation
; Run parameters
integrator  = md        ; leap-frog integrator
nsteps      = 500000    ; 2 * 500000 = 1000 ps (1 ns)
dt          = 0.002     ; 2 fs
; Output control
nstxout             = 5000      ; save coordinates every 10.0 ps
nstvout             = 5000      ; save velocities every 10.0 ps
nstenergy           = 5000      ; save energies every 10.0 ps
nstlog              = 5000      ; update log file every 10.0 ps
nstxout-compressed  = 5000      ; save compressed coordinates every 10.0 ps
                                ; nstxout-compressed replaces nstxtcout
compressed-x-grps   = System    ; replaces xtc-grps
; Bond parameters
continuation            = yes       ; Restarting after NPT
constraint_algorithm    = lincs     ; holonomic constraints
constraints             = all-bonds ; all bonds (even heavy atom-H bonds) constrained
lincs_iter              = 1         ; accuracy of LINCS
lincs_order             = 4         ; also related to accuracy
; Neighborsearching
cutoff-scheme   = Verlet
ns_type         = grid      ; search neighboring grid cells
nstlist         = 10        ; 20 fs, largely irrelevant with Verlet scheme
rcoulomb        = 0.8       ; short-range electrostatic cutoff (in nm)
rvdw            = 0.8       ; short-range van der Waals cutoff (in nm)
rlist             =0.8
; Electrostatics
coulombtype     = PME       ; Particle Mesh Ewald for long-range electrostatics
pme_order       = 4         ; cubic interpolation
fourierspacing  = 0.16      ; grid spacing for FFT
; Temperature coupling is on
tcoupl      = V-rescale             ; modified Berendsen thermostat
tc-grps     = system   ; one coupling groups - more accurate
tau_t       = 0.1 ; time constant, in ps
ref_t       = 300 ; reference temperature, one for each group, in K
; Pressure coupling is on
pcoupl              = Parrinello-Rahman     ; Pressure coupling on in NPT
pcoupltype          = isotropic             ; uniform scaling of box vectors
tau_p               = 2.0                   ; time constant, in ps
ref_p               = 1.0                   ; reference pressure, in bar
compressibility     = 4.5e-5                ; isothermal compressibility of water, bar^-1
; Periodic boundary conditions
pbc     = xyz       ; 3-D PBC
; Dispersion correction
DispCorr    = EnerPres  ; account for cut-off vdW scheme
; Velocity generation
gen_vel     = no        ; Velocity generation is off


================================================

    Please note that the sample commands provided above are for reference only, and actual operations should be adjusted according to specific circumstances and requirements.














##问题：在跑完MD成品后，我发现并未达到我的预期效果，我想更改截断距离重新跑一次的话要如何修改我的mdp文件。

回答：如果您想更改GROMACS模拟中的截断距离，可以通过修改mdp文件中的相应参数来实现。具体操作如下：

1. 打开您的mdp文件，找到“Cutoff Scheme”部分。
    在这个部分中，您会看到类似于以下内容的行：
  
     cutoff-scheme          = Verlet

2. 这里的"Verlet"是默认的截断方案。如果您想要修改截断距离，可以将其修改为其他截断方案，例如：

     cutoff-scheme          = Group

3. 然后，在mdp文件中找到“Nonbonded Settings”部分。

4. 在这个部分中，您会看到以下内容：

    coulombtype           = PME
    rcoulomb              = 1.0
    vdwtype               = Cut-off
    rvdw                  = 1.0

    这里的“rcoulomb”和“rvdw”参数分别控制库仑相互作用和范德华相互作用的截断距离。您可以将其修改为您需要的值，例如：

    coulombtype           = PME
    rcoulomb              = 1.2
    vdwtype               = Cut-off
    rvdw                  = 1.2

5. 保存您的mdp文件，并在运行模拟程序时指定该文件。

    注意：在修改截断距离时，请确保使用合理的数值，并考虑到系统的特性和物理效应。不当的截断距离设置可能会导致模拟结果不准确或者出现异常。建议在更改截断距离时，先进行小规模的测试和验证，以确保模拟的准确性和可靠性。


##Question: After running the MD simulation, I found that the results did not meet my expectations. I would like to modify the cutoff distance and run the simulation again. How can I modify my mdp file for this purpose?

Answer: If you want to change the cutoff distance in your GROMACS simulation, you can achieve this by modifying the corresponding parameters in the mdp file. Here are the steps:

1. Open your mdp file and locate the "Cutoff Scheme" section. You will find a line similar to the following:

    cutoff-scheme          = Verlet

    Here, "Verlet" is the default cutoff scheme. If you want to modify the cutoff distance, you can change it to another cutoff scheme, for example:

    cutoff-scheme          = Group

2. Next, find the "Nonbonded Settings" section in the mdp file.

3. In this section, you will see the following lines:

    coulombtype           = PME
    rcoulomb              = 1.0
    vdwtype               = Cut-off
    rvdw                  = 1.0

    The parameters "rcoulomb" and "rvdw" control the cutoff distance for the Coulombic interaction and van der Waals interaction, respectively. You can modify these values as needed, for example:

    coulombtype           = PME
    rcoulomb              = 1.2
    vdwtype               = Cut-off
    rvdw                  = 1.2

4. Save your mdp file and use it when running the simulation program.

    Note: When modifying the cutoff distance, ensure that reasonable values are used, taking into account the system's characteristics and physical effects. Improper cutoff distance settings may lead to inaccurate simulation results or anomalies. It is recommended to conduct small-scale testing and validation when changing the cutoff distance to ensure the accuracy and reliability of the simulation.







##问题：MD成品没有达到我的预期效果，我怀疑是模拟的时长太短了，我要怎么更改我的模拟时长？

回答：如果您想更改GROMACS模拟的时长，可以通过修改mdp文件中的相应参数来实现。具体操作如下：

1. 打开您的mdp文件，找到“Time-Stepping”部分。

2. 在这个部分中，您会看到类似于以下内容的行：

    dt                    = 0.002
    nsteps                = 1000000

    这里的“dt”是时间步长，单位为皮秒（ps），而“nsteps”是模拟步数。您可以根据需要更改这些参数以调整模拟时长。例如，如果您想将模拟时长延长至5纳秒（ns），可以将“nsteps”修改为2500000。

    dt                    = 0.002
    nsteps                = 2500000

3. 如果您同时更改了模拟时长和时间步长，还需要确保二者的乘积不变，以保持模拟的稳定性。也就是说，模拟时长应该等于时间步长乘以模拟步数。例如，在上述示例中，如果您将时间步长增加至0.004 ps，则“nsteps”应该减半，即1250000。

    dt                    = 0.004
    nsteps                = 1250000

4. 保存您的mdp文件，并在运行模拟程序时指定该文件。

注意：在更改模拟时长时，请确保使用合理的数值，并考虑到系统的特性和物理效应。过长或过短的模拟时长都可能会导致模拟结果不准确或者出现异常。建议在更改模拟时长时，先进行小规模的测试和验证，以确保模拟的准确性和可靠性。通常更多情况下我们会选择修改nsteps参数。因为修改dt参数大部分时候会影响模拟的物理性质和稳定性。总之，如果您希望在不改变模拟速度的情况下延迟或者缩短模拟时长，可以修改nstpes参数；如果您希望通过加快或者减慢速度来调整模拟时长可以，可以修改dt参数。


##Question: The MD simulation did not yield the expected results, and I suspect that the simulation duration was too short. How can I adjust the simulation duration?

Answer: If you wish to modify the simulation duration in GROMACS, you can achieve this by adjusting the relevant parameters in the mdp file. The specific steps are as follows:

1. Open your mdp file and locate the "Time-Stepping" section.

2. In this section, you will find lines similar to the following:

dt                    = 0.002
nsteps                = 1000000

    Here, "dt" represents the time step with a unit of picoseconds (ps), and "nsteps" denotes the number of simulation steps. You can modify these parameters as needed to adjust the simulation duration. For example, if you intend to extend the simulation duration to 5 nanoseconds (ns), you can modify "nsteps" to 2500000.

dt                    = 0.002
nsteps                = 2500000

3. If you simultaneously modify the simulation duration and the time step, ensure that their product remains constant to maintain the stability of the simulation. In other words, the simulation duration should equal the time step multiplied by the number of simulation steps. For instance, in the above example, if you increase the time step to 0.004 ps, then "nsteps" should be halved, i.e., 1250000.

dt                    = 0.004
nsteps                = 1250000

4. Save your mdp file and specify it when running the simulation program.

    Note: When adjusting the simulation duration, it is crucial to use reasonable values and consider the characteristics and physical effects of the system. Both excessively long and short simulation durations may lead to inaccurate results or anomalies. It is recommended to conduct small-scale testing and validation when modifying the simulation duration to ensure its accuracy and reliability. In most cases, it is preferable to modify the nsteps parameter, as altering the dt parameter will often affect the physical properties and stability of the simulation. In summary, if you wish to extend or shorten the simulation duration without altering the simulation speed, you can modify the nsteps parameter; if you intend to adjust the simulation duration by accelerating or decelerating the speed, you can modify the dt parameter.



##问题：我现在已经跑完我的模型了，请问我可以用gromacs中的什么指令来分析我的模型？

回答：GROMACS提供了一系列的指令和工具来分析模拟模型。以下是一些常用的GROMACS指令和功能，可以用于模型的分析：

1. 输出某个特定时刻的pdb：
    -命令：gmx trjconv -s model_name.tpr -f model_name.xtc -o model_name-pdb_time.pdb -n index-name.ndx -b pdb_time -e pdb_time -tu tu -pbc mol -center
    -描述：输出某些时刻的pdb文件以达到可视化的效果。

2. 计算和输出模拟系统的氢键数目：
   - 命令：gmx hbond -s model_name.tpr -f model_name.xtc -n index-name.ndx -tu tu -b begin_time -e end_time -num area-H-bond-name.xvg
   - 描述：这个命令可以根据你的需求去选择想要输出的原子和原子的氢键数量。

3. 计算密度分布：
   - 命令：gmx density -f model_name.xtc -s model_name.tpr -o density-z-CU3-0ns.xvg -sl 200 -n model_name.ndx -d z -symm -dens mass -b 0 -e 0
   - 描述：根据你的需求可以通过调整时间来计算你需要的密度分布。

4. 计算接触面积（Solvent Accessible Surface Area）：
   - 命令：gmx sasa -surface -output -s model_name.tpr -f model_name-pbc.xtc -n index-name.ndx -tu tu -b begin_time -e end_time -o area-SASA_name.xvg
   - 描述：根据你的需求可以计算原子之间的接触面积。

5.  计算RMSD（Root Mean Square Deviation）：
   - 命令：gmx rms -s model_name.tpr -f model_name-pbc.xtc -o RMSD-item-name-model_name.xvg -n index-name.ndx -tu tu -b begin_time -e end_time
   - 描述：计算每个时间点的蛋白质结构与参考结构之间的RMSD值，以了解蛋白质结构的稳定性和构象变化。

6. 计算RG（Radius of Gyration）：
   - 命令：gmx gyrate -s model_name.tpr -f model_name-pbc.xtc -n index-name.ndx -o Rg-RG_nanme-model_name.xvg
   - 描述：计算聚合物或者蛋白质分子整体结构的紧凑性的指标。

7. 分析能量（LJ/SR Coul/SR）：
   - 命令：gmx energy -s md-rerun.tpr -f md.edr -o md-THR-JQR.xvg
   - 描述：提取模拟中各种能量组分的时间演变曲线，如总能量、动能、势能等。

上述指令只是GROMACS提供的部分功能，具体使用时可以参考GROMACS的官方文档和指南，根据研究需求选择合适的指令进行分析。




##Question: I have finished running my model. What commands in GROMACS can I use to analyze my model?

Answer: GROMACS provides a range of commands and tools for analyzing simulation models. Here are some commonly used GROMACS commands and functions for model analysis:

1. Output a pdb file at a specific time frame:

    -Command: gmx trjconv -s model_name.tpr -f model_name.xtc -o model_name-pdb_time.pdb -n index-name.ndx -b pdb_time -e pdb_time -tu tu -pbc mol -center
    -Description: Outputs a pdb file at specific time frames for visualization purposes.

2. Compute and output the number of hydrogen bonds in the simulated system:

    -Command: gmx hbond -s model_name.tpr -f model_name.xtc -n index-name.ndx -tu tu -b begin_time -e end_time -num area-H-bond-name.xvg
    -Description: This command allows you to select specific atoms and calculate the number of hydrogen bonds as needed.

3. Compute density distribution:

    -Command: gmx density -f model_name.xtc -s model_name.tpr -o density-z-CU3-0ns.xvg -sl 200 -n model_name.ndx -d z -symm -dens mass -b 0 -e 0
    -Description: Calculate density distribution based on your requirements by adjusting the time frames.

4. Compute Solvent Accessible Surface Area (SASA):

    -Command: gmx sasa -surface -output -s model_name.tpr -f model_name-pbc.xtc -n index-name.ndx -tu tu -b begin_time -e end_time -o area-SASA_name.xvg
    -Description: Calculate the contact surface area between atoms based on your requirements.

5. Compute Root Mean Square Deviation (RMSD):

    -Command: gmx rms -s model_name.tpr -f model_name-pbc.xtc -o RMSD-item-name-model_name.xvg -n index-name.ndx -tu tu -b begin_time -e end_time
    -Description: Calculate the RMSD values between protein structures at each time frame compared to a reference structure to assess stability and conformational changes.

6. Compute Radius of Gyration (RG):

    -Command: gmx gyrate -s model_name.tpr -f model_name-pbc.xtc -n index-name.ndx -o Rg-RG_nanme-model_name.xvg
    -Description: Calculate a measure of compactness for polymer or protein structures.

7. Analyze energy (LJ/SR Coul/SR):

    -Command: gmx energy -s md-rerun.tpr -f md.edr -o md-THR-JQR.xvg
    -Description: Extract time-evolution curves of various energy components in the simulation such as total energy, kinetic energy, potential energy, etc.

    The above commands represent only some of the functionalities offered by GROMACS. For specific usage, refer to the GROMACS official documentation and guides, and choose appropriate commands based on research requirements.






##问题：请问我可以用那些软件来可视化我的模型？

回答：有多种软件可以用来可视化分子模型和轨迹，以下是其中几个常用的软件：

1. VMD：VMD是一款功能强大的生物分子可视化软件，支持多种分子文件格式，包括PDB、GRO、DCD等。VMD提供了多种可视化功能，包括球棒模型、空间填充模型、表面模型、电子密度图等。

2. PyMOL：PyMOL是一款专业的分子可视化软件，支持多种分子文件格式，包括PDB、GRO、XYZ等。PyMOL提供了丰富的可视化功能，包括球棒模型、线框模型、卡通模型、表面模型等。

3. ChimeraX：ChimeraX是一款功能强大的分子可视化软件，支持多种分子文件格式，包括PDB、GRO、XYZ等。ChimeraX提供了多种可视化功能，包括球棒模型、线框模型、表面模型、密度图等。

4. UCSF Chimera：UCSF Chimera是一款广泛使用的分子可视化软件，支持多种分子文件格式，包括PDB、GRO、XYZ等。UCSF Chimera提供了多种可视化功能，包括球棒模型、线框模型、表面模型、密度图等。

5. Avogadro：Avogadro是一款免费的分子建模和可视化软件，支持多种分子文件格式，包括PDB、GRO、XYZ等。Avogadro提供了多种可视化功能，包括球棒模型、线框模型、表面模型等。

这些软件都非常适合用于可视化分子模型和轨迹，可以根据研究需求和个人喜好选择合适的软件进行使用。



##Question: What software can I use to visualize my model?

Answer: There are several software options available for visualizing molecular models and trajectories. Here are a few commonly used software tools:

1. VMD: VMD is a powerful molecular visualization software that supports various molecular file formats, including PDB, GRO, and DCD. It offers multiple visualization functions such as ball-and-stick models, space-filling models, surface models, and electron density maps.

2. PyMOL: PyMOL is a professional molecular visualization software that supports multiple molecular file formats, including PDB, GRO, and XYZ. It provides rich visualization features including ball-and-stick models, wireframe models, cartoon models, and surface models.

3. ChimeraX: ChimeraX is a powerful molecular visualization software supporting multiple molecular file formats, including PDB, GRO, and XYZ. It offers various visualization features such as ball-and-stick models, wireframe models, surface models, and density maps.

4. UCSF Chimera: UCSF Chimera is widely used molecular visualization software supporting multiple molecular file formats, including PDB, GRO, and XYZ. It provides diverse visualization functions including ball-and-stick models, wireframe models, surface models, and density maps.

5. Avogadro: Avogadro is a free molecular modeling and visualization software supporting multiple molecular file formats, including PDB, GRO, and XYZ. It offers various visualization features such as ball-and-stick models, wireframe models, and surface models.

    These software tools are well-suited for visualizing molecular models and trajectories. Users can choose the appropriate software based on their research needs and personal preferences.




# GROMACS各类程序(名称排序)


## gmx anadock: 根据Autodock运行计算团簇结构

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx anadock [-f [<.pdb>]] [-od [<.xvg>]] [-of [<.xvg>]] [-g [<.log>]]
            [-nice ] [-xvg ] [-[no]free] [-[no]rms]
            [-cutoff ]
```
:::
:::

` gmx anadock `{.language-plaintext .highlighter-rouge}
基于距离或RMSD对分子对接(docking)软件Autodock的计算结果进行分析,
并将结构划分成团簇. 程序会分析对接能和自由能,
并打印每个团簇的能量统计情况.

另一个可采用的方法是先使用 ` gmx cluster `{.language-plaintext
.highlighter-rouge} 将结构划分为团簇,
然后按照最低能量或最低平均能量对这些团簇进行排序.

  选项                      默认值 类型   说明                    
------------------ ------------- ------ ----------------------- --
  ` -f [<.pdb>] `        eiwit.pdb 输入   蛋白质数据库文件        
  ` -od [<.xvg>] `     edocked.xvg 输出   xvgr/xmgr文件, 能量     
  ` -of [<.xvg>] `       efree.xvg 输出   xvgr/xmgr文件, 自由能   
  ` -g [<.log>] `      anadock.log 输出   日志文件                

  : 输入/输出文件选项 {#tab-0}

  选项                    默认值 说明                                                             
-------------------- --------- ---------------------------------------------------------------- --
  ` -nice <int> `              0 设置优先级                                                       
  ` -xvg <enum> `        xmgrace xvg绘图格式: xmgrace, xmgr, none                                 
  ` -[no]free `               no 使用autodock估算的自由能对结构进行分类                           
  ` -[no]rms `               yes 根据RMS或距离进行团簇化                                          
  ` -cutoff <real> `         0.2 属于相同团簇的最大RMSD或距离值. 偏离大于此值时认为属于不同团簇   

  : 控制选项 {#tab-1}

## gmx anaeig: 分析简正模式

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx anaeig [-v [<.trr/.cpt/...>]] [-v2 [<.trr/.cpt/...>]]
           [-f [<.xtc/.trr/...>]] [-s [<.tpr/.tpb/...>]] [-n [<.ndx>]]
           [-eig [<.xvg>]] [-eig2 [<.xvg>]] [-comp [<.xvg>]] [-rmsf [<.xvg>]]
           [-proj [<.xvg>]] [-2d [<.xvg>]] [-3d [<.gro/.g96/...>]]
           [-filt [<.xtc/.trr/...>]] [-extr [<.xtc/.trr/...>]]
           [-over [<.xvg>]] [-inpr [<.xpm>]] [-nice ] [-b ]
           [-e ] [-dt ] [-tu ] [-[no]w] [-xvg ]
           [-first ] [-last ] [-skip ] [-max ]
           [-nframes ] [-[no]split] [-[no]entropy] [-temp ]
           [-nevskip ]
```
:::
:::

` gmx anaeig `{.language-plaintext .highlighter-rouge} 用于分析特征向量.
特征向量可以来自协方差矩阵( ` gmx covar `{.language-plaintext
.highlighter-rouge} )或简正模式分析( ` gmx nmeig `{.language-plaintext
.highlighter-rouge} ).

当将一条轨迹投影到特征向量上时, 如果特征向量文件中存在结构,
会将所有结构叠合到特征向量文件中的结构, 否则, 会叠合到结构文件中的结构.
如果没有提供运行输入文件, 程序不会考虑周期性. 程序会对从
` -first `{.language-plaintext .highlighter-rouge} 到
` -last `{.language-plaintext .highlighter-rouge}
的几个特征向量进行大部分分析, 但当 ` -first `{.language-plaintext
.highlighter-rouge} 设置为-1时, 程序会提示你选择要分析的特征向量.

几个选项的说明:

-   ` -comp `{.language-plaintext .highlighter-rouge} : 对从
    ` -first `{.language-plaintext .highlighter-rouge} 到
    ` -last `{.language-plaintext .highlighter-rouge} 的特征向量,
    给出其每个原子的向量分量
-   ` -rmsf `{.language-plaintext .highlighter-rouge} : 对从
    ` -first `{.language-plaintext .highlighter-rouge} 到
    ` -last `{.language-plaintext .highlighter-rouge} 的特征向量,
    给出其每个原子的RMS涨落(需要 ` -eig `{.language-plaintext
    .highlighter-rouge} )
-   ` -proj `{.language-plaintext .highlighter-rouge} : 计算一条轨迹在从
    ` -first `{.language-plaintext .highlighter-rouge} 到
    ` -last `{.language-plaintext .highlighter-rouge}
    的特征向量上的投影. 轨迹在其协方差矩阵特征向量上的投影称为主成分(pc,
    principal components). 检查主成分的余弦含量通常会有帮助,
    因为随机扩散的主成分为周期数为主成分数一半的余弦. 可使用
    ` gmx analyze `{.language-plaintext .highlighter-rouge}
    计算主成分的余弦含量.
-   ` -2d `{.language-plaintext .highlighter-rouge} : 计算一条轨迹在从
    ` -first `{.language-plaintext .highlighter-rouge} 到
    ` -last `{.language-plaintext .highlighter-rouge}
    的特征向量上的2d投影
-   ` -3d `{.language-plaintext .highlighter-rouge} : 计算一条轨迹在从
    ` -first `{.language-plaintext .highlighter-rouge} 到
    ` -last `{.language-plaintext .highlighter-rouge}
    的特征向量上的3d投影
-   ` -filt `{.language-plaintext .highlighter-rouge} : 对轨迹进行滤波,
    只显示沿从 ` -first `{.language-plaintext .highlighter-rouge} 到
    ` -last `{.language-plaintext .highlighter-rouge} 特征向量的运动
-   ` -extr `{.language-plaintext .highlighter-rouge} :
    计算沿一条轨迹在平均结构上的两个极值投影, 并在它们之间插值
    ` -nframe `{.language-plaintext .highlighter-rouge} 帧, 或使用
    ` -max `{.language-plaintext .highlighter-rouge} 设定你自己的极值数.
    会输出特征向量 ` -first `{.language-plaintext .highlighter-rouge} ,
    除非明确指定了 ` -first `{.language-plaintext .highlighter-rouge} 和
    ` -last `{.language-plaintext .highlighter-rouge} 的值,
    在那种情况下, 所有特征向量会写入单独的文件. 当输出
    ` .pdb `{.language-plaintext .highlighter-rouge} 文件时,
    若含有两个或三个结构, 会添加链标识(你可以使用
    ` rasmol -nmrpdb `{.language-plaintext .highlighter-rouge}
    来查看这样的 ` .pdb `{.language-plaintext .highlighter-rouge} 文件).

协方差分析的重叠计算:

**注意** : 分析时应使用相同的叠合结构

-   ` -over `{.language-plaintext .highlighter-rouge} : 计算文件
    ` -v2 `{.language-plaintext .highlighter-rouge} 中的特征向量与文件
    ` -v `{.language-plaintext .highlighter-rouge} 中从
    ` -first `{.language-plaintext .highlighter-rouge} 到
    ` -last `{.language-plaintext .highlighter-rouge}
    的特征向量之间的子空间重叠.
-   ` -inpr `{.language-plaintext .highlighter-rouge} : 计算文件
    ` -v `{.language-plaintext .highlighter-rouge} 和
    ` -v2 `{.language-plaintext .highlighter-rouge}
    中的特征向量间的内积矩阵. 会使用两个文件中的所有特征向量,
    除非明确指定了 ` -first `{.language-plaintext .highlighter-rouge} 和
    ` -last `{.language-plaintext .highlighter-rouge} .

当给出了 ` -v `{.language-plaintext .highlighter-rouge} ,
` -eig `{.language-plaintext .highlighter-rouge} ,
` -v2 `{.language-plaintext .highlighter-rouge} 和
` -eig2 `{.language-plaintext .highlighter-rouge} 时,
会给出表征协方差矩阵之间重叠的一个数值, 其计算公式为:

差异 difference = sqrt(tr((sqrt(M1) - sqrt(M2))\^2))

归一化重叠 normalized overlap = 1 - difference/sqrt(tr(M1) + tr(M2))

形状重叠 shape overlap = 1 - sqrt(tr((sqrt(M1/tr(M1)) -
sqrt(M2/tr(M2)))\^2))

其中M1和M2为两个协方差矩阵, tr为矩阵的迹.
给出的数值正比于涨落平方根的重叠. 归一化的重叠是最有用的数字,
对全等矩阵其值为1, 当抽样子空间正交时, 其值为零.

当给定 ` -entropy `{.language-plaintext .highlighter-rouge} 选项时,
会依据准简谐近似以及Schlitter公式给出熵估计.

  选项                                   默认值 类型         说明                                             
----------------------------- --------------- ------------ ------------------------------------------------ --
  ` -v [<.trr/.cpt/...>] `         eigenvec.trr 输入         全精度轨迹: trr cpt trj tng                      
  ` -v2 [<.trr/.cpt/...>] `       eigenvec2.trr 输入, 可选   全精度轨迹: trr cpt trj tng                      
  ` -f [<.xtc/.trr/...>] `             traj.xtc 输入, 可选   轨迹: xtc trr cpt trj gro g96 pdb tng            
  ` -s [<.tpr/.tpb/...>] `            topol.tpr 输入, 可选   结构+质量(db): tpr tpb tpa gro g96 pdb brk ent   
  ` -n [<.ndx>] `                     index.ndx 输入, 可选   索引文件                                         
  ` -eig [<.xvg>] `                eigenval.xvg 输入, 可选   xvgr/xmgr文件                                    
  ` -eig2 [<.xvg>] `              eigenval2.xvg 输入, 可选   xvgr/xmgr文件                                    
  ` -comp [<.xvg>] `                eigcomp.xvg 输出, 可选   xvgr/xmgr文件                                    
  ` -rmsf [<.xvg>] `                eigrmsf.xvg 输出, 可选   xvgr/xmgr文件                                    
  ` -proj [<.xvg>] `                   proj.xvg 输出, 可选   xvgr/xmgr文件                                    
  ` -2d [<.xvg>] `                   2dproj.xvg 输出, 可选   xvgr/xmgr文件                                    
  ` -3d [<.gro/.g96/...>] `          3dproj.pdb 输出, 可选   结构文件: gro g96 pdb brk ent esp                
  ` -filt [<.xtc/.trr/...>] `      filtered.xtc 输出, 可选   轨迹: xtc trr cpt trj gro g96 pdb tng            
  ` -extr [<.xtc/.trr/...>] `       extreme.pdb 输出, 可选   轨迹: xtc trr cpt trj gro g96 pdb tng            
  ` -over [<.xvg>] `                overlap.xvg 输出, 可选   xvgr/xmgr文件                                    
  ` -inpr [<.xpm>] `                 inprod.xpm 输出, 可选   X PixMap兼容矩阵文件                             

  : 输入/输出文件选项 {#tab-2}

--------------------------------------------------------------------------------------------------
  选项                                     默认值 说明
----------------------- ----------------------- --------------------------------------------------
  ` -nice <int> `                              19 设置优先级

  ` -b <time> `                                 0 从轨迹文件中读取的第一帧(ps)

  ` -e <time> `                                 0 从轨迹文件中读取的最后一帧(ps)

  ` -dt <time> `                                0 只使用t除以dt的余数等于第一帧时间(ps)的帧,
                                                  即两帧之间的时间间隔

  ` -tu <enum> `                               ps 时间单位: fs, ps, ns, us, ms, s

  ` -[no]w `                                   no 程序运行结束查看输出文件: .xvg, .xpm, .eps和.pdb

  ` -xvg <enum> `                         xmgrace xvg绘图格式: xmgrace, xmgr, none

  ` -first <int> `                              1 要分析的第一个特征向量(-1则手动选择)

  ` -last <int> `                              -1 要分析的最后一个特征向量(-1则手动选择)

  ` -skip <int> `                               1 每nr帧分析一次

  ` -max <real> `                               0 特征向量在平均结构上投影的最大值, 为0时给出极值

  ` -nframes <int> `                            2 极值输出的帧数

  ` -[no]split `                               no 当时间为零时拆分特征向量投影

  ` -[no]entropy `                             no 计算对应于准简谐公式或Schlitter方法的熵

  ` -temp <real> `                         298.15 计算熵时的温度

  ` -nevskip <int> `                            6 当计算准简谐近似对应的熵时忽略的特征向量的数目.\
                                                  当在协方差分析前进行转动/平动叠合时,
                                                  会得到3或6个非常接近于零的特征值,\
                                                  在计算熵时不应该考虑这些特征值.
  --------------------------------------------------------------------------------------------------

  : 控制选项 {#tab-3}

## gmx analyze: 分析数据集

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx analyze [-f [<.xvg>]] [-ac [<.xvg>]] [-msd [<.xvg>]] [-cc [<.xvg>]]
            [-dist [<.xvg>]] [-av [<.xvg>]] [-ee [<.xvg>]] [-bal [<.xvg>]]
            [-g [<.log>]] [-nice ] [-[no]w] [-xvg ] [-[no]time]
            [-b ] [-e ] [-n ] [-[no]d] [-bw ]
            [-errbar ] [-[no]integrate] [-aver_start ]
            [-[no]xydy] [-[no]regression] [-[no]luzar] [-temp ]
            [-fitstart ] [-fitend ] [-smooth ]
            [-filter ] [-[no]power] [-[no]subav] [-[no]oneacf]
            [-acflen ] [-[no]normalize] [-P ] [-fitfn ]
            [-beginfit ] [-endfit ]
```
:::
:::

` gmx analyze `{.language-plaintext .highlighter-rouge}
可以读取一个ASCII文本文件并对其中的数据集进行分析.
输入文件中每行的第一个数据可以为时间(见 ` -time `{.language-plaintext
.highlighter-rouge} 选项), 后面跟着任意数目的y值.
程序也可以读入多个数据集, 各个数据集之间以 ` & `{.language-plaintext
.highlighter-rouge} 分割( ` -n `{.language-plaintext .highlighter-rouge}
选项). 在这种情况下, 对每一行, 程序只会读入一个y值. 程序会忽略所有以
` # `{.language-plaintext .highlighter-rouge} 和
` @ `{.language-plaintext .highlighter-rouge} 开始的行.
所有的分析方法都可用于数据集的导数( ` -d `{.language-plaintext
.highlighter-rouge} 选项).

除 ` -av `{.language-plaintext .highlighter-rouge} 和
` -power `{.language-plaintext .highlighter-rouge} 外,
所有选项都假定数据点之间的时间间隔是相等的.

` gmx analyze `{.language-plaintext .highlighter-rouge}
总会给出各数据集的平均值和标准偏差,
以及来自具有相同标准偏差的高斯分布的三阶和四阶累积量的相对偏差.

选项 ` -ac `{.language-plaintext .highlighter-rouge} 计算自相关函数.
请确保数据点之间的时间间隔远远小于自相关的时间尺度.

选项 ` -cc `{.language-plaintext .highlighter-rouge} 给出数据集 \$i\$
与周期为 \$i/2\$ 的余弦函数的相似性, 公式为:

\\\[{2 \\left(\\int_0\^T y(t) \\cos(i\\p t) dt \\right)\^2 / \\int_0\^T
y\^2(t) dt}\\\]

这可用于由协方差分析得到的主成分, 因为随机扩散的主成分是单纯的余弦.

选项 ` -msd `{.language-plaintext .highlighter-rouge} 计算均方位移.

选项 ` -dist `{.language-plaintext .highlighter-rouge} 计算分布图.

选项 ` -av `{.language-plaintext .highlighter-rouge} 计算数据集的平均值.
可以使用 ` -errbar `{.language-plaintext .highlighter-rouge}
选项得到平均值的误差. 误差可代表标准偏差, 误差(假定点是独立的),
或通过弃去顶部和底部5%的点而包含90%的点的区间.

选项 ` -ee `{.language-plaintext .highlighter-rouge} 使用块平均估计误差.
数据集被分成几块, 并计算每块的平均值. 总平均值的误差由 \$m\$ 个块平均值
\$B_i\$ 的方差进行计算:

\\\[error\^2 = \\Sum (B_i - \\lt B \\gt)\^2 / (m(m-1))\\\]

程序会给出误差随块数的变化关系. 假定自相关是两个指数函数的加和,
程序还会给出解析的块平均值曲线. 块平均值的解析曲线为:

\\\[f(t) = \\s \\sqrt{2/T ( \\a (\\t_1 ((\\exp(-t/\\t_1) - 1) \\t_1/t +
1)) +(1-\\a) (\\t_2 ((\\exp(-t/\\t_2) - 1) \\t_2/t + 1)))}\\\]

其中 \$T\$ 为总时间, \$\\a\$, \$\\t_1\$ 和 \$\\t_2\$ 通过将 \$error\^2\$
拟合为 \$f\^2(t)\$ 得到. 当实际的块平均值与解析曲线十分接近时, 误差为
\$\\s \\sqrt{2/T (a \\t_1 + (1-a) \\t_2)}\$. 完整的推导见B. Hess, *J.
Chem. Phys.* 116:209-217, 2002.

选项 ` -bal `{.language-plaintext .highlighter-rouge}
通过多指数拟合发现并减去来自于氢键自相关函数的超快"弹道"分量,
具体请参考O. Markovitch, *J. Chem. Phys.* 129:084505, 2008.
最快项对应于具有最大负系数的指数项. 或者使用 ` -d `{.language-plaintext
.highlighter-rouge} 选项时, 最快项对应于0时刻具有最负的时间导数的项.
` -nbalexp `{.language-plaintext .highlighter-rouge}
设定用于拟合的指数函数的数目.

选项 ` -gem `{.language-plaintext .highlighter-rouge}
根据可逆成对重组模型拟合氢键自相关函数的双分子速率常数ka和kb(以及可选的kD).
强烈建议先去除弹道分量. 模型的细节见O. Markovitch, *J. Chem. Phys.*
129:084505, 2008.

选项 ` -filter `{.language-plaintext .highlighter-rouge}
打印每个数据集和所有数据集相对于滤波器平均值的RMS高频涨落. 滤波器正比于
\$\\cos(\\p t/len)\$, 其中 \$t\$ 从 \$-len/2\$ 到 \$len/2\$. \$len\$ 由
` -filter `{.language-plaintext .highlighter-rouge} 选项提供.
此滤波器可以将周期为 \$len/2\$ 和 \$len\$
的振动分别降低为原来的79%和33%.

选项 ` -g `{.language-plaintext .highlighter-rouge} 使用选项
` -fitfn `{.language-plaintext .highlighter-rouge}
给出的函数对数据进行拟合.

选项 ` -power `{.language-plaintext .highlighter-rouge} 使用 \$b t\^a\$
对数据进行拟合, 这是通过在双对数尺度下进行 \$at+b\$ 拟合来完成的.
拟合时, 第一个零之后或值为负的所有点都被忽略.

选项 ` -luzar `{.language-plaintext .highlighter-rouge} 对
` gmx hbond `{.language-plaintext .highlighter-rouge}
的输出进行Luzar-Chandler动力学分析. 输入文件可直接来自
` gmx hbond -ac `{.language-plaintext .highlighter-rouge} ,
并应得到相同的结果.

  选项                          默认值 类型         说明
-------------------- --------------- ------------ ---------------
  ` -f [<.xvg>] `            graph.xvg 输入         xvgr/xmgr文件
  ` -ac [<.xvg>] `        autocorr.xvg 输出, 可选   xvgr/xmgr文件
  ` -msd [<.xvg>] `            msd.xvg 输出, 可选   xvgr/xmgr文件
  ` -cc [<.xvg>] `         coscont.xvg 输出, 可选   xvgr/xmgr文件
  ` -dist [<.xvg>] `         distr.xvg 输出, 可选   xvgr/xmgr文件
  ` -av [<.xvg>] `         average.xvg 输出, 可选   xvgr/xmgr文件
  ` -ee [<.xvg>] `          errest.xvg 输出, 可选   xvgr/xmgr文件
  ` -bal [<.xvg>] `      ballisitc.xvg 输出, 可选   xvgr/xmgr文件
  ` -g [<.log>] `           fitlog.log 输出, 可选   日志文件

  : 输入/输出文件选项 {#tab-4}

----------------------------------------------------------------------------------------------------
  选项                                      默认值 说明
------------------------ ----------------------- ---------------------------------------------------
  ` -nice <int> `                                0 设置优先级

  ` -[no]w `                                    no 查看输出的.xvg, .xpm, .eps和.pdb文件

  ` -xvg <enum> `                          xmgrace xvg绘图格式: xmgrace, xmgr, none

  ` -[no]time `                                yes 预计输入含有时间

  ` -b <real> `                                 -1 读取数据集的起始时间

  ` -e <real> `                                 -1 读取数据集的终止时间

  ` -n <int> `                                   1 读取指定数目, 彼此间以 ` & ` 分开的数据集

  ` -[no]d `                                    no 使用导数

  ` -bw <real> `                               0.1 分布的分格宽度

  ` -errbar <enum> `                          none ` -av ` 的误差: none, stddev, error, 90

  ` -[no]integrate `                            no 使用梯形规则对数据函数进行数值积分

  ` -aver_start <real> `                         0 由此开始对积分进行平均

  ` -[no]xydy `                                 no 积分时将第二个数据集作为y值的误差

  ` -[no]regression `                           no 对数据进行线性回归分析.\
                                                   如果设定了 ` -xydy ` 选项,
                                                   第二个数据集将被视为Y值的误差.\
                                                   否则, 如果存在多个数据集, 将会进行多元线性回归,\
                                                   计算能使χ\^2\^ = (y - A_0 x_0 - A_1 x_1 - \... -
                                                   A_N x_N)\^2\^取最小值的常数A,\
                                                   其中Y为输入文件中的第一个数据集而x_i为其他数据集.
                                                   请阅读 ` -time ` 选项的信息.

  ` -[no]luzar `                                no 对相关函数进行Luzar-Chandler分析, 并与
                                                   ` gmx hbond ` 的结果进行关联.\
                                                   当同时也给出 ` -xydy ` 选项时,
                                                   第二列和第四列将被视为c(t)和n(t)的误差.

  ` -temp <real> `                          298.15 进行Luzar氢键动力学分析时的温度(K)

  ` -fitstart <real> `                           1 为获得HB断裂和形成的前向和后向速度常数,
                                                   对相关函数进行拟合的起始时间(ps)

  ` -fitend <real> `                            60 为获得HB断裂和形成的前向和后向速度常数,
                                                   对相关函数进行拟合的终止时间(ps).\
                                                   只能与 ` -gem ` 一起使用.

  ` -smooth <real> `                            -1 如果此值\>=0, 通过拟合为指数函数 y=A exp(-x/τ)
                                                   对ACF的尾部进行平滑

  ` -filter <real> `                             0 使用此长度的余弦滤波器滤波后打印高频涨落

  ` -[no]power `                                no 将数据拟合为 \$b t\^a\$

  ` -[no]subav `                               yes 计算自相关前减去平均值

  ` -[no]oneacf `                               no 对所有数据集计算一个ACF

  ` -acflen <int> `                             -1 ACF的长度, 默认为帧数的一半

  ` -[no]normalize `                           yes 归一化ACF

  ` -P <enum> `                                  0 ACF Legendre多项式的阶数(0表示不使用): 0, 1, 2, 3

  ` -fitfn <enum> `                           none 拟合函数: none, exp, aexp, exp_exp, vac, exp5,
                                                   exp7, exp9, erfit

  ` -beginfit <real> `                           0 对相关函数进行指数拟合的起始时间

  ` -endfit <real> `                            -1 对相关函数进行指数拟合的终止时间, -1表示直到最后
  ----------------------------------------------------------------------------------------------------

  : 控制选项 {#tab-5}

## gmx angle: 计算键角和二面角的分布及相关

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx angle [-f [<.xtc/.trr/...>]] [-n [<.ndx>]] [-od [<.xvg>]] [-ov [<.xvg>]]
          [-of [<.xvg>]] [-ot [<.xvg>]] [-oh [<.xvg>]] [-oc [<.xvg>]]
          [-or [<.trr>]] [-nice ] [-b ] [-e ] [-dt ]
          [-[no]w] [-xvg ] [-type ] [-[no]all] [-binwidth ]
          [-[no]periodic] [-[no]chandler] [-[no]avercorr] [-acflen ]
          [-[no]normalize] [-P ] [-fitfn ] [-beginfit ]
          [-endfit ]
```
:::
:::

` gmx angle `{.language-plaintext .highlighter-rouge}
用于计算一些键角或二面角的角度分布.

利用 ` -ov `{.language-plaintext .highlighter-rouge} 选项,
可以得到一组键角的平均值随时间的变化关系图. 使用
` -all `{.language-plaintext .highlighter-rouge} 选项时,
第一幅图为平均键角, 其他则为单个键角. 例如,
如果我们选择几个不同的原子组合来计算其角度

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
75    76   1145
75    76   1147
222  223   1145
```
:::
:::

则默认输出文件 ` angaver.xvg `{.language-plaintext .highlighter-rouge}
中共包含4列数据, 首列为3个角度平均值, 之后每列为每个角度值.

利用 ` -of `{.language-plaintext .highlighter-rouge} 选项,
` gmx angle `{.language-plaintext .highlighter-rouge}
也会计算反式二面角的比例(仅适用于二面角)与时间的函数关系,
但这可能只适用于少量的二面角.

利用 ` -oc `{.language-plaintext .highlighter-rouge} 选项,
可计算二面角的相关函数.

需要注意, 对键角, 在索引文件中必须包含原子三元组,
对二面角则必须包含原子四元组. 否则, 程序会崩溃.

利用 ` -or `{.language-plaintext .highlighter-rouge} 选项,
可生成包含所选二面角sin和cos函数值的轨迹文件. 当利用
` gmx covar `{.language-plaintext .highlighter-rouge} 进行主成分分析时,
此轨迹文件可作为输入.

利用 ` -ot `{.language-plaintext .highlighter-rouge} 选项,
可以记录多重度为3的二面角旋转异构体之间的转变.
假定输入轨迹各帧之间的时间间隔相等, 可利用 ` -oh `{.language-plaintext
.highlighter-rouge} 选项得到转变间隔时间的直方图.

  选项                               默认值 类型         说明
-------------------------- -------------- ------------ ---------------------------------------
  ` -f [<.xtc/.trr/...>] `         traj.xtc 输入         轨迹: xtc trr cpt trj gro g96 pdb tng
  ` -n [<.ndx>] `                 angle.ndx 输入         索引文件
  ` -od [<.xvg>] `              angdist.xvg 输出         xvgr/xmgr文件
  ` -ov [<.xvg>] `              angaver.xvg 输出, 可选   xvgr/xmgr文件
  ` -of [<.xvg>] `              dihfrac.xvg 输出, 可选   xvgr/xmgr文件
  ` -ot [<.xvg>] `             dihtrans.xvg 输出, 可选   xvgr/xmgr文件
  ` -oh [<.xvg>] `              trhisto.xvg 输出, 可选   xvgr/xmgr文件
  ` -oc [<.xvg>] `              dihcorr.xvg 输出, 可选   xvgr/xmgr文件
  ` -or [<.trr>] `                 traj.trr 输出, 可选   兼容xdr格式的轨迹

  : 输入/输出文件选项 {#tab-6}

--------------------------------------------------------------------------------------------
  选项                                     默认值 说明
----------------------- ----------------------- --------------------------------------------
  ` -nice <int> `                              19 设置优先级

  ` -b <time> `                                 0 从轨迹文件中读取的第一帧(ps)

  ` -e <time> `                                 0 从轨迹文件中读取的最后一帧(ps)

  ` -dt <time> `                                0 只使用t除以dt的余数等于第一帧时间(ps)的帧,
                                                  即两帧之间的时间间隔

  ` -[no]w `                                   no 查看输出的 .xvg, .xpm, .eps和.pdb文件

  ` -xvg <enum> `                         xmgrace xvg绘图格式: xmgrace, xmgr, none

  ` -type <enum> `                          angle 要分析的键角类型: angle, dihedral, improper,
                                                  ryckaert-bellemans

  ` -[no]all `                                 no 按索引文件中的出现顺序,
                                                  在平均值文件中单独输出每个键角的平均值

  ` -binwidth <real> `                          1 计算分布的分格值(单位: 度)

  ` -[no]periodic `                           yes 输出二面角除以360度的余数

  ` -[no]chandler `                            no 使用Chandler相关函数(N\[trans\] = 1,
                                                  N\[gauche\] = 0)而不是余弦相关函数.\
                                                  转变的定义为phi \< -60或phi \> 60.

  ` -[no]avercorr `                            no 对单个键角或二面角的相关函数进行平均

  ` -acflen <int> `                            -1 ACF的长度, 默认为帧数的一半.

  ` -[no]normalize `                          yes 归一化ACF

  ` -P <enum> `                                 0 ACF Legendre多项式的阶数(0表示不使用): 0, 1,
                                                  2, 3

  ` -fitfn <enum> `                          none 拟合函数: none, exp, aexp, exp_exp, vac,
                                                  exp5, exp7, exp9, erffit

  ` -beginfit <real> `                          0 对相关函数进行指数拟合的起始时间

  ` -endfit <real> `                           -1 对相关函数进行指数拟合的终止时间,
                                                  -1表示直到最终
  --------------------------------------------------------------------------------------------

  : 控制选项 {#tab-7}

### 已知问题

-   对转变进行计数只适用于多重度为3的二面角

## gmx bar: 利用Bennett接受比率方法计算自由能差的估计值

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx bar [-f [<.xvg> [...]]] [-g [<.edr> [...]]] [-o [<.xvg>]] [-oi [<.xvg>]]
        [-oh [<.xvg>]] [-nice ] [-[no]w] [-xvg ] [-b ]
        [-e ] [-temp ] [-prec ] [-nbmin ]
        [-nbmax ] [-nbin ] [-[no]extp]
```
:::
:::

` gmx bar `{.language-plaintext .highlighter-rouge}
通过Bennett接受率方法(BAR, Bennett's acceptance ratio)估计自由能差值,
也可以自动将由BAR得到的一系列分立自由能进行组合得到自由能估计值.

每个分立的BAR自由能差值依赖于两个不同状态的模拟, 且称为态A和态B,
它们由参数λ控制(见 ` .mdp `{.language-plaintext .highlighter-rouge} 参数
` init_lambda `{.language-plaintext .highlighter-rouge} ). 给定态A,
BAR方法可以计算态B相对于态A的哈密顿差的加权平均的比率, 反之亦然.
相对于另一状态的能量差在模拟中必须显式地计算, 可以通过
` .mdp `{.language-plaintext .highlighter-rouge} 选项
` foreign_lambda `{.language-plaintext .highlighter-rouge} 实现.

输入选项 ` -f `{.language-plaintext .highlighter-rouge} 需要读入多个
` dhdl.xvg `{.language-plaintext .highlighter-rouge} 文件,
支持两种输入文件类型:

-   包含多于一个y值的文件, 其中应包含dH/dλ和Δλ的列. λ的值根据列标题推定:
    模拟使用的λ根据dH/dλ列的标题推定, 外部λ值根据Delta H列的标题推定.
-   仅有一个y值的文件. 对这些文件应使用 ` -extp `{.language-plaintext
    .highlighter-rouge} 选项, 并假定y值为dH/dλ, 而哈密顿量与λ呈线性关系.
    模拟的λ值根据子标题(如果存在)推定,
    否则会根据子目录下文件名中的数字推定.

模拟的λ值根据 ` dhdl.xvg `{.language-plaintext .highlighter-rouge}
文件中包含字符串 ` dH `{.language-plaintext .highlighter-rouge}
的列标题解析得出, 外部λ值根据包含大写字母 ` D `{.language-plaintext
.highlighter-rouge} 和 ` H `{.language-plaintext .highlighter-rouge}
的列标题解析得出, 温度根据包含 ` T= `{.language-plaintext
.highlighter-rouge} 的标题解析得出.

输入选项 ` -g `{.language-plaintext .highlighter-rouge} 需要读入多个
` .edr `{.language-plaintext .highlighter-rouge} 文件,
它们可以包含能量差列表(见 ` .mdp `{.language-plaintext
.highlighter-rouge} 选项 ` separate_dhdl_file `{.language-plaintext
.highlighter-rouge} ), 或者一系列直方图(见 ` .mdp `{.language-plaintext
.highlighter-rouge} 选项 ` dh_hist_size `{.language-plaintext
.highlighter-rouge} 和 ` dh_hist_spacing `{.language-plaintext
.highlighter-rouge} ). 程序会自动从 ` ener.edr `{.language-plaintext
.highlighter-rouge} 文件中推断出温度和λ值.

除了 ` .mdp `{.language-plaintext .highlighter-rouge} 的
` foreign_lambda `{.language-plaintext .highlighter-rouge} 选项外,
也可以根据dH/dλ值外推得到能量差. 这可通过 ` -extp `{.language-plaintext
.highlighter-rouge} 选项实现, 它假定系统的哈密顿量与λ呈线性关系,
虽然通常并非如此.

自由能估计由使用二分法的BAR方法确定, 输出精度由
` -prec `{.language-plaintext .highlighter-rouge} 设定.
误差估计考虑了时间相关, 这是通过将数据分块, 并假定这些分块之间互相独立,
计算它们之间的自由能差来实现的. 最终的误差估计由5个分块的平均方差决定.
用于误差估计的分块数可以通过选项 ` -nbmin `{.language-plaintext
.highlighter-rouge} 和 ` -nbmax `{.language-plaintext
.highlighter-rouge} 来指定.

` gmx bar `{.language-plaintext .highlighter-rouge}
会尝试合计具有相同'本地'和'外部'λ值的样本, 但总会假定样本互相独立.
**注意** , 当合计具有不同采样间隔的能量差或能量导数时,
这个假定几乎肯定是不正确的. 连续的能量通常是相关的,
不同的时间间隔意味着样本间的相关度不同.

结果分为两部分: 后一部分包含了以kJ/mol为单位的最终结果,
以及每一部分和总体的误差估计.
前一部分包含了详细的自由能差估计和相空间重叠量度,
以kT为单位(以及它们的误差估计). 打印出的值为:

-   lam_A: A点的λ值.
-   lam_B: B点的λ值.
-   DG: 自由能估计.
-   s_A: B在A中的相对熵估计.
-   s_B: A在B中的相对熵估计.
-   stdev: 每个样本标准偏差的估计期望

两个状态在彼此系综内的相对熵可以理解为相空间重叠的量度:
lambda_B的工作样本在lambda_A系综内的相对熵s_A(对s_B反之亦然),
是两个状态Boltzmann分布之间'距离'的量度, 当分布相同时, 其值为0. 详见Wu &
Kofke, *J. Chem. Phys.* 123 084109 (2005).

每个样本标准偏差的估计期望, 见Bennett BAR方法的原始论文 Bennett, *J.
Comp. Phys.* 22, p 245 (1976). 其中的Eq.
10给出了采样质量的估计(并非直接的实际统计误差,
因为它假定了样本相互独立).

要得到相空间重叠估计的可视化结果, 可使用 ` -oh `{.language-plaintext
.highlighter-rouge} 选项及 ` -nbin `{.language-plaintext
.highlighter-rouge} 选项输出一系列直方图.

  选项                             默认值 类型         说明
----------------------- --------------- ------------ ---------------
  ` -f [<.xvg> [...]] `          dhdl.xvg 输入, 可选   xvgr/xmgr文件
  ` -g [<.edr> [...]] `          ener.edr 输入, 可选   能量文件
  ` -o [<.xvg>] `                 bar.xvg 输出, 可选   xvgr/xmgr文件
  ` -oi [<.xvg>] `             barint.xvg 输出, 可选   xvgr/xmgr文件
  ` -oh [<.xvg>] `          histogram.xvg 输出, 可选   xvgr/xmgr文件

  : 输入/输出文件选项 {#tab-8}

  选项                  默认值 说明
------------------ --------- --------------------------------------
  ` -nice <int> `            0 设定优先级
  ` -[no]w `                no 查看输出的.xvg, .xpm, .eps和.pdb文件
  ` -xvg <enum> `      xmgrace xvg绘图格式: xmgrace, xmgr, none
  ` -b <real> `              0 BAR的起始时间
  ` -e <real> `             -1 BAR的终止时间
  ` -temp <real> `          -1 温度(K)
  ` -prec <int> `            2 小数点后的小数位数
  ` -nbmin <int> `           5 用于误差估计的最小分块数
  ` -nbmax <int> `           5 用于误差估计的最大分块数
  ` -nbin <int> `          100 输出直方图的分格数
  ` -[no]extp `             no 是否对dH/dλ进行线性外推作为能量使用

  : 控制选项 {#tab-9}

## gmx bundle: 分析轴束, 例如螺旋

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx bundle [-f [<.xtc/.trr/...>]] [-s [<.tpr/.tpb/...>]] [-n [<.ndx>]]
           [-ol [<.xvg>]] [-od [<.xvg>]] [-oz [<.xvg>]] [-ot [<.xvg>]]
           [-otr [<.xvg>]] [-otl [<.xvg>]] [-ok [<.xvg>]] [-okr [<.xvg>]]
           [-okl [<.xvg>]] [-oa [<.pdb>]] [-nice ] [-b ]
           [-e ] [-dt ] [-tu ] [-xvg ] [-na ]
           [-[no]z]
```
:::
:::

` gmx bundle `{.language-plaintext .highlighter-rouge} 用于分析轴束,
例如螺旋轴. 程序读入两个索引组, 把它们分成 ` -na `{.language-plaintext
.highlighter-rouge} 个部分. 不同部分的质心确定轴的顶部和底部.
以下几个量会写入输出文件中: 轴的长度,
轴中点相对于所有轴的平均中点的距离和Z方向的偏移量,
轴相对于平均轴的总倾斜, 径向倾斜, 侧向倾斜.

使用选项 ` -ok `{.language-plaintext .highlighter-rouge} ,
` -okr `{.language-plaintext .highlighter-rouge} 和
` -okl `{.language-plaintext .highlighter-rouge} 可输出轴的总扭结,
径向扭结和侧向扭结. 这种情况下还需要定义扭结原子的索引组, 它也会被分为
` -na `{.language-plaintext .highlighter-rouge} 个部分.
扭结角定义为扭结顶部和扭结底部矢量间的夹角.

使用选项 ` -oa `{.language-plaintext .highlighter-rouge} 时,
每帧中每个轴的顶点, 中点(或扭结, 若指定了 ` -ok `{.language-plaintext
.highlighter-rouge} ), 最低点会写入一个 ` .pdb `{.language-plaintext
.highlighter-rouge} 文件, 残基编号对应于轴的编号.
当使用Rasmol查看这个文件时, 指定命令行选项
` -nmrpdb `{.language-plaintext .highlighter-rouge} , 并输入
` set axis true `{.language-plaintext .highlighter-rouge} 来显示参考轴.

  选项                                默认值 类型         说明
-------------------------- --------------- ------------ ------------------------------------------------
  ` -f [<.xtc/.trr/...>] `          traj.xtc 输入         轨迹: xtc trr cpt trj gro g96 pdb tng
  ` -s [<.tpr/.tpb/...>] `         topol.tpr 输入         结构+质量(db): tpr tpb tpa gro g96 pdb brk ent
  ` -n [<.ndx>] `                  index.ndx 输入, 可选   索引文件
  ` -ol [<.xvg>] `               bun_len.xvg 输出         xvgr/xmgr文件
  ` -od [<.xvg>] `              bun_dist.xvg 输出         xvgr/xmgr文件
  ` -oz [<.xvg>] `                 bun_z.xvg 输出         xvgr/xmgr文件
  ` -ot [<.xvg>] `              bun_tilt.xvg 输出         xvgr/xmgr文件
  ` -otr [<.xvg>] `            bun_tiltr.xvg 输出         xvgr/xmgr文件
  ` -otl [<.xvg>] `            bun_tiltl.xvg 输出         xvgr/xmgr文件
  ` -ok [<.xvg>] `              bun_kink.xvg 输出, 可选   xvgr/xmgr文件
  ` -okr [<.xvg>] `            bun_kinkr.xvg 输出, 可选   xvgr/xmgr文件
  ` -okl [<.xvg>] `            bun_kinkl.xvg 输出, 可选   xvgr/xmgr文件
  ` -oa [<.pdb>] `                  axes.pdb 输出, 可选   PDB文件

  : 输入/输出文件选项 {#tab-10}

  选项                 默认值 说明
----------------- --------- -----------------------------------------------------------------
  ` -nice <int> `          19 设置优先级
  ` -b <time> `             0 从轨迹文件中读取的第一帧(ps)
  ` -e <time> `             0 从轨迹文件中读取的最后一帧(ps)
  ` -dt <time> `            0 只使用t除以dt的余数等于第一帧时间(ps)的帧, 即两帧之间的时间间隔
  ` -tu <enum> `           ps 时间单位: fs, ps, ns, us, ms, s
  ` -xvg <enum> `     xmgrace xvg绘图格式: xmgrace, xmgr, none
  ` -na <int> `             0 轴的数目
  ` -[no]z `               no 使用z坐标轴取代平均轴作为参考轴

  : 控制选项 {#tab-11}

## gmx check: 检查并比较文件

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx check [-f [<.xtc/.trr/...>]] [-f2 [<.xtc/.trr/...>]]
          [-s1 [<.tpr/.tpb/...>]] [-s2 [<.tpr/.tpb/...>]]
          [-c [<.tpr/.tpb/...>]] [-e [<.edr>]] [-e2 [<.edr>]] [-n [<.ndx>]]
          [-m [<.tex>]] [-nice ] [-vdwfac ] [-bonlo ]
          [-bonhi ] [-[no]rmsd] [-tol ] [-abstol ]
          [-[no]ab] [-lastener ]
```
:::
:::

` gmx check `{.language-plaintext .highlighter-rouge} 读取一个轨迹文件(
` .trj `{.language-plaintext .highlighter-rouge} ,
` .trr `{.language-plaintext .highlighter-rouge} 或
` .xtc `{.language-plaintext .highlighter-rouge} ), 一个能量文件(
` .ene `{.language-plaintext .highlighter-rouge} 或
` .edr `{.language-plaintext .highlighter-rouge} ), 或一个索引文件(
` .ndx `{.language-plaintext .highlighter-rouge} ),
并输出与其相关的有用信息.

如果指定了 ` -c `{.language-plaintext .highlighter-rouge} 选项,
程序就会检查文件中是否包含了坐标, 速度和盒子大小. 如果存在坐标,
程序进而会检查原子是不是有近距离的接触(距离小于
` -vdwfac `{.language-plaintext .highlighter-rouge} , 而且没有键相连,
即距离不在 ` -bonlo `{.language-plaintext .highlighter-rouge} 和
` -bonhi `{.language-plaintext .highlighter-rouge} 之间.
注意这几个选项指定的都是与两个原子范德华半径之和的比例).
程序还会检查处于盒子外面的原子(这是经常发生的事情, 并不是什么问题).
如果文件中含有速度, 程序就会根据温度估算出温度.

如果指定了一个索引文件, 程序会对索引文件中的所有索引进行处理,
并给出一个总结.

如果同时给定了轨迹文件和 ` .tpr `{.language-plaintext
.highlighter-rouge} 文件(使用 ` -s1 `{.language-plaintext
.highlighter-rouge} 选项), 程序就会检查 ` .tpr `{.language-plaintext
.highlighter-rouge} 文件中定义的键长在轨迹中是否正确. 如果不正确,
那么轨迹文件和 ` .tpr `{.language-plaintext .highlighter-rouge}
文件可能不匹配, 原因可能出于原子重组或虚拟位点的问题. 所以,
通过这些选项, 你可以快速检查这些问题.

当同时指定 ` -s1 `{.language-plaintext .highlighter-rouge} 和
` -s2 `{.language-plaintext .highlighter-rouge} 时,
程序还可以对比两个输入文件( ` .tpr `{.language-plaintext
.highlighter-rouge} , ` .tpb `{.language-plaintext .highlighter-rouge}
或 ` .tpa `{.language-plaintext .highlighter-rouge} ). 类似的,
程序也可以对比两个轨迹文件(使用 ` -f2 `{.language-plaintext
.highlighter-rouge} 选项), 或对比两个能量文件(使用
` -e2 `{.language-plaintext .highlighter-rouge} 选项).

对于自由能计算, 来自同一运行输入文件A和B两种状态的拓扑, 可以通过
` -s1 `{.language-plaintext .highlighter-rouge} 和
` -ab `{.language-plaintext .highlighter-rouge} 选项进行比较.

指定了 ` -m `{.language-plaintext .highlighter-rouge} 选项后,
程序会输出一个LaTeX文件, 其中包含了可用于论文方法部分的粗略提纲.

  选项                             默认值 类型         说明
--------------------------- ----------- ------------ ----------------------------------------------------
  ` -f [<.xtc/.trr/...>] `       traj.xtc 输入, 可选   轨迹: xtc trr cpt trj gro g96 pdb tng
  ` -f2 [<.xtc/.trr/...>] `      traj.xtc 输入, 可选   轨迹: xtc trr cpt trj gro g96 pdb tng
  ` -s1 [<.tpr/.tpb/...>] `      top1.tpr 输入, 可选   运行输入文件: tpr tpb tpa
  ` -s2 [<.tpr/.tpb/...>] `      top2.tpr 输入, 可选   运行输入文件: tpr tpb tpa
  ` -c [<.tpr/.tpb/...>] `      topol.tpr 输入, 可选   结构+质量文件(db): tpr tpb tpa gro g96 pdb brk ent
  ` -e [<.edr>] `                ener.edr 输入, 可选   能量文件
  ` -e2 [<.edr>] `              ener2.edr 输入, 可选   能量文件
  ` -n [<.ndx>] `               index.ndx 输入, 可选   索引文件
  ` -m [<.tex>] `                 doc.tex 输出, 可选   LaTeX文件

  : 输入/输出文件选项 {#tab-12}

--------------------------------------------------------------------------------------------------
  选项                                      默认值 说明
------------------------ ----------------------- -------------------------------------------------
  ` -nice <int> `                                0 设置优先级

  ` -vdwfac <real> `                           0.8 原子之间的最小距离,
                                                   使用与两个原子范德华半径之和的比例来指定.
                                                   超过此值时会给出警告.

  ` -bonlo <real> `                            0.4 成键原子之间的最小距离,
                                                   使用与两个原子范德华半径之和的比例来指定

  ` -bonhi <real> `                            0.7 成键原子之间的最大距离,
                                                   使用与两个原子范德华半径之和的比例来指定

  ` -[no]rmsd `                                 no 输出坐标, 速度和力的均方根偏差

  ` -tol <real> `                            0.001 相对容许误差 \$2\*(a-b)/(\\vert a\\vert+\\vert
                                                   b\\vert)\$. 用于判断两个实数是否一致

  ` -abstol <real> `                         0.001 绝对容许误差. 当两个数绝对值之和接近为0时有用

  ` -[no]ab `                                   no 比较同一个文件中的A和B状态的拓扑

  ` -lastener <string> `                           指定检查的最后一个能量项(若未给出则测试所有项),
                                                   不检查在此之后的所有能量项.\
                                                   比如可以只检查Pressure以及之前的能量项.
  --------------------------------------------------------------------------------------------------

  : 控制选项 {#tab-13}

## gmx chi: 计算chi和其他二面角的所有信息

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx chi [-s [<.gro/.g96/...>]] [-f [<.xtc/.trr/...>]] [-o [<.xvg>]]
        [-p [<.pdb>]] [-ss [<.dat>]] [-jc [<.xvg>]] [-corr [<.xvg>]]
        [-g [<.log>]] [-ot [<.xvg>]] [-oh [<.xvg>]] [-rt [<.xvg>]]
        [-cp [<.xvg>]] [-nice ] [-b ] [-e ] [-dt ]
        [-[no]w] [-xvg ] [-r0 ] [-[no]phi] [-[no]psi] [-[no]omega]
        [-[no]rama] [-[no]viol] [-[no]periodic] [-[no]all] [-[no]rad]
        [-[no]shift] [-binwidth ] [-core_rotamer ]
        [-maxchi ] [-[no]normhisto] [-[no]ramomega] [-bfact ]
        [-[no]chi_prod] [-[no]HChi] [-bmax ] [-acflen ]
        [-[no]normalize] [-P ] [-fitfn ] [-beginfit ]
        [-endfit ]
```
:::
:::

` gmx chi `{.language-plaintext .highlighter-rouge}
用于计算所有氨基酸骨架和侧链的φ, ψ, ω以及χ二面角.
它也可以计算二面角与时间的函数关系, 以及二面角的直方图分布. 分布(
` histo-(dihedral) (RESIDUE).xvg `{.language-plaintext
.highlighter-rouge} )会对每一类型的所有残基进行累计.

如果使用 ` -corr `{.language-plaintext .highlighter-rouge} 选项,
程序会计算二面角的自相关函数 C(t) = \<cos(χ(τ)) cos(χ(τ+t))\>.
之所以使用余弦而不是角度自身, 是为了解决周期性的问题(Van der Spoel &
Berendsen (1997), *Biophys. J.* 72, 2032-2041).
程序会将每个残基的每个二面角输出到单独的文件(
` corr(dihedral) (RESIDUE) (nresnr).xvg `{.language-plaintext
.highlighter-rouge} )中, 同时还会输出一个包含所有残基信息的文件(
` -corr `{.language-plaintext .highlighter-rouge} 选项).

使用 ` -all `{.language-plaintext .highlighter-rouge} 选项,
程序会将每个残基的角度与时间的函数关系输出到独立的文件
` (dihedral) (RESIDUE) (nresnr).xvg `{.language-plaintext
.highlighter-rouge} 中. 所用的单位可以是弧度或度.

程序还会输出一个日志文件( ` -g `{.language-plaintext .highlighter-rouge}
选项), 其中包含:

-   \(a\) 每种类型残基的数目信息.
-   \(b\) 由Karplus方程得到的NMR ^3^ J 偶合常数.
-   \(c\) 一个表格, 其中包含每个残基的旋转异构体每纳秒内的转变次数,
    以及每个二面角的序参数S\^2.
-   \(d\) 一个表格, 其中包含每个残基旋转异构体的占据率.

所有的旋转异构体的多重度都视为3, 除平面基团的ω和χ二面角(如芳香化合物,
Asp和Asn的χ_2; Glu和Gln的χ_3; 以及Arg的χ_4)外, 它们的多重度为2. "rotamer
0"表示二面角不处于每个旋转异构体的核心区域. 核心区域的宽度可使用
` -core_rotamer `{.language-plaintext .highlighter-rouge} 设置.

S\^2序参数也会输出到一个 ` .xvg `{.language-plaintext
.highlighter-rouge} 文件(由 ` -o `{.language-plaintext
.highlighter-rouge} 选项指定), 作为可选项,
可将S\^2的值作为B因子输出到一个 ` .pdb `{.language-plaintext
.highlighter-rouge} 文件中(由 ` -p `{.language-plaintext
.highlighter-rouge} 选项指定). 每个时间步旋转异构体转变的总数(
` -ot `{.language-plaintext .highlighter-rouge} 选项),
每个旋转异构体的转变数( ` -rt `{.language-plaintext .highlighter-rouge}
选项)和 ^3^ J 偶合( ` -jc `{.language-plaintext .highlighter-rouge}
选项)也可以写入到 ` .xvg `{.language-plaintext .highlighter-rouge}
文件中. 注意, 在分析旋转异构体转变时,
假定所提供的轨迹帧之间的时间间隔是相等的.

如果设置了 ` -chi_prod `{.language-plaintext .highlighter-rouge}
选项(并且 ` -maxchi > 0 `{.language-plaintext .highlighter-rouge} ),
会计算累积旋转异构体,
如1+9(χ_1-1)3(χ_2-1)+(χ_3-1)(如果残基具有三个3重二面角, 并且
` -maxchi >= 3 `{.language-plaintext .highlighter-rouge} ). 如前所述,
任何二面角如果不处于核心区域内, 旋转异构体取为0.
这些累积旋转异构体的占据率(由旋转异构体0开始)会写入由
` -cp `{.language-plaintext .highlighter-rouge} 选项指定的文件中,
如果使用 ` -all `{.language-plaintext .highlighter-rouge} 选项,
旋转异构体作为时间的函数会写入
` chiproduct (RESIDUE) (nresnr).xvg `{.language-plaintext
.highlighter-rouge} 文件中, 其占据率会写入
` histo-chiproduct (RESIDUE) (nresnr).xvg `{.language-plaintext
.highlighter-rouge} 文件.

选项 ` -r `{.language-plaintext .highlighter-rouge}
可生成作为φ和ψ角函数的平均ω角的等值线图,
也就是使用颜色编码的平均ω角的Ramachandran图.

  选项                                   默认值 类型         说明
-------------------------- ------------------ ------------ -----------------------------------------------
  ` -s [<.gro/.g96/...>] `             conf.gro 输入         结构文件: gro g96 pdb brk ent esp tpr tpb tpa
  ` -f [<.xtc/.trr/...>] `             traj.xtc 输入         轨迹: xtc trr cpt trj gro g96 pdb tng
  ` -o [<.xvg>] `                     order.xvg 输出         xvgr/xmgr文件
  ` -p [<.pdb>] `                     order.pdb 输出, 可选   PDB文件
  ` -ss [<.dat>] `                   ssdump.dat 输入, 可选   通用数据文件
  ` -jc [<.xvg>] `                Jcoupling.xvg 输出         xvgr/xmgr文件
  ` -corr [<.xvg>] `                dihcorr.xvg 输出, 可选   xvgr/xmgr文件
  ` -g [<.log>] `                       chi.log 输出         日志文件
  ` -ot [<.xvg>] `                 dihtrans.xvg 输出, 可选   xvgr/xmgr文件
  ` -oh [<.xvg>] `                  trhisto.xvg 输出, 可选   xvgr/xmgr文件
  ` -rt [<.xvg>] `                 restrans.xvg 输出, 可选   xvgr/xmgr文件
  ` -cp [<.xvg>] `             chiprodhisto.xvg 输出, 可选   xvgr/xmgr文件

  : 输入/输出文件选项 {#tab-14}

-----------------------------------------------------------------------------------------------------------------
  选项                                        默认值 说明
-------------------------- ----------------------- --------------------------------------------------------------
  ` -nice <int> `                                 19 设置优先级

  ` -b <time> `                                    0 从轨迹读取的第一帧(ps)

  ` -e <time> `                                    0 从轨迹读取最后一帧(ps)

  ` -dt <time> `                                   0 只使用t除以dt的余数等于第一帧时间(ps)的帧,
                                                     即两帧之间的时间间隔

  ` -[no]w `                                      no 查看输出的.xvg, .xpm, .eps和.pdb文件

  ` -xvg <enum> `                            xmgrace xvg绘图格式: xmgrace, xmgr, none

  ` -r0 <int> `                                    1 起始残基

  ` -[no]phi `                                    no 输出φ二面角

  ` -[no]psi `                                    no 输出ψ二面角

  ` -[no]omega `                                  no 输出ω二面角(肽键)

  ` -[no]rama `                                   no 生成φ/ψ和χ_1/χ_2的Ramachandran图

  ` -[no]viol `                                   no 输出一个文件, 对违背Ramachandran规则的角使用0或1

  ` -[no]periodic `                              yes 输出二面角与360度的模

  ` -[no]all `                                    no 对每个二面角使用独立的输出文件

  ` -[no]rad `                                    no 在角度与时间关系的文件中, 使用弧度而不是角度

  ` -[no]shift `                                  no 根据φ/ψ角度计算化学位移

  ` -binwidth <int> `                              1 直方图的分格宽度(单位: 度)

  ` -core_rotamer <real> `                       0.5 只输出中心 ` -core_rotamer `
                                                     \*(360/multiplicity)属于每个旋转异构体的值(其余的赋给rotamer
                                                     0)

  ` -maxchi <enum> `                               0 计算前几个χ二面角: 0, 1, 2, 3, 4, 5, 6

  ` -[no]normhisto `                             yes 直方图归一化

  ` -[no]ramomega `                               no 计算omega角度的平均值与φ/ψ的函数关系, 并输出到 ` .xpm ` 文件

  ` -bfact <real> `                               -1 对没有计算二面角序参数的原子, ` .pdb ` 文件中的B因子值

  ` -[no]chi_prod `                               no 计算每个残基的单个累积旋转异构体

  ` -[no]HChi `                                   no 包含到支链氢原子的二面角

  ` -bmax <real> `                                 0 对统计时所考虑的二面角, 组成二面角的任何原子的最大B因子.\
                                                     当进行射线结构分析X时作为基础数据. ` -bmax <= 0 `
                                                     意味着没有限制.

  ` -acflen <int> `                               -1 ACF的长度, 默认为帧数的一半.

  ` -[no]normalize `                             yes 归一化ACF

  ` -P <enum> `                                    0 ACF Legendre多项式的阶数(0表示不使用): 0, 1, 2, 3

  ` -fitfn <enum> `                             none 拟合函数: none, exp, aexp, exp_exp, vac, exp5, exp7, exp9,
                                                     erffit

  ` -beginfit <real> `                             0 对相关函数进行指数拟合的起始时间

  ` -endfit <real> `                              -1 对相关函数进行指数拟合的终止时间, -1表示直到最终
  -----------------------------------------------------------------------------------------------------------------

  : 控制选项 {#tab-15}

### 已知问题

-   产生 **非常非常多** 的输出文件(数目最多约为蛋白质残基数目的4倍,
    如果计算自相关函数会再增加两倍). 通常会有几百个输出文件.
-   使用非标准方式计算φ和ψ二面角, 使用H-N-CA-C计算φ,
    而不是使用C(-)-N-CA-C, 使用N-CA-C-O计算ψ, 而不是使用N-CA-C-N(+).
    这将导致计算结果与其他工具, 如 ` gmx rama `{.language-plaintext
    .highlighter-rouge} 的计算结果不符(通常很小).
-   ` -r0 `{.language-plaintext .highlighter-rouge} 选项不能正常工作.
-   二重旋转异构体会写入 ` chi.log `{.language-plaintext
    .highlighter-rouge} , 如三重一样, 只不过第三个(g(+))的概率总为0.

## gmx cluster: 对结构进行团簇分析

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx cluster [-f [<.xtc/.trr/...>]] [-s [<.tpr/.tpb/...>]] [-n [<.ndx>]]
            [-dm [<.xpm>]] [-om [<.xpm>]] [-o [<.xpm>]] [-g [<.log>]]
            [-dist [<.xvg>]] [-ev [<.xvg>]] [-conv [<.xvg>]] [-sz [<.xvg>]]
            [-tr [<.xpm>]] [-ntr [<.xvg>]] [-clid [<.xvg>]]
            [-cl [<.xtc/.trr/...>]] [-nice ] [-b ] [-e ]
            [-dt ] [-tu ] [-[no]w] [-xvg ] [-[no]dista]
            [-nlevels ] [-cutoff ] [-[no]fit] [-max ]
            [-skip ] [-[no]av] [-wcl ] [-nst ]
            [-rmsmin ] [-method ] [-minstruct ]
            [-[no]binary] [-M ] [-P ] [-seed ] [-niter ]
            [-nrandom ] [-kT ] [-[no]pbc]
```
:::
:::

` gmx cluster `{.language-plaintext .highlighter-rouge}
可以使用几种不同的方法团簇化结构. 结构之间的距离可由轨迹来确定, 或使用
` -dm `{.language-plaintext .highlighter-rouge} 选项从
` .xpm `{.language-plaintext .highlighter-rouge} 矩阵文件读取.
结构间的距离可以由叠合后的RMS偏差或原子对距离的RMS偏差来定义.

确定团簇的方法有以下几种:

-   single linkage(单连接): 当一个结构到团簇中任何一个原子的距离小于
    ` cutoff `{.language-plaintext .highlighter-rouge} 时,
    就将此结构加入到团簇中.
-   Jarvis Patrick: 当一个结构和团簇中的一个结构互为近邻结构, 并且至少有
    ` P `{.language-plaintext .highlighter-rouge} 个相同的邻近结构时,
    将这个结构加入到团簇中. 一个结构的近邻结构是指距离它最近的
    ` M `{.language-plaintext .highlighter-rouge} 个结构或在
    ` cutoff `{.language-plaintext .highlighter-rouge} 以内的全部结构.
-   Monte Carlo(蒙特卡洛): 利用蒙特卡洛方法重新排列RMSD矩阵,
    以使帧的排列具有尽可能小的递增顺序.
    这样做可以使从一个结构到另一个结构的动画尽量平滑,
    并且结构之间的具有最大的可能(例如)RMSD, 但中间步骤应尽可能小.
    这种方法可用于显示模拟的平均力势能系综或牵引模拟. 显然,
    用户要仔细地准备轨迹文件(例如不能存在叠加的帧). 最终的结果可以通过
    ` .xpm `{.language-plaintext .highlighter-rouge}
    矩阵文件进行直观的检查, 此文件从下到上都应该平滑地变化.
-   diagonalization(对角化): 对角化RMSD矩阵.
-   gromos: 利用Daura等介绍的算法(Angew. Chem. Int. Ed. **1999** , 38,
    pp 236-240). 使用截断来数算近邻结构的个数,
    把具有最多近邻的结构及其所有近邻作为一个团簇,
    并从团簇池中将这个团簇移除. 然后对团簇池中剩下的结构重复以上算法.

当团簇化算法(single linkage, Jarvis Patrick and gromos)
将每个结构都精确地分配到了一个团簇, 并且提供了轨迹文件时,
在每一个团簇中,
相对于其他结构或平均结构或所有结构拥有最小平均距离的结构将被写入到轨迹文件中.
当输出所有结构时, 对每个团簇会使用单独编号的文件.

程序总会给出两个输出文件:

-   ` -o `{.language-plaintext .highlighter-rouge} :
    输出矩阵左上半区域的RMSD值, 团簇图像的右下半区域. 当
    ` -minstruct = 1 `{.language-plaintext .highlighter-rouge} 时,
    若两个结构属于同一团簇, 相应的图像点为黑色; 当
    ` -minstruct > 1 `{.language-plaintext .highlighter-rouge} 时,
    对每一个团簇使用不同的颜色.
-   ` -g `{.language-plaintext .highlighter-rouge} :
    输出所用选项的信息和所有团簇及其成员的详细列表.

此外, 程序也可以给出多个可选的输出文件:

-   ` -dist `{.language-plaintext .highlighter-rouge} : 输出RMSD的分布
-   ` -ev `{.language-plaintext .highlighter-rouge} :
    输出RMSD矩阵对角化的特征向量
-   ` -sz `{.language-plaintext .highlighter-rouge} : 输出团簇的大小
-   ` -tr `{.language-plaintext .highlighter-rouge} :
    输出两个团簇之间的转变次数矩阵
-   ` -ntr `{.language-plaintext .highlighter-rouge} :
    输出从/到每个团簇的总转变次数
-   ` -clid `{.language-plaintext .highlighter-rouge} :
    输出团簇数随时间变化的函数
-   ` -cl `{.language-plaintext .highlighter-rouge} :
    输出每个团簇的平均(利用 ` -av `{.language-plaintext
    .highlighter-rouge} 选项)或中心结构, 或对所选的一组团簇,
    将团簇成员输出到带编号的文件(利用 ` -wcl `{.language-plaintext
    .highlighter-rouge} 选项, 取决于 ` -nst `{.language-plaintext
    .highlighter-rouge} 和 ` -rmsmin `{.language-plaintext
    .highlighter-rouge} 选项).
    一个团簇的中心是指团簇中与所有其他结构具有最小平均RMSD的结构.

  选项                                   默认值 类型         说明
  --------------------------- ----------------- ------------ ------------------------------------------------
  ` -f [<.xtc/.trr/...>] `             traj.xtc 输入, 可选   轨迹: xtc trr cpt trj gro g96 pdb tng
  ` -s [<.tpr/.tpb/...>] `            topol.tpr 输入, 可选   结构+质量(db): tpr tpb tpa gro g96 pdb brk ent
  ` -n [<.ndx>] `                     index.ndx 输入, 可选   索引文件
  ` -dm [<.xpm>] `                     rmsd.xpm 输入, 可选   X PixMap兼容的矩阵文件
  ` -om [<.xpm>] `                 rmsd-raw.xpm 输出         X PixMap兼容的矩阵文件
  ` -o [<.xpm>] `                rmsd-clust.xpm 输出         X PixMap兼容的矩阵文件
  ` -g [<.log>] `                   cluster.log 输出         日志文件
  ` -dist [<.xvg>] `              rmsd-dist.xvg 输出, 可选   xvgr/xmgr文件
  ` -ev [<.xvg>] `                 rmsd-eig.xvg 输出, 可选   xvgr/xmgr文件
  ` -conv [<.xvg>] `                mc-conv.xvg 输出, 可选   xvgr/xmgr文件
  ` -sz [<.xvg>] `               clust-size.xvg 输出, 可选   xvgr/xmgr文件
  ` -tr [<.xpm>] `              clust-trans.xpm 输出, 可选   X PixMap兼容的矩阵文件
  ` -ntr [<.xvg>] `             clust-trans.xvg 输出, 可选   xvgr/xmgr文件
  ` -clid [<.xvg>] `               clust-id.xvg 输出, 可选   xvgr/xmgr文件
  ` -cl [<.xtc/.trr/...>] `        clusters.pdb 输出, 可选   轨迹: xtc trr cpt trj gro g96 pdb tng

  : 输入/输出文件选项 {#tab-16}

  选项                      默认值 说明
  ---------------------- --------- -------------------------------------------------------------------------------
  ` -nice <int> `               19 设置优先级
  ` -b `                         0 从轨迹文件中读取的第一帧(ps)
  ` -e `                         0 从轨迹文件中读取的最后一帧(ps)
  ` -dt `                        0 只使用t除以dt的余数等于第一帧时间(ps)的帧, 即两帧之间的时间间隔
  ` -tu `                       ps 时间值的单位: fs, ps, ns, us, ms, s
  ` -[no]w `                    no 查看输出的 .xvg, .xpm, .eps和.pdb文件
  ` -xvg <enum> `          xmgrace xvg图形格式: xmgrace, xmgr, none
  ` -[no]dista `                no 利用RMSD距离而不是RMS偏差
  ` -nlevels <int> `            40 离散化RMSD矩阵时使用的水平数
  ` -cutoff <real> `           0.1 定义两个近邻结构所用的RMSD截断距离(nm)
  ` -[no]fit `                 yes 计算RMSD之前使用最小二乘叠合结构
  ` -max <real> `               -1 RMSD矩阵的最高水平
  ` -skip <int> `                1 每nr帧分析一次
  ` -[no]av `                   no 输出每一团簇的平均等中间结构
  ` -wcl <int> `                 0 将此数目团簇的结构输出到编号文件中
  ` -nst <int> `                 1 每个团簇中的结构数超过此数时才会输出团簇中的所有结构
  ` -rmsmin <real> `             0 输出结构与其余团簇的最小rms差异
  ` -method <enum> `       linkage 团簇的确定方法: linkage, jarvis-patrick, monte-carlo, diagonalization, gromos
  ` -minstruct <int> `           1 ` .xpm ` 文件中着色团簇具有的最小结构数
  ` -[no]binary `               no 将RMSD矩阵视为由0和1组成的矩阵, 截断由 ` -cutoff ` 给出
  ` -M <int> `                  10 Jarvis-Patrick算法中使用的最近近邻数, 取0时使用截断
  ` -P <int> `                   3 形成团簇需要的全同最近近邻数
  ` -seed <int> `             1993 蒙特卡洛团簇化算法的随机数种子: \<= 0 代表生成
  ` -niter <int> `           10000 蒙特卡洛的迭代次数
  ` -nrandom <int> `             0 蒙特卡洛的第一次迭代可以完全随机, 以对帧进行混洗
  ` -kT <real> `             0.001 蒙特卡洛优化中使用的Boltzmann权重因子(取0时会关闭上升步骤)
  ` -[no]pbc `                 yes PBC检查

  : 控制选项 {#tab-17}

## gmx clustsize: 计算原子团簇的尺寸分布

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx clustsize [-f [<.xtc/.trr/...>]] [-s [<.tpr>]] [-n [<.ndx>]]
              [-o [<.xpm>]] [-ow [<.xpm>]] [-nc [<.xvg>]] [-mc [<.xvg>]]
              [-ac [<.xvg>]] [-hc [<.xvg>]] [-temp [<.xvg>]] [-mcn [<.ndx>]]
              [-nice ] [-b ] [-e ] [-dt ] [-tu ]
              [-[no]w] [-xvg ] [-cut ] [-[no]mol] [-[no]pbc]
              [-nskip ] [-nlevels ] [-ndf ] [-rgblo ]
              [-rgbhi ]
```
:::
:::

` gmx clustsize `{.language-plaintext .highlighter-rouge}
用于计算气相中的分子/原子团簇的尺寸分布. 结果以
` .xpm `{.language-plaintext .highlighter-rouge} 格式的文件给出.
总的团簇数目会写入一个 ` .xvg `{.language-plaintext .highlighter-rouge}
文件中.

当指定 ` -mol `{.language-plaintext .highlighter-rouge} 选项时,
计算团簇时将以分子为基本单元, 而不是以原子为基本单元,
这样允许对大分子进行团簇化. 在这种情况下,
索引文件中仍然应当包括原子编号, 否则计算会终止并给出SEGV信号.

当轨迹中包含速度时, 程序假定所有粒子都可自由移动,
并将最大团簇的温度输出在一个独立的 ` .xvg `{.language-plaintext
.highlighter-rouge} 文件中. 如果使用了约束, 则需要校正温度. 例如,
使用SHAKE或SETTLE算法模拟水时, 得到的温度是正常温度的1/1.5. 你可以使用
` -ndf `{.language-plaintext .highlighter-rouge} 选项来补偿这一点.
请记得计算时去除质心的运动.

使用 ` -mc `{.language-plaintext .highlighter-rouge}
选项将输出一个索引文件, 其中包含最大团簇的原子编号.

  选项                                  默认值 类型         说明
-------------------------- ----------------- ------------ ---------------------------------------
  ` -f [<.xtc/.trr/...>] `            traj.xtc 输入         轨迹: xtc trr cpt trj gro g96 pdb tng
  ` -s [<.tpr>] `                    topol.tpr 输入, 可选   兼容的xdr运行输入文件
  ` -n [<.ndx>] `                    index.ndx 输入, 可选   索引文件
  ` -o [<.xpm>] `                    csize.xpm 输出         X PixMap兼容矩阵文件
  ` -ow [<.xpm>] `                  csizew.xpm 输出         X PixMap兼容矩阵文件
  ` -nc [<.xvg>] `                  nclust.xvg 输出         xvgr/xmgr文件
  ` -mc [<.xvg>] `                maxclust.xvg 输出         xvgr/xmgr文件
  ` -ac [<.xvg>] `                 avclust.xvg 输出         xvgr/xmgr文件
  ` -hc [<.xvg>] `             histo-clust.xvg 输出         xvgr/xmgr文件
  ` -temp [<.xvg>] `                  temp.xvg 输出, 可选   xvgr/xmgr文件
  ` -mcn [<.ndx>] `               maxclust.ndx 输出, 可选   索引文件

  : 输入/输出文件选项 {#tab-18}

  选项                     默认值 说明
--------------------- --------- -----------------------------------------------------------------
  ` -nice <int> `              19 设置优先级
  ` -b <time> `                 0 从轨迹文件中读取的第一帧(ps)
  ` -e <time> `                 0 从轨迹文件中读取的最后一帧(ps)
  ` -dt <time> `                0 只使用t除以dt的余数等于第一帧时间(ps)的帧, 即两帧之间的时间间隔
  ` -tu <enum> `               ps 时间单位: fs, ps, ns, us, ms, s
  ` -[no]w `                   no 查看输出的.xvg, .xpm, .eps和.pdb文件
  ` -xvg <enum> `         xmgrace xvg绘图格式: xmgrace, xmgr, none
  ` -cut <real> `            0.35 一个团簇中的最大距离(单位nm)
  ` -[no]mol `                 no 对分子而不是原子进行团簇分析(需要 ` .tpr ` 文件)
  ` -[no]pbc `                yes 使用周期性边界条件
  ` -nskip <int> `              0 输出时跳过的帧数
  ` -nlevels <int> `           20 ` .xpm ` 输出文件中灰度的数目
  ` -ndf <int> `               -1 计算温度时整个体系的自由度数. 如果未设置, 会使用3倍的原子数目
  ` -rgblo <vector> `       1 1 0 团簇大小最低值的GRB颜色值
  ` -rgbhi <vector> `       0 0 1 团簇大小最高值的GRB颜色值

  : 控制选项 {#tab-19}

## gmx confrms: 叠合两个结构并计算RMSD

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx confrms [-f1 [<.tpr/.tpb/...>]] [-f2 [<.gro/.g96/...>]]
            [-o [<.gro/.g96/...>]] [-n1 [<.ndx>]] [-n2 [<.ndx>]]
            [-no [<.ndx>]] [-nice ] [-[no]w] [-[no]one] [-[no]mw]
            [-[no]pbc] [-[no]fit] [-[no]name] [-[no]label] [-[no]bfac]
```
:::
:::

` gmx confrms `{.language-plaintext .highlighter-rouge}
首先将第二个结构最小二乘叠合到第一个结构,
然后再计算两个结构的均方根偏差(RMSD, root mean square deviation).
两个结构的原子数 **不必** 相同, 只要用于叠合的两个索引组一样即可. 使用
` -name `{.language-plaintext .highlighter-rouge} 选项时,
只对所选组中名称匹配的原子进行叠合和RMSD计算.
当比较蛋白质的突变体时这个功能很有用.

叠合的结构会写入一个文件中. 在这个 ` .pdb `{.language-plaintext
.highlighter-rouge} 文件中, 两个结构会当作独立的模型(使用
` rasmol –nmrpdb `{.language-plaintext .highlighter-rouge} ). 使用
` -bfac `{.language-plaintext .highlighter-rouge} 选项时,
根据原子的MSD值计算的B因子也会写入这个 ` .pdb `{.language-plaintext
.highlighter-rouge} 文件中.

  选项                             默认值 类型                               说明
--------------------------- ----------- ------------ ------------------------------------------------
  ` -f1 [<.tpr/.tpb/...>] `     conf1.gro 输入          结构+质量(db): tpr tpb tpa gro g96 pdb brk ent
  ` -f2 [<.gro/.g96/...>] `     conf2.gro 输入          结构文件: gro g96 pdb brk ent esp tpr tpb tpa
  ` -o [<.gro/.g96/...>] `        fit.pdb 输出                结构文件: gro g96 pdb brk ent esp
  ` -n1 [<.ndx>] `               fit1.ndx 输入, 可选                       索引文件
  ` -n2 [<.ndx>] `               fit2.ndx 输入, 可选                       索引文件
  ` -no [<.ndx>] `              match.ndx 输出, 可选                       索引文件

  : 输入/输出文件选项 {#tab-20}

  选项                默认值 说明
----------------- -------- ------------------------------------------
  ` -nice <int> `         19 设置优先级
  ` -[no]w `              no 查看输出的.xvg, .xpm, .eps和.pdb文件
  ` -[no]one `            no 只输出叠合后的结构
  ` -[no]mw `            yes 叠合与计算RMSD时使用质量加权
  ` -[no]pbc `            no 尝试将分子恢复完整
  ` -[no]fit `           yes 将目标结构与参考结构进行最小二乘叠合
  ` -[no]name `           no 只考虑名称匹配的原子
  ` -[no]label `          no 增加链标识, 第一个结构为A, 第二个结构为B
  ` -[no]bfac `           no 根据原子的MSD值输出B因子

  : 控制选项 {#tab-21}

## gmx convert-tpr: 生成修改的运行输出文件

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx convert-tpr [-s [<.tpr/.tpb/...>]] [-f [<.trr/.cpt/...>]] [-e [<.edr>]]
                [-n [<.ndx>]] [-o [<.tpr/.tpb/...>]] [-nice ]
                [-extend ] [-until ] [-nsteps ] [-time ]
                [-[no]zeroq] [-[no]vel] [-[no]cont] [-init_fep_state ]
```
:::
:::

` gmx convert-tpr `{.language-plaintext .highlighter-rouge}
可以四种方式来编辑运行输入文件:

1.  修改运行输入文件中的模拟步数, 可使用选项
    ` -extend `{.language-plaintext .highlighter-rouge} ,
    ` -until `{.language-plaintext .highlighter-rouge} 或
    ` -nsteps `{.language-plaintext .highlighter-rouge} (
    ` nsteps=-1 `{.language-plaintext .highlighter-rouge}
    表示步数不受限制).
2.  (已废弃) 因磁盘已满等原因而导致模拟崩溃时,
    产生一个运行输入文件以继续模拟, 或创建一个继续的运行输入文件.
    此选项已废弃, 因为 ` mdrun `{.language-plaintext .highlighter-rouge}
    现在可以读写检查点文件. **注意** , 运行需要带有坐标和速率的帧.
    当使用压力和/或Nose-Hoover温度耦合时,
    还需要提供能量文件以得到原始运行的精确继续.
3.  对原始tpx文件一部分创建一个 ` .tpx `{.language-plaintext
    .highlighter-rouge} 文件. 当你想从 ` .tpx `{.language-plaintext
    .highlighter-rouge} 文件中移除溶剂, 或想产生一个例如只包含C\~α\~的
    ` .tpx `{.language-plaintext .highlighter-rouge} 文件时,
    此功能很有用. 需要注意的是, 你可能需要使用
    ` -nsteps -1 `{.language-plaintext .highlighter-rouge}
    (或类似的选项). **警告: 此 ` .tpx `{.language-plaintext
    .highlighter-rouge} 文件功能不全.**
4.  将指定组的电荷设置为零. 当使用LIE(Linear Interaction Energy,
    线性相互作用能)方法估算自由能时, 此功能很有用.

  选项                             默认值 类型         说明
-------------------------- ------------ ------------ -----------------------------
  ` -s [<.tpr/.tpb/...>] `      topol.tpr 输入         运行输入文件: tpr tpb tpa
  ` -f [<.trr/.cpt/...>] `       traj.trr 输入, 可选   全精度轨迹: trr cpt trj tng
  ` -e [<.edr>] `                ener.edr 输入,可选    能量文件
  ` -n [<.ndx>] `               index.ndx 输入,可选    索引文件
  ` -o [<.tpr/.tpb/...>] `     tpxout.tpr 输出         运行输入文件: tpr tpb tpa

  : 输入/输出文件选项 {#tab-22}

  选项                          默认值 说明
--------------------------- -------- --------------------------------------------------------
  ` -nice <int> `                    0 设置优先级
  ` -extend <real> `                 0 通过此值来延长运行时间 (单位: ps)
  ` -until <real> `                  0 延长运行时间直到此时间结束 (单位: ps)
  ` -nsteps <int> `                  0 修改模拟运行步数
  ` -time <real> `                  -1 由此时间(单位: ps)帧继续运行, 而不是从最后一帧继续运行
  ` -[no]zeroq `                    no 将一个组(来自索引)的电荷设置为零
  ` -[no]vel `                     yes 需要来自轨迹的速度
  ` -[no]cont `                    yes 为了精确的延续, 在第一步之前不应施加约束
  ` -init_fep_state <int> `          0 由此状态开始初始化fep状态

  : 控制选项 {#tab-23}

## gmx covar: 计算并对角化协方差矩阵

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx covar [-f [<.xtc/.trr/...>]] [-s [<.tpr/.tpb/...>]] [-n [<.ndx>]]
          [-o [<.xvg>]] [-v [<.trr/.cpt/...>]] [-av [<.gro/.g96/...>]]
          [-l [<.log>]] [-ascii [<.dat>]] [-xpm [<.xpm>]] [-xpma [<.xpm>]]
          [-nice ] [-b ] [-e ] [-dt ] [-tu ]
          [-xvg ] [-[no]fit] [-[no]ref] [-[no]mwa] [-last ]
          [-[no]pbc]
```
:::
:::

` gmx covar `{.language-plaintext .highlighter-rouge}
用于计算并对角化(质量加权的)协方差矩阵.
所有结构都叠合到结构文件中的结构. 当结构文件不是运行输入文件时,
将不考虑周期性. 如果叠合组与分析组相同, 分析时不使用质量加权,
叠合也不使用质量加权.

本征向量会写入一个轨迹文件( ` -v `{.language-plaintext
.highlighter-rouge} ). 如果叠合与协方差分析的原子相同,
会首先输出用于叠合的参考结构, 其t=-1. 平均(或参考, 若使用了
` -ref `{.language-plaintext .highlighter-rouge} )结构的t=0,
本征向量会写入不同的帧, 以其本征向量序号为时间戳.

本征向量可使用 ` gmx anaeig `{.language-plaintext .highlighter-rouge}
分析.

选项 ` -ascii `{.language-plaintext .highlighter-rouge}
会将整个协方差矩阵写入一个ASCII文件. 元素的顺序为: x1x1, x1y1, x1z1,
x1x2, ...

选项 ` -xpm `{.language-plaintext .highlighter-rouge}
会将整个协方差矩阵写入一个 ` .xpm `{.language-plaintext
.highlighter-rouge} 文件.

选项 ` -xpma `{.language-plaintext .highlighter-rouge}
会将原子的协方差矩阵写入一个 ` . xpm `{.language-plaintext
.highlighter-rouge} 文件, 即, 写入每个原子对xx, yy和zz协方差的总和.

注意, 对角化一个矩阵所需的内存和时间至少会以原子数平方的速度增加,
因此很容易耗尽内存. 在这种情况下, 程序很可能会出现段错误并推出.
你应该仔细考虑数目更少的一组原子是否能满足你的需求, 这样计算成本更低.

  选项                                默认值 类型         说明
--------------------------- -------------- ------------ ------------------------------------------------
  ` -f [<.xtc/.trr/...>] `          traj.xtc 输入         轨迹: xtc trr cpt trj gro g96 pdb tng
  ` -s [<.tpr/.tpb/...>] `         topol.tpr 输入         结构+质量(db): tpr tpb tpa gro g96 pdb brk ent
  ` -n [<.ndx>] `                  index.ndx 输入, 可选   索引文件
  ` -o [<.xvg>] `               eigenval.xvg 输出         xvgr/xmgr文件
  ` -v [<.trr/.cpt/...>] `      eigenvec.trr 输出         全精度轨迹: trr cpt trj tng
  ` -av [<.gro/.g96/...>] `      average.pdb 输出         结构文件: gro g96 pdb brk ent esp
  ` -l [<.log>] `                  covar.log 输出         日志文件
  ` -ascii [<.dat>] `              covar.dat 输出, 可选   通用数据文件
  ` -xpm [<.xpm>] `                covar.xpm 输出, 可选   X PixMap兼容矩阵文件
  ` -xpma [<.xpm>] `              covara.xpm 输出, 可选   X PixMap兼容矩阵文件

  : 输入/输出文件选项 {#tab-24}

  选项                 默认值 说明
----------------- --------- -----------------------------------------------------------------
  ` -nice <int> `          19 设置优先级
  ` -b <time> `             0 从轨迹文件中读取的第一帧(ps)
  ` -e <time> `             0 从轨迹文件中读取的最后一帧(ps)
  ` -dt <time> `            0 只使用t除以dt的余数等于第一帧时间(ps)的帧, 即两帧之间的时间间隔
  ` -tu <enum> `           ps 时间单位: fs, ps, ns, us, ms, s
  ` -xvg <enum> `     xmgrace xvg绘图格式: xmgrace, xmgr, none
  ` -[no]fit `            yes 叠合到参考结构
  ` -[no]ref `             no 使用与结构文件中的构型的偏离, 而不是使用平均构型
  ` -[no]mwa `             no 质量加权的协方差分析
  ` -last <int> `          -1 输出的最后一个本征向量的编号(-1会输出所有本征向量)
  ` -[no]pbc `            yes 对周期性边界条件进行校正

  : 控制选项 {#tab-25}

## gmx current: 计算介电常数和电流自相关函数

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx current [-s [<.tpr/.tpb/...>]] [-n [<.ndx>]] [-f [<.xtc/.trr/...>]]
            [-o [<.xvg>]] [-caf [<.xvg>]] [-dsp [<.xvg>]] [-md [<.xvg>]]
            [-mj [<.xvg>]] [-mc [<.xvg>]] [-nice ] [-b ]
            [-e ] [-dt ] [-[no]w] [-xvg ] [-sh ]
            [-[no]nojump] [-eps ] [-bfit ] [-efit ]
            [-bvit ] [-evit ] [-tr ] [-temp ]
```
:::
:::

` gmx current `{.language-plaintext .highlighter-rouge}
可用于计算电流自相关函数, 体系转动偶极矩和平动偶极矩的相关,
以及相关的静态介电常数. 为得到合理的结果, 索引组应当是中性的. 更进一步,
如果给出了速度, 程序也可以根据电流自相关函数计算静态电导率. 此外,
也可以利用Einstein-Helfand拟合得到静态电导率.

` -caf `{.language-plaintext .highlighter-rouge}
选项用于指定电流自相关函数的输出文件, ` -mc `{.language-plaintext
.highlighter-rouge} 选项用于指定偶极矩转动和平动部分相关的输出文件.
但这些选项只适用于包含速度的轨迹. 选项 ` -sh `{.language-plaintext
.highlighter-rouge} 和 ` -tr `{.language-plaintext .highlighter-rouge}
对自相关函数进行平均和积分. 由于平均是通过移动轨迹的起始点进行的,
可以利用 ` -sh `{.language-plaintext .highlighter-rouge}
选项修改移动以便选择不相关的起始点. 当接近终止点时, 统计的不精确度增加,
对自相关函数进行积分只有在某一点之前才能得到合理的值,
数据的可靠性取决于帧数. 选项 ` -tr `{.language-plaintext
.highlighter-rouge} 控制用于计算静态介电常数的积分区域的大小.

选项 ` -temp `{.language-plaintext .highlighter-rouge}
可以设置计算静态介电常数所需要的温度.

当模拟中使用了反应场或偶极修正Ewald加和( ` -eps=0 `{.language-plaintext
.highlighter-rouge} 对应于圆罐边界条件)时, 选项
` -eps `{.language-plaintext .highlighter-rouge}
可以控制周围介质的介电常数.

` -[no]nojump `{.language-plaintext .highlighter-rouge}
选项取消坐标折叠允许自由扩散.
这需要一个连续的平动偶极矩以便进行Einstein-Helfand拟合.
拟合结果可用于确定带电分子体系的介电常数. 然而,
也可以根据折叠坐标的总偶极矩涨落计算介电常数. 但使用此选项时需要小心,
因为只有在非常小的时间跨度内才能满足分子密度近似恒定且平均值收敛的条件.
为保险起见, 计算介电常数时,
应借助Einstein-Helfand方法计算介电常数的平动部分.

  选项                              默认值 类型         说明
-------------------------- ------------- ------------ ------------------------------------------------
  ` -s [<.tpr/.tpb/...>] `       topol.tpr 输入         结构+质量(db): tpr tpb tpa gro g96 pdb brk ent
  ` -n [<.ndx>] `                index.ndx 输入, 可选   索引文件
  ` -f [<.xtc/.trr/...>] `        traj.xtc 输入         轨迹: xtc trr cpt trj gro g96 pdb tng
  ` -o [<.xvg>] `              current.xvg 输出         xvgr/xmgr文件
  ` -caf [<.xvg>] `                caf.xvg 输出, 可选   xvgr/xmgr文件
  ` -dsp [<.xvg>] `                dsp.xvg 输出         xvgr/xmgr文件
  ` -md [<.xvg>] `                  md.xvg 输出         xvgr/xmgr文件
  ` -mj [<.xvg>] `                  mj.xvg 输出         xvgr/xmgr文件
  ` -mc [<.xvg>] `                  mc.xvg 输出, 可选   xvgr/xmgr文件

  : 输入/输出文件选项 {#tab-26}

  选项                  默认值 说明
------------------ --------- -----------------------------------------------------------------
  ` -nice <int> `            0 设置优先级
  ` -b <time> `              0 从轨迹文件中读取的第一帧(ps)
  ` -e <time> `              0 从轨迹文件中读取的最后一帧(ps)
  ` -dt <time> `             0 只使用t除以dt的余数等于第一帧时间(ps)的帧, 即两帧之间的时间间隔
  ` -[no]w `                no 查看输出的 ` .xvg ` , ` .xpm ` , ` .eps ` 以及 ` .pdb ` 文件
  ` -xvg <enum> `      xmgrace xvg绘图格式: xmgrace, xmgr, none
  ` -sh <int> `           1000 为计算相关函数平均值及均方差位移而移动的帧
  ` -[no]nojump `          yes 移除横跨盒子的原子跳跃
  ` -eps <real> `            0 周围介质的介电常数. 该值为0时相当于无穷大(圆罐边界条件).
  ` -bfit <real> `         100 平动偶极矩MSD拟合为直线的起始值
  ` -efit <real> `         400 平动偶极矩MSD拟合为直线的终止值
  ` -bvit <real> `         0.5 电流自相关函数拟合为a\*t\^b的起始值
  ` -evit <real> `           5 电流自相关函数拟合为a\*t\^b的终止值
  ` -tr <real> `          0.25 积分时所用轨迹所占的比例
  ` -temp <real> `         300 计算介电常数时所用的温度

  : 控制选项 {#tab-27}

## gmx density: 计算体系的密度

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx density [-f [<.xtc/.trr/...>]] [-n [<.ndx>]] [-s [<.tpr/.tpb/...>]]
            [-ei [<.dat>]] [-o [<.xvg>]] [-nice ] [-b ]
            [-e ] [-dt ] [-[no]w] [-xvg ] [-d ]
            [-sl ] [-dens ] [-ng ] [-[no]center] [-[no]symm]
            [-[no]relative]
```
:::
:::

` gmx density `{.language-plaintext .highlighter-rouge}
用于计算盒子中的局部密度, 需要使用索引文件.

对于NPT模拟的总密度, 可以直接使用 ` gmx energy `{.language-plaintext
.highlighter-rouge} 来得到.

选项 ` -center `{.language-plaintext .highlighter-rouge}
相对任意组中心以绝对盒子坐标进行直方图分格.
如果你想计算沿盒子Z轴的密度剖面, 盒子Z方向的大小为bZ,
如果基于整个体系进行居中, 输出的坐标范围从-bZ/2到bZ/2. 注意, 在GROMACS
5.0中, 这种行为有所改变. 早期的版本中只是在(0,
bZ)范围内进行简单的静态分格, 并将输出进行移动.
新版本会计算每一帧的中心并在(-bZ/2,bZ/2)范围内进行分格.

选项 ` -symn `{.language-plaintext .highlighter-rouge}
使输出结果关于中心对称. 这一选项也会自动打开
` -center `{.language-plaintext .highlighter-rouge} 选项. 选项
` -relative `{.language-plaintext .highlighter-rouge}
基于盒子的相对坐标而不是绝对坐标进行分格,
然后对输出结果按输出轴方向盒子的平均尺寸进行标定. 这一选项可以与
` -center `{.language-plaintext .highlighter-rouge} 结合使用.

密度的单位为kg/m\^3\^, 同时也可以计算数密度或电子密度. 计算电子密度时,
需要使用选项 ` -ei `{.language-plaintext .highlighter-rouge}
提供一个文件, 其中包含了每一原子类型的电子数. 文件内容如下所示:

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
2
atomname = nrelectrons
atomname = nrelectrons
```
:::
:::

第一行指明了该文件的行数. 体系中每个唯一的原子名称对应于一行.
每个原子的电子数会根据其原子部分电荷进行修改.

**对双层体系需要注意的几点**

最常见的使用情境之一是计算跨脂质双层的各种原子组的密度,
通常是以Z轴作为法线方向. 对小体系的短时间模拟, 当固定盒子尺寸时,
比较好处理, 但对更一般的情况, 脂质双层可能比较复杂.
第一个问题就是蛋白质和脂质的体积压缩率都很小,
而脂质有非常高的面积压缩率. 这意味即便对完全弛豫好的体系,
在模拟过程中盒子形状(厚度或是面积/脂质)的涨落仍然很大.

因为GROMACS将盒子置于原点和正轴之上,
这也就意味着居于盒子中间的脂质双层由于涨落将会上下移动,
并进而模糊密度剖面.
解决这个问题的最简单方法(如果你要使用压力耦合)就是使用
` -center `{.language-plaintext .highlighter-rouge}
选项以计算相对于盒子中心的密度剖面. 注意, 你仍然可以用双层部分居中,
即使你有一个复杂的非对称的脂质双层和膜蛋白体系.
这样输出的数据点在(中心)原点参考位置的某一侧会较多.

因为脂质本身会被压缩和膨胀, 居中计算会导致输出的密度剖面模糊. 即使如此,
在多数情况下你希望得到这样的结果(因为它对应于宏观实验).
但如果你要关注分子细节, 可以使用 ` -relative `{.language-plaintext
.highlighter-rouge} 选项来尝试消除体积涨落带来的影响.

最后, 对不受表面张力影响的大的双层,
在体系中形成"波浪"的地方会表现出起伏涨落. 这是生物体系的基本性质,
如果要和实验做对比, 你可能要包括这种波动模糊效应.

  选项                                默认值 类型         说明
-------------------------- --------------- ------------ ---------------------------------------
  ` -f [<.xtc/.trr/...>] `          traj.xtc 输入         轨迹: xtc trr cpt trj gro g96 pdb tng
  ` -n [<.ndx>] `                  index.ndx 输入, 可选   索引文件
  ` -s [<.tpr/.tpb/...>] `         topol.tpr 输入         运行输入文件: tpr tpb tpa
  ` -ei [<.dat>] `             electrons.dat 输入, 可选   通用数据文件
  ` -o [<.xvg>] `                density.xvg 输出         xvgr/xmgr文件

  : 输入/输出文件选项 {#tab-28}

--------------------------------------------------------------------------------------------
  选项                                     默认值 说明
----------------------- ----------------------- --------------------------------------------
  ` -nice <int> `                              19 设置优先级

  ` -b <time> `                                 0 从轨迹文件中读取的第一帧(ps)

  ` -e <time> `                                 0 从轨迹文件中读取的最后一帧(ps)

  ` -dt <time> `                                0 只使用t除以dt的余数等于第一帧时间(ps)的帧,
                                                  即两帧之间的时间间隔

  ` -[no]w `                                   no 查看输出的 ` .xvg ` , ` .xpm ` , ` .eps `
                                                  以及 ` .pdb ` 文件

  ` -xvg <enum> `                         xmgrace xvg绘图格式: xmgrace, xmgr, none

  ` -d <string> `                               Z 指定膜的法线方向: X, Y或Z

  ` -sl <int> `                                50 将盒子划分为指定数目的片

  ` -dens <enum> `                           mass 密度类型: mass, number, charge, electron

  ` -ng <int> `                                 1 要计算密度的组的数目\
                                                  一次性可以计算多个组的密度,
                                                  可在输出文件中查看

  ` -[no]center `                              no 相对于(变化的)盒子中心进行分格,
                                                  适用于双层体系.

  ` -[no]symm `                                no 使密度分布沿轴向对称. 适用于双层体系

  ` -[no]relative `                            no 对变化的盒子使用相对坐标,
                                                  并根据平均尺寸对使出进行标定
  --------------------------------------------------------------------------------------------

  : 控制选项 {#tab-29}

### 已知问题

-   当计算电子密度时, 使用了原子名称而不是原子类型. 这种做法很不好.

### 补充说明

` gmx density `{.language-plaintext .highlighter-rouge}
是获取体系或各个组分在盒子内分布密度的一个程序. 一般来说可使用如命令:

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx density -f *.trr -n *.ndx -s *.tpr -d z -o density.xvg
```
:::
:::

其中

-   ` -f *.trr `{.language-plaintext .highlighter-rouge}
    指定要分析的轨迹文件
-   ` -n *.ndx `{.language-plaintext .highlighter-rouge} 指定索引文件,
    使用它可以在分析时指定不同的组来分析
-   ` -s *.tpr `{.language-plaintext .highlighter-rouge} 指定拓扑文件
-   ` -d z `{.language-plaintext .highlighter-rouge}
    指定沿着z轴方向进行分析

如果要指定分析索引组1的密度, 可以使用命令管道:

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
echo 1 | gmx density -f npt.trr -n system.ndx -s npt.tpr -d z -o density_DRG.xvg
```
:::
:::

此程序不支持根据残基名称来获取密度, 可通过
` gmx make_ndx `{.language-plaintext .highlighter-rouge}
来获取索引组代号再通过命令管道传给 ` gmx density `{.language-plaintext
.highlighter-rouge} 实现.

## gmx densmap: 计算二维的平面或轴径向密度映射图

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx densmap [-f [<.xtc/.trr/...>]] [-s [<.tpr/.tpb/...>]] [-n [<.ndx>]]
            [-od [<.dat>]] [-o [<.xpm>]] [-nice ] [-b ]
            [-e ] [-dt ] [-[no]w] [-bin ] [-aver ]
            [-xmin ] [-xmax ] [-n1 ] [-n2 ]
            [-amax ] [-rmax ] [-[no]mirror] [-[no]sums]
            [-unit ] [-dmin ] [-dmax ]
```
:::
:::

` gmx densmap `{.language-plaintext .highlighter-rouge}
用于计算2D数密度的映射图. 它可以计算平面和轴径向的密度映射图. 输出的
` .xpm `{.language-plaintext .highlighter-rouge}
文件可以利用XV等程序进行可视化, 也可以利用
` xpm2ps `{.language-plaintext .highlighter-rouge} 转换为psotscript.
利用 ` -od `{.language-plaintext .highlighter-rouge}
选项可将数据输出为文本形式的 ` .dat `{.language-plaintext
.highlighter-rouge} 文件, 而不是 ` -o `{.language-plaintext
.highlighter-rouge} 输出的通常 ` .xpm `{.language-plaintext
.highlighter-rouge} 文件.

程序默认计算选定的一组原子在xy平面内的2D数密度映射图. 可以使用
` -aver `{.language-plaintext .highlighter-rouge} 选项改变平均方向.
当设定了 ` -xmin `{.language-plaintext .highlighter-rouge} 和/或
` -xmax `{.language-plaintext .highlighter-rouge} 时,
计算时只会考虑平均方向上处于限制范围之内的原子. 使用
` -bin `{.language-plaintext .highlighter-rouge} 设置格点间距. 当
` -n1 `{.language-plaintext .highlighter-rouge} 或
` -n2 `{.language-plaintext .highlighter-rouge} 取非零值时,
格点尺寸由该选项决定. 计算时考虑了盒子尺寸的涨落.

当设定了 ` -amax `{.language-plaintext .highlighter-rouge} 和
` -rmax `{.language-plaintext .highlighter-rouge} 选项时,
会计算轴径向数密度映射图. 应提供三个组, 前两个组的质心用与定义轴线,
第三个组为要分析组. 轴向范围从-amax至+amax, 中心为两质心的中点,
并且正方向为第一组的质心到第二组的质心. 径向范围从0到rmax. 当指定了
` -mirror `{.language-plaintext .highlighter-rouge} 选项时,
径向范围从-rmax至+rmax.

可使用 ` -unit `{.language-plaintext .highlighter-rouge}
选项对输出进行归一化. 默认给出实际的数密度. 使用
` -unit nm-2 `{.language-plaintext .highlighter-rouge}
选项忽略对平均值或角方向的归一化处理. 使用
` -unit count `{.language-plaintext .highlighter-rouge}
选项可得到每个格点单元的计数值.
如果不想在输出中使用从零到最大密度的标尺, 你可以使用
` -dmax `{.language-plaintext .highlighter-rouge} 选项设定最大密度值.

  选项                              默认值 类型         说明
-------------------------- ------------- ------------ ------------------------------------------------
  ` -f [<.xtc/.trr/...>] `        traj.xtc 输入         轨迹: xtc trr cpt trj gro g96 pdb tng
  ` -s [<.tpr/.tpb/...>] `       topol.tpr 输入, 可选   结构+质量(db): tpr tpb tpa gro g96 pdb brk ent
  ` -n [<.ndx>] `                index.ndx 输入, 可选   索引文件
  ` -od [<.dat>] `             densmap.dat 输出, 可选   通用数据文件
  ` -o [<.xpm>] `              densmap.xpm 输出         X PixMap兼容数据文件

  : 输入/输出文件选项 {#tab-30}

  选项                 默认值 说明
------------------ -------- -----------------------------------------------------------------
  ` -nice <int> `          19 设置优先级
  ` -b <time> `             0 从轨迹文件中读取的第一帧(ps)
  ` -e <time> `             0 从轨迹文件中读取的最后一帧(ps)
  ` -dt <time> `            0 只使用t除以dt的余数等于第一帧时间(ps)的帧, 即两帧之间的时间间隔
  ` -[no]w `               no 查看输出的 ` .xvg ` , ` .xpm ` , ` .eps ` 以及 ` .pdb ` 文件
  ` -bin <real> `        0.02 格点尺寸 (nm)
  ` -aver <enum> `          z 平均的方向: z, y, x
  ` -xmin <real> `         -1 平均的最小坐标
  ` -xmax <real> `         -1 平均的最大坐标
  ` -n1 <int> `             0 第一方向的格点单元数
  ` -n2 <int> `             0 第二方向的格点单元数
  ` -amax <real> `          0 距离中心的最大轴向距离
  ` -rmax <real> `          0 最大径向距离
  ` -[no]mirror `          no 在轴下添加镜像
  ` -[no]sums `            no 将密度累加值(1D映射图)输出到屏幕
  ` -unit <enum> `       nm-3 输出单位: nm-3, nm-2, count
  ` -dmin <real> `          0 输出中的最小密度
  ` -dmax <real> `          0 输出中的最大密度(0表示由计算值确定)

  : 控制选项 {#tab-31}

### 补充说明

-   Sobereva,
    [使用g_densmap得到分子附近二维密度分布图](http://sobereva.com/12)

## gmx densorder: 计算表面涨落

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx densorder [-s [<.tpr/.tpb/...>]] [-f [<.xtc/.trr/...>]] [-n [<.ndx>]]
              [-o [<.dat>]] [-or [<.out> [...]]] [-og [<.xpm> [...]]]
              [-Spect [<.out> [...]]] [-nice ] [-b ] [-e ]
              [-dt ] [-[no]w] [-[no]1d] [-bw ] [-bwn ]
              [-order ] [-axis ] [-method ] [-d1 ]
              [-d2 ] [-tblock ] [-nlevel ]
```
:::
:::

` gmx densorder `{.language-plaintext .highlighter-rouge}
利用MD轨迹计算沿着某一方向的双相密度分布,
通过将界面密度拟合为函数的剖面, 可得到二维表面随时间的涨落. 利用
` -tavg `{.language-plaintext .highlighter-rouge}
选项可输出界面的时间平均的空间表示.

  选项                                 默认值 类型         说明
--------------------------- --------------- ------------ -------------------------------------------
  ` -s [<.tpr/.tpb/...>] `          topol.tpr 输入         运行输入文件: tpr tpb tpa
  ` -f [<.xtc/.trr/...>] `           traj.xtc 输入         轨迹文件: xtc trr cpt trj gro g96 pdb tng
  ` -n [<.ndx>] `                   index.ndx 输入         索引文件
  ` -o [<.dat>] `               Density4D.dat 输出, 可选   通用数据文件
  ` -or [<.out> [...]] `            hello.out 输出, 可选   通用输出文件
  ` -og [<.xpm> [...]] `        interface.xpm 输出, 可选   X PixMap兼容矩阵文件
  ` -Spect [<.out> [...]] `     intfspect.out 输出, 可选   通用输出文件

  : 输入/输出文件选项 {#tab-32}

  选项                   默认值 说明
-------------------- -------- -----------------------------------------------------------------
  ` -nice <int> `            19 设置优先级
  ` -b <time> `               0 从轨迹文件中读取的第一帧(ps)
  ` -e <time> `               0 从轨迹文件中读取的最后一帧(ps)
  ` -dt <time> `              0 只使用t除以dt的余数等于第一帧时间(ps)的帧, 即两帧之间的时间间隔
  ` -[no]w `                 no 查看输出的.xvg, .xpm, .eps和.pdb文件
  ` -[no]1d `                no 伪1D界面结构
  ` -bw <real> `            0.2 平行于界面的密度分布的分格宽度
  ` -bwn <real> `          0.05 垂直于界面的密度分布的分格宽度
  ` -order <int> `            0 高斯滤波器的阶数, 0意味着不使用滤波
  ` -axis <string> `          Z 轴的方向: X, Y或Z
  ` -method <enum> `     bisect 定位界面的方法: bisect, functional
  ` -d1 <real> `              0 相1的体相密度(z值小时)
  ` -d2 <real> `           1000 相2的体相密度 (z值大时)
  ` -tblock <int> `         100 一次时间块平均所用的帧数
  ` -nlevel <int> `         100 2D-XPixMaps中高度的水平数

  : 控制选项 {#tab-33}

## gmx dielectric: 计算频率相关的介电常数

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx dielectric [-f [<.xvg>]] [-d [<.xvg>]] [-o [<.xvg>]] [-c [<.xvg>]]
               [-nice ] [-b ] [-e ] [-dt ] [-[no]w]
               [-xvg ] [-[no]fft] [-[no]x1] [-eint ] [-bfit ]
               [-efit ] [-tail ] [-A ] [-tau1 ]
               [-tau2 ] [-eps0 ] [-epsRF ] [-fix ]
               [-ffn ] [-nsmooth ]
```
:::
:::

` gmx dielectric `{.language-plaintext .highlighter-rouge}
可以利用模拟得到的总偶极矩的自相关函数(ACF)计算频率依赖的介电常数.
ACF可由 ` gmx dipoles `{.language-plaintext .highlighter-rouge}
计算得到. 可使用的函数形式如下:

-   单参数: y = exp(-a_1 x)
-   双参数: y = a_2 exp(-a_1 x)
-   三参数: y = a_2 exp(-a_1 x) + (1 - a_2) exp(-a_3 x)

拟合的初始值可以在命令行中指定, 也可以使用 ` -fix `{.language-plaintext
.highlighter-rouge} 和参数编号将需要固定的参数的值固定为初始值.

程序会生成三个输出文件. 第一个文件中包含了ACF, 对ACF使用1, 2,
3个参数的指数拟合, 以及组合的数据/拟合的数值导数.
第二个文件中包含了频率依赖介电常数的实部和虚部.
最后一个文件给出了所谓的Cole-Cole图, 图中虚部是实部的函数.
对于一个纯指数弛豫(也称德拜弛豫), Cole-Cole图应该是个半圆.

  选项                     默认值 类型   说明
----------------- ------------- ------ ---------------
  ` -f [<.xvg>] `     dipcorr.xvg 输入   xvgr/xmgr文件
  ` -d [<.xvg>] `       deriv.xvg 输出   xvgr/xmgr文件
  ` -o [<.xvg>] `        epsw.xvg 输出   xvgr/xmgr文件
  ` -c [<.xvg>] `        cole.xvg 输出   xvgr/xmgr文件

  : 输入/输出文件选项 {#tab-34}

  选项                    默认值 说明
-------------------- --------- -------------------------------------------------------------------
  ` -nice <int> `             19 设置优先级
  ` -b <time> `                0 从轨迹文件中读取的第一帧(ps)
  ` -e <time> `                0 从轨迹文件中读取的最后一帧(ps)
  ` -dt <time> `               0 只使用t除以dt的余数等于第一帧时间(ps)的帧, 即两帧之间的时间间隔
  ` -[no]w `                  no 查看输出的.xvg, .xpm, .eps和.pdb文件
  ` -xvg <enum> `        xmgrace xvg绘图格式: xmgrace, xmgr, none
  ` -[no]fft `                no 使用快速傅里叶变换计算相关函数
  ` -[no]x1 `                yes 使用第一列作为X轴数据, 而不是使用第一个数据集
  ` -eint <real> `             5 终止数据积分并开始使用拟合的时间
  ` -bfit <real> `             5 拟合的起始时间
  ` -efit <real> `           500 拟合的终止时间
  ` -tail <real> `           500 函数的长度, 包括数据与拟合的尾部
  ` -A <real> `              0.5 拟合参数A的初始值
  ` -tau1 <real> `            10 拟合参数τ1的初始值
  ` -tau2 <real> `             1 拟合参数τ2的初始值
  ` -eps0 <real> `            80 液体的ε0
  ` -epsRF <real> `         78.5 模拟中使用的反应场的ε. 值为0表示无穷大.
  ` -fix <int> `               0 将参数固定为初始值, A (2), tau1 (1)或tau2 (4)
  ` -ffn <enum> `           none 拟合函数: none, exp, aexp, exp_exp, vac, exp5, exp7, exp9, erffit
  ` -nsmooth <int> `           3 用于平滑的点的个数

  : 控制选项 {#tab-35}

## gmx dipoles: 计算总偶极及其涨落

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx dipoles [-en [<.edr>]] [-f [<.xtc/.trr/...>]] [-s [<.tpr/.tpb/...>]]
            [-n [<.ndx>]] [-o [<.xvg>]] [-eps [<.xvg>]] [-a [<.xvg>]]
            [-d [<.xvg>]] [-c [<.xvg>]] [-g [<.xvg>]] [-adip [<.xvg>]]
            [-dip3d [<.xvg>]] [-cos [<.xvg>]] [-cmap [<.xpm>]]
            [-slab [<.xvg>]] [-nice ] [-b ] [-e ]
            [-dt ] [-[no]w] [-xvg ] [-mu ] [-mumax ]
            [-epsilonRF ] [-skip ] [-temp ] [-corr ]
            [-[no]pairs] [-[no]quad] [-ncos ] [-axis ]
            [-sl ] [-gkratom ] [-gkratom2 ] [-rcmax ]
            [-[no]phi] [-nlevels ] [-ndegrees ] [-acflen ]
            [-[no]normalize] [-P ] [-fitfn ] [-beginfit ]
            [-endfit ]
```
:::
:::

` gmx dipoles `{.language-plaintext .highlighter-rouge}
用于计算模拟体系的总偶极及其涨落. 利用这些数据, 你可以计算其他一些性质,
如低介电介质的介电常数. 对于具有净电荷的分子,
会在分子质心处减去分子的净电荷.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ --- ----------- ------- ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ` Mtot.xvg `{.language-plaintext .highlighter-rouge} 文件中包含了每帧的总偶极矩, 总偶极矩的分量以及大小. ` aver.xvg `{.language-plaintext .highlighter-rouge} 文件中包含了模拟过程中的\<   μ   \\\^2\>和   \<μ\>   \\\^2. ` dipdist.xvg `{.language-plaintext .highlighter-rouge} 文件包含了模拟过程中偶极矩的分布. ` -mumax `{.language-plaintext .highlighter-rouge} 的值是来统计分布图的最高值.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ --- ----------- ------- ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

而且, 如果使用了 ` -corr `{.language-plaintext .highlighter-rouge} 选项,
程序会计算偶极的自相关函数, 输出文件的名字可通过
` -c `{.language-plaintext .highlighter-rouge} 选项来指定.
相关函数可以对所有分子进行平均, 独立地绘制每个分子(
` molsep `{.language-plaintext .highlighter-rouge} )的分布,
或计算模拟盒子的总偶极矩( ` total `{.language-plaintext
.highlighter-rouge} ).

选项 ` -g `{.language-plaintext .highlighter-rouge}
可以给出依赖距离的Kirkwood G因子,
以及偶极夹角余弦平均值与距离的函数关系. 图中包括了gOO和hOO, 请参考Nymand
& Linse, *J. Chem. Phys.* 112 (2000) pp 6386-6395. 在同一图中,
还包括了每一尺度的能量, 它是偶极矩内积与距离三次方的商.

示例:
` gmx dipoles -corr mol -P 1 -o dip_sqr -mu 2.273 -mumax 5.0 `{.language-plaintext
.highlighter-rouge}

上面的命令将计算分子偶极矩的自相关函数,
计算时使用了偶极矩向量与其t时刻后的值之间的夹角的一阶Legendre多项式.
此计算将会使用1001帧. 更进一步, 可以计算
` -epsilonRF `{.language-plaintext .highlighter-rouge} 无穷大(默认),
温度300 K(默认), 分子平均偶极矩2.273(SPC)条件下的介电常数. 对分布函数,
其最大值被设定为5.0.

  选项                              默认值 类型         说明
-------------------------- ------------- ------------ ---------------------------------------
  ` -en [<.edr>] `                ener.edr 输入, 可选   能量文件
  ` -f [<.xtc/.trr/...>] `        traj.xtc 输入         轨迹: xtc trr cpt trj gro g96 pdb tng
  ` -s [<.tpr/.tpb/...>] `       topol.tpr 输入         运行输入文件: tpr tpb tpa
  ` -n [<.ndx>] `                index.ndx 输入, 可选   索引文件
  ` -o [<.xvg>] `                 Mtot.xvg 输出         xvgr/xmgr文件
  ` -eps [<.xvg>] `            epsilon.xvg 输出         xvgr/xmgr文件
  ` -a [<.xvg>] `                 aver.xvg 输出         xvgr/xmgr文件
  ` -d [<.xvg>] `              dipdist.xvg 输出         xvgr/xmgr文件
  ` -c [<.xvg>] `              dipcorr.xvg 输出, 可选   xvgr/xmgr文件
  ` -g [<.xvg>] `                  gkr.xvg 输出, 可选   xvgr/xmgr文件
  ` -adip [<.xvg>] `              adip.xvg 输出, 可选   xvgr/xmgr文件
  ` -dip3d [<.xvg>] `            dip3d.xvg 输出, 可选   xvgr/xmgr文件
  ` -cos [<.xvg>] `            cosaver.xvg 输出, 可选   xvgr/xmgr文件
  ` -cmap [<.xpm>] `              cmap.xpm 输出, 可选   X PixMap兼容的矩阵文件
  ` -slab [<.xvg>] `              slab.xvg 输出, 可选   xvgr/xmgr文件

  : 输入/输出文件选项 {#tab-36}

--------------------------------------------------------------------------------------------------------------
  选项                                     默认值 说明
----------------------- ----------------------- --------------------------------------------------------------
  ` -nice <int> `                              19 设置优先级

  ` -b <time> `                                 0 从轨迹文件中读取的第一帧(ps)

  ` -e <time> `                                 0 从轨迹文件中读取的最后一帧(ps)

  ` -dt <time> `                                0 只使用t除以dt的余数等于第一帧时间(ps)的帧,
                                                  即两帧之间的时间间隔

  ` -[no]w `                                   no 查看输出的.xvg, .xpm, .eps和.pdb文件

  ` -xvg <enum> `                         xmgrace xvg绘图格式: xmgrace, xmgr, none

  ` -mu <real> `                               -1 单个分子的偶极矩(单位Debye)

  ` -mumax <real> `                             5 以Debye为单位的最大偶极矩(用于直方图)

  ` -epsilonRF <real> `                         0 模拟中使用的反应场的ε值, 用于计算介电常数. 注意:
                                                  0.0代表无穷大(默认)

  ` -skip <int> `                               0 输出结果中跳过的步数(但计算中使用了所有步)

  ` -temp <real> `                            300 模拟的平均温度(用于计算介电常数)

  ` -corr <enum> `                           none 要计算的相关函数: none, mol, molsep, total

  ` -[no]pairs `                              yes 计算所有分子对的 \$\\vert \\cos(\\q)\\vert\$.
                                                  计算可能比较耗时.

  ` -[no]quad `                                no 考虑四极距

  ` -ncos <int> `                               1 该值只能为1或2, 决定了是计算同一组分子之间的\<cos(θ)\>,
                                                  还是计算不同组之间的\<cos(θ)\>.\
                                                  使用此选项会打开 ` -g ` 选项.

  ` -axis <string> `                            Z 计算盒子的法线沿X, Y或Z方向

  ` -sl <int> `                                10 将盒子划分成若干片.

  ` -gkratom <int> `                            0 计算依赖距离的Kirkwood因子时,
                                                  使用分子的第n个原子(从1开始)来计算分子间的距离,\
                                                  而不是使用电荷中心(此值取0时).

  ` -gkratom2 <int> `                           0 与上一选项相同, 但用于 ` -ncos 2 ` ,
                                                  即两组分子间的偶极相互作用

  ` -rcmax <real> `                             0 偶极取向分布中使用的最大距离(用于 ` - ncos 2 ` ). 如果为0,
                                                  将使用基于盒子长度的规则.

  ` -[no]phi `                                 no 将\'扭转角度\'输出至由 ` -cmap ` 选项指定的 ` .xpm ` 文件中,\
                                                  扭转角度定义为两个分子的偶极向量绕分子间距离向量的旋转角度.\
                                                  默认给出的是偶极矩夹角的余弦值.

  ` -nlevels <int> `                           20 颜色映射图输出中颜色的数目

  ` -ndegrees <int> `                          90 颜色映射图输出中Y轴的划分数(180度)

  ` -acflen <int> `                            -1 ACF的长度, 默认值为帧数的一半

  ` -[no]normalize `                          yes 归一化ACF

  ` -P <enum> `                                 0 ACF Legendre多项式的阶数(0表示不使用): 0, 1, 2, 3

  ` -fitfn <enum> `                          none 拟合函数: none, exp, aexp, exp_exp, vac, exp5, exp7, exp9,
                                                  erffit

  ` -beginfit <real> `                          0 对相关函数进行指数拟合的开始时间

  ` -endfit <real> `                           -1 对相关函数进行指数拟合的终止时间, -1代表直到结束
  --------------------------------------------------------------------------------------------------------------

  : 控制选项 {#tab-37}

## gmx disre: 分析距离限制

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx disre [-s [<.tpr/.tpb/...>]] [-f [<.xtc/.trr/...>]] [-ds [<.xvg>]]
          [-da [<.xvg>]] [-dn [<.xvg>]] [-dm [<.xvg>]] [-dr [<.xvg>]]
          [-l [<.log>]] [-n [<.ndx>]] [-q [<.pdb>]] [-c [<.ndx>]]
          [-x [<.xpm>]] [-nice ] [-b ] [-e ] [-dt ]
          [-[no]w] [-xvg ] [-ntop ] [-maxdr ]
          [-nlevels ] [-[no]third]
```
:::
:::

` gmx disre `{.language-plaintext .highlighter-rouge}
计算距离限制的方差. 如果需要, 可以使用
` gmx protonate `{.language-plaintext .highlighter-rouge}
程序将所有的质子添加到蛋白质分子中.

` gmx disre `{.language-plaintext .highlighter-rouge}
总是计算瞬时方差而不是时间平均的方差, 因为分析是根据轨迹文件进行的,
使用时间平均没有意义. 尽管如此,
每个限制的时间平均值还是都会输出在日志文件中.

为输出所选的特定限制, 可以使用索引文件.

当给定 ` -q `{.language-plaintext .highlighter-rouge} 选项时, 会输出
` .pdb `{.language-plaintext .highlighter-rouge} 文件,
并使用平均方差对其着色.

当给定 ` -c `{.language-plaintext .highlighter-rouge} 选项时,
程序将读取一个索引文件,
其中包含了轨迹中与你要分析的团簇(以另一种方式定义)相应的帧. 对这些团簇,
程序将使用三次平均算法来计算平均方差, 并将其输出在日志文件中.

  选项                             默认值 类型         说明
-------------------------- ------------ ------------ ---------------------------------------
  ` -s [<.tpr/.tpb/...>] `      topol.tpr 输入         运行输入文件: tpr tpb tpa
  ` -f [<.xtc/.trr/...>] `       traj.xtc 输入         轨迹: xtc trr cpt trj gro g96 pdb tng
  ` -ds [<.xvg>] `              drsum.xvg 输出         xvgr/xmgr文件
  ` -da [<.xvg>] `             draver.xvg 输出         xvgr/xmgr文件
  ` -dn [<.xvg>] `              drnum.xvg 输出         xvgr/xmgr文件
  ` -dm [<.xvg>] `              drmax.xvg 输出         xvgr/xmgr文件
  ` -dr [<.xvg>] `              restr.xvg 输出         xvgr/xmgr文件
  ` -l [<.log>] `              disres.log 输出         日志文件
  ` -n [<.ndx>] `                viol.ndx 输入, 可选   索引文件
  ` -q [<.pdb>] `                viol.pdb 输出, 可选   蛋白质数据库文件
  ` -c [<.ndx>] `               clust.ndx 输入, 可选   索引文件
  ` -x [<.xpm>] `              matrix.xpm 输出, 可选   X PixMap兼容的矩阵文件

  : 输入/输出文件选项 {#tab-38}

  选项                    默认值 说明
-------------------- --------- --------------------------------------------------------------------
  ` -nice <int> `             19 设置优先级
  ` -b <time> `                0 从轨迹文件中读取的第一帧(ps)
  ` -e <time> `                0 从轨迹文件中读取的最后一帧(ps)
  ` -dt <time> `               0 只使用t除以dt的余数等于第一帧时间(ps)的帧, 即两帧之间的时间间隔
  ` -[no]w `                  no 查看输出.xvg, .xpm, .eps和.pdb文件
  ` -xvg <enum> `        xmgrace xvg绘图格式: xmgrace, xmgr, none
  ` -ntop <int> `              0 每步存储在日志文件中的较大方差的数目
  ` -maxdr <real> `            0 输出矩阵中最大的距离方差. 如果此值小于等于0, 将根据数据确定最大值.
  ` -nlevels <int> `          20 输出矩阵的水平数
  ` -[no]third `             yes 对输出矩阵使用立方反比平均或线性平均

  : 控制选项 {#tab-39}

## gmx distance: 计算两个位置之间的距离

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx distance [-f [<.xtc/.trr/...>]] [-s [<.tpr/.tpb/...>]] [-n [<.ndx>]]
             [-oav [<.xvg>]] [-oall [<.xvg>]] [-oxyz [<.xvg>]] [-oh [<.xvg>]]
             [-oallstat [<.xvg>]] [-b ] [-e ] [-dt ]
             [-tu ] [-xvg ] [-[no]rmpbc] [-[no]pbc] [-sf ]
             [-selrpos ] [-select ] [-len ]
             [-tol ] [-binw ]
```
:::
:::

` gmx distance `{.language-plaintext .highlighter-rouge}
计算一对位置间的距离随时间变化的函数. 每个选择指定要计算的一组独立距离.
每个选择应包括位置对, 要计算的, 如位置1-2, 3-4等之间的距离.

` -oav `{.language-plaintext .highlighter-rouge}
记录下每个选择的平均距离随时间变化的函数. ` -oall `{.language-plaintext
.highlighter-rouge} 记录下所有独立的间距随时间变化的函数;
` -oxyz `{.language-plaintext .highlighter-rouge}
也是记录所有独立的间距, 但会记录距离的x, y, z分量而不是距离向量的大小.
` -oh `{.language-plaintext .highlighter-rouge}
记录每个选择的距离的直方图, 直方图的位置由 ` -len `{.language-plaintext
.highlighter-rouge} 和 ` –tol `{.language-plaintext .highlighter-rouge}
来进行设置, 分格的宽度由 ` -binw `{.language-plaintext
.highlighter-rouge} 设置. ` -oallstat `{.language-plaintext
.highlighter-rouge} 记录下所有帧的每个单独距离的平均值和标准偏差.

  选项                                  默认值 类型         说明
---------------------------- --------------- ------------ -----------------------------------------------------
  ` -f [<. xtc/. trr/...>] `         traj. xtc 输入, 可选   输入轨迹或单个构型: xtc trr cpt trj gro g96 pdb tng
  ` -s [<. tpr/. tpb/...>] `        topol. tpr 输入, 可选   输入结构: tpr tpb tpa gro g96 pdb brk ent
  ` -n [<. ndx>] `                  index. ndx 输入, 可选   额外的索引组
  ` -oav [<. xvg>] `              distave. xvg 输出, 可选   平均距离随时间变化的函数
  ` -oall [<. xvg>] `                dist. xvg 输出, 可选   间距随时间变化的函数
  ` -oxyz [<. xvg>] `             distxyz. xvg 输出, 可选   间距(在x y z 方向上的分量)随时间变化的函数
  ` -oh [<. xvg>] `              disthist. xvg 输出, 可选   距离的直方图
  ` -oallstat [<. xvg>] `        diststat. xvg 输出, 可选   独立距离的统计

  : 输入/输出文件选项 {#tab-40}

----------------------------------------------------------------------------------------------
  选项                                       默认值 说明
------------------------- ----------------------- --------------------------------------------
  ` -b <time> `                                   0 从轨迹文件中读取的第一帧(ps)

  ` -e <time> `                                   0 从轨迹文件中读取的最后一帧(ps)

  ` -dt <time> `                                  0 只使用t除以dt的余数等于第一帧时间(ps)的帧,
                                                    即两帧之间的时间间隔

  ` -tu <enum> `                                 ps 时间的单位: fs, ps, ns, us, ms, s

  ` -xvg <enum> `                           xmgrace 绘制的格式: none, xmgrace, xmgr

  ` -[no]rmpbc `                                yes 每一帧使用所有分子

  ` -[no]pbc `                                  yes 使用周期性边界条件计算距离

  ` -sf <file> `                                    从文件中提供选择

  ` -selrpos <enum> `                          atom 选择参考的位置: atom, res_com, res_cog,
                                                    mol_com, mol_cog,\
                                                    whole_res_com, whole_res_cog, whole_mol_com,
                                                    whole_mol_cog,\
                                                    part_res_com, part_res_cog, part_mol_com,
                                                    part_mol_cog,\
                                                    dyn_res_com, dyn_res_cog, dyn_mol_com,
                                                    dyn_mol_cog

  ` -select <selection> `                           计算距离对的位置

  ` -len <real> `                               0.1 直方图的平均距离

  ` -tol <real> `                                 1 直方图分布的宽度关于 ` -len ` 的函数.

  ` -binw <real> `                            0.001 直方图单元格的宽度
  ----------------------------------------------------------------------------------------------

  : 控制选项 {#tab-41}

### 补充说明

~~可以使用 ` gmx distance `{.language-plaintext .highlighter-rouge}
提取两个原子间的距离随时间的变化, 需要一个索引文件, 其写法是,
在里面加入两个组, 内容分别是这两个原子序号, 再运行
` gmx distance -f file.xtc -s file.tpr -n index.ndx `{.language-plaintext
.highlighter-rouge} 会提示选择组, 分别选择那两个组即可. 计算结果输出在
` dist.xvg `{.language-plaintext .highlighter-rouge} 文件中,
其中第二列是距离, 后面三列是距离的x/y/z分量.~~

上述为旧版本说明, 新版本使用方法见
[GROMACS计算距离的方法及注意点](https://jerkwin.github.io/2018/01/14/GROMACS%E8%AE%A1%E7%AE%97%E8%B7%9D%E7%A6%BB%E7%9A%84%E6%96%B9%E6%B3%95%E5%8F%8A%E6%B3%A8%E6%84%8F%E7%82%B9/)

## gmx do_dssp: 指定二级结构并计算溶剂可及表面积

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx do_dssp [-f [<.xtc/.trr/...>]] [-s [<.tpr/.tpb/...>]] [-n [<.ndx>]]
            [-ssdump [<.dat>]] [-map [<.map>]] [-o [<.xpm>]] [-sc [<.xvg>]]
            [-a [<.xpm>]] [-ta [<.xvg>]] [-aa [<.xvg>]] [-nice ]
            [-b ] [-e ] [-dt ] [-tu ] [-[no]w]
            [-xvg ] [-sss ] [-ver ]
```
:::
:::

` gmx do_dssp `{.language-plaintext .highlighter-rouge} 读取轨迹文件,
并调用第三方程序dssp计算每一时间帧蛋白质的二级结构信息.
如果你还没有安装dssp程序, 可以在这里获得:
<http://swift.cmbi.ru.nl/gv/dssp> . ` gmx do_dssp `{.language-plaintext
.highlighter-rouge} 假定dssp可执行程序的路径为
` /usr/local/bin/dssp `{.language-plaintext .highlighter-rouge} .
如果不是, 那么需要设置环境变量 ` DSSP `{.language-plaintext
.highlighter-rouge} , 并将其指向dssp可执行程序的路径, 例如
` setenv DSSP /opt/dssp/bin/dssp `{.language-plaintext
.highlighter-rouge} . 如果使用bash, 可使用
` export DSSP='/opt/dssp/bin/dssp' `{.language-plaintext
.highlighter-rouge} , 也可以直接将该变量加到bash的配置文件中.

自2.0.0版本起, dssp的语法不同于之前的版本.
如果你正在使用旧版本的dssp程序, 可用选项 ` -ver `{.language-plaintext
.highlighter-rouge} 指示 ` do_dssp `{.language-plaintext
.highlighter-rouge} 使用旧的语法. 默认情况下,
` do_dssp `{.language-plaintext .highlighter-rouge}
使用2.0.0版本引入的语法.
即使更新的版本(编写此文档时尚未发布)也被假定与2.0.0版本使用同样的语法.

程序会将每一残基每一时间帧的二级结构写入一个
` .xpm `{.language-plaintext .highlighter-rouge} 矩阵文件.
该文件实际上是一个文本文件, 可以用文本编辑器打开.
文件中用不同字符表示蛋白质每一残基属于何种二级结构, 并随时间变化,
同时定义了每个字符的颜色. 这一文件可使用 ` xv `{.language-plaintext
.highlighter-rouge} 之类的程序可视化, 也可使用
` xpm2ps `{.language-plaintext .highlighter-rouge} 转换为PostScript格式,
扩展名为 ` .eps `{.language-plaintext .highlighter-rouge} ,
这样就可以直接打开或用到Latex文件中. 在 ` .xpm `{.language-plaintext
.highlighter-rouge} 和PostScript文件中, 每个链以浅灰线分割开.

程序可以统计每个二级结构类型的残基数目和总的二级结构类型数(
` -sss `{.language-plaintext .highlighter-rouge} ),
并将统计结果随时间的变化写入文件中( ` -sc `{.language-plaintext
.highlighter-rouge} ). 输出文件中包含了所有不同二级结构的氨基酸残基数目,
可以用xmgrace的 ` -nxy `{.language-plaintext .highlighter-rouge}
选项打开.

程序可以计算每个残基的溶剂可及表面积(SAS, Solvent Accesible Surface),
包括绝对值(Å\^2\^)和相对于残基最大可及表面积的比例.
残基的最大可及表面积定义为该残基在甘氨酸链中的可及表面积. **注意** ,
` gmx sas `{.language-plaintext .highlighter-rouge}
程序也可用于计算SAS且更简单高效.

最后, 这个程序可以将二级结构信息转存在一个特殊的文件
` ssdump.dat `{.language-plaintext .highlighter-rouge}
中(此文件为文本文件, 里面用字符代表残基的二级结构类型, 如H表示螺旋,
B表示折叠等), 以供 ` gmx chi `{.language-plaintext .highlighter-rouge}
程序使用. 将这两个程序结合起来,
就可以分析残基二面角性质与二级结构类型的关系.

---------------------------------------------------------------------------------------------------------
  选项                                  默认值 类型              说明
-------------------------- ----------------- ----------------- ------------------------------------------
  ` -f [<.xtc/.trr/...>] `            traj.xtc 输入              轨迹: xtc trr cpt trj gro g96 pdb tng

  ` -s [<.tpr/.tpb/...>] `           topol.tpr 输入              结构+质量(db): tpr tpb tpa gro g96 pdb brk
                                                                 ent

  ` -n [<.ndx>] `                    index.ndx 输入, 可选        索引文件

  ` -ssdump [<.dat>] `              ssdump.dat 输出, 可选        通用数据文件

  ` - map [<.map>] `                    ss.map 输入, 库          矩阵数据到颜色的映射文件.\
                                                                 程序输出 ` .xpm ` 文件的原色库文件,
                                                                 如无则默认输出

  ` -o [<.xpm>] `                       ss.xpm 输出              X PixMap兼容的矩阵文件.\
                                                                 各个残基属于某二级结构的信息并随时间变化

  ` -sc [<.xvg>] `                  scount.xvg 输出              xvgr/xmgr文件\
                                                                 统计某二级结构的残基数目

  ` -a [<.xpm>] `                     area.xpm 输出, 可选        X PixMap兼容的矩阵文件\
                                                                 各残基的溶剂可及表面积

  ` -ta [<.xvg>] `                 totarea.xvg 输出, 可选        xvgr/xmgr文件\
                                                                 总溶剂可及表面积, 包括疏水和亲水表面积

  ` -aa [<.xvg>] `                averarea.xvg 输出, 可选        xvgr/xmgr文件\
                                                                 平均溶剂可及表面积
  ---------------------------------------------------------------------------------------------------------

  : 输入/输出文件选项 {#tab-42}

  选项                    默认值 说明
-------------------- --------- -----------------------------------------------------------------
  ` -nice <int> `             19 设置优先级
  ` -b <time> `                0 从轨迹文件中读取的第一帧(ps)
  ` -e <time> `                0 从轨迹文件中读取的最后一帧(ps)
  ` -dt <time> `               0 只使用t除以dt的余数等于第一帧时间(ps)的帧, 即两帧之间的时间间隔
  ` -tu <enum> `              ps 时间单位: fs, ps, ns, us, ms, s
  ` -[no] `                   no 程序运行结束查看输出文件: .xvg, .xpm, .eps和.pdb
  ` -xvg <enum> `        xmgrace xvg绘图格式: xmgrace, xmgr, none
  ` -sss <string> `         HEBT 用于数算结构的二级结构
  ` -sss ver <int> `           2 DSSP主版本号. 自2.0版本开始语法发生变化.

  : 控制选项 {#tab-43}

## gmx dos: 分析态密度及相关性质

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx dos [-f [<.trr/.cpt/...>]] [-s [<.tpr/.tpb/...>]] [-n [<.ndx>]]
        [-vacf [<.xvg>]] [-mvacf [<.xvg>]] [-dos [<.xvg>]] [-g [<.log>]]
        [-nice ] [-b ] [-e ] [-dt ] [-[no]w]
        [-xvg ] [-[no]v] [-[no]recip] [-[no]abs] [-[no]normdos]
        [-T ] [-acflen ] [-[no]normalize] [-P ]
        [-fitfn ] [-beginfit ] [-endfit ]
```
:::
:::

` gmx dos `{.language-plaintext .highlighter-rouge} 根据模拟计算态密度.
为使计算结果有意义, 必须使用足够高的频率来保存轨迹中的速度,
这样才能包含所有的振动. 对于柔性体系, 保存轨迹的时间间隔大约是几飞秒.
程序会将基于DoS的性质在打印在标准输出.

  选项                            默认值 类型         说明
-------------------------- ----------- ------------ -----------------------------
  ` -f [<.trr/.cpt/...>] `      traj.trr 输入         全精度轨迹: trr cpt trj tng
  ` -s [<.tpr/.tpb/...>] `     topol.tpr 输入         运行输入文件: tpr tpb tpa
  ` -n [<.ndx>] `              index.ndx 输入, 可选   索引文件
  ` -vacf [<.xvg>] `            vacf.xvg 输出         xvgr/xmgr文件
  ` -mvacf [<.xvg>] `          mvacf.xvg 输出         xvgr/xmgr文件
  ` -dos [<.xvg>] `              dos.xvg 输出         xvgr/xmgr文件
  ` -g [<.log>] `                dos.log 输出         日志文件

  : 输入/输出文件选项 {#tab-44}

  选项                      默认值 说明
---------------------- --------- -------------------------------------------------------------------
  ` -nice <int> `               19 设置优先级
  ` -b <time> `                  0 从轨迹文件中读取的第一帧(ps)
  ` -e <time> `                  0 从轨迹文件中读取的最后一帧(ps)
  ` -dt <time> `                 0 只使用t除以dt的余数等于第一帧时间(ps)的帧, 即两帧之间的时间间隔
  ` -[no]w `                    no 查看输出的.xvg, .xpm, .eps和.pdb文件
  ` -xvg <enum> `          xmgrace xvg绘图格式: xmgrace, xmgr, none
  ` -[no]v `                   yes 显示更多信息
  ` -[no]recip `                no 绘制DoS图时, X轴使用cm\^-1而不是1/ps
  ` -[no]abs `                  no 使用VACF傅里叶变换的绝对值作为态密度. 默认仅仅使用实部.
  ` -[no]normdos `              no 对DoS进行归一化以便其累加和等于3N. 这并不时一个必要的选项.
  ` -T <real> `             298.15 模拟温度
  ` -acflen <int> `             -1 ACF的长度, 默认为帧数的一半
  ` -[no]normalize `           yes 归一化ACF
  ` -P <enum> `                  0 ACF勒让德多项式的级数(0表示无): 0, 1, 2, 3
  ` -fitfn <enum> `           none 拟合函数: none, exp, aexp, exp_exp, vac, exp5, exp7, exp9, erffit
  ` -beginfit <real> `           0 对相关函数进行指数拟合的起始时间
  ` -endfit <real> `            -1 对相关函数进行指数拟合的终止时间, -1表示直至最后

  : 控制选项 {#tab-45}

### 已知问题

-   此程序运行时需要大量内存:
    总使用量等于原子数乘以3乘以帧数再乘以4(或8, 当使用双精度时)

## gmx dump: 生成人类可读的二进制文件

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx dump [-s [<.tpr/.tpb/...>]] [-f [<.xtc/.trr/...>]] [-e [<.edr>]]
         [-cp [<.cpt>]] [-p [<.top>]] [-mtx [<.mtx>]] [-om [<.mdp>]]
         [-nice ] [-[no]nr] [-[no]sys]
```
:::
:::

` gmx dump `{.language-plaintext .highlighter-rouge}
读取一个运行输入文件( ` .tpa `{.language-plaintext .highlighter-rouge} /
` .tpr `{.language-plaintext .highlighter-rouge} /
` .tpb `{.language-plaintext .highlighter-rouge} ), 轨迹文件(
` .trj `{.language-plaintext .highlighter-rouge} /
` .trr `{.language-plaintext .highlighter-rouge} /
` .xtc `{.language-plaintext .highlighter-rouge} ), 能量文件(
` .ene `{.language-plaintext .highlighter-rouge} /
` .edr `{.language-plaintext .highlighter-rouge} ), 或检查点文件(
` .cpt `{.language-plaintext .highlighter-rouge} ),
而后将其以可读格式打印到标准输出. 在检查运行输入文件是否有误时,
此程序至关重要.

此程序也能预处理拓扑文件以此帮助发现问题. 注意,
目前定制包含文件搜索目录的唯一方法是设置 ` GMXLIB `{.language-plaintext
.highlighter-rouge} .

  选项                              默认值 类型         说明
-------------------------- ------------- ------------ -------------------------------------------
  ` -s [<.tpr/.tpb/...>] `       topol.tpr 输入, 可选   运行输入文件: tpr tpb tpa
  ` -f [<.xtc/.trr/...>] `        traj.xtc 输入, 可选   轨迹文件: xtc trr cpt trj gro g96 pdb tng
  ` -e [<.edr>] `                 ener.edr 输入, 可选   能量文件
  ` -cp [<.cpt>] `               state.cpt 输入, 可选   检查点文件
  ` -p [<.top>] `                topol.top 输入, 可选   拓扑文件
  ` -mtx [<.mtx>] `            hessian.mtx 输入, 可选   海森矩阵
  ` -om [<.mdp>] `              grompp.mdp 输出, 可选   含有MD参数的grompp输入文件

  : 输入/输出文件选项 {#tab-46}

  选项                默认值 说明
----------------- -------- -------------------------------------------------------------
  ` -nice <int> `          0 设置优先级
  ` -[no]nr `            yes 在输出中显示索引编号(忽略这些更容易比较, 但创建的拓扑无用)
  ` -[no]sys `            no 列出整个体系的原子与键合相互作用, 而不是列出每个分子类型的.

  : 控制选项 {#tab-47}

### 已知问题：

-   来自 ` -sys -s `{.language-plaintext .highlighter-rouge}
    的位置限制输出会中断.

## gmx dyecoupl: 从轨迹中抽取染料动力学

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx dyecoupl [-f [<.xtc/.trr/...>]] [-n [<.ndx>]] [-ot [<.xvg>]]
             [-oe [<.xvg>]] [-o [<.dat>]] [-rhist [<.xvg>]] [-khist [<.xvg>]]
             [-nice ] [-b ] [-e ] [-tu ] [-[no]w]
             [-xvg ] [-[no]pbcdist] [-[no]norm] [-bins ]
             [-R0 ]
```
:::
:::

` gmx dyecoupl `{.language-plaintext .highlighter-rouge}
用于从轨迹文件中抽取染料动力学. 目前, 可抽取染料分子间的R和kappa\^2,
用于假定偶极耦合遵从Foerster方程的(F)RET模拟. 进一步,
程序也可计算R(t)和kappa\^2(t), R和kappa\^2\^的直方图与平均,
以及指定Foerster半径R_0( ` -R0 `{.language-plaintext .highlighter-rouge}
选项)的瞬时FRET效率E(t). 输入染料分子必须是完整的(参看
` gmx trjconv `{.language-plaintext .highlighter-rouge} 的
` res `{.language-plaintext .highlighter-rouge} 和
` mol pbc `{.language-plaintext .highlighter-rouge} 选项).
染料的转移偶极矩至少要使用一个原子对进行定义,
但也可使用索引文件提供的多个原子对. 距离R基于给定原子对的COM进行计算.
` -pbcdist `{.language-plaintext .highlighter-rouge}
选项指定计算到最近周期映象的距离, 而不是盒子内的距离,
但这仅适用于具有3维周期性边界的情况. ` -norm `{.language-plaintext
.highlighter-rouge} 选项用于(面积)归一化直方图.

  选项                              默认值 类型         说明
-------------------------- ------------- ------------ ---------------------------------------
  ` -f [<.xtc/.trr/...>] `        traj.xtc 输入         轨迹: xtc trr cpt trj gro g96 pdb tng
  ` -n [<.ndx>] `                index.ndx 输入         索引文件
  ` -ot [<.xvg>] `              rkappa.xvg 输出, 可选   xvgr/xmgr文件
  ` -oe [<.xvg>] `             insteff.xvg 输出, 可选   xvgr/xmgr文件
  ` -o [<.dat>] `               rkappa.dat 输出, 可选   通用数据文件
  ` -rhist [<.xvg>] `            rhist.xvg 输出, 可选   xvgr/xmgr文件
  ` -khist [<.xvg>] `            khist.xvg 输出, 可选   xvgr/xmgr文件

  : 输入/输出文件选项 {#tab-48}

  选项                  默认值 说明
------------------ --------- --------------------------------------------------
  ` -nice <int> `           19 设置优先级
  ` -b <time> `              0 从轨迹文件中读取的第一帧(ps)
  ` -e <time> `              0 从轨迹文件中读取的最后一帧(ps)
  ` -tu <enum> `            ps 时间单位: fs, ps, ns, us, ms, s
  ` -[no] `                 no 程序运行结束查看输出文件: .xvg, .xpm, .eps和.pdb
  ` -xvg <enum> `      xmgrace xvg绘图格式: xmgrace, xmgr, none
  ` -[no]pbcdist `          no 基于PBC的距离R
  ` -[no]norm `             no 归一化直方图
  ` -bins <int> `           50 直方图的分格数目
  ` -R0 <real> `            -1 包含kappa\^2\^=2/3的Foerster半径, 单位nm

  : 控制选项 {#tab-49}

## gmx dyndom: 结构旋转的内插和外推

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx dyndom [-f [<.pdb>]] [-o [<.xtc/.trr/...>]] [-n [<.ndx>]] [-nice ]
           [-firstangle ] [-lastangle ] [-nframe ]
           [-maxangle ] [-trans ] [-head ]
           [-tail ]
```
:::
:::

` gmx dyndom `{.language-plaintext .highlighter-rouge} 读取DynDom程序(
<http://www.cmp.uea.ac.uk/dyndom/> )输出的 ` .pdb `{.language-plaintext
.highlighter-rouge} 文件. 它会读取坐标,
旋转轴的坐标以及包含分区的索引文件. 而且,
它把矢量文件的第一个和最后一个原子当作命令行参数(头和尾),
最终得到平移矢量(DynDom的info文件给出)和旋转角度(也当作命令行参数).
如果给出了DynDom确定的角度,
你应该能够恢复用于生成DynDom输出文件的二级结构. 由于数值精度的限制,
需要通过计算所有原子的RMSD( ` gmx confrms `{.language-plaintext
.highlighter-rouge} )而不是文件对比(使用 ` diff `{.language-plaintext
.highlighter-rouge} )来进行确认.

此程序的目的是对DynDom揭示的旋转进行内插和外推. 所以,
可能会产生含有过长或过短键的不现实结构, 或者原子会重叠在一起. 因此,
可能需要查看结构和并进行能量优化以验证结构.

  选项                              默认值 类型   说明
-------------------------- ------------- ------ ---------------------------------------
  ` -f [<.pdb>] `               dyndom.pdb 输入   蛋白质数据库文件
  ` -o [<.xtc/.trr/...>] `     rotated.xtc 输出   轨迹文件: xtc trr trj gro g96 pdb tng
  ` -n [<.ndx>] `              domains.ndx 输入   索引文件

  : 输入/输出文件选项 {#tab-50}

  选项                       默认值 说明
------------------------ -------- ------------------------------------------------
  ` -nice <int> `                 0 设置优先级
  ` -firstangle <real> `          0 绕旋转矢量的旋转角度
  ` -lastangle <real> `           0 绕旋转矢量的旋转角度
  ` -nframe <int> `              11 途径上的步数
  ` -maxangle <real> `            0 DymDom确定的绕旋转矢量的旋转角度
  ` -trans <real> `               0 沿旋转矢量的平移量(单位: 埃) (参看DynDom info)
  ` -head <vector> `          0 0 0 矢量的第一个原子
  ` -tail <vector> `          0 0 0 矢量的最后一个原子

  : 控制选项 {#tab-51}

## gmx editconf: 编辑模拟盒子以及转换和操控结构文件

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx editconf [-f [<.gro/.g96/...>]] [-n [<.ndx>]] [-o [<.gro/.g96/...>]]
             [-mead [<.pqr>]] [-bf [<.dat>]] [-nice ] [-[no]w]
             [-[no]ndef] [-bt ] [-box ] [-angles ]
             [-d ] [-[no]c] [-center ] [-aligncenter ]
             [-align ] [-translate ] [-rotate ]
             [-[no]princ] [-scale ] [-density ] [-[no]pbc]
             [-resnr ] [-[no]grasp] [-rvdw ] [-[no]sig56]
             [-[no]vdwread] [-[no]atom] [-[no]legend] [-label ]
             [-[no]conect]
```
:::
:::

` gmx editconf `{.language-plaintext .highlighter-rouge}
的主要功能是对体系结构进行编辑, 也可以将通用结构格式保存或转换为
` .gro `{.language-plaintext .highlighter-rouge} ,
` .g96 `{.language-plaintext .highlighter-rouge} 或
` .pdb `{.language-plaintext .highlighter-rouge} 等其他格式.

在分子动力学模拟中, 通常会给体系添加一个周期性的模拟盒子.
` gmx editconf `{.language-plaintext .highlighter-rouge}
有许多控制盒子的选项.

利用选项 ` -box `{.language-plaintext .highlighter-rouge} ,
` -d `{.language-plaintext .highlighter-rouge} 和
` -angles `{.language-plaintext .highlighter-rouge} 可以对盒子进行修改.
除非明确使用了 ` -noc `{.language-plaintext .highlighter-rouge} 选项,
` -box `{.language-plaintext .highlighter-rouge} 和
` -d `{.language-plaintext .highlighter-rouge} 都可以使体系在盒子内居中.

选项 ` -bt `{.language-plaintext .highlighter-rouge} 设定盒子类型:
` triclinic `{.language-plaintext .highlighter-rouge} 为三斜盒子,
` cubic `{.language-plaintext .highlighter-rouge}
为所有边长都相等的长方体盒子(即立方体盒子),
` dodecahedron `{.language-plaintext .highlighter-rouge}
代表菱形十二面体盒子(等边十二面体), ` octahedron `{.language-plaintext
.highlighter-rouge}
为截角八面体盒子(即将两个底面重合的四面体切去方向相反的两头,
同时保证所有的边长相等). 后面两种盒子是三斜盒子的特殊情况.
截角八面体三个盒向量的长度是两个相对六边形之间的最短距离.
相对于具有周期性映象距离的立方盒子,
具有相同周期距离的菱形十二面体盒子的体积是立方盒子的71%,
而截角八面体盒子的体积是立方盒子的77%.

对一般的三斜盒子, ` -box `{.language-plaintext .highlighter-rouge}
的参数是三个实数, 为长方体的边长. 对于立方盒子,
菱形十二面体盒子或者截面八面体盒子, 选项 ` -box `{.language-plaintext
.highlighter-rouge} 只需要提供一个数值, 即盒子边长.

` -d `{.language-plaintext .highlighter-rouge}
选项指定体系中的原子到盒子编边界的最小距离. 使用
` -d `{.language-plaintext .highlighter-rouge} 选项时,
对三斜盒子会使用体系在x, y和z方向的大小, 对立方盒子,
菱形十二面体盒子或截角八面体盒子,
盒子的大小被设定为体系直径(原子间的最大距离)加上两倍的指定距离.

选项 ` -angles `{.language-plaintext .highlighter-rouge} 只能与选项
` -box `{.language-plaintext .highlighter-rouge}
和三斜盒子一起使用才有意义, 而且不能和选项 ` -d `{.language-plaintext
.highlighter-rouge} 一起使用.

当使用 ` -n `{.language-plaintext .highlighter-rouge} 或
` -ndef `{.language-plaintext .highlighter-rouge} 时,
可以指定一个索引文件, 并选择其中的一个组来计算大小和几何中心,
否则会使用整个体系的大小和几何中心.

` -rotate `{.language-plaintext .highlighter-rouge}
选项可以对坐标和速度进行旋转. 如 ` -rotate 0 30 0 `{.language-plaintext
.highlighter-rouge} 表示将体系绕Y轴沿顺时针方向旋转30度.

` -princ `{.language-plaintext .highlighter-rouge}
选项将体系(或体系某一部分)的主轴与坐标轴平齐, 并且最长的轴沿x轴方向.
这可以减小盒子的体积, 特别当分子为长条形时.
但是注意分子在纳秒的时间尺度内可能发生明显的旋转, 所以使用时要小心.

缩放会在任何其他操作之前进行.
可以对盒子和坐标进行缩放以得到一定的密度(选项
` -density `{.language-plaintext .highlighter-rouge} ). 注意如果输入是
` .gro `{.language-plaintext .highlighter-rouge} 文件的话,
密度可能不够精确. ` -scale `{.language-plaintext .highlighter-rouge}
选项的一个特性是, 当某一维度的缩放因子为-1时,
可以得到体系相对于一个平面的镜面映象. 当三个维度的缩放因子都是-1时,
可以获得体系相对于坐标原点的对称映象.

组的选择是在其他所有操作都完成之后进行的. 在程序输出时,
可以只输出体系中的某一个组, 或者某一个部分,
还可以建立划分更细致的索引文件, 以便进行更加细致的选择.

可以粗略地去除体系的周期性. 当去除周期性时,
输入文件最底部的盒向量必须保证正确, 这非常重要, 因为
` gmx editconf `{.language-plaintext .highlighter-rouge}
去除周期性的算法十分简单, 只是将原子坐标直接减去盒子边长.

当输出 ` .pdb `{.language-plaintext .highlighter-rouge} 文件时, 可以使用
` -bf `{.language-plaintext .highlighter-rouge} 选项添加B因子.
B因子可以从文件中读取, 格式如下: 第一行声明文件中所含B因子数值的个数,
从第二行开始, 每行声明一个索引号, 后面跟着B因子. 默认情况下,
B因子将附加到每个残基上, 每个残基一个数值,
除非索引大于残基数目或者设定了 ` -atom `{.language-plaintext
.highlighter-rouge} 选项. 显然,
可以添加任何类型的数值数据而不仅仅是B因子.
` -legend `{.language-plaintext .highlighter-rouge}
选项将生成一列CA原子, 其B因子的范围为所用数据的最小值到最大值,
可以有效地作为查看的图例, 便于可视化软件显示.

使用 ` -mead `{.language-plaintext .highlighter-rouge}
选项时可以生成一个特殊的 ` .pdb `{.language-plaintext
.highlighter-rouge} 文件( ` .pqr `{.language-plaintext
.highlighter-rouge} ), 它可用于MEAD静电程序(泊松玻尔兹曼方程求解器).
使用这个选项的前提条件是输入文件必须为运行输入文件(如tpr),
因为这样的文件中才包含了力场参数.
输出文件中的B因子段为原子的范德华半径而占有率段为原子的电荷.

` -grasp `{.language-plaintext .highlighter-rouge}
选项的作用与上一选项类似, 只不过互换了电荷与半径的位置, 电荷位于B因子段,
而半径位于占有率段.

选项 ` -align `{.language-plaintext .highlighter-rouge}
可以将特定组的主轴与给定的向量平齐, ` -aligncenter `{.language-plaintext
.highlighter-rouge} 选项指定可选的旋转中心.

最后, 使用选项 ` -label `{.language-plaintext .highlighter-rouge} ,
` gmx editconf `{.language-plaintext .highlighter-rouge} 可以为
` .pdb `{.language-plaintext .highlighter-rouge} 文件添加一个链标识符.
如果一个文件中不同残基属于不同肽链, 那么这个选项可以为残基指定肽链归属,
这样不但有利于可视化, 在使用一些程序如Rasmol进行分析时也很有帮助,
在建立模拟体系时也十分方便.

对一些软件包(如GROMOS), 会使用对立方盒子进行角截断的方法生成截角八面体,
为转换这种截角八面体文件, 可使用以下命令:

` gmx editconf -f in -rotate 0 45 35.264 -bt o -box veclen -o out `{.language-plaintext
.highlighter-rouge}

其中 ` veclen `{.language-plaintext .highlighter-rouge}
是立方盒子大小乘以sqrt(3)/2.

  选项                            默认值 类型         说明
-------------------------- ----------- ------------ ----------------------------------------------------------------
  ` -f [<.gro/.g96/...>] `      conf.gro 输入         结构文件: gro g96 pdb brk ent esp tpr tpb tpa
  ` -n [<.ndx>] `              index.ndx 输入, 可选   索引文件
  ` -o [<.gro/.g96/...>] `       out.gro 输出, 可选   结构文件: gro g96 pdb brk ent esp. 放进盒子里面的分子坐标文件.
  ` -mead [<.pqr>] `            mead.pqr 输出, 可选   用于MEAD的坐标文件
  ` -bf [<.dat>] `             bfact.dat 输入, 可选   通用数据文件

  : 输入/输出文件选项 {#tab-52}

-----------------------------------------------------------------------------------------------------------------------------
  选项                                         默认值 说明
--------------------------- ----------------------- -------------------------------------------------------------------------
  ` -nice <int> `                                   0 设置优先级

  ` -[no]w `                                       no 程序结束自动打开输出的.xvg, .xpm, .eps和.pdb文件

  ` -[no]ndef `                                    no 从默认索引组选择输出

  ` -bt <enum> `                            triclinic 用于 ` -box ` 和 ` -d ` 的盒子类型: triclinic, cubic, dodecahedron,
                                                      octahedron

  ` -box <vector> `                             0 0 0 盒向量长度 (a,b,c). 即自定义的盒子大小

  ` -angles <vector> `                       90 90 90 盒向量之间的角度 (bc,ac,ab)

  ` -d <real> `                                     0 溶质分子与盒子之间的距离

  ` -[no]c `                                       no 使分子在盒子内居中( ` -box ` 和 ` -d ` 选项暗含此选项)

  ` -center <vector> `                          0 0 0 几何中心的坐标

  ` -aligncenter <vector> `                     0 0 0 平齐的旋转中心

  ` -align <vector> `                           0 0 0 与目标向量平齐

  ` -translate <vector> `                       0 0 0 平移

  ` -rotate <vector> `                          0 0 0 绕X, Y和Z轴的旋转角度, 单位为度

  ` -[no]princ `                                   no 使分子取向沿其主轴

  ` -scale <vector> `                           1 1 1 缩放因子

  ` -density <real> `                            1000 通过缩放使输出盒子的密度(g/L)为指定值

  ` -[no]pbc `                                     no 移除周期性(使分子保持完整)

  ` -resnr <int> `                                 -1 从resnr开始重新对残基进行编号

  ` -[no]grasp `                                   no 在B因子段存储原子电荷, 在占有率段存储原子半径.

  ` -rvdw <real> `                               0.12 如果在数据库中找不到范德华半径或者拓扑文件中不存在参数,
                                                      将使用默认的范德华半径(单位nm).\
                                                      可用于处理缺少力场参数的原子.

  ` -[no]sig56 `                                   no 使用rmin/2(范德华势能的最小点对应距离的一半)而不是σ/2(范德华半径的一半)

  ` -[no]vdwread `                                 no 从 ` vdwradii.dat ` 文件中读取范德华半径, 而不是根据力场计算半径.

  ` -[no]atom `                                    no 强制为每个原子附加B因子

  ` -[no]legend `                                  no 创建B因子图例

  ` -label <string> `                               A 为所有残基添加链标识符, 以便指定其肽链归属

  ` -[no]conect `                                  no 当写入的时候将CONECT记录添加到 ` .pdb ` 文件中.
                                                      只有当拓扑文件存在时才可以.
  -----------------------------------------------------------------------------------------------------------------------------

  : 控制选项 {#tab-53}

### 已知问题

-   对复杂的分子, 去除周期性的子程序可能会崩溃, 在这种情况下你可以使用
    ` gmx trjconv `{.language-plaintext .highlighter-rouge} .

### 补充说明

在使用 ` pdb2gmx `{.language-plaintext .highlighter-rouge}
创建了模拟分子体系之后, 可以使用 ` editconf `{.language-plaintext
.highlighter-rouge} 为你的分子创建一个模拟盒子, 也可以认为是使用
` editconf `{.language-plaintext .highlighter-rouge}
将分子放进一个盒子中. 这样, 你就可以往盒子里面添加水分子,
离子或者其他溶剂等等了.

` -princ `{.language-plaintext .highlighter-rouge}
这个选项可以用来对齐分子, 比如使分子沿X轴对齐. 例如,
你想将分子中的两个残基沿Y轴对齐, 那么就在索引文件中将这俩个残基标记一下,
然后使用 ` -princ `{.language-plaintext .highlighter-rouge} ,
根据提示就能对齐分子了.

## gmx eneconv: 转换能量文件

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx eneconv [-f [<.edr> [...]]] [-o [<.edr>]] [-nice ] [-b ]
            [-e ] [-dt ] [-offset ] [-[no]settime]
            [-[no]sort] [-[no]rmdh] [-scalefac ] [-[no]error]
```
:::
:::

当使用 ` -f `{.language-plaintext .highlighter-rouge}
选项指定多个文件时:

按顺序将几个能量文件合并在一起. 当发现同一时刻存在两帧时,
会使用后一文件中的帧. 通过使用 ` -settime `{.language-plaintext
.highlighter-rouge} , 你可以指定每一文件的起始时间.
输入文件由命令行得到, 你可能要使用像
` gmx eneconv -f *.edr -o fixed.edr `{.language-plaintext
.highlighter-rouge} 这样的技巧.

当使用 ` -f `{.language-plaintext .highlighter-rouge}
选项指定一个文件时:

读入一个能量文件, 并根据 ` -dt `{.language-plaintext .highlighter-rouge}
, ` -offset `{.language-plaintext .highlighter-rouge} ,
` -t0 `{.language-plaintext .highlighter-rouge} 和
` -settime `{.language-plaintext .highlighter-rouge}
选项输出到另一个文件, 需要时还会转换为不同的格式(有文件扩展名确定).

程序会首先应用 ` -settime `{.language-plaintext .highlighter-rouge}
选项, 然后是 ` -dt `{.language-plaintext .highlighter-rouge} /
` -offset `{.language-plaintext .highlighter-rouge} 选项,
` -b `{.language-plaintext .highlighter-rouge} 和
` -e `{.language-plaintext .highlighter-rouge} 选项, 用以选择输出哪些帧.

  选项                         默认值 类型   说明
----------------------- ----------- ------ ----------
  ` -f [<.edr> [...]] `      ener.edr 输入   能量文件
  ` -o [<.edr>] `           fixed.edr 输出   能量文件

  : 输入/输出文件选项 {#tab-54}

  选项                     默认值 说明
---------------------- -------- -----------------------------------------------------------------
  ` -nice <int> `              19 设置优先级
  ` -b `                        0 从轨迹文件中读取的第一帧(ps)
  ` -e `                        0 从轨迹文件中读取的最后一帧(ps)
  ` -dt `                       0 只使用t除以dt的余数等于第一帧时间(ps)的帧, 即两帧之间的时间间隔
  ` -offset <real> `            0 ` -dt ` 选项的时间偏移, 即从哪一时间帧开始输出到新的能量文件中
  ` -[no]settime `             no 交互式地设定每一输入文件在新输出文件中的起始时间
  ` -[no]sort `               yes 自动排序输入能量文件(而不是帧)
  ` -[no]rmdh `                no 移除自由能块数据
  ` -scalefac <real> `          1 将能量分量乘以此因子
  ` -[no]error `              yes 当输入文件中出现错误时自动终止程序

  : 控制选项 {#tab-55}

### 已知问题

-   当组合轨迹时, 在新的输出文件中, 没有正确地更新sigma和E\^2(用于统计),
    只有实际能量项是正确的. 这样你需要使用其他方式来计算统计值, 如
    ` gmx analyze `{.language-plaintext .highlighter-rouge} .

### 补充说明

GROMACS模拟有一个非常重要的能量输出文件, 即 ` .edr `{.language-plaintext
.highlighter-rouge} 文件. ` gmx eneconv `{.language-plaintext
.highlighter-rouge} 就是对能量输出文件进行处理的程序.

一个模拟可以分多次进行, 于是得到很多 ` .edr `{.language-plaintext
.highlighter-rouge} 文件. 使用 ` gmx eneconv `{.language-plaintext
.highlighter-rouge} 的 ` -f `{.language-plaintext .highlighter-rouge}
选项, 然后把这些能量文件罗列出来, 就可以对这些能量文件进行合并,
并输出一个完整的能量文件. 如果几个能量文件中有重复的时间帧,
那么后一个读入的能量文件将覆盖前一个. 也可以使用
` -settime `{.language-plaintext .highlighter-rouge}
选项对每一个输入文件的起始时间进行设置, 以免互相覆盖. 如下是一个示例:

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
eneconv -o fixed.edr -f *.edr
```
:::
:::

即对当前目录下所有 ` .edr `{.language-plaintext .highlighter-rouge}
文件进行合并, 然后输出为 ` fixed.edr `{.language-plaintext
.highlighter-rouge} 文件.

当使用 ` -f `{.language-plaintext .highlighter-rouge}
选项读入单独一个能量文件时, 可以配合其他参数对能量文件进行编辑.

## gmx enemat: 从能量文件中提取能量矩阵

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx enemat [-f [<.edr>]] [-groups [<.dat>]] [-eref [<.dat>]]
           [-emat [<.xpm>]] [-etot [<.xvg>]] [-nice ] [-b ]
           [-e ] [-dt ] [-[no]w] [-xvg ] [-[no]sum]
           [-skip ] [-[no]mean] [-nlevels ] [-max ]
           [-min ] [-[no]coulsr] [-[no]coullr] [-[no]coul14]
           [-[no]ljsr] [-[no]ljlr] [-[no]lj14] [-[no]bhamsr] [-[no]bhamlr]
           [-[no]free] [-temp ]
```
:::
:::

` gmx enemat `{.language-plaintext .highlighter-rouge} 从能量文件(
` -f `{.language-plaintext .highlighter-rouge} )中提取能量矩阵. 使用
` -group `{.language-plaintext .highlighter-rouge}
选项时必须提供一个文件名称, 文件中每行包含一组使用的原子.
通过寻找名称对应于原子组对名称的能量组,
会从能量文件中提取这些组的相互作用能的矩阵. 例如, 如果
` -group `{.language-plaintext .highlighter-rouge} 文件中包含:

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
2
Protein
SOL
```
:::
:::

程序会预期能量文件中包含具有 ` Coul-SR:Protein-SOL `{.language-plaintext
.highlighter-rouge} 和 ` LJ:Protein-SOL `{.language-plaintext
.highlighter-rouge} 名称的能量组(尽管同时分析很多组时,
` gmx enemat `{.language-plaintext .highlighter-rouge} 非常有用).
不同能量类型的矩阵会分开输出, 由 ` -[no]coul `{.language-plaintext
.highlighter-rouge} , ` -[no]coulr `{.language-plaintext
.highlighter-rouge} , ` -[no]coul14 `{.language-plaintext
.highlighter-rouge} , ` -[no]lj `{.language-plaintext
.highlighter-rouge} , ` -[no]lj14 `{.language-plaintext
.highlighter-rouge} , ` -[no]bham `{.language-plaintext
.highlighter-rouge} 和 ` -[no]free `{.language-plaintext
.highlighter-rouge} 选项控制. 最后, 可以计算每组的总相互作用能(
` -etot `{.language-plaintext .highlighter-rouge} ).

近似的自由能可以如下计算: \$E\_{free} = E_0 + kT
\\log(\<\\exp((E-E_0)/kT)\>)\$, 其中 \$\<\>\$ 代表时间平均.
可以提供包含参考自由能的文件, 用以计算相对于一些参考状态的自由能差值.
参考文件中的组名称(如残基名称)应当与 ` -group `{.language-plaintext
.highlighter-rouge} 文件中的组名称一致, 但在
` -group `{.language-plaintext .highlighter-rouge}
中追加的数字(如残基编号)在比较时将会被忽略.

  选项                         默认值 类型         说明
---------------------- ------------ ------------ ----------------------
  ` -f [<.edr>] `            ener.edr 输入, 可选   能量文件
  ` -groups [<.dat>] `     groups.dat 输入         通用数据文件
  ` -eref [<.dat>] `         eref.dat 输入, 可选   通用数据文件
  ` -emat [<.xpm>] `         emat.xpm 输出         X PixMap兼容矩阵文件
  ` -etot [<.xvg>] `       energy.xvg 输出         xvgr/xmgr文件

  : 输入/输出文件选项 {#tab-56}

  选项                    默认值 说明
-------------------- --------- -----------------------------------------------------------------
  ` -nice <int> `             19 设置优先级
  ` -b `                       0 从轨迹文件中读取的第一帧(ps)
  ` -e `                       0 从轨迹文件中读取的最后一帧(ps)
  ` -dt `                      0 只使用t除以dt的余数等于第一帧时间(ps)的帧, 即两帧之间的时间间隔
  ` -[no]w `                  no 查看输出.xvg, .xpm, .eps和.pdb文件
  ` -xvg <enum> `        xmgrace xvg绘图格式: xmgrace, xmgr, none
  ` -[no]sum `                no 累加所选的能量项而不是显示它们全部
  ` -skip <int> `              0 数据点之间跳过的帧数
  ` -[no]mean `              yes 与 ` -groups ` 一起使用时抽取平均能量矩阵而不是每一时间步的矩阵
  ` -nlevels <int> `          20 矩阵颜色的水平数
  ` -max <real> `          1e+20 能量的最大值
  ` -min <real> `         -1e+20 能量的最小值
  ` -[no]coulsr `            yes 抽取短程Coulomb能量
  ` -[no]coullr `             no 抽取长程Coulomb能量
  ` -[no]coul14 `             no 抽取Coulomb 1-4能量
  ` -[no]ljsr `              yes 抽取短程Lennard-Jones能量
  ` -[no]ljlr `               no 抽取长程Lennard-Jones能量
  ` -[no]lj14 `               no 抽取Lennard-Jones 1-4能量
  ` -[no]bhamsr `             no 抽取短程Buckingham能量
  ` -[no]bhamlr `             no 抽取长程Buckingham能量
  ` -[no]free `              yes 计算自由能
  ` -temp <real> `           300 计算自由能的参考温度

  : 控制选项 {#tab-57}

## gmx energy: 将能量写入xvg文件并显示平均值

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx energy [-f [<.edr>]] [-f2 [<.edr>]] [-s [<.tpr/.tpb/...>]] [-o [<.xvg>]]
           [-viol [<.xvg>]] [-pairs [<.xvg>]] [-ora [<.xvg>]] [-ort [<.xvg>]]
           [-oda [<.xvg>]] [-odr [<.xvg>]] [-odt [<.xvg>]] [-oten [<.xvg>]]
           [-corr [<.xvg>]] [-vis [<.xvg>]] [-ravg [<.xvg>]] [-odh [<.xvg>]]
           [-nice ] [-b ] [-e ] [-[no]w] [-xvg ]
           [-[no]fee] [-fetemp ] [-zero ] [-[no]sum] [-[no]dp]
           [-nbmin ] [-nbmax ] [-[no]mutot] [-skip ]
           [-[no]aver] [-nmol ] [-[no]fluct_props] [-[no]driftcorr]
           [-[no]fluc] [-[no]orinst] [-[no]ovec] [-acflen ]
           [-[no]normalize] [-P ] [-fitfn ] [-beginfit ]
           [-endfit ]
```
:::
:::

` gmx energy `{.language-plaintext .highlighter-rouge}
用于从能量文件中提取能量组分或距离限制数据.
程序会提示用户以交互方式选择所需的能量项.

程序会使用全精度计算模拟中能量的平均值, RMSD和漂移(参见手册).
漂移是通过使用最小二乘法将数据拟合为直线得到的.
报告的总漂移是拟合直线第一个点和最后一个点的差值.
平均值的误差估计是基于5个块的块平均得到的, 计算时使用了全精度的平均值.
利用 ` -nbmin `{.language-plaintext .highlighter-rouge} 和
` -nbmax `{.language-plaintext .highlighter-rouge} 选项,
可以使用多个块长度进行误差估计. **注意** , 在大多数情况下,
能量文件包含了对所有MD步骤的平均,
或进行平均的点比能量文件中的帧数多很多. 这使得
` gmx energy `{.language-plaintext .highlighter-rouge} 的统计输出比
` .xvg `{.language-plaintext .highlighter-rouge} 文件中的数据更准确.
当能量文件中不存在精确的平均值时,
上述统计数据只是简单地对每帧能量数据的平均.

涨落项给出了围绕最小二乘拟合线的RMSD.

如果选择了正确的能量项, 并且使用了该命令行选项
` -fluct_props `{.language-plaintext .highlighter-rouge} ,
程序可以计算一些涨落相关的性质. 会计算以下性质:

          性质          需要的能量项
--------------------- --------------
     Enthalpy, Temp     
       Etot, Temp       
   Enthalpy, Vol, Temp  
        Vol, Temp       
        Vol, Temp       

你也需要通过 ` -nmol `{.language-plaintext .highlighter-rouge}
来设定分子的数目. C_p/C_v的计算 **不** 包含任何量子效应校正.
如果需要考虑量子效应可以使用 ` gmx dos `{.language-plaintext
.highlighter-rouge} 程序.

当设置 ` -viol `{.language-plaintext .highlighter-rouge} 选项时,
会绘制时间平均的背离数据, 并重新计算背离的实时时间平均值和瞬时累计值.
此外, 可以利用 ` -pairs `{.language-plaintext .highlighter-rouge}
选项来绘制选定原子对之间的实时时间平均距离和瞬时距离.

选项 ` -ora `{.language-plaintext .highlighter-rouge} ,
` -ort `{.language-plaintext .highlighter-rouge} ,
` -oda `{.language-plaintext .highlighter-rouge} ,
` -odr `{.language-plaintext .highlighter-rouge} 和
` -odt `{.language-plaintext .highlighter-rouge} 用于分析取向限制数据.
前两个选项绘制取向, 后三个选项绘制来自实验值的取向偏差. 以上选项中以
` a `{.language-plaintext .highlighter-rouge}
结尾的选项绘制时间平均随限制的变化. 以 ` t `{.language-plaintext
.highlighter-rouge} 结尾选项会提示用户限制标签号并绘制数据随时间的变化.
选项 ` -odr `{.language-plaintext .highlighter-rouge}
绘制RMS偏差随限制的变化. 当使用时间或系综平均的取向限制运行时, 选项
` -orinst `{.language-plaintext .highlighter-rouge} 可以用来分析瞬时,
非系综平均的取向和偏差, 而不是时间和系综平均的值.

选项 ` -oten `{.language-plaintext .highlighter-rouge}
用于绘制每个取向限制实验中分子序张量的特征值. 与选项
` -ovec `{.language-plaintext .highlighter-rouge}
同用时还可以绘制特征向量.

选项 ` -odh `{.language-plaintext .highlighter-rouge} 用于从
` ener.edr `{.language-plaintext .highlighter-rouge}
文件中提取并绘制自由能数据(哈密顿差值和/或哈密顿导数dhdl).

使用 ` -fee `{.language-plaintext .highlighter-rouge}
选项会计算体系与理想气体状态时的自由能差值:

\\\[\\D A = A(N,V,T) - A\_{idealgas}(N,V,T) = kT
\\ln(\<\\exp(U\_{pot}/kT)\>)\\\] \\\[\\D G = G(N,p,T) -
G\_{idealgas}(N,p,T) = kT \\ln(\<\\exp(U\_{pot}/kT)\>)\\\]

其中, \$k\$ 为玻尔兹曼常数, \$T\$ 由 ` -fetemp `{.language-plaintext
.highlighter-rouge} 设定, 平均对整个系综(或轨迹中的时间)进行. 请注意,
只有当平均是对整个(玻尔兹曼)系综进行并使用势能时,
这种作法在理论上才是正确的. 这允许对熵进行估计:

\\\[\\D S(N,V,T) = S(N,V,T) - S\_{idealgas}(N,V,T) = (\< U\_{pot} \> -
\\D A)/T\\\] \\\[\\D S(N,p,T) = S(N,p,T) - S\_{idealgas}(N,p,T) = (\<
U\_{pot} \> + pV - \\D G)/T\\\]

当指定了第二个能量文件( ` -f2 `{.language-plaintext .highlighter-rouge}
)时, 将计算自由能量差值 \$dF = -kT \\ln(\<\\exp(-(E_B-E_A)/kT)\>\_A)\$,
其中 \$E_A\$ 和 \$E_B\$ 分布为第一个和第二个能量文件中的能量值,
平均对系综A进行. 自由能差的实时平均值会输出到由
` -ravg `{.language-plaintext .highlighter-rouge} 指定的文件中. **注意**
, 能量必须由同一轨迹计算而来.

  选项                               默认值 类型         说明
-------------------------- -------------- ------------ ---------------------------
  ` -f [<.edr>] `                  ener.edr 输入         能量文件
  ` -f2 [<.edr>] `                 ener.edr 输入, 可选   能量文件
  ` -s [<.tpr/.tpb/...>] `        topol.tpr 输入, 可选   运行输入文件: tpr tpb tpa
  ` -o [<.xvg>] `                energy.xvg 输出         xvgr/xmgr文件
  ` -viol [<.xvg>] `           violaver.xvg 输出, 可选   xvgr/xmgr文件
  ` -pairs [<.xvg>] `             pairs.xvg 输出, 可选   xvgr/xmgr文件
  ` -ora [<.xvg>] `             orienta.xvg 输出, 可选   xvgr/xmgr文件
  ` -ort [<.xvg>] `             orientt.xvg 输出, 可选   xvgr/xmgr文件
  ` -oda [<.xvg>] `             orideva.xvg 输出, 可选   xvgr/xmgr文件
  ` -odr [<.xvg>] `             oridevr.xvg 输出, 可选   xvgr/xmgr文件
  ` -odt [<.xvg>] `             oridevt.xvg 输出, 可选   xvgr/xmgr文件
  ` -oten [<.xvg>] `             oriten.xvg 输出, 可选   xvgr/xmgr文件
  ` -corr [<.xvg>] `            enecorr.xvg 输出, 可选   xvgr/xmgr文件
  ` -vis [<.xvg>] `               visco.xvg 输出, 可选   xvgr/xmgr文件
  ` -ravg [<.xvg>] `           runavgdf.xvg 输出, 可选   xvgr/xmgr文件
  ` -odh [<.xvg>] `                dhdl.xvg 输出, 可选   xvgr/xmgr文件

  : 输入/输出文件选项 {#tab-59}

  选项                      默认值 说明
---------------------- --------- -------------------------------------------------------------------
  ` -nice <int> `               19 设置优先级
  ` -b `                         0 从轨迹文件中读取的第一帧(ps)
  ` -e `                         0 从轨迹文件中读取的最后一帧(ps)
  ` -[no]w `                    no 查看输出 .xvg, .xpm, .eps和.pdb文件
  ` -xvg <enum> `          xmgrace xvg绘图格式: xmgrace, xmgr, none
  ` -[no]fee `                  no 进行自由能估计
  ` -fetemp <real> `           300 自由能计算的参考温度
  ` -zero <real> `               0 减去零点能
  ` -[no]sum `                  no 累加选中的能量项而不是全部展示出来
  ` -[no]dp `                   no 以高精度格式输出能量
  ` -nbmin <int> `               5 误差估计的最小块数
  ` -nbmax <int> `               5 误差估计的最大块数
  ` -[no]mutot `                no 根据分量计算总的偶极矩
  ` -skip <int> `                0 数据点之间跳过的帧数
  ` -[no]aver `                 no 同时打印能量帧中精确的平均值和RMSD(只计算一项时)
  ` -nmol <int> `                1 采样的分子数: 能量将除以此值
  ` -[no]fluct_props `          no 基于能量涨落计算性质, 如热容
  ` -[no]driftcorr `            no 只用于计算涨落性质. 计算涨落性质前减去观测量的漂移
  ` -[no]fluc `                 no 计算能量涨落的自相关函数而不是能量自身
  ` -[no]orinst `               no 分析瞬时取向数据
  ` -[no]ovec `                 no 与 ` -oten ` 同用时也给出特征向量
  ` -acflen <int> `             -1 ACF的长度, 默认为帧数的一半
  ` -[no]normalize `           yes 归一化ACF
  ` -P <enum> `                  0 ACF Legendre多项式的阶数(0意味着没有): 0, 1, 2, 3
  ` -fitfn <enum> `           none 拟合函数: none, exp, aexp, exp_exp, vac, exp5, exp7, exp9, erffit
  ` -beginfit <real> `           0 对相关函数进行指数拟合的开始时间
  ` -endfit <real> `            -1 对相关函数进行指数拟合的结束时间, -1表示最终

  : 控制选项 {#tab-60}

### 补充说明

` gmx energy `{.language-plaintext .highlighter-rouge} 可提取
` .edr `{.language-plaintext .highlighter-rouge}
文件中的能量数据并将结果输出为 ` .xvg `{.language-plaintext
.highlighter-rouge} 文件, 一般来说, 命令为:

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx energy -f edr_file -o result.xvg
```
:::
:::

如果加上 ` -b `{.language-plaintext .highlighter-rouge} ,
` -e `{.language-plaintext .highlighter-rouge} 选项,
可以从具体时间段提取结果而不是全部时间.

如果要编写bash脚本, 可以使用命令管道, 比如提取温度:

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
echo "temperature" | gmx energy -f npt.edr -o temperature.xvg
```
:::
:::

` gmx energy `{.language-plaintext .highlighter-rouge}
的分析项目有以下这些方面

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
Select the terms you want from the following list by
selecting either (part of) the name or the number or a combination.
End your selection with an empty line or a zero.
-------------------------------------------------------------------
  1  Angle            2  Proper-Dih.      3  Ryckaert-Bell.   4  LJ-14
  5  Coulomb-14       6  LJ-(SR)          7  LJ-(LR)          8  Coulomb-(SR)
  9  Coul.-recip.    10  Potential       11  Kinetic-En.     12  Total-Energy
 13  Temperature     14  Pressure        15  Constr.-rmsd    16  Box-X
 17  Box-Y           18  Box-Z           19  Volume          20  Density
 21  pV              22  Enthalpy        23  Vir-XX          24  Vir-XY
 25  Vir-XZ          26  Vir-YX          27  Vir-YY          28  Vir-YZ
 29  Vir-ZX          30  Vir-ZY          31  Vir-ZZ          32  Pres-XX
 33  Pres-XY         34  Pres-XZ         35  Pres-YX         36  Pres-YY
 37  Pres-YZ         38  Pres-ZX         39  Pres-ZY         40  Pres-ZZ
 41  #Surf*SurfTen   42  Mu-X            43  Mu-Y            44  Mu-Z
 45  T-DRG           46  T-OIL           47  T-SOL           48  Lamb-DRG
 49  Lamb-OIL        50  Lamb-SOL
```
:::
:::

常用的一些如下:

-   ` Potential `{.language-plaintext .highlighter-rouge} 体系势能
-   ` Total-Energy `{.language-plaintext .highlighter-rouge} 体系总能量,
    包括势能与动能, 动能项目为Kinetic-En
-   ` Temperature `{.language-plaintext .highlighter-rouge} 温度
-   ` Pressure `{.language-plaintext .highlighter-rouge} 体系平均压强
-   ` Density `{.language-plaintext .highlighter-rouge} 体系平均密度
-   ` Pres-XX `{.language-plaintext .highlighter-rouge} X方向压强
-   ` Pres-YY `{.language-plaintext .highlighter-rouge} Y方向压强
-   ` Pres-ZZ `{.language-plaintext .highlighter-rouge} Z方向压强
-   ` #Surf*SurfTen `{.language-plaintext .highlighter-rouge}
    表面或界面张力

` gmx energy `{.language-plaintext .highlighter-rouge}
用于得到体系的各个能量, 一般跑完MD之后, 使用
` gmx energy `{.language-plaintext .highlighter-rouge} 处理
` ener.edr `{.language-plaintext .highlighter-rouge}
只能得到体系的各个能量项.
但如果想求体系中两个不同部分在模拟过程中的相互作用能,
那就要使用一些小窍门. 以下是实现的一种方法:

1.  根据原来的 ` .tpr `{.language-plaintext .highlighter-rouge}
    文件建立一个新 ` .tpr `{.language-plaintext .highlighter-rouge} ,
    在新的 ` .tpr `{.language-plaintext .highlighter-rouge} 中,
    使用索引文件明确定义感兴趣的组.
2.  使用 ` gmx mdrun `{.language-plaintext .highlighter-rouge} 的
    ` -rerun `{.language-plaintext .highlighter-rouge}
    选项指定原来的轨迹文件再跑一次模拟, 这个过程很快. 如果还想更快,
    可以使用 ` gmx trjconv `{.language-plaintext .highlighter-rouge}
    把水分子去掉. 这一个重复的模拟也产生轨迹文件, 重要的是,
    还会产生一个新的 ` ener.edr `{.language-plaintext
    .highlighter-rouge} 文件, 这个文件中包含了
    ` .tpr `{.language-plaintext .highlighter-rouge}
    文件中定义的各个组能量及相互作用能(库伦相互作用能,
    范德华相互作用能等).
3.  使用 ` gmx energy `{.language-plaintext .highlighter-rouge}
    把各个能量项提出来

## gmx filter: 轨迹频率滤波, 用于制作平滑的动画

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx filter [-f [<.xtc/.trr/...>]]` [-s [<.tpr/.tpb/...>]]` [-n [<.ndx>]]
           [-ol [<.xtc/.trr/...>]]` [-oh [<.xtc/.trr/...>]]` [-nice ]
           [-b ]` [-e ]` [-dt ]` [-[no]w]` [-nf ]
           [-[no]all]` [-[no]nojump]` [-[no]fit]
```
:::
:::

` gmx filter `{.language-plaintext .highlighter-rouge}
用于对轨迹进行频率滤波. 滤波器的形状为从-A到+A的cos(π t/A) + 1,
其中A为选项 ` -nf `{.language-plaintext .highlighter-rouge}
与输入文件中时间步的乘积. 对低通滤波, 滤波器可将周期为A的涨落降低85%,
周期为2 *A的降低50%, 周期为3* A的降低17%.
程序可输出低通和高通滤波后的轨迹.

选项 ` -ol `{.language-plaintext .highlighter-rouge}
输出低通滤波后的轨迹, 每 ` -nf `{.language-plaintext .highlighter-rouge}
输入帧输出一次.
滤波器长度与输出间隔的比值保证了可很好地抑制高频运动的混淆,
这非常有利于制作平滑的电影. 此外, 对与坐标有线性关系的性质,
其平均值会保持不变, 因为所有输入帧在输出中的权重都是相同的.
当需要所有帧时, 可使用 ` -all `{.language-plaintext .highlighter-rouge}
选项.

选项 ` -oh `{.language-plaintext .highlighter-rouge}
输出高通滤波后的轨迹. 高通滤波后的坐标会加到结构文件中的坐标上.
当使用高通滤波时, 请使用 ` -fit `{.language-plaintext
.highlighter-rouge} 选项或保证所用轨迹已经叠合到结构文件中的坐标.

  选项                                默认值 类型         说明
--------------------------- -------------- ------------ ------------------------------------------------
  ` -f [<.xtc/.trr/...>] `          traj.xtc 输入         轨迹: xtc trr cpt trj gro g96 pdb tng
  ` -s [<.tpr/.tpb/...>] `         topol.tpr 输入, 可选   结构+质量(db): tpr tpb tpa gro g96 pdb brk ent
  ` -n [<.ndx>] `                  index.ndx 输入, 可选   索引文件
  ` -ol [<.xtc/.trr/...>] `      lowpass.xtc 输出, 可选   轨迹: xtc trr trj gro g96 pdb tng
  ` -oh [<.xtc/.trr/...>] `     highpass.xtc 输出, 可选   轨迹: xtc trr trj gro g96 pdb tng

  : 输入/输出文件选项 {#tab-61}

  选项                默认值 说明
----------------- -------- -----------------------------------------------------------------
  ` -nice `               19 设置优先级
  ` -b `                   0 从轨迹文件中读取的第一帧(ps)
  ` -e `                   0 从轨迹文件中读取的最后一帧(ps)
  ` -dt `                  0 只使用t除以dt的余数等于第一帧时间(ps)的帧, 即两帧之间的时间间隔
  ` -[no]w `              no 查看输出的.xvg, .xpm, .eps和.pdb文件
  ` -nf <int> `           10 设置低通滤波的滤波器长度以及输出间距
  ` -[no]all `            no 输出所有低通滤波后的帧
  ` -[no]nojump `        yes 移除穿越盒子的原子跳跃
  ` -[no]fit `            no 将所有帧叠合到参考结构

  : 控制选项 {#tab-62}

## gmx freevolume: 计算自由体积

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx freevolume [-f [<.xtc/.trr/...>]] [-s [<.tpr/.tpb/...>]] [-n [<.ndx>]]
               [-o [<.xvg>]] [-b ] [-e ] [-dt ] [-tu ]
               [-xvg ] [-[no]rmpbc] [-sf ] [-selrpos ]
               [-select ] [-radius ] [-seed ]
               [-ninsert ]
```
:::
:::

` gmx freevolume `{.language-plaintext .highlighter-rouge}
用于计算一个盒子中的自由体积及其与时间的函数关系,
输出自由体积所占总体积的比例.
程序会尝试将一个指定半径的探针插入模拟盒子中,
如果探针与任何原子之间的距离小于两个原子的范德华半径之和,
就认为这个位置已被占据, 即非自由. 通过利用半径为0的探针,
可以计算出真实的自由体积. 通过利用较大半径的探针, 如0.14 nm,
大致对应于水分子的半径, 可计算对应于指定大小假想粒子的自由体积. 然而,
值得注意的是, 由于将原子视为硬球, 这些数字是非常近似的,
通常只有相对变化才有意义, 例如进行不同温度下的一系列模拟.

通过选择指定的组来用于描述非自由体积.
单位体积的插入数目对结果的收敛影响很大.
使用大约1000/nm\^3\^的值可得到总的标准偏差,
这是由轨迹的涨落决定而不是由随机数的涨落决定的.

所得结果非常依赖于范德华半径; 我们推荐使用Bondi(1964)给出的数值.

一些作者喜欢使用部分自由体积(FFV, Fractional Free Volume),
它的值为1-1.3\*(1-Free Volume). 此值会显示在终端上.

  选项                                 默认值 类型         说明
-------------------------- ---------------- ------------ -----------------------------------------------------
  ` -f [<.xtc/.trr/...>] `           traj.xtc 输入, 可选   输入轨迹或单个构型: xtc trr cpt trj gro g96 pdb tng
  ` -s [<.tpr/.tpb/...>] `          topol.tpr 输入, 可选   输入结构: tpr tpb tpa gro g96 pdb brk ent
  ` -n [<.ndx>] `                   index.ndx 输入, 可选   额外的索引组
  ` -o [<.xvg>] `              freevolume.xvg 输出, 可选   计算的自由体积

  : 输入/输出文件选项 {#tab-63}

----------------------------------------------------------------------------------------------
  选项                                       默认值 说明
------------------------- ----------------------- --------------------------------------------
  ` -b <time> `                                   0 从轨迹文件中读取的第一帧(ps)

  ` -e <time> `                                   0 从轨迹文件中读取的最后一帧(ps)

  ` -dt <time> `                                  0 只使用t除以dt的余数等于第一帧时间(ps)的帧,
                                                    即两帧之间的时间间隔

  ` -tu <enum> `                                 ps 时间单位: fs, ps, ns, us, ms, s

  ` -xvg <enum> `                           xmgrace 绘图格式: none, xmgrace, xmgr

  ` -[no]rmpbc `                                yes 使每帧中的分子保持完整

  ` -sf <file> `                                    使用文件提供选择

  ` -selrpos <enum> `                          atom 选择参考位置: atom, res_com, res_cog,
                                                    mol_com, mol_cog,\
                                                    whole_res_com, whole_res_cog, whole_mol_com,
                                                    whole_mol_cog,\
                                                    part_res_com, part_res_cog, part_mol_com,
                                                    part_mol_cog,\
                                                    dyn_res_com, dyn_res_cog, dyn_mol_com,
                                                    dyn_mol_cog

  ` -select <selection> `                           使用选区

  ` -radius <real> `                              0 插入探针的半径(单位nm,
                                                    使用0可得到真正的自由体积)

  ` -seed <int> `                                -1 随机数产生器的种子

  ` -ninsert <int> `                           1000 对轨迹中的每一帧, 每立方nm探针尝试插入的次数
  ----------------------------------------------------------------------------------------------

  : 控制选项 {#tab-64}

## gmx gangle: 计算角度

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx gangle [-f [<.xtc/.trr/...>]] [-s [<.tpr/.tpb/...>]] [-n [<.ndx>]]
           [-oav [<.xvg>]] [-oall [<.xvg>]] [-oh [<.xvg>]] [-b ]
           [-e ] [-dt ] [-tu ] [-xvg ] [-[no]rmpbc]
           [-[no]pbc] [-sf ] [-selrpos ] [-g1 ]
           [-g2 ] [-binw ] [-group1 ]
           [-group2 ]
```
:::
:::

` gmx gangle `{.language-plaintext .highlighter-rouge}
计算矢量之间不同类型的角度, 它支持由两个位置定义的矢量,
也支持由三个位置定义的平面的法线. 矢量还可以是z轴或球面的局部法线. 此外,
选项 ` angle `{.language-plaintext .highlighter-rouge} 和
` dihedral `{.language-plaintext .highlighter-rouge}
可方便地用于计算由三/四个位置定义的键角和二面角.

角度类型通过 ` -g1 `{.language-plaintext .highlighter-rouge} 和
` -g2 `{.language-plaintext .highlighter-rouge} 指定. 如果
` -g1 `{.language-plaintext .highlighter-rouge} 为
` angle `{.language-plaintext .highlighter-rouge} 或
` dihedral `{.language-plaintext .highlighter-rouge} , 就不应再指定
` -g2 `{.language-plaintext .highlighter-rouge} . 在这种情况下,
` -group1 `{.language-plaintext .highlighter-rouge}
应指定一个或多个选择, 并且每个选择应包括位置的三联对或四联对,
它们定义了要计算的角度.

如果 ` -g1 `{.language-plaintext .highlighter-rouge} 为
` vector `{.language-plaintext .highlighter-rouge} 或
` plane `{.language-plaintext .highlighter-rouge} ,
` -group1 `{.language-plaintext .highlighter-rouge}
指定的选择应包含位置对( ` vector `{.language-plaintext
.highlighter-rouge} )或位置三元对( ` plane `{.language-plaintext
.highlighter-rouge} ). 对矢量, 位置设置了矢量的端点, 对平面,
三个位置用于计算平面的法向. 在这两种情况下, ` -g2 `{.language-plaintext
.highlighter-rouge} 指定要使用的其它矢量(见下文).

使用 ` -g2 vector `{.language-plaintext .highlighter-rouge} 或
` -g2 plane `{.language-plaintext .highlighter-rouge} 时,
` -group2 `{.language-plaintext .highlighter-rouge} 应指定另一组矢量.
` -group1 `{.language-plaintext .highlighter-rouge} 和
` -group2 `{.language-plaintext .highlighter-rouge}
应指定相同的选择数目. 对其中的一个选项也可以只有一个选择, 在这种情况下,
对其他组中的每个选择会使用相同的选择. 同样, 对
` -group1 `{.language-plaintext .highlighter-rouge} 中的每个选择, 相应的
` -group2 `{.language-plaintext .highlighter-rouge}
中的选择应指定相同数目的矢量或单独一个矢量. 在后一种情况下,
会计算这个单一矢量与其它选择中的每个矢量之间的角度.

使用 ` -g2 sphnorm `{.language-plaintext .highlighter-rouge} 时,
` -group2 `{.language-plaintext .highlighter-rouge}
中的每个选择应指定单一的位置, 它是球的中心. 第二个矢量从中心到由
` -group1 `{.language-plaintext .highlighter-rouge} 指定的位置的中点.

使用 ` -g2 z `{.language-plaintext .highlighter-rouge} 时, 不需要指定
` -group2 `{.language-plaintext .highlighter-rouge} ,
会计算第一个矢量与Z轴正半轴之间的角度.

使用 ` -g2 t0 `{.language-plaintext .highlighter-rouge} 时, 不需要指定
` -group2 `{.language-plaintext .highlighter-rouge} ,
会利用第一帧的矢量计算角度.

有三个输出选项: ` -oav `{.language-plaintext .highlighter-rouge}
会将每一帧的时间与平均角度写入一个xvg文件. ` -oall `{.language-plaintext
.highlighter-rouge} 会输出单独的角度. ` -oh `{.language-plaintext
.highlighter-rouge} 输出角度的直方图. 分格的宽度由
` -binw `{.language-plaintext .highlighter-rouge} 设置. 对
` -oav `{.language-plaintext .highlighter-rouge} 和
` -oh `{.language-plaintext .highlighter-rouge} , 会计算
` -group1 `{.language-plaintext .highlighter-rouge}
中每个选择的单独平均/直方图.

  选项                              默认值 类型         说明
-------------------------- ------------- ------------ -----------------------------------------------------
  ` -f [<.xtc/.trr/...>] `        traj.xtc 输入, 可选   输入轨迹或单一构型: xtc trr cpt trj gro g96 pdb tng
  ` -s [<.tpr/.tpb/...>] `       topol.tpr 输入, 可选   输入结构: tpr tpb tpa gro g96 pdb brk ent
  ` -n [<.ndx>] `                index.ndx 输入, 可选   额外的索引组
  ` -oav [<.xvg>] `            angaver.xvg 输出, 可选   作为时间函数的平均角度
  ` -oall [<.xvg>] `            angles.xvg 输出, 可选   作为时间函数的所有角度
  ` -oh [<.xvg>] `             anghist.xvg 输出, 可选   角度的直方图

  : 输入/输出文件选项 {#tab-65}

----------------------------------------------------------------------------------------------
  选项                                       默认值 说明
------------------------- ----------------------- --------------------------------------------
  ` -b <time> `                                   0 从轨迹文件中读取的第一帧(ps)

  ` -e <time> `                                   0 从轨迹文件中读取的最后一帧(ps)

  ` -dt <time> `                                  0 只使用t除以dt的余数等于第一帧时间(ps)的帧,
                                                    即两帧之间的时间间隔

  ` -tu <enum> `                                 ps 时间值的单位: fs, ps, ns, us, ms, s

  ` -xvg <enum> `                           xmgrace 绘图格式: none, xmgrace, xmgr

  ` -[no]rmpbc `                                yes 对每一帧, 使分子保持完整

  ` -[no]pbc `                                  yes 计算距离时使用周期性边界条件

  ` -sf <file> `                                    使用文件提供选择

  ` -selrpos <enum> `                          atom 选择参考位置: atom, res_com, res_cog,
                                                    mol_com, mol_cog,\
                                                    whole_res_com, whole_res_cog, whole_mol_com,
                                                    whole_mol_cog,\
                                                    part_res_com, part_res_cog, part_mol_com,
                                                    part_mol_cog,\
                                                    dyn_res_com, dyn_res_cog, dyn_mol_com,
                                                    dyn_mol_cog

  ` -g1 <enum> `                              angle 分析类型/第一矢量组: angle, dihedral,
                                                    vector, plane

  ` -g2 <enum> `                               none 第二向量组的类型: none, vector, plane, t0,
                                                    z, sphnorm

  ` -binw <real> `                                1 ` -oh ` 的分格宽度, 以度为单位

  ` -group1 <selection> `                           第一个分析/矢量选择

  ` -group2 <selection> `                           第二个分析/矢量选择
  ----------------------------------------------------------------------------------------------

  : 控制选项 {#tab-66}

## gmx genconf: 增加"随机"取向的构象

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx genconf [-f [<.gro/.g96/...>]] [-o [<.gro/.g96/...>]]
            [-trj [<.xtc/.trr/...>]] [-nice ] [-nbox ]
            [-dist ] [-seed ] [-[no]rot] [-[no]shuffle]
            [-[no]sort] [-block ] [-nmolat ] [-maxrot ]
            [-[no]renumber]
```
:::
:::

` gmx genconf `{.language-plaintext .highlighter-rouge}
程序对给定的坐标文件进行简单的堆叠, 就像小孩子玩积木一样.
该程序会根据用户定义的比例( ` -nbox `{.language-plaintext
.highlighter-rouge} )创建一个网格, 格点间的额外空间由
` -dist `{.language-plaintext .highlighter-rouge} 指定.

指定 ` -rot `{.language-plaintext .highlighter-rouge} 选项时,
程序不会检查格点上分子之间的重叠.
建议输入文件中的盒子边长至少等于原子坐标与范德华半径之和.

如果给出了可选的轨迹文件, 不会产生构象, 但会从文件中读取构象,
经过适当平移后创建格点.

  选项                             默认值 类型         说明
---------------------------- ---------- ------------ -----------------------------------------------
  ` -f [<.gro/.g96/...>] `       conf.gro 输入         结构文件: gro g96 pdb brk ent esp tpr tpb tpa
  ` -o [<.gro/.g96/...>] `        out.gro 输出         结构文件: gro g96 pdb brk ent esp
  ` -trj [<.xtc/.trr/...>] `     traj.xtc 输入, 可选   轨迹: xtc trr cpt trj gro g96 pdb tng

  : 输入/输出文件选项 {#tab-67}

---------------------------------------------------------------------------------
  选项                                     默认值 说明
----------------------- ----------------------- ---------------------------------
  ` -nice <int> `                               0 设置优先级

  ` -nbox <vector> `                        1 1 1 盒子数目\
                                                  将分子像堆积木一样堆积起来,
                                                  一般按从小到大的顺序定义x y
                                                  z方向上的分子数,\
                                                  否则会出现分子间距离较近的情况.
                                                  最后分子的个数为x\*y\*z

  ` -dist <vector> `                        0 0 0 盒子间的距离

  ` -seed <int> `                               0 随机数发生器的种子, 如果为0,
                                                  根据当前时间产生.

  ` -[no]rot `                                 no 随机旋转构象

  ` -[no]shuffle `                             no 随机混洗分子

  ` -[no]sort `                                no 根据X方向坐标对分子排序

  ` -block <int> `                              1 根据此CPU数将盒子划分为块

  ` -nmolat <int> `                             3 每个分子的原子数, 假定从0开始.
                                                  如果设置错误, 体系可能完全不对.

  ` -maxrot <vector> `                180 180 180 最大的随机转动

  ` -[no]renumber `                           yes 重新编号残基
  ---------------------------------------------------------------------------------

  : 控制选项 {#tab-68}

### 已知问题

-   程序应允许随机放置格点

## gmx genion: 在能量有利位置加入单原子离子

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx genion [-s [<.tpr/.tpb/...>]] [-n [<.ndx>]] [-o [<.gro/.g96/...>]]
           [-p [<.top>]] [-nice ] [-np ] [-pname ]
           [-pq ] [-nn ] [-nname ] [-nq ]
           [-rmin ] [-seed ] [-conc ] [-[no]neutral]
```
:::
:::

` gmx genion `{.language-plaintext .highlighter-rouge}
用单原子离子随机地取代溶剂分子. 溶剂分子组应该连续,
且所有分子的原子数应该相同. 用户应该将离子添加到拓扑文件中, 或使用
` -p `{.language-plaintext .highlighter-rouge} 选项自动修改拓扑文件.

在所有力场中, 离子的分子类型,
残基名称和原子名称都是大写的元素名称且不含符号. 分子名称应使用
` -pname `{.language-plaintext .highlighter-rouge} 或
` -nname `{.language-plaintext .highlighter-rouge} 给出, 并且拓扑文件的
` [ molecules ] `{.language-plaintext .highlighter-rouge}
段也要相应地更新, 可以手动更新或使用 ` -p `{.language-plaintext
.highlighter-rouge} 选项. 不要使用原子名称!

具有多个电荷态的离子会添加多重度, 不含符号, 只用于非常见态.

对更大的离子, 例如硫酸根, 我们建议使用
` gmx insert-molecules `{.language-plaintext .highlighter-rouge}

---------------------------------------------------------------------------------------------------------------
  选项                                  默认值 类型              说明
-------------------------- ----------------- ----------------- ------------------------------------------------
  ` -s [<.tpr/.tpb/...>] `           topol.tpr 输入              运行输入文件: tpr tpb tpa

  ` -n [<.ndx>] `                    index.ndx 输入, 可选        索引文件

  ` -o [<.gro/.g96/...>] `             out.gro 输出              结构文件: gro g96 pdb brk ent esp\
                                                                 得到这个文件之后, 可以再用它产生tpr文件.

  ` -p [<.top>] `                    topol.top 输入/输出, 可选   拓扑文件\
                                                                 在往体系中添加金属离子时,\
                                                                 ` genion `
                                                                 会往拓扑文件最后的分子类型中写入添加的离子数,\
                                                                 并修改拓扑文件中体系的原子数.
  ---------------------------------------------------------------------------------------------------------------

  : 输入/输出文件选项 {#tab-69}

-----------------------------------------------------------------------------------------------
  选项                                     默认值 说明
----------------------- ----------------------- -----------------------------------------------
  ` -nice <int> `                              19 设置优先级

  ` -np <int> `                                 0 阳离子的数目

  ` -pname <string> `                          NA 阳离子的名称

  ` -pq <int> `                                 1 阳离子的电荷

  ` -nn <int> `                                 0 阴离子的数目

  ` -nname <string> `                          CL 阴离子的名称

  ` -nq <int> `                                -1 阴离子的电荷

  ` -rmin <real> `                            0.6 离子间的最小距离

  ` -seed <int> `                            1993 随机数发生器的种子

  ` -conc <real> `                              0 指定盐的浓度(mol/L).
                                                  程序会添加足够多的离子以达到指定的浓度,\
                                                  浓度根据输入 ` .tpr ` 文件中的盒子体积计算.
                                                  覆盖 ` -np ` 和 ` -nn ` 选项.

  ` -[no]neutral `                             no 此选项会添加足够多的离子以使体系的净电荷为零.
                                                  会优先添加这些离子,\
                                                  然后在添加那些由 ` -np ` / ` -nn ` 或 ` -conc `
                                                  指定的离子.
  -----------------------------------------------------------------------------------------------

  : 控制选项 {#tab-70}

### 已知问题

-   如果你指定了盐的浓度, 不会考虑已有的离子. 为此,
    你需要指定要添加的盐的量.

### 补充说明

在给蛋白质添加了水环境之后, 一般要在水环境中添加离子,
使模拟体系更接近真实体系. 如果体系中的蛋白质本身已经带了静电荷,
那么就更要给体系加几个带相反电荷的离子, 使体系处于电中性.

几个常用选项的说明:

-   ` -np/-nn/-conc `{.language-plaintext .highlighter-rouge} :
    带正/负电离子的数目.\
    假如想要得到0.1 mol/L的离子浓度到底要加多少离子, 可以自己算一下,
    也可以直接使用 ` -conc `{.language-plaintext .highlighter-rouge}
    指定离子浓度. 在使用 ` -conc `{.language-plaintext
    .highlighter-rouge} 时, 建议配合使用
    ` -neutral `{.language-plaintext .highlighter-rouge} ,
    以便使体系最后处于电中性.
-   ` -pn/-nn `{.language-plaintext .highlighter-rouge} :
    指定正负离子的名称, 比如 ` NA+ `{.language-plaintext
    .highlighter-rouge} 或者 ` CL- `{.language-plaintext
    .highlighter-rouge} .\
    可以参看GROMACS安装路径 ` share/gromacs/top/ `{.language-plaintext
    .highlighter-rouge} 下面的力场文件中离子使用的名称,
    也可以使用新的离子, 但要在力场中定义, 或者把新离子的itp文件使用
    ` include `{.language-plaintext .highlighter-rouge}
    添加到体系拓扑文件中.
-   ` -seed `{.language-plaintext .highlighter-rouge} : 随机数种子.\
    如果发现添加的离子离蛋白太近(比如说小于0.1 nm),
    那么可以指定新的种子.

### 使用范例

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx genion -s topol.tpr -o system_ion.pdb -p system.top -np 100 -pname Na -nn 100 -nname Cl
```
:::
:::

添加100个Na+离子和100个Cl离子, 输出文件为
` system_ion.pdb `{.language-plaintext .highlighter-rouge} 文件.

## gmx genrestr: 生成索引组的位置限制或距离限制

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx genrestr [-f [<.gro/.g96/...>]] [-n [<.ndx>]] [-o [<.itp>]]
             [-of [<.ndx>]] [-nice ] [-fc ] [-freeze ]
             [-[no]disre] [-disre_dist ] [-disre_frac ]
             [-disre_up2 ] [-cutoff ] [-[no]constr]
```
:::
:::

基于 ` -f `{.language-plaintext .highlighter-rouge} 指定的文件内容,
` gmx genrestr `{.language-plaintext .highlighter-rouge} 为拓扑生成一个
` #include `{.language-plaintext .highlighter-rouge} 头文件,
其中包含一个原子编号列表以及x, y和z三个方向的力常数.
也可以在命令行中指定单一的各向同性力常数, 而不是给出三个分量.

**警告** : 位置限制是分子内的相互作用,
因此在拓扑文件中它们必须被包含在正确的
` [ moleculetype ] `{.language-plaintext .highlighter-rouge} 段中. 而
` [ position_restraints ] `{.language-plaintext .highlighter-rouge}
段中的原子索引必须在相应分子类型的原子索引范围之内.
因为在每个分子类型中原子编号都是从1开始的, 而在
` gmx genrestr `{.language-plaintext .highlighter-rouge}
命令的输入文件中却是从1开始连续编号, 所以
` gmx genrestr `{.language-plaintext .highlighter-rouge}
命令只会对第一个分子生成有用的文件.
你可能需要编辑生成的索引文件以删除第一个分子后面的原子,
或构建一个合适的索引组作为 ` gmx genrestr `{.language-plaintext
.highlighter-rouge} 的输入.

` -of `{.language-plaintext .highlighter-rouge}
选项可生成一个用于冻结原子的索引文件. 在这种情况下, 输入文件必须是
` .pdb `{.language-plaintext .highlighter-rouge} 文件.

使用 ` -disre `{.language-plaintext .highlighter-rouge}
选项会生成距离限制而非位置限制的半个矩阵.
该矩阵通常用于蛋白质中的C\~α\~原子,
这样可以维持一个蛋白质的总体构象而不必将其绑定到特定位置(使用位置限制时).

  选项                             默认值 类型         说明
-------------------------- ------------ ------------ -----------------------------------------------
  ` -f [<.gro/.g96/...>] `       conf.gro 输入         结构文件: gro g96 pdb brk ent esp tpr tpb tpa
  ` -n [<.ndx>] `               index.ndx 输入, 可选   索引文件
  ` -o [<.itp>] `               posre.itp 输出         拓扑的包含文件
  ` -of [<.ndx>] `             freeze.ndx 输出, 可选   索引文件

  : 输入/输出文件选项 {#tab-71}

--------------------------------------------------------------------------------------------
  选项                                      默认值 说明
------------------------ ----------------------- -------------------------------------------
  ` -nice <int> `                                0 设置优先级

  ` -fc <vector> `                  1000 1000 1000 力常数(kJ/mol nm\^2\^)

  ` -freeze <real> `                             0 如果给出 ` -of ` 选项或此选项,
                                                   对所有B因子小于选项指定值的原子,\
                                                   其编号都将被写入一个索引文件.

  ` -[no]disre `                                no 生成所有索引中原子的距离限制矩阵.

  ` -disre_dist <real> `                       0.1 生成距离限制时围绕真实距离的范围.

  ` -disre_frac <real> `                         0 用作间隔而不是固定距离的距离分数.\
                                                   如果在此指定的距离分数小于前一选项(
                                                   ` -disre_dist ` )指定的距离,\
                                                   将使用 ` -disre_dist ` 选项指定的值.

  ` -disre_up2 <real> `                          1 距离限制的上限距离,
                                                   在此距离处力将变为常量(参见手册).

  ` -cutoff <real> `                            -1 仅对处于截断半径(nm)内的原子生成距离限制.

  ` -[no]constr `                               no 生成约束矩阵而非距离限制.
                                                   会生成类型2的约束, 并包含排除.
  --------------------------------------------------------------------------------------------

  : 控制选项 {#tab-72}

## gmx grompp: 生成运行输入文件

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx grompp [-f [<.mdp>]] [-po [<.mdp>]] [-c [<.gro/.g96/...>]]
           [-r [<.gro/.g96/...>]] [-rb [<.gro/.g96/...>]] [-n [<.ndx>]]
           [-p [<.top>]] [-pp [<.top>]] [-o [<.tpr/.tpb/...>]]
           [-t [<.trr/.cpt/...>]] [-e [<.edr>]] [-imd [<.gro>]]
           [-ref [<.trr/.cpt/...>]] [-nice ] [-[no]v] [-time ]
           [-[no]rmvsbds] [-maxwarn ] [-[no]zero] [-[no]renum]
```
:::
:::

` gmx grompp `{.language-plaintext .highlighter-rouge}
(gromacs预处理器)读取分子的拓扑文件, 检查其合理性,
并将拓扑从分子描述拓展到原子描述.
拓扑文件包含了分子类型和分子数目的信息, 预处理器会复制每个需要的分子.
对分子类型的数目没有限制. 键和键角可以转换为约束,
对氢原子和重原子独立进行. 然后读入坐标文件,
如果需要可以由Maxwell分布生成速度. ` gmx grompp `{.language-plaintext
.highlighter-rouge} 还会读取用于 ` gmx mdrun `{.language-plaintext
.highlighter-rouge} 的参数(例如, MD的步数,
时间步长和截断)以及其他一些参数, 如NEMD参数.
程序会对这些参数进行校正以使得净加速度为零.
程序最终会生成一个二进制文件, 它可以单独地作为MD程序的输入文件.

` gmx grompp `{.language-plaintext .highlighter-rouge}
使用来自拓扑文件的原子名称. 当坐标文件中(选项 ` -c `{.language-plaintext
.highlighter-rouge} )的原子名称与拓扑文件中的不一致时, 会产生警告. 注意,
原子名称与模拟无关, 因为生成相互作用参数只使用了原子类型.

` gmx grompp `{.language-plaintext .highlighter-rouge}
使用内置的预处理器来解决包含, 宏等问题. 预处理器支持下面的关键词:

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
#ifdef VARIABLE
#ifndef VARIABLE
#else
#endif
#define VARIABLE
#undef VARIABLE
#include "filename"
#include <filename>
```
:::
:::

在 ` .mdp `{.language-plaintext .highlighter-rouge} 文件中,
拓扑文件中的这些语句的功能可以通过以下两个选项来模块化：

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
define = -DVARIABLE1 -DVARIABLE2
include = -I/home/john/doe
```
:::
:::

要了解更多的信息, 可以学习C语言程序的教材. 指定
` -pp `{.language-plaintext .highlighter-rouge}
选项可以输出预处理的拓扑文件, 这样你就可以验证其内容了.

当使用位置限制时, 可以使用 ` -r `{.language-plaintext
.highlighter-rouge} 选项提供一个包含限制坐标的文件,
否则将会使用相对于来自 ` -c `{.language-plaintext .highlighter-rouge}
选项的构象进行限制. 对自由能计算, B拓扑的坐标可使用
` -rb `{.language-plaintext .highlighter-rouge} 提供,
否则它们将等同于A拓扑的坐标.

起始坐标可以由 ` -t `{.language-plaintext .highlighter-rouge}
提供的轨迹文件中读取. 程序会读取最后一帧的坐标和速度, 除非使用了
` -time `{.language-plaintext .highlighter-rouge} 选项.
只有当这些信息缺失时才会使用由 ` -c `{.language-plaintext
.highlighter-rouge} 提供的文件中的坐标. 注意, 当
` .mdp `{.language-plaintext .highlighter-rouge} 文件中设置了
` gen_vel = yes `{.language-plaintext .highlighter-rouge} 时,
不会使用文件中的速度信息. 可以使用选项 ` -e `{.language-plaintext
.highlighter-rouge} 提供能量文件,
以读取Nose-Hoover和/或Parrinello-Rahman耦合变量.

` gmx grompp `{.language-plaintext .highlighter-rouge}
可用于重启模拟(保持连续), 只需要使用 ` -t `{.language-plaintext
.highlighter-rouge} 选项提供一个检查点文件即可. 然而,
如果只是简单地改变运行步数以延长模拟, 使用
` gmx convert-tpr `{.language-plaintext .highlighter-rouge} 比使用
` gmx grompp `{.language-plaintext .highlighter-rouge} 更方便.
你只需要使用 ` -cpi `{.language-plaintext .highlighter-rouge}
选项将旧的检查点文件直接提供给 ` gmx mdrun `{.language-plaintext
.highlighter-rouge} 即可. 如果想要改变系综或是输出频率等, 建议使用
` -t `{.language-plaintext .highlighter-rouge} 为
` gmx grompp `{.language-plaintext .highlighter-rouge} 提供检查点文件,
并使用 ` -f `{.language-plaintext .highlighter-rouge} 提供新的
` .mdp `{.language-plaintext .highlighter-rouge} 文件.

默认情况下,
所有由构建虚拟位点引入的具有恒定能量的键合相互作用都会被移除.
如果此恒定能量不为零, 将会导致总能量移动. 所有键合相互作用都可以通过关闭
` -rmvsbds `{.language-plaintext .highlighter-rouge} 来维持. 另外,
所有因虚拟位点构建引入的距离约束都具有恒定能量, 它们都会被移除.
如果仍然存在涉及虚拟位点的任何约束, 将导致致命错误.

为验证运行输入文件, 请注意屏幕上显示的所有警告, 并对必要的警告加以纠正.
此外也需要查看 ` mdout.mdp `{.language-plaintext .highlighter-rouge}
文件的内容, 其中包括注释行以及 ` gmx grompp `{.language-plaintext
.highlighter-rouge} 读入的输入信息. 如果有疑问, 你可以使用
` -debug `{.language-plaintext .highlighter-rouge} 选项启动
` gmx grompp `{.language-plaintext .highlighter-rouge} , 这将会生成一个
` grompp.log `{.language-plaintext .highlighter-rouge}
文件(以及真正的调试信息), 里面包含了更多的信息. 你可以使用
` gmx dump `{.language-plaintext .highlighter-rouge}
程序查看运行输入文件的内容. ` gmx check `{.language-plaintext
.highlighter-rouge} 可用于比较两个运行输入文件的内容.

` -maxwarn `{.language-plaintext .highlighter-rouge} 选项可用于覆盖
` gmx grompp `{.language-plaintext .highlighter-rouge} 给出的警告,
否则会停止输出. 在某些情况下, 警告无关紧要, 但大多数情况下并非如此.
建议用户在使用这个选项绕过这些警告之前认真阅读并理解输出信息.

  选项                                  默认值 类型              说明
---------------------------- --------------- ----------------- -----------------------------------------------
  ` -f [<.mdp>] `                   grompp.mdp 输入              包含MD参数的grompp输入文件
  ` -po [<.mdp>] `                   mdout.mdp 输出              包含MD参数的grompp输入文件
  ` -c [<.gro/.g96/...>] `            conf.gro 输入              结构文件: gro g96 pdb brk ent esp tpr tpb tpa
  ` -r [<.gro/.g96/...>] `            conf.gro 输入, 可选        结构文件: gro g96 pdb brk ent esp tpr tpb tpa
  ` -rb [<.gro/.g96/...>] `           conf.gro 输入, 可选        结构文件: gro g96 pdb brk ent esp tpr tpb tpa
  ` -n [<.ndx>] `                    index.ndx 输入, 可选        索引文件
  ` -p [<.top>] `                    topol.top 输入              拓扑文件
  ` -pp [<.top>] `               processed.top 输出, 可选        拓扑文件
  ` -o [<.tpr/.tpb/...>] `           topol.tpr 输出              运行输入文件: tpr tpb tpa
  ` -t [<.trr/.cpt/...>] `            traj.trr 输入, 可选        全精度轨迹: trr cpt trj tng
  ` -e [<.edr>] `                     ener.edr 输入, 可选        能量文件
  ` -imd [<.gro>] `               imdgroup.gro 输出, 可选        Gromos-87格式的坐标文件
  ` -ref [<.trr/.cpt/...>] `        rotref.trr 输入/输出, 可选   全精度轨迹: trr cpt trj tng

  : 输入/输出文件选项 {#tab-73}

  选项                   默认值 说明
-------------------- -------- -----------------------------------------------------------------------
  ` -nice <int> `             0 设置优先级
  ` -[no]v `                 no 输出更多信息
  ` -time <real> `           -1 采用此刻的帧或此刻之后的第一帧
  ` -[no]rmvsbds `          yes 移除涉及虚拟位点的具有恒定能量的键合相互作用
  ` -maxwarn <int> `          0 处理输入过程中所允许的最大警告数目. 如果非正常使用可能导致体系不稳定.
  ` -[no]zero `              no 对没有默认值的键合相互作用, 将其参数设置为零, 而不是产生错误.
  ` -[no]renum `            yes 重新对原子类型进行编号以使原子类型的数目最小

  : 控制选项 {#tab-74}

## gmx gyrate: 计算蛋白质的回旋半径

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx gyrate [-f [<.xtc/.trr/...>]] [-s [<.tpr/.tpb/...>]] [-n [<.ndx>]]
           [-o [<.xvg>]] [-acf [<.xvg>]] [-nice ] [-b ]
           [-e ] [-dt ] [-[no]w] [-xvg ] [-nmol ]
           [-[no]q] [-[no]p] [-[no]moi] [-nz ] [-acflen ]
           [-[no]normalize] [-P ] [-fitfn ] [-beginfit ]
           [-endfit ]
```
:::
:::

` gmx gyrate `{.language-plaintext .highlighter-rouge}
用于计算分子的回旋半径, 分子关于X, Y和Z轴的回旋半径,
并给出它们随时间的变化关系. 计算时会明确地使用原子的质量权重.

将分析组划分为大小相同的几部分后, 可使用 ` -nmol `{.language-plaintext
.highlighter-rouge} 选项可以计算多个分子的回旋半径.

使用 ` -nz `{.language-plaintext .highlighter-rouge}
选项可计算沿Z轴方向X-Y切面内的2D回旋半径.

  选项                              默认值 类型         说明
-------------------------- ------------- ------------ ------------------------------------------------
  ` -f [<.xtc/.trr/...>] `        traj.xtc 输入         轨迹: xtc trr cpt trj gro g96 pdb tng
  ` -s [<.tpr/.tpb/...>] `       topol.tpr 输入         结构+质量(db): tpr tpb tpa gro g96 pdb brk ent
  ` -n [<.ndx>] `                index.ndx 输入, 可选   索引文件
  ` -o [<.xvg>] `               gyrate.xvg 输出         xvgr/xmgr文件
  ` -acf [<.xvg>] `            moi-acf.xvg 输出, 可选   xvgr/xmgr文件

  : 输入/输出文件选项 {#tab-75}

  选项                      默认值 说明
---------------------- --------- -------------------------------------------------------------------
  ` -nice <int> `               19 设置优先级
  ` -b <time> `                  0 从轨迹读取的第一帧(ps)
  ` -e <time> `                  0 从轨迹读取最后一帧(ps)
  ` -dt <time> `                 0 只使用t除以dt的余数等于第一帧时间(ps)的帧, 即两帧之间的时间间隔
  ` -[no]w `                    no 查看输出的.xvg, .xpm, .eps和.pdb文件
  ` -xvg <enum> `          xmgrace xvg绘图格式: xmgrace, xmgr, none
  ` -nmol <int> `                1 要分析的分子数目
  ` -[no]q `                    no 使用原子电荷的绝对值而不是质量作为权重因子
  ` -[no]p `                    no 计算关于主轴的回转半径
  ` -[no]moi `                  no 计算转动惯量(由主轴定义).
  ` -nz <int> `                  0 计算2D回转半径时沿Z轴的切片数
  ` -acflen <int> `             -1 ACF的长度, 默认为帧数的一半.
  ` -[no]normalize `           yes 归一化ACF
  ` -P <enum> `                  0 ACF Legendre多项式的阶数(0表示不使用): 0, 1, 2, 3
  ` -fitfn <enum> `           none 拟合函数: none, exp, aexp, exp_exp, vac, exp5, exp7, exp9, erffit
  ` -beginfit <real> `           0 对相关函数进行指数拟合的起始时间
  ` -endfit <real> `            -1 对相关函数进行指数拟合的终止时间, -1表示直到最终

  : 控制选项 {#tab-76}

### 补充说明

蛋白质的回旋半径反映了蛋白质分子的体积和形状. 同一体系的回旋半径越大,
说明体系越膨松.

## gmx h2order: 计算水分子的取向(翻译: 嘉晔, 严立京)

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx h2order [-f [<.xtc/.trr/...>]] [-n [<.ndx>]] [-nm [<.ndx>]]
            [-s [<.tpr/.tpb/...>]] [-o [<.xvg>]] [-nice ] [-b ]
            [-e ] [-dt ] [-[no]w] [-xvg ] [-d ]
            [-sl ]
```
:::
:::

` gmx h2order `{.language-plaintext .highlighter-rouge}
用于计算水分子相对于盒子法向的取向,
确定水分子偶极矩与盒子轴线间夹角的余弦平均值.
计算时盒子被划分为许多切片, 程序会输出每一切片的平均取向.
根据氧原子的位置, 每一时间帧中的每个水分子都被归属到某一切片中.
如果使用了 ` -nm `{.language-plaintext .highlighter-rouge} 选项,
程序将计算水分子偶极与从质心到氧原子的轴线之间的夹角,
而不是偶极与盒子轴线间的夹角.

  选项                            默认值 类型         说明
-------------------------- ----------- ------------ ---------------------------------------
  ` -f [<.xtc/.trr/...>] `      traj.xtc 输入         轨迹: xtc trr cpt trj gro g96 pdb tng
  ` -n [<.ndx>] `              index.ndx 输入         索引文件
  ` -nm [<.ndx>] `             index.ndx 输入, 可选   索引文件
  ` -s [<.tpr/.tpb/...>] `     topol.tpr 输入         运行输出文件: tpr tpb tpa
  ` -o [<.xvg>] `              order.xvg 输出         xvgr/xmgr文件

  : 输入/输出文件选项 {#tab-77}

  选项                 默认值 说明
----------------- --------- -----------------------------------------------------------------
  ` -nice <int> `          19 设置优先级
  ` -b <time> `             0 从轨迹文件中读取的第一帧(ps)
  ` -e <time> `             0 从轨迹文件中读取的最后一帧(ps)
  ` -dt <time> `            0 只使用t除以dt的余数等于第一帧时间(ps)的帧, 即两帧之间的时间间隔
  ` -[no]w `               no 查看输出的 ` .xvg ` , ` .xpm ` , ` .eps ` 以及 ` .pdb ` 文件
  ` -xvg <enum> `     xmgrace xvg绘图格式: xmgrace, xmgr, none
  ` -d <string> `           Z 膜的法线方向: X, Y或Z
  ` -sl <int> `             0 计算序参数与盒子长度的函数关系, 将盒子划分为指定数目的切片

  : 控制选项 {#tab-78}

### 已知问题

-   程序将整个水分子归属到某一切片时,
    是根据索引文件组中的三个原子中的第一个原子. 假定顺序为O, H, H.
    名称并不重要, 但顺序很关键. 如果不满足这个要求,
    将水分子归属到切片时差异很大.

## gmx hbond: 计算分析氢键

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx hbond [-f [<.xtc/.trr/...>]] [-s [<.tpr/.tpb/...>]] [-n [<.ndx>]]
          [-num [<.xvg>]] [-g [<.log>]] [-ac [<.xvg>]] [-dist [<.xvg>]]
          [-ang [<.xvg>]] [-hx [<.xvg>]] [-hbn [<.ndx>]] [-hbm [<.xpm>]]
          [-don [<.xvg>]] [-dan [<.xvg>]] [-life [<.xvg>]]
          [-nhbdist [<.xvg>]] [-nice ] [-b ] [-e ]
          [-dt ] [-tu ] [-xvg ] [-a ] [-r ]
          [-[no]da] [-r2 ] [-abin ] [-rbin ] [-[no]nitacc]
          [-[no]contact] [-shell ] [-fitstart ] [-fitend ]
          [-temp ] [-smooth ] [-dump ] [-max_hb ]
          [-[no]merge] [-acflen ] [-[no]normalize] [-P ]
          [-fitfn ] [-beginfit ] [-endfit ]
```
:::
:::

` gmx hbond `{.language-plaintext .highlighter-rouge}
用于计算和分析氢键.
氢键是由氢原子-施体-受体所成角度(0为扩展)的截断值与施体-受体之间距离(当使用
` -noda `{.language-plaintext .highlighter-rouge}
时为氢原子-受体距离)的截断值共同决定的. OH和NH被认作氢键施体,
O总是作为氢键受体, N默认为受体, 但可以利用
` -nitacc `{.language-plaintext .highlighter-rouge} 更改为施体.
哑的氢原子被假定为与前面的第一个非氢原子相连.

你需要指定用于分析的两个组, 它们必须完全相同或者彼此之间无任何重叠.
程序会分析两组间形成的所有氢键.

如果设置了 ` -shell `{.language-plaintext .highlighter-rouge} ,
就需要指定一个额外的索引组, 其中应该只包含一个原子. 在这种情况下,
计算时只会考虑距离这个原子某一壳层距离范围内的原子之间所形成的氢键.

使用选项 ` -ac `{.language-plaintext .highlighter-rouge} ,
会给出氢键的速率常数, 计算时采用Luzar和Chandler(Nature 394, 1996; J.
Chem. Phys. 113:23, 2000)的模型或Markovitz和Agmon (J. Chem. Phys 129,
2008)的模型. 如果使用 ` -contact `{.language-plaintext
.highlighter-rouge} 选项分析接触动力学,
n(t)可以定义为t时刻不处于接触距离r范围内的所有对(对应于
` -r2 `{.language-plaintext .highlighter-rouge} 选项使用默认值0),
或者处于距离r2范围内的所有对(对应于使用 ` -r2 `{.language-plaintext
.highlighter-rouge} 选项设置第二个截断值).
更多细节和定义请参考上面提到的文献.

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
[ selected ]
20 21 24
25 26 29
1 3 6
```
:::
:::

注意, 三联对需要处于同一行中. 每个原子三联对指定了要分析的氢键,
也要注意计算前不会对原子类型进行核对.

**输出**

-   ` -num `{.language-plaintext .highlighter-rouge} :
    随时间变化的氢键数目
-   ` -ac `{.language-plaintext .highlighter-rouge} :
    对所有氢键存在函数(0或1)的自相关函数进行平均
-   ` -dist `{.language-plaintext .highlighter-rouge} :
    所有氢键的距离分布
-   ` -ang `{.language-plaintext .highlighter-rouge} :
    所有氢键的角度分布
-   ` -hx `{.language-plaintext .highlighter-rouge} :
    随时间变化的n-n+i氢键数目, 其中n和n+i代表残基的数目, i的范围从0到6.
    这包括了蛋白螺旋中的n-n+3, n-n+4和n-n+5氢键.
-   ` -hbn `{.language-plaintext .highlighter-rouge} : 所有选择的组,
    选择组中的施体, 氢原子和受体, 所有组中形成氢键的所有原子,
    所有参与插入的溶剂原子.
-   ` -hbm `{.language-plaintext .highlighter-rouge} :
    所有帧中所有氢键存在矩阵, 也包含了溶剂插入氢键的信息. 顺序与
    ` -hbn `{.language-plaintext .highlighter-rouge}
    索引文件中的完全相同.
-   ` -dan `{.language-plaintext .highlighter-rouge} :
    输出分析的每时间帧中氢键施体和受体的数目. 当使用
    ` -shell `{.language-plaintext .highlighter-rouge} 时, 这尤其有用.
-   ` -nhbdist `{.language-plaintext .highlighter-rouge} :
    计算每个氢原子的氢键数, 以便将结果与Raman光谱相比较.

注意: 选项 ` -ac `{.language-plaintext .highlighter-rouge} ,
` -life `{.language-plaintext .highlighter-rouge} ,
` -hbn `{.language-plaintext .highlighter-rouge} 和
` -hbm `{.language-plaintext .highlighter-rouge}
需要的内存量正比于所选组中施体的总数目乘上受体的总数目.

  选项                              默认值 类型         说明
-------------------------- ------------- ------------ ---------------------------------------
  ` -f [<.xtc/.trr/...>] `        traj.xtc 输入         轨迹: xtc trr cpt trj gro g96 pdb tng
  ` -s [<.tpr/.tpb/...>] `       topol.tpr 输入         运行输入文件: tpr tpb tpa
  ` -n [<.ndx>] `                index.ndx 输入, 可选   索引文件
  ` -num [<.xvg>] `              hbnum.xvg 输出         xvgr/xmgr文件
  ` -g [<.log>] `                hbond.log 输出, 可选   Log文件
  ` -ac [<.xvg>] `                hbac.xvg 输出, 可选   xvgr/xmgr文件
  ` -dist [<.xvg>] `            hbdist.xvg 输出, 可选   xvgr/xmgr文件
  ` -ang [<.xvg>] `              hbang.xvg 输出, 可选   xvgr/xmgr文件
  ` -hx [<.xvg>] `             hbhelix.xvg 输出, 可选   xvgr/xmgr文件
  ` -hbn [<.ndx>] `              hbond.ndx 输出, 可选   索引文件
  ` -hbm [<.xpm>] `              hbmap.xpm 输出, 可选   与X PixMap兼容的矩阵文件
  ` -don [<.xvg>] `              donor.xvg 输出, 可选   xvgr/xmgr文件
  ` -dan [<.xvg>] `              danum.xvg 输出, 可选   xvgr/xmgr文件
  ` -life [<.xvg>] `            hblife.xvg 输出, 可选   xvgr/xmgr文件
  ` -nhbdist [<.xvg>] `        nhbdist.xvg 输出, 可选   xvgr/xmgr文件

  : 输入/输出文件选项 {#tab-79}

------------------------------------------------------------------------------------------------------
  选项                                     默认值 说明
----------------------- ----------------------- ------------------------------------------------------
  ` -nice <int> `                              19 设置优先级

  ` -b <time> `                                 0 从轨迹文件中读取的第一帧(ps)

  ` -e <time> `                                 0 从轨迹文件中读取的最后一帧(ps)

  ` -dt <time> `                                0 只使用t除以dt的余数等于第一帧时间(ps)的帧,
                                                  即两帧之间的时间间隔

  ` -tu <enum> `                               ps 时间单位: fs, ps, ns, us, ms, s

  ` -xvg <enum> `                         xmgrace xvg绘图格式: xmgrace, xmgr, none

  ` -a <real> `                                30 角度截断值(度, 氢原子-施体-受体)

  ` -r <real> `                              0.35 半径截断值(nm, X-受体, 见下一选项)

  ` -[no]da `                                 yes 使用施体-受体距离(若为真)或者氢原子-受体距离(若为假)

  ` -r2 <real> `                                0 第二半径截断值. 主要与 ` -contact ` 和 ` -ac `
                                                  一起使用

  ` -abin <real> `                              1 角度分布的分格宽度(度)

  ` -rbin <real> `                          0.005 距离分布的分格宽度(nm)

  ` -[no]nitacc `                             yes 将N原子视为受体

  ` -[no]contact `                             no 不查找氢键, 仅查找截断距离内的接触数

  ` -shell <real> `                            -1 当\>0时, 仅计算在一个粒子周围# nm范围内的氢键

  ` -fitstart <real> `                          1 拟合相关函数的起始时间(ps),
                                                  以便获得氢键断裂和形成的正向与反向速率常数.\
                                                  与 ` -gemfit ` 同用时, 我们建议使用 ` -fitstart 0 `

  ` -fitend <real> `                           60 拟合相关函数的终止时间(ps),
                                                  以便获得氢键断裂和形成的正向与反向速率常数. (仅与
                                                  ` -gemfit ` 同用)

  ` -temp <real> `                         298.15 计算氢键断裂和形成对应的吉布斯自由能的温度

  ` -smooth <real> `                           -1 如果\>=0, 会对ACF的尾部进行平滑,
                                                  平滑时使用指数函数拟合: y = A exp(-x/τ)

  ` -dump <int> `                               0 将第一个N氢键的ACF转存到单个的.xvg文件中, 用于调试

  ` -max_hb <real> `                            0 归一化氢键自相关函数时所用的氢键数目的理论最大值.
                                                  在程序估算错误的情况下, 此选项有用.

  ` -[no]merge `                              yes 相同施体和受体之间的氢键,
                                                  但不同氢原子作为单一氢键进行处理. 主要对ACF重要.

  ` -acflen <int> `                            -1 ACF的长度, 默认为帧数的一半.

  ` -[no]normalize `                          yes 对ACF进行归一化

  ` -P <enum> `                                 0 用于ACF的Legendre多项式的阶数(0代表不使用): 0, 1, 2, 3

  ` -fitfn <enum> `                          none 拟合函数: none, exp, aexp, exp_exp, vac, exp5, exp7,
                                                  exp9, erffit

  ` -beginfit <real> `                          0 相关函数指数拟合的起始时间

  ` -endfit <real> `                           -1 相关函数指数拟合的终止时间, -1代表直到最后
  ------------------------------------------------------------------------------------------------------

  : 控制选项 {#tab-80}

### 已知问题

-   用于所选氢键的选项 ` -sel `{.language-plaintext .highlighter-rouge}
    有问题, 因此暂时无法使用.

### 补充说明

使用 ` -hbn `{.language-plaintext .highlighter-rouge} 选项时默认输出
` hbond.ndx `{.language-plaintext .highlighter-rouge} 文件,
其中列出了两个所选组中的氢键受体, 施体,
施体氢和两个组间氢键的Acceptor-Donor-Hydrogen的原子序号. 其中
` donors_hydrogens `{.language-plaintext .highlighter-rouge}
部分数据格式类似如下:

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
1    2    1    3    1    4
18   19
56   57
```
:::
:::

示例所用为CRM1-NES binding domain, 首个残基为GLU,
上面的第一行1所指为N(donor), 之后2, 3, 4为N上所带的H(hydogens). 18,
19也是一样.

## gmx helix: 计算α螺旋结构的基本性质

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx helix [-s [<.tpr/.tpb/...>]] [-n [<.ndx>]] [-f [<.xtc/.trr/...>]]
          [-cz [<.gro/.g96/...>]] [-nice ] [-b ] [-e ]
          [-dt ] [-[no]w] [-r0 ] [-[no]q] [-[no]F] [-[no]db]
          [-[no]ev] [-ahxstart ] [-ahxend ]
```
:::
:::

` gmx helix `{.language-plaintext .highlighter-rouge}
计算各种类型螺旋的性质. 程序首先会检查多肽段, 找到最长的螺旋部分,
这由氢键和φ/ψ角度确定的. 再将其拟合成一个绕z轴的理想螺旋, 以原点居中.
然后计算以下性质:

1.  螺旋半径( ` radius.xvg `{.language-plaintext .highlighter-rouge}
    输出文件). 这仅仅是二维平面内所有C\~α\~原子的RMS偏差,
    计算方法为sqrt((sum_i (x\\\^2(i)+y\\\^2(i)))/N), 其中N为骨干原子数.
    理想螺旋的半径为0.23 nm.
2.  扭转( ` twist.xvg `{.language-plaintext .highlighter-rouge}
    输出文件). 计算每个残基的平均螺旋角. 对α螺旋此值为100度,
    对3-10螺旋值会更小, 5-螺旋的值更大.
3.  每个残基的上升量( ` rise.xvg `{.language-plaintext
    .highlighter-rouge} 输出文件).
    每个残基的螺旋上升量以C\~α\~原子z坐标的差值表示.
    对于理想螺旋此值为0.15 nm
4.  总螺旋长度( ` len-ahx.xvg `{.language-plaintext .highlighter-rouge}
    输出文件). 以nm为单位的总螺旋长度.
    其值简单由平均上升量(见上文)乘上螺旋残基数(见下文)计算.
5.  螺旋偶极. 只计算骨干原子的( ` dip-ahx.xvg `{.language-plaintext
    .highlighter-rouge} 输出文件).
6.  与理想螺旋的RMS偏差, 仅根据C\~α\~原子计算(
    ` rms-ahx.xvg `{.language-plaintext .highlighter-rouge} 输出文件).
7.  平均C\~α\~-C\~α\~二面角( ` phi-ahx.xvg `{.language-plaintext
    .highlighter-rouge} 输出文件)
8.  平均φ和ψ角度( ` phipsi.xvg `{.language-plaintext .highlighter-rouge}
    输出文件).
9.  根据Hirst和Brooks方法计算的222 nm处的椭圆度

  选项                             默认值 类型   说明
--------------------------- ----------- ------ ---------------------------------------
  ` -s [<.tpr/.tpb/...>] `      topol.tpr 输入   运行输入文件: tpr tpb tpa
  ` -n [<.ndx>] `               index.ndx 输入   索引文件
  ` -f [<.xtc/.trr/...>] `       traj.xtc 输入   轨迹: xtc trr cpt trj gro g96 pdb tng
  ` -cz [<.gro/.g96/...>] `     zconf.gro 输出   结构文件: gro g96 pdb brk ent esp

  : 输入/输出文件选项 {#tab-81}

  选项                    默认值 说明
--------------------- -------- -----------------------------------------------------------------
  ` -nice <int> `             19 设置优先级
  ` -b <time> `                0 从轨迹文件中读取的第一帧(ps)
  ` -e <time> `                0 从轨迹文件中读取的最后一帧(ps)
  ` -dt <time> `               0 只使用t除以dt的余数等于第一帧时间(ps)的帧, 即两帧之间的时间间隔
  ` -[no]w `                  no 查看输出的.xvg, .xpm, .eps和.pdb文件
  ` -r0 <int> `                1 序列中的第一个残基编号
  ` -[no]q `                  no 每一步都检查哪一部分序列是螺旋
  ` -[no]F `                 yes 是否拟合到理想螺旋
  ` -[no]db `                 no 输出调试信息
  ` -[no]ev `                 no 输出新的轨迹文件用于ED
  ` -ahxstart <int> `          0 螺旋的第一个残基
  ` -ahxend <int> `            0 螺旋的最后一个残基

  : 控制选项 {#tab-82}

## gmx helixorient: 计算螺旋内的局部螺距/弯曲/旋转/取向

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx helixorient [-s [<.tpr/.tpb/...>]] [-f [<.xtc/.trr/...>]] [-n [<.ndx>]]
                [-oaxis [<.dat>]] [-ocenter [<.dat>]] [-orise [<.xvg>]]
                [-oradius [<.xvg>]] [-otwist [<.xvg>]] [-obending [<.xvg>]]
                [-otilt [<.xvg>]] [-orot [<.xvg>]] [-nice ] [-b ]
                [-e ] [-dt ] [-xvg ] [-[no]sidechain]
                [-[no]incremental]
```
:::
:::

` gmx helixorient `{.language-plaintext .highlighter-rouge}
用于计算α螺旋内部平均轴的坐标和方向,
C\~α\~与(可选)侧链原子相对于轴的的方向/向量.

对输入, 你需要指定索引组, 其中的C\~α\~原子对应于连续残基的α螺旋.
侧链方向需要另一个原子数目相同的索引组, 包括每个残基中代表残基的重原子.

**注意** , 此程序不会对结构进行叠合.

我们需要四个C\~α\~的坐标来定义α螺旋轴的局部方向.

倾斜/旋转根据欧拉旋转计算, 其中定义的螺旋轴作为x轴方向,
残基/C\~α\~向量作为y轴方向, z轴方向由它们的叉积确定.
我们使用Y-Z-X次序的欧拉旋转, 这意味着我们 (1) 首先倾斜螺旋轴, (2)
然后使其与残基向量正交, (3) 最终对齐进行旋转. 为便于调试或满足其他用途,
我们在 ` theta[1-3].xvg `{.language-plaintext .highlighter-rouge}
文件中输出了实际的欧拉旋转角.

  选项                                默认值 类型         说明
-------------------------- --------------- ------------ ---------------------------------------
  ` -s [<.tpr/.tpb/...>] `         topol.tpr 输入         运行输入文件: tpr tpb tpa
  ` -f [<.xtc/.trr/...>] `          traj.xtc 输入         轨迹: xtc trr cpt trj gro g96 pdb tng
  ` -n [<.ndx>] `                  index.ndx 输入, 可选   索引文件
  ` -oaxis [<.dat>] `          helixaxis.dat 输出         通用数据文件
  ` -ocenter [<.dat>] `           center.dat 输出         通用数据文件
  ` -orise [<.xvg>] `               rise.xvg 输出         xvgr/xmgr文件
  ` -oradius [<.xvg>] `           radius.xvg 输出         xvgr/xmgr文件
  ` -otwist [<.xvg>] `             twist.xvg 输出         xvgr/xmgr文件
  ` -obending [<.xvg>] `         bending.xvg 输出         xvgr/xmgr文件
  ` -otilt [<.xvg>] `               tilt.xvg 输出         xvgr/xmgr文件
  ` -orot [<.xvg>] `            rotation.xvg 输出         xvgr/xmgr文件

  : 输入/输出文件选项 {#tab-83}

  选项                      默认值 说明
---------------------- --------- -----------------------------------------------------------------
  ` -nice <int> `               19 设置优先级
  ` -b <time> `                  0 从轨迹文件中读取的第一帧(ps)
  ` -e <time> `                  0 从轨迹文件中读取的最后一帧(ps)
  ` -dt <time> `                 0 只使用t除以dt的余数等于第一帧时间(ps)的帧, 即两帧之间的时间间隔
  ` -xvg <enum> `          xmgrace xvg绘图格式: xmgrace, xmgr, none
  ` -[no]sidechain `            no 计算侧链相对于螺旋轴的方向
  ` -[no]incremental `          no 计算旋转/倾斜的增量而不是总量

  : 控制选项 {#tab-84}

## gmx help - 打印帮助信息

## gmx hydorder: 计算给定原子周围的四面体参数

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx hydorder [-f [<.xtc/.trr/...>]] [-n [<.ndx>]] [-s [<.tpr/.tpb/...>]]
             [-o [<.xpm> [...]]] [-or [<.out> [...]]] [-Spect [<.out> [...]]]
             [-nice ] [-b ] [-e ] [-dt ] [-[no]w]
             [-d ] [-bw ] [-sgang1 ] [-sgang2 ]
             [-tblock ] [-nlevel ]
```
:::
:::

` gmx hydorder `{.language-plaintext .highlighter-rouge}
计算一个给定原子周围的四面体序参数, 可同时计算角和距离的序参数.
更多细节请参考 P.-L. Chau and A.J. Hardwick, *Mol. Phys.* , 93, (1998),
511-518.

` gmx hydorder `{.language-plaintext .highlighter-rouge}
计算盒子内3维网格中的序参数. 当盒子中存在两相时, 用户可以通过指定参数
` -sgang1 `{.language-plaintext .highlighter-rouge} 和
` -sgang2 `{.language-plaintext .highlighter-rouge}
来定义不同时刻分开两相的二维界面(明智地选择这些参数很重要).

  选项                                 默认值 类型         说明
--------------------------- --------------- ------------ ---------------------------------------
  ` -f [<.xtc/.trr/...>] `           traj.xtc 输入         轨迹: xtc trr cpt trj gro g96 pdb tng
  ` -n [<.ndx>] `                   index.ndx 输入         索引文件
  ` -s [<.tpr/.tpb/...>] `          topol.tpr 输入         运行输入文件: tpr tpb tpa
  ` -o [<.xpm> [...]] `              intf.xpm 输出         X PixMap兼容的矩阵文件
  ` -or [<.out> [...]] `              raw.out 输出, 可选   通用输出文件
  ` -Spect [<.out> [...]] `     intfspect.out 输出, 可选   通用输出文件

  : 输入/输出文件选项 {#tab-85}

  选项                   默认值 说明
-------------------- -------- -----------------------------------------------------------------
  ` -nice <int> `            19 设置优先级
  ` -b <time> `               0 从轨迹文件中读取的第一帧(ps)
  ` -e <time> `               0 从轨迹文件中读取的最后一帧(ps)
  ` -dt <time> `              0 只使用t除以dt的余数等于第一帧时间(ps)的帧, 即两帧之间的时间间隔
  ` -[no]w `                 no 查看输出.xvg, .xpm, .eps和.pdb文件
  ` -d <enum> `               z 膜的法线方向: z, x, y
  ` -bw <real> `              1 盒子网格的分格宽度
  ` -sgang1 <real> `          1 相1(体相)中的四面体角参数
  ` -sgang2 <real> `          1 相2(体相)中的四面体角参数
  ` -tblock <int> `           1 进行一次时间块平均所用的帧数
  ` -nlevel <int> `         100 2D-XPixMaps中高度的水平数

  : 控制选项 {#tab-86}

## gmx insert-molecules: 将分子插入已有空位

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx insert-molecules [-f [<.gro/.g96/...>]] [-ci [<.gro/.g96/...>]]
                     [-ip [<.dat>]] [-o [<.gro/.g96/...>]] [-nice ]
                     [-box ] [-nmol ] [-try ] [-seed ]
                     [-radius ] [-scale ] [-dr ] [-rot ]
                     [-[no]allpair]
```
:::
:::

` gmx insert-molecules `{.language-plaintext .highlighter-rouge}
命令可以插入 ` -nmol `{.language-plaintext .highlighter-rouge}
个体系的副本到盒子中, 体系由 ` -ci `{.language-plaintext
.highlighter-rouge} 输入文件定义. 插入的分子可以填充由
` -f `{.language-plaintext .highlighter-rouge}
指定的溶质分子构型中的空位, 或者填充由 ` -box `{.language-plaintext
.highlighter-rouge} 指定的空盒子. 同时指定 ` -f `{.language-plaintext
.highlighter-rouge} 和 ` -box `{.language-plaintext .highlighter-rouge}
选项等同于 ` -f `{.language-plaintext .highlighter-rouge} ,
但插入前会在溶质周围放置一个新盒子. 该命令运行过程中,
坐标文件中的速度不予考虑.

默认情况下, 插入的位置是随机的(初始随机数种子由
` -seed `{.language-plaintext .highlighter-rouge} 设置).
程序将会迭代直至将 ` -nmol `{.language-plaintext .highlighter-rouge}
个分子插入盒子中. 对某一位置,
若已存在的任意原子和插入分子任意原子之间的距离小于两个原子范德华半径之和,
则不会插入分子. 程序会读取数据文件( ` vdwradii.dat `{.language-plaintext
.highlighter-rouge} )中的范德华半径, 并根据
` -scale `{.language-plaintext .highlighter-rouge} 选项的设置进行缩放.
若不能在数据文件中找到所需的半径值, 相应的原子将通过
` -radius `{.language-plaintext .highlighter-rouge} 来设定(未缩放)距离.

停止前共进行 ` -nmol `{.language-plaintext .highlighter-rouge} \*
` -try `{.language-plaintext .highlighter-rouge} 次尝试插入.
若存在一些小的空隙需要填充, 可以增加 ` -try `{.language-plaintext
.highlighter-rouge} 的值. ` -rot `{.language-plaintext
.highlighter-rouge} 选项用于指定在尝试插入前是否对插入分子进行随机旋转.

作为替代, 也可以仅将分子插入到 ` positions.dat `{.language-plaintext
.highlighter-rouge} ( ` -ip `{.language-plaintext .highlighter-rouge}
)文件中指定的特定位置. 此文件应包含三列信息(x,y,z),
它们给出了相对于输入分子位置( ` -ci `{.language-plaintext
.highlighter-rouge} )的偏离位移. 因此, 如果该文件应包含绝对位置, 使用
` gmx insert-molecules `{.language-plaintext .highlighter-rouge}
命令前必须把分子的中心置于(0, 0, 0)(例如, 使用
` gmx editconf -center `{.language-plaintext .highlighter-rouge} ).
该文件中以 ` # `{.language-plaintext .highlighter-rouge}
开始的内容为注释, 会被忽略. ` -dr `{.language-plaintext
.highlighter-rouge} 选项定义了插入尝试中允许的最大位移.
` -try `{.language-plaintext .highlighter-rouge} 和
` -rot `{.language-plaintext .highlighter-rouge} 以默认模式运行(见上文).

  选项                                 默认值 类型         说明
--------------------------- --------------- ------------ -----------------------------------------------
  ` -f [<.gro/.g96/...>] `        protein.gro 输入, 可选   结构文件: gro g96 pdb brk ent esp tpr tpb tpa
  ` -ci [<.gro/.g96/...>] `        spc216.gro 输入         结构文件: gro g96 pdb brk ent esp tpr tpb tpa
  ` -ip [<.dat>] `              positions.dat 输入, 可选   通用数据文件
  ` -o [<.gro/.g96/...>] `            out.gro 输出         结构文件: gro g96 pdb brk ent esp

  : 输入/输出文件选项 {#tab-87}

-----------------------------------------------------------------------------------------
  选项                                     默认值 说明
----------------------- ----------------------- -----------------------------------------
  ` -nice <int> `                              19 设置优先级

  ` -box <vector> `                         0 0 0 盒子尺寸(nm)

  ` -nmol <int> `                               0 要插入的分子的数目

  ` -try <int> `                               10 尝试插入 ` -nmol ` 乘以 ` -try ` 次

  ` -seed <int> `                            1997 随机数发生器的种子

  ` -radius <real> `                        0.105 默认的范德华距离

  ` -scale <real> `                          0.57 用于数据文件
                                                  ` share/gromacs/top/vdwradii.dat `
                                                  中范德华半径的缩放因子.\
                                                  对水中的蛋白质,
                                                  使用默认值0.57可以得到接近1000
                                                  g/l的密度值.

  ` -dr <vector> `                          0 0 0 相对 ` -ip ` 文件中的位置,
                                                  在x/y/z方向允许的最大偏离位移

  ` -rot <enum> `                             xyz 随机旋转插入分子, 可用选项: xyz, z或none

  ` -[no]allpair `                             no 与 ` -ci `
                                                  选项同用时避免近邻搜索过程中的内存泄露.
                                                  对大的体系可能会比较慢.
  -----------------------------------------------------------------------------------------

  : 控制选项 {#tab-88}

### 已知问题

-   对初始构型所有分子必须保持完整.
-   使用 ` -ci `{.language-plaintext .highlighter-rouge} 选项时,
    重复的近邻搜索会占用大量内存, ` -allpair `{.language-plaintext
    .highlighter-rouge}
    选项可以通过检查所有原子之间的距离来避免这个问题(但对大的体系计算较慢).

### 补充说明

-   ` -ci `{.language-plaintext .highlighter-rouge} :
    为分子特定部位添加水环境, 只在研究的分子部位添加水环境,
    这样可以减少原子数, 节省计算时间
-   ` -seed `{.language-plaintext .highlighter-rouge} : 随机数种子,
    添加水分子时, 各个水分子的位置是随机的,
    可以改变这个随机数种子使水分子重新分布

## gmx lie: 根据线性组合估计自由能

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx lie [-f [<.edr>]] [-o [<.xvg>]] [-nice ] [-b ] [-e ]
        [-dt ] [-[no]w] [-xvg ] [-Elj ] [-Eqq ]
        [-Clj ] [-Cqq ] [-ligand ]
```
:::
:::

` gmx lie `{.language-plaintext .highlighter-rouge}
基于对非键能的能量分析估算自由能. 程序需要包含Coul-(A-B),
LJ-SR(A-B)等能量项的能量文件.

为正确使用 ` g_lie `{.language-plaintext .highlighter-rouge} ,
需要进行两次模拟: 一次是目标分子与受体结合的模拟,
一次是目标分子在水中的模拟. 两者都需要利用
` energygrps `{.language-plaintext .highlighter-rouge} 以使Coul-SR(A-B),
LJ-SR(A-B)等能量项写入 ` .edr `{.language-plaintext .highlighter-rouge}
文件. 水中分子的模拟数据可提供-Elj和-Eqq的合适值.

  选项                  默认值 类型   说明
----------------- ---------- ------ ---------------
  ` -f [<.edr>] `     ener.edr 输入   能量文件
  ` -o [<.xvg>] `      lie.xvg 输出   xvgr/xmgr文件

  : 输入/输出文件选项 {#tab-89}

  选项                      默认值 说明
---------------------- --------- -----------------------------------------------------------------
  ` -nice `                     19 设置优先级
  ` -b `                         0 从轨迹文件中读取的第一帧(ps)
  ` -e `                         0 从轨迹文件中读取的最后一帧(ps)
  ` -dt `                        0 只使用t除以dt的余数等于第一帧时间(ps)的帧, 即两帧之间的时间间隔
  ` -[no]w `                    no 查看输出的.xvg, .xpm, .eps和.pdb文件
  ` -xvg <enum> `          xmgrace xvg绘图格式: xmgrace, xmgr, none
  ` -Elj <real> `                0 配体和溶剂之间的Lennard-Jones相互作用
  ` -Eqq <real> `                0 配体和溶剂之间的库伦相互作用
  ` -Clj <real> `            0.181 LIE方程中能量Lennard-Jones分量的系数
  ` -Cqq <real> `              0.5 LIE方程中能量库伦分量的系数
  ` -ligand <string> `        none 能量文件中配体的名称

  : 控制选项 {#tab-90}

## gmx make_edi: 生成主成分动力学抽样的输入文件

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx make_edi [-f [<.trr/.cpt/...>]] [-eig [<.xvg>]] [-s [<.tpr/.tpb/...>]]
             [-n [<.ndx>]] [-tar [<.gro/.g96/...>]] [-ori [<.gro/.g96/...>]]
             [-o [<.edi>]] [-nice ] [-xvg ] [-mon ]
             [-linfix ] [-linacc ] [-radfix ]
             [-radacc ] [-radcon ] [-flood ]
             [-outfrq ] [-slope ] [-linstep ]
             [-accdir ] [-radstep ] [-maxedsteps ]
             [-eqsteps ] [-deltaF0 ] [-deltaF ]
             [-tau ] [-Eflnull ] [-T ] [-alpha ]
             [-[no]restrain] [-[no]hessian] [-[no]harmonic]
             [-constF ]
```
:::
:::

` gmx make_edi `{.language-plaintext .highlighter-rouge}
用于产生一个主成分动力学(ED, essential dynamics)抽样的输入文件供
` gmx mdrun `{.language-plaintext .highlighter-rouge} 使用,
产生方法基于来自协方差矩阵( ` gmx covar `{.language-plaintext
.highlighter-rouge} )或简正模式分析( ` gmx nmeig `{.language-plaintext
.highlighter-rouge} )的特征向量. 在模拟过程中,
ED抽样可用于沿集约坐标(特征向量)操控(生物)大分子的位置. 特别地,
通过促使体系沿这些集约坐标探测新的区域,
ED抽样可用于提高MD模拟的抽样效率.
有大量的算法可以驱使体系沿特征向量运动( ` -linfix `{.language-plaintext
.highlighter-rouge} , ` -linacc `{.language-plaintext
.highlighter-rouge} , ` -radfix `{.language-plaintext
.highlighter-rouge} , ` -radacc `{.language-plaintext
.highlighter-rouge} , ` -radcon `{.language-plaintext
.highlighter-rouge} ), 维持沿确定(系列)坐标的位置固定(
` -linfix `{.language-plaintext .highlighter-rouge} ),
或者仅仅监测位置在这些坐标上的投影( ` -mon `{.language-plaintext
.highlighter-rouge} )

参考文献:

-   A. Amadei, A.B.M. Linssen, B.L. de Groot, D.M.F. van Aalten and
    H.J.C. Berendsen; An efficient method for sampling the essential
    subspace of proteins., *J. Biomol. Struct. Dyn.* 13:615-626 (1996)
-   B.L. de Groot, A. Amadei, D.M.F. van Aalten and H.J.C. Berendsen;
    Towards an exhaustive sampling of the configurational spaces of the
    two forms of the peptide hormone guanylin, *J. Biomol. Struct. Dyn.*
    13 : 741-751 (1996)
-   B.L. de Groot, A.Amadei, R.M. Scheek, N.A.J. van Nuland and H.J.C.
    Berendsen; An extended sampling of the configurational space of HPr
    from E. coli, *Proteins: Struct. Funct. Gen.* 26: 314-322 (1996)

运行时程序会提示选择一个或者多个索引组, 它们对应于特征向量, 参考结构,
目标位置等.

` -mon `{.language-plaintext .highlighter-rouge} :
监测坐标在选定特征向量上的投影

` -linfix `{.language-plaintext .highlighter-rouge} :
沿选定特征向量进行固定步数的线性扩张

` -linacc `{.language-plaintext .highlighter-rouge} :
沿选定特征向量进行可接受线性扩张. (接受期望方向上的步进, 拒绝其他的)

` -radfix `{.language-plaintext .highlighter-rouge} :
沿选定特征向量进行固定步数的径向扩张.

` -radacc `{.language-plaintext .highlighter-rouge} :
沿选定特征向量进行可接受径向扩张. (接受期望方向上的步进, 拒绝其他的).
**注意** : 默认将使用起始MD结构作为第一次径向扩张循环的起点. 如果指定了
` -ori `{.language-plaintext .highlighter-rouge} 选项,
可以读入一个结构文件定义外部起点.

` -radcon `{.language-plaintext .highlighter-rouge} :
沿选定特征向量进行可接受径向收缩, 收缩指向的目标结构由
` -tar `{.language-plaintext .highlighter-rouge} 选项指定.

**注意** : 每个特征向量只能选择一次.

` -outfrq `{.language-plaintext .highlighter-rouge} : 将投影等写入
` .xvg `{.language-plaintext .highlighter-rouge}
文件的频率(以步数为单位)

` -slope `{.language-plaintext .highlighter-rouge} :
可接受径向扩张的最小斜率.
如果半径的瞬时增长率(以nm/step为单位)小于规定数值,
将开始一个新的扩张循环.

` -maxedsteps `{.language-plaintext .highlighter-rouge} :
在开始一个新循环前, 径向扩张中每个循环的最大步数.

并行实现的注意点: 由于ED抽样的"全局性"(集约坐标等), 至少在"蛋白质"方面,
从实现的角度看ED抽样并不太适合并行. 因为并行ED需要一些额外的通讯,
除非运行性能低于不受约束的MD模拟,
尤其是当进程数目很大和/或当ED组包含大量原子时.

同时请注意如果你的ED组包含不止一个蛋白质, 那么
` .tpr `{.language-plaintext .highlighter-rouge}
文件必须包含ED组的正确PBC表示. 查看一下参考结构的初始RMSD值,
这个数值在模拟一开始就会输出; 如果此数值远远高于期望值,
某个ED分子可能沿盒向量方向平移了几个单位.

` gmx mdrun `{.language-plaintext .highlighter-rouge}
程序中所有与ED相关的输出作为时间的函数都写在一个
` .xvg `{.language-plaintext .highlighter-rouge} 文件中,
输出的间隔步数由 ` -outfrq `{.language-plaintext .highlighter-rouge}
指定.

**注意** , 如果一开始合并了多个 ` .edi `{.language-plaintext
.highlighter-rouge} 文件,
在一个模拟中你可以(在不同分子上)施加多个ED约束和洪泛势能.
约束的施加顺序按照它们出现在 ` .edi `{.language-plaintext
.highlighter-rouge} 文件中的顺序. 根据 ` .edi `{.language-plaintext
.highlighter-rouge} 输入文件中的指定, 对每个ED数据集,
输出文件中可能包含以下内容:

-   分子叠合到参考结构的RMSD值
-   位置在选定特征向量上的投影

**洪泛**

使用 ` -flood `{.language-plaintext .highlighter-rouge} 选项,
你可以指定使用哪个特征向量计算洪泛势能, 它将导致额外的力,
将结构排除出由协方差矩阵描述的某些区域. 如果你使用了
` -restrain `{.language-plaintext .highlighter-rouge} 选项, 势能将反转,
可以将结构保持在特定区域内.

模拟起始点通常是存储在 ` eigvec.trr `{.language-plaintext
.highlighter-rouge} 文件中的平均结构. 使用 ` -ori `{.language-plaintext
.highlighter-rouge} 选项, 可以把起始点更改为构象空间中的任意一个位置.
使用 ` -tau `{.language-plaintext .highlighter-rouge} ,
` -deltaF0 `{.language-plaintext .highlighter-rouge} 和
` -Eflnull `{.language-plaintext .highlighter-rouge} 选项,
你可以控制洪泛的行为. Efl为洪泛强度, 根据自适应洪泛的规则进行更新.
Tau为自适应洪泛的时间常数, 大的τ值意味着自适应慢(即增长慢).
DeltaF0为经过tau皮秒模拟之后想达到的洪泛强度. 如果想使Efl为常数, 可将
` -tau `{.language-plaintext .highlighter-rouge} 设置成零.

` -alpha `{.language-plaintext .highlighter-rouge}
为控制洪泛势能宽度的经验参数. 当其值为2时,
对于蛋白质洪泛的大多数标准例子都能给出很好的结果.
α基本用于考虑抽样的不完整性. 如果进行更多的抽样, 系综宽度将会增大,
这可以通过α\>1来模拟. 对限制, α&#lt;1得到的限制势的宽度更小.

洪泛模拟的重新开始: 如果你想重新开始一个已经崩溃的洪泛模拟,
请在输出文件中找到deltaF和Efl的值, 然后手动地将它们分别放入
` .edi `{.language-plaintext .highlighter-rouge}
文件中DELTA_F0和EFL_NULL中.

  选项                                 默认值 类型         说明
---------------------------- -------------- ------------ ------------------------------------------------
  ` -f [<.trr/.cpt/...>] `       eigenvec.trr 输入         全精度轨迹: trr cpt trj tng
  ` -eig [<.xvg>] `              eigenval.xvg 输入, 可选   xvgr/xmgr文件
  ` -s [<.tpr/.tpb/...>] `          topol.tpr 输入         结构+质量(db): tpr tpb tpa gro g96 pdb brk ent
  ` -n [<.ndx>] `                   index.ndx 输入, 可选   索引文件
  ` -tar [<.gro/.g96/...>] `       target.gro 输入, 可选   结构文件: gro g96 pdb brk ent esp tpr tpb tpa
  ` -ori [<.gro/.g96/...>] `       origin.gro 输入, 可选   结构文件: gro g96 pdb brk ent esp tpr tpb tpa
  ` -o [<.edi>] `                     sam.edi 输出         ED抽样输入

  : 输入/输出文件选项 {#tab-91}

-----------------------------------------------------------------------------------------
  选项                                     默认值 说明
----------------------- ----------------------- -----------------------------------------
  ` -nice <int> `                               0 设置优先级

  ` -xvg <enum> `                         xmgrace xvg绘图格式: xmgrace, xmgr, none

  ` -mon <string> `                               x投影方向的特征向量索引(如 ` 1,2-5,9 ` ,
                                                  或 ` 1-100:10 ` 表示1 11 21 31 \... 91)

  ` -linfix <string> `                            固定增量线性抽样的特征向量索引

  ` -linacc <string> `                            可接受线性抽样的特征向量索引

  ` -radfix <string> `                            固定增量径向扩张的特征向量索引

  ` -radacc <string> `                            可接受径向扩张的特征向量索引

  ` -radcon <string> `                            可接受径向收缩的特征向量索引

  ` -flood <string> `                             洪泛的特征向量索引

  ` -outfrq <int> `                           100 输出 ` .xvg ` 文件的频率(单位: 步数)

  ` -slope <real> `                             0 可接受径向扩张的最小斜率

  ` -linstep <string> `                           固定增量线性抽样的步长(nm/step)
                                                  (要放在引号内! 如 ` "1.0 2.3 5.1 -3.1" `
                                                  )

  ` -accdir <string> `                            可接受线性抽样的方向\--只考虑正负号
                                                  (要放在引号内! 如 ` "-1 +1 -1.1" ` )

  ` -radstep <real> `                           0 固定增量径向扩张的步长(nm/step)

  ` -maxedsteps <int> `                         0 每个循环的最大步数

  ` -eqsteps <int> `                            0 无微扰运行的步数

  ` -deltaF0 <real> `                         150 洪泛模拟中目标失稳能量

  ` -deltaF <real> `                            0 起始的deltaF使用指定值. 默认为0,
                                                  非零值只用于重启模拟

  ` -tau <real> `                             0.1 相应于deltaF0洪泛强度自适应的耦合常数,
                                                  0等于无限大, 也就是洪泛强度为常数

  ` -Eflnull <real> `                           0 洪泛强度的起始值.
                                                  洪泛强度会根据自适应洪泛方案进行更新.
                                                  使用恒定的洪泛强度时请指定 ` -tau 0 ` .

  ` -T <real> `                               300 T是温度, 做洪泛模拟需要这个数据

  ` -alpha <real> `                             1 使用alpha\^2\^缩放高斯洪泛势能的宽度

  ` -[no]restrain `                            no 使用反转的洪泛势能, 效果类似准简谐限制势

  ` -[no]hessian `                             no 特性向量和特征值来自Hessian矩阵

  ` -[no]harmonic `                            no 将特征值视为弹簧常数

  ` -constF <string> `                            恒力洪泛: 利用 ` -flood `
                                                  手动设置选定特征向量的力(要放在引号内! 如
                                                  ` "1.0 2.3 5.1 -3.1" ` ).\
                                                  当直接指定力的大小时不需要其他洪泛参数.
  -----------------------------------------------------------------------------------------

  : 控制选项 {#tab-92}

## gmx make_ndx: 制作索引文件

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx make_ndx [-f [<.gro/.g96/...>]] [-n [<.ndx> [...]]] [-o [<.ndx>]]
             [-nice ] [-natoms ] [-[no]twin]
```
:::
:::

几乎每个GROMACS程序都需要使用索引组. 所有程序都可以生成默认的索引组.
**只有** 需要 **特殊** 索引组的时候, 你才不得不使用
` gmx make_ndx `{.language-plaintext .highlighter-rouge} . 一般情况下,
整个体系会有一个默认组, 蛋白质会有九个默认组,
每个其他的残基会有一个默认组.

当没有提供索引文件时, ` gmx make_ndx `{.language-plaintext
.highlighter-rouge} 也会生成这些默认组. 借助命令中的索引编辑器,
你可以选择原子, 残基或链的名称和数目. 如果提供了运行输入文件,
你也可以选择原子类型. 可以使用NOT, AND或OR等逻辑判断词,
你可以将索引组分成链, 残基会原子. 你也可以随意删除或重命名索引组.

在索引编辑器和索引文件中, 原子编号都是从1开始的.

选项 ` -twin `{.language-plaintext .highlighter-rouge}
可以复写所有索引组, 并对其施加 ` -natoms `{.language-plaintext
.highlighter-rouge} 的偏移. 在设置计算电生理双层膜时, 这个选项很有用.

  选项                            默认值 类型         说明
-------------------------- ----------- ------------ -----------------------------------------------
  ` -f [<.gro/.g96/...>] `      conf.gro 输入, 可选   结构文件: gro g96 pdb brk ent esp tpr tpb tpa
  ` -n [<.ndx> [...]] `        index.ndx 输入, 可选   索引文件
  ` -o [<.ndx>] `              index.ndx 输出         索引文件

  : 输入/输出文件选项 {#tab-93}

  选项                  默认值 说明
------------------- -------- -----------------------------------------
  ` -nice <int> `            0 设置优先级
  ` -natoms <int> `          0 设置原子数(默认从坐标或索引文件中读取)
  ` -[no]twin `             no 复写所有索引组并进行 ` -natoms ` 的偏移

  : 控制选项 {#tab-94}

### 补充说明

GROMACS的索引文件, 即index文件, 扩展名为 ` .ndx `{.language-plaintext
.highlighter-rouge} , 可使用 ` make_ndx `{.language-plaintext
.highlighter-rouge} 程序生成.

索引文件是GROMACS的重要文件, 使用它可以在模拟过程中为所欲为.
举一个简单的例子, 如果想详细了解HIV整合酶切割DNA的反应机理,
使用量子力学方法模拟反应位点的反应过程,
而对其他部位使用一般的分子力学方法进行模拟.
于是我们就面临一个对模拟体系进行分开定义的问题. 在GROMACS中,
我们可以使用索引文件来达到目的. 基本思路是这样的, 在索引文件中,
定义一个独立的组, 这个组包括反应位点附近的所有原子. 在模拟的
` .mdp `{.language-plaintext .highlighter-rouge} 文件中,
对这个组定义使用量子力学模拟. 对蛋白进行量子力学模拟时,
一般使用洋葱模型. 所谓洋葱模型, 就是对反应位点使用高水平的方法,
对距离反应位点一定半径范围内的, 使用低水平的方法,
然后其他部分使用分子力学方法. 在这种情况下,
就可以在索引文件中定义高水平方法组,
把需要使用高水平方法的原子放到这个组中; 再定义低水平方法组,
指定使用低水平方法的原子.

再举一个例子, 比如说在进行SMD(Steered Molecular Dynamics)时,
要对蛋白膜上的一个原子或者残基施加作用力, 那么可以建立一个索引文件,
在该文件中定义一个组, 把要施力的残基或者原子放到该组中.
然后在相应的文件中就可以使用该组了.

` make_ndx `{.language-plaintext .highlighter-rouge}
程序可用来选择原子组(要分析的某些特定原子或残基的ID标签)并创建索引文件.
GROMACS已经定义了一些默认的组, 对普通分析可能够用了,
但如果你想进行更深入的分析, 如为了在模拟中固定某些特定的组,
或获得某些组的特殊能量信息, 则需要使用 ` make_ndx `{.language-plaintext
.highlighter-rouge} 程序来指定这些组.

运行 ` make_ndx `{.language-plaintext .highlighter-rouge} 后, 可使用
` r `{.language-plaintext .highlighter-rouge} 选择残基,
` a `{.language-plaintext .highlighter-rouge} 选择原子,
` name `{.language-plaintext .highlighter-rouge} 对多组进行改名,
还可以使用 ` | `{.language-plaintext .highlighter-rouge} 表示或运算,
` & `{.language-plaintext .highlighter-rouge} 表示与运算.
下面是几个简单的例子:

-   ` r 56 `{.language-plaintext .highlighter-rouge} : 选择56号残基
-   ` r 1 36 37 `{.language-plaintext .highlighter-rouge} :
    选择不连续的残基
-   ` r 3-45 `{.language-plaintext .highlighter-rouge} :
    选择3至45号残基, 使用连接符指定残基标号范围
-   ` r 3-15 | r 23-67 `{.language-plaintext .highlighter-rouge} :
    选择3至15, 23至67号残基
-   ` r 3-15 & 4 `{.language-plaintext .highlighter-rouge} :
    选择3至15号残基的主干链原子, 在索引文件中, 4号组为默认的主干链.
-   ` r 1-36 & a C N CA `{.language-plaintext .highlighter-rouge} :
    使用包含 ` & `{.language-plaintext .highlighter-rouge}
    的命令指定只包含骨架原子的残基范围

新建索引组的默认名称(如 ` r_1_36_37 `{.language-plaintext
.highlighter-rouge} )很繁琐, 可以使用 ` name `{.language-plaintext
.highlighter-rouge} 命令进行修改. 如
` name 15 Terminal `{.language-plaintext .highlighter-rouge} 可将组
` 15 `{.language-plaintext .highlighter-rouge} 的名称改为
` Terminal `{.language-plaintext .highlighter-rouge} .
修改后我们可以使用 ` v `{.language-plaintext .highlighter-rouge}
命令查看名称是否修改成功, 使用 ` q `{.language-plaintext
.highlighter-rouge} 命令保存修改并退出.

需要注意的一点就是, 对 ` make_ndx `{.language-plaintext
.highlighter-rouge} 的选择, 处理是由左向右依次执行的,
` & `{.language-plaintext .highlighter-rouge} 和
` | `{.language-plaintext .highlighter-rouge} 没有优先级别之分. 如
` r 1-3 | r 5-9 & CA `{.language-plaintext .highlighter-rouge}
会先选择1-3, 5-9号残基, 再从中选择CA原子.

下面是使用示例:

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
There are:     0      OTHER residues
There are:   960    PROTEIN residues
There are:     0        DNA residues
Analysing Protein...

  0 System              : 14571 atoms
  1 Protein             : 14571 atoms
  2 Protein-H           :  7479 atoms
  3 C-alpha             :   960 atoms
  4 Backbone            :  2880 atoms
  5 MainChain           :  3844 atoms
  6 MainChain+Cb        :  4730 atoms
  7 MainChain+H         :  4744 atoms
  8 SideChain           :  9827 atoms
  9 SideChain-H         :  3635 atoms

nr : group      !   'name' nr name  'splitch' nr   Enter: list groups
'a': atom       &   'del' nr        'splitres' nr  'l': list residues
't': atom type  |   'keep' nr       'splitat' nr   'h': help
'r': residue        'res' nr        'chain' char
"name": group       'case': case sensitive          'q': save and quit
```
:::
:::

命令 ` r 1 - 355 `{.language-plaintext .highlighter-rouge}

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
Found 5467 atoms with res.nr. in range 1-355

 10 r_1-355             :  5467 atoms
  0 System              : 14571 atoms
  1 Protein             : 14571 atoms
  2 Protein-H           :  7479 atoms
  3 C-alpha             :   960 atoms
  4 Backbone            :  2880 atoms
  5 MainChain           :  3844 atoms
  6 MainChain+Cb        :  4730 atoms
  7 MainChain+H         :  4744 atoms
  8 SideChain           :  9827 atoms
  9 SideChain-H         :  3635 atoms
 10 r_1-355             :  5467 atoms
```
:::
:::

命令\
` name 10 SUB_H `{.language-plaintext .highlighter-rouge}\
` 10 & 2 `{.language-plaintext .highlighter-rouge}

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
Copied index group 10 'SUB_H'
Copied index group 2 'Protein-H'
Merged two groups with AND: 5467 7479 -> 2783

 11 SUB_H_&_Protein-H   :  2783 atoms
```
:::
:::

命令 ` name 11 SUB_H_HEAVY `{.language-plaintext .highlighter-rouge}

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
  0 System              : 14571 atoms
  1 Protein             : 14571 atoms
  2 Protein-H           :  7479 atoms
  3 C-alpha             :   960 atoms
  4 Backbone            :  2880 atoms
  5 MainChain           :  3844 atoms
  6 MainChain+Cb        :  4730 atoms
  7 MainChain+H         :  4744 atoms
  8 SideChain           :  9827 atoms
  9 SideChain-H         :  3635 atoms
 10 SUB_H               :  5467 atoms
 11 SUB_H_HEAVY         :  2783 atoms
 12 SUB_H_BB            :  1065 atoms
```
:::
:::

命令 ` splitch 1 `{.language-plaintext .highlighter-rouge}

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
Found 4 chains
1:  5467 atoms (1 to 5467)
2:  5467 atoms (5468 to 10934)
3:  1816 atoms (10935 to 12750)
4:  1821 atoms (12751 to 14571)
```
:::
:::

命令 ` del 5-13 `{.language-plaintext .highlighter-rouge}

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
  0 System              : 14571 atoms
  1 Protein             : 14571 atoms
  2 Protein-H           :  7479 atoms
  3 C-alpha             :   960 atoms
  4 Backbone            :  2880 atoms
  5 SUB_H_BB            :  1065 atoms
  6 SUB_J_BB            :  1065 atoms
  7 SUB_M_BB            :   375 atoms
  8 SUB_L_BB            :   375 atoms
```
:::
:::

命令 ` r 886 905 `{.language-plaintext .highlighter-rouge}

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
9 r_886_905           :    40 atoms
```
:::
:::

命令 ` splitat 9 `{.language-plaintext .highlighter-rouge}

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
  0 System              : 14571 atoms
  1 Protein             : 14571 atoms
  2 Protein-H           :  7479 atoms
  3 C-alpha             :   960 atoms
  4 Backbone            :  2880 atoms
  5 SUB_H_BB            :  1065 atoms
  6 SUB_J_BB            :  1065 atoms
  7 SUB_M_BB            :   375 atoms
  8 SUB_L_BB            :   375 atoms
  9 r_886_905           :    40 atoms
 10 r_886_905_N_13464   :     1 atoms
 11 r_886_905_H_13465   :     1 atoms
 ...
 32 r_886_905_CM_13486  :     1 atoms
 33 r_886_905_HM1_13487 :     1 atoms
 34 r_886_905_HM2_13488 :     1 atoms
 35 r_886_905_HM3_13489 :     1 atoms
 ...
 45 r_886_905_CG_13770  :     1 atoms
 46 r_886_905_OD1_13771 :     1 atoms
 47 r_886_905_OD2_13772 :     1 atoms
 48 r_886_905_C_13773   :     1 atoms
 49 r_886_905_O_13774   :     1 atoms
```
:::
:::

命令\
` del 9-31 `{.language-plaintext .highlighter-rouge}\
` del 13 -21 `{.language-plaintext .highlighter-rouge}\
` del 16-17 `{.language-plaintext .highlighter-rouge}

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
  0 System              : 14571 atoms
  1 Protein             : 14571 atoms
  2 Protein-H           :  7479 atoms
  3 C-alpha             :   960 atoms
  4 Backbone            :  2880 atoms
  5 SUB_H_BB            :  1065 atoms
  6 SUB_J_BB            :  1065 atoms
  7 SUB_M_BB            :   375 atoms
  8 SUB_L_BB            :   375 atoms
  9 r_886_905_CM_13486  :     1 atoms
 10 r_886_905_HM1_13487 :     1 atoms
 11 r_886_905_HM2_13488 :     1 atoms
 12 r_886_905_HM3_13489 :     1 atoms
 13 r_886_905_CG_13770  :     1 atoms
 14 r_886_905_OD1_13771 :     1 atoms
 15 r_886_905_OD2_13772 :     1 atoms
```
:::
:::

## gmx mdmat: 计算残基接触映射图

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx mdmat [-f [<.xtc/.trr/...>]] [-s [<.tpr/.tpb/...>]] [-n [<.ndx>]]
          [-mean [<.xpm>]] [-frames [<.xpm>]] [-no [<.xvg>]] [-nice ]
          [-b ] [-e ] [-dt ] [-xvg ] [-t ]
          [-nlevels ]
```
:::
:::

` gmx mdmat `{.language-plaintext .highlighter-rouge}
创建残基对之间的最小距离构成的矩阵. 使用 ` -frames `{.language-plaintext
.highlighter-rouge} 选项时, 可以将这些矩阵按顺序存储下来,
用以查看蛋白质三级结构随着时间的变化. 如果不明智地使用选项,
程序可能会生成非常大的输出文件.
默认只输出对整个轨迹进行平均后的距离矩阵. 同时,
也可以输出整个轨迹中残基间不同原子之间的接触数. 输出文件可以利用
` gmx xpm2ps `{.language-plaintext .highlighter-rouge}
进行处理以生成PostScript(tm)图.

  选项                            默认值 类型         说明
-------------------------- ----------- ------------ ------------------------------------------------
  ` -f [<.xtc/.trr/...>] `      traj.xtc 输入         轨迹: xtc trr cpt trj gro g96 pdb tng
  ` -s [<.tpr/.tpb/...>] `     topol.tpr 输入         结构+质量(db): tpr tpb tpa gro g96 pdb brk ent
  ` -n [<.ndx>] `              index.ndx 输入, 可选   索引文件
  ` -mean [<.xpm>] `              dm.xpm 输出         与X PixMap兼容的矩阵文件
  ` -frames [<.xpm>] `           dmf.xpm 输出, 可选   与X PixMap兼容的矩阵文件
  ` -no [<.xvg>] `               num.xvg 输出, 可选   xvgr/xmgr文件

  : 输入/输出文件选项 {#tab-95}

  选项                    默认值 说明
-------------------- --------- -----------------------------------------------------------------
  ` -nice <int> `             19 设置优先级
  ` -b <time> `                0 从轨迹文件中读取的第一帧(ps)
  ` -e <time> `                0 从轨迹文件中读取的最后一帧(ps)
  ` -dt <time> `               0 只使用t除以dt的余数等于第一帧时间(ps)的帧, 即两帧之间的时间间隔
  ` -xvg <enum> `        xmgrace xvg绘图格式: xmgrace, xmgr, none
  ` -t <real> `              1.5 切断距离
  ` -nlevels <int> `          40 距离的离散水平数

  : 控制选项 {#tab-96}

## gmx mdrun: 执行模拟, 简正分析或能量最小化

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx mdrun [-s [<.tpr/.tpb/...>]] [-o [<.trr/.cpt/...>]] [-x [<.xtc/.tng>]]
          [-cpi [<.cpt>]] [-cpo [<.cpt>]] [-c [<.gro/.g96/...>]]
          [-e [<.edr>]] [-g [<.log>]] [-dhdl [<.xvg>]] [-field [<.xvg>]]
          [-table [<.xvg>]] [-tabletf [<.xvg>]] [-tablep [<.xvg>]]
          [-tableb [<.xvg>]] [-rerun [<.xtc/.trr/...>]] [-tpi [<.xvg>]]
          [-tpid [<.xvg>]] [-ei [<.edi>]] [-eo [<.xvg>]] [-devout [<.xvg>]]
          [-runav [<.xvg>]] [-px [<.xvg>]] [-pf [<.xvg>]] [-ro [<.xvg>]]
          [-ra [<.log>]] [-rs [<.log>]] [-rt [<.log>]] [-mtx [<.mtx>]]
          [-dn [<.ndx>]] [-multidir [
       [...]]] [-membed [<.dat>]]
               [-mp [<.top>]] [-mn [<.ndx>]] [-if [<.xvg>]] [-swap [<.xvg>]]
               [-nice ] [-deffnm ] [-xvg ] [-dd ]
               [-ddorder ] [-npme ] [-nt ] [-ntmpi ]
               [-ntomp ] [-ntomp_pme ] [-pin ] [-pinoffset ]
               [-pinstride ] [-gpu_id ] [-[no]ddcheck] [-rdd ]
               [-rcon ] [-dlb ] [-dds ] [-gcom ]
               [-nb ] [-nstlist ] [-[no]tunepme] [-[no]testverlet]
               [-[no]v] [-[no]compact] [-[no]seppot] [-pforce ]
               [-[no]reprod] [-cpt ] [-[no]cpnum] [-[no]append]
               [-nsteps ] [-maxh ] [-multi ] [-replex ]
               [-nex ] [-reseed ]
```
:::
:::

` gmx mdrun `{.language-plaintext .highlighter-rouge}
是GROMACS的主要计算化学引擎. 很显然, 它执行分子动力学模拟,
但它也可以执行随机动力学, 能量最小化, 测试粒子插入或(重新)计算能量.
它还可以进行简正模式分析. 在这种情况下 ` mdrun `{.language-plaintext
.highlighter-rouge} 可以根据单一的构象计算Hessian矩阵.
对于通常的简正模式类计算, 请确保所提供的结构已经正确地进行过能量最小化.
可以使用 ` gmx nmeig `{.language-plaintext .highlighter-rouge}
对得到的矩阵进行对角化.

` mdrun `{.language-plaintext .highlighter-rouge} 程序读取运行输入文件(
` -s `{.language-plaintext .highlighter-rouge} ), 如果需要,
它会将拓扑分发给不同的进程号. ` mdrun `{.language-plaintext
.highlighter-rouge} 至少会产生四个输出文件. 单个日志文件(
` -g `{.language-plaintext .highlighter-rouge} ), 除非使用了
` -seppot `{.language-plaintext .highlighter-rouge} 选项, 在这种情况下,
每个进程号都会输出一个日志文件. 轨迹文件( ` -o `{.language-plaintext
.highlighter-rouge} ), 包含了坐标, 速度和可选的力. 结构文件(
` -c `{.language-plaintext .highlighter-rouge}
)包含了最后一步的坐标和速度. 能量文件( ` -e `{.language-plaintext
.highlighter-rouge} )含有能量, 温度, 压力等,
这些量大都也会在日志文件中输出. 作为可选项,
坐标也可以被写入到压缩轨迹文件中( ` -x `{.language-plaintext
.highlighter-rouge} ).

只有当进行自由能计算时, 才可以使用选项 ` -dhdl `{.language-plaintext
.highlighter-rouge} .

并行运行模拟时, 可以使用两种不同的并行方案: MPI并行和/或OpenMP线程并行.
对使用常规MPI库编译的 ` mdrun `{.language-plaintext .highlighter-rouge}
, MPI并行使用多个处理器; 对使用GROMACS内置的线程MPI库编译的
` mdrun `{.language-plaintext .highlighter-rouge} ,
MPI并行则使用多个线程. 使用OpenMP编译的 ` mdrun `{.language-plaintext
.highlighter-rouge} 支持OpenMP线程. 只有Verlet截断方案全面支持OpenMP,
对于(旧的)组方案, 只有PME进程可以使用OpenMP并行. 对上述所有情况,
` mdrun `{.language-plaintext .highlighter-rouge}
默认会尝试使用所有可用的硬件资源. 使用常规MPI库时, 只有
` -ntomp `{.language-plaintext .highlighter-rouge}
(与Verlet截断方案一起使用)和 ` -ntomp_pme `{.language-plaintext
.highlighter-rouge} 选项可用于控制PME进程中的线程数目. 使用线程MPI时,
还可使用选项 ` -nt `{.language-plaintext .highlighter-rouge}
设置总线程数, 使用 ` -ntmpi `{.language-plaintext .highlighter-rouge}
设置线程MPI的线程数. 也可以使用标准环境变量
` OMP_NUM_THREADS `{.language-plaintext .highlighter-rouge} 设置
` mdrun `{.language-plaintext .highlighter-rouge} 使用的OpenMP线程数.
环境变量 ` GMX_PME_NUM_THREADS `{.language-plaintext .highlighter-rouge}
可用于指定PME进程使用的线程数.

需要注意的是, 在许多情况下MPI+OpenMP混合并行要比单独使用其中的一种慢.
然而, 对高并行化使用这种混合并行通常是有益的,
因为它减少了区域的数目和/或MPI进程的数目.
(更少或更多的区域可以改进标度行为, 对独立的PME进程,
使用更少的MPI进程可以降低通信成本.) 在单CPU(
` -die `{.language-plaintext .highlighter-rouge} )上,
单纯的OpenMP并行通常比单纯的MPI并行更快.
由于目前我们还没有检测硬件拓扑的合适方法, 使用线程MPI编译的
` mdrun `{.language-plaintext .highlighter-rouge}
只能自动使用单纯的OpenMP并行, 如果你使用的线程数达到4个,
使用英特尔的Nehalem/Westmere处理器时最多可使用12个线程,
使用英特尔的Sandy Bridge或更新的CPU最多可使用16个线程. 否则,
会使用单纯的MPI并行(除非使用GPU, 见下文).

要使用旧的 ` .tpr `{.language-plaintext .highlighter-rouge}
文件快速地测试新的Verlet截断方案, 无论使用CPU还是CPU+GPU, 你都可以使用
` -testverlet `{.language-plaintext .highlighter-rouge} 选项.
此选项不能用于成品模拟, 因为它会稍微修改势能,
并且还会移除电荷组导致分析困难, 但 ` .tpr `{.language-plaintext
.highlighter-rouge} 文件中仍包含电荷组. 对成品模拟, 强烈建议在
` .mdp `{.language-plaintext .highlighter-rouge} 文件中指定
` cutoff-scheme = verlet `{.language-plaintext .highlighter-rouge} .

使用GPU(仅支持Verlet截断方案)时, GPU数应与粒子-粒子进程数匹配,
即不包括单纯的PME进程. 使用线程MPI时, 除非在命令行中设定,
MPI线程数将被自动设置为检测到的GPU数. 要使用可用GPU中的一部分,
或手动提供PP进程的GPU映射, 你可以使用 ` -gpu_id `{.language-plaintext
.highlighter-rouge} 选项. ` -gpu_id `{.language-plaintext
.highlighter-rouge} 的参数为一串数字(无分隔符), 代表要使用的GPU的设备号.
例如, ` 02 `{.language-plaintext .highlighter-rouge}
指定对每个计算节点上的第一和第二个PP进程分别使用GPU 0和2.
要选择计算集群不同节点上的GPU, 可使用环境变量
` GMX_GPU_ID `{.language-plaintext .highlighter-rouge} .
` GMX_GPU_ID `{.language-plaintext .highlighter-rouge} 的格式和
` -gpu_id `{.language-plaintext .highlighter-rouge} 相同,
区别在于环境变量在不同的计算节点上可以有不同的值.
每个节点上的多个MPI进程可以共享GPU, 这可以通过多次指定GPU的id来实现,
例如, ` 0011 `{.language-plaintext .highlighter-rouge}
表示在这个节点上四个进程共享两个GPU. 这种方法对单个或多个模拟都起作用,
并适用于任何形式的MPI.

使用Verlet截断方案和Verlet缓冲容差设置时, 可以使用
` -nstlist `{.language-plaintext .highlighter-rouge}
选项自由地选择配对列表的更新间隔 ` nstlist `{.language-plaintext
.highlighter-rouge} . ` mdrun `{.language-plaintext .highlighter-rouge}
随后会调整配对列表的截断以保持精度, 而不是调整
` nstlist `{.language-plaintext .highlighter-rouge} . 否则, 默认情况下
` mdrun `{.language-plaintext .highlighter-rouge} 会尝试增加
` .mdp `{.language-plaintext .highlighter-rouge} 文件中
` nstlist `{.language-plaintext .highlighter-rouge} 的设定值以提高性能.
对只使用CPU的模拟, ` nstlist `{.language-plaintext .highlighter-rouge}
可能增加至20, 对使用GPU的模拟, 可能增加至40.
对中度到高度的并行或快速的GPU, 使用(用户提供)更大的
` nstlist `{.language-plaintext .highlighter-rouge} 可以得到更好的性能.

当PME计算使用单独的PME进程或GPU时, 两类主要的计算任务,
非键力计算和PME计算, 在不同的计算资源上进行. 如果负载不均衡,
某些资源会有一部分空闲时间. 使用Verlet截断方案时, 负载会自动均衡,
如果PME负载过高的话(但过低时则不会).
这是通过对库仑截断和PME格点间距进行相同的缩放完成的.
在前几百步中程序会尝试各种不同的设置,
然后选择最快的设置用于模拟的其余部分. 这并不影响结果的精确度,
但确实会影响将库仑能分解为粒子和网格的贡献. 可以使用
` -notunepme `{.language-plaintext .highlighter-rouge} 选项关闭自动调整.

` mdrun `{.language-plaintext .highlighter-rouge}
将线程关联(设定附着)到特定的核, 当 ` mdrun `{.language-plaintext
.highlighter-rouge} 使用了计算节点上的所有(逻辑)核时,
即便没有使用多线程, 通常也会显著地提高性能.
如果排队系统或OpenMP库已经关联了线程, 我们将不再关联,
即使布局可能是次优的. 如果你想使 ` mdrun `{.language-plaintext
.highlighter-rouge} 覆盖一个已经设定的线程关联, 或使用更少的核关联线程,
可以使用 ` -pin on `{.language-plaintext .highlighter-rouge} .
随着SMT(同步多线程), 如英特尔超线程的出现,
每个物理核心上可以有多个逻辑核心. 选项
` -pinstride `{.language-plaintext .highlighter-rouge}
可以在逻辑核心上设置步幅以关联连续的线程. 如果没有SMT,
1通常是最好的选择. 使用英特尔超线程, 并使用一半或更少的逻辑核心时,
2是最好的选择, 否则就使用1. 默认值0恰恰如此:
它最大限度地减少每个逻辑核心的线程以优化性能.
如果你想在同一物理节点上运行多个 ` mdrun `{.language-plaintext
.highlighter-rouge} 工作, 当使用所有逻辑核心时你应该将
` -pinstride `{.language-plaintext .highlighter-rouge} 设置为1.
当在相同的物理节点上运行多个 ` mdrun `{.language-plaintext
.highlighter-rouge} (或其它)模拟时, 一些模拟需要从非零核心开始关联,
以避免核心过载; 使用 ` -pinoffset `{.language-plaintext
.highlighter-rouge} 你可以设置逻辑核心关联的偏移值.

当使用超过1个进程启动 ` mdrun `{.language-plaintext .highlighter-rouge}
时, 会使用区域分解的并行.

使用区域分解时, 空间分解可以通过 ` -dd `{.language-plaintext
.highlighter-rouge} 选项设置. 默认情况下 ` mdrun `{.language-plaintext
.highlighter-rouge} 会选择一个好的分解. 只有当体系非常不均匀时,
用户才需要更改此设置. 动态负载平衡由 ` -dlb `{.language-plaintext
.highlighter-rouge} 选项设置, 它可以显著地提升性能,
特别是对于非均相体系.
动态负载均衡的唯一缺点是运行不再具有二进制级别的可重现性,
但在大多数情况下, 这并不重要. 由负载失衡导致的性能损失达到5%或以上时,
默认会自动开启动态负载均衡. 对低并行度计算,
这些是区域分解仅有的重要选项. 对高并行度计算,
下面两节中的选项可能是提升性能的重要选项.

当PME与区域分解一起使用时, 可以分配独立的进程只进行PME网格计算;
大约从12个进程开始, 这样计算效率更高, 当使用OpenMP并行时,
需要的线程数可能更少. PME线程数可由选项 ` -npme `{.language-plaintext
.highlighter-rouge} 设定, 但不能超过总线程数的一半. 默认情况下,
当总线程数超过16时, ` mdrun `{.language-plaintext .highlighter-rouge}
会猜测一个PME线程数. 使用GPU时, 不会自动选择使用单独的PME线程,
因为最佳设置在很大程度上取决于硬件的详细信息. 在任何情况下,
你都可能通过优化 ` -npme `{.language-plaintext .highlighter-rouge}
提高性能. 关于此选项的性能统计数据会写到日志文件的结束处.
为了在高并行度下获得良好的负载均衡,
PME格点的X和Y尺寸应该能被PME线程数整除(即便不是这样,
模拟也可以正常运行).

本节列出了能够影响区域分解的所有选项.

选项 ` -rdd `{.language-plaintext .highlighter-rouge}
可用于设置计算电荷组之间的键合相互作用时所需要的最大距离.
对于非键截断距离以下的二体键合相互作用, 其通讯总是与非键通讯一起进行.
只有当含有丢失的键合相互作用时, 超过非键截断的原子才进行通讯;
这意味着额外的花销是很小的, 而且几乎与 ` -rdd `{.language-plaintext
.highlighter-rouge} 的值无关. 使用动态负载均衡时,
` -rdd `{.language-plaintext .highlighter-rouge}
选项同时也是区域分解单元晶胞尺寸的下限. 默认情况下,
` mdrun `{.language-plaintext .highlighter-rouge} 会根据初始的坐标确定
` -rdd `{.language-plaintext .highlighter-rouge} ,
所选值基于相互作用范围和通讯成本之间的平衡.

当电荷组间的键合相互作用超过了键合截断距离时,
` mdrun `{.language-plaintext .highlighter-rouge} 会终止运行,
并给出一个错误信息. 对不使用排除的配对相互作用和表格键, 可以使用
` -noddcheck `{.language-plaintext .highlighter-rouge} 选项关闭此检查.

当存在约束时, 选项 ` -rcon `{.language-plaintext .highlighter-rouge}
也会影响晶胞的大小限制. 由NC约束连接的原子, 其中NC为LINCS的阶数加1,
不应超出最小的晶胞尺寸. 如果发生了这种情况, 程序会给出错误信息,
用户应更改分解或减小LINCS阶数并增加LINCS的迭代次数. 默认情况下
` mdrun `{.language-plaintext .highlighter-rouge}
会以保守的方式估计P-LINCS所需要的最小晶胞尺寸. 对高并行度的计算,
使用选项 ` -rcon `{.language-plaintext .highlighter-rouge}
来设置P-LINCS所需要的距离, 可能会有帮助.

使用动态负载均衡时, ` -dds `{.language-plaintext .highlighter-rouge}
选项设置晶胞x, y和/或z方向缩放的最小允许比例.
` mdrun `{.language-plaintext .highlighter-rouge}
会确保晶胞至少缩放此比例. 这个选项用于自动空间分解(当不使用
` -dd `{.language-plaintext .highlighter-rouge}
时)以及确定网格脉冲的数量, 进而设置晶胞的最小允许尺寸. 在某些情况下,
可能需要调整 ` -dds `{.language-plaintext .highlighter-rouge}
的值以考虑体系高或低的空间不均匀性.

选项 ` -gcom `{.language-plaintext .highlighter-rouge}
可用于决定每n步只进行一次全局通讯. 当全局通讯步成为瓶颈的时候,
对高并行度的模拟此选项可以提高性能. 对全局控温器和/或控压器,
其温度和/或压力也会每 ` -gcom `{.language-plaintext .highlighter-rouge}
步数更新一次. 默认情况下此选项的值被设为
` nstcalcenergy `{.language-plaintext .highlighter-rouge} 和
` nstlist `{.language-plaintext .highlighter-rouge} 中的较小值.

使用 ` -rerun `{.language-plaintext .highlighter-rouge} 选项,
可以(重新)计算一个输入轨迹的的力和能量. 会针对每一帧进行近邻搜索, 除非
` nstlist `{.language-plaintext .highlighter-rouge} 被设置为零(见
` .mdp `{.language-plaintext .highlighter-rouge} 文件).

ED(主成分动力学)采样和/或额外的洪泛势可使用 ` -ei `{.language-plaintext
.highlighter-rouge} 选项启用, 后面指定一个 ` .edi `{.language-plaintext
.highlighter-rouge} 文件. ` .edi `{.language-plaintext
.highlighter-rouge} 文件可以使用 ` make_edi `{.language-plaintext
.highlighter-rouge} 工具创建, 或通过WHAT IF程序essdyn菜单中的选项来创建.
` mdrun `{.language-plaintext .highlighter-rouge} 会产生一个
` .xvg `{.language-plaintext .highlighter-rouge} 输出文件,
里面包含了位置, 速度, 力在选定的特征向量上的投影.

当在 ` .mdp `{.language-plaintext .highlighter-rouge}
文件中指定了用户自定义的势函数时, 可使用 ` -table `{.language-plaintext
.highlighter-rouge} 选项将式化的势函数表格传递给
` mdrun `{.language-plaintext .highlighter-rouge} .
该表格文件从当前目录或 ` GMXLIB `{.language-plaintext
.highlighter-rouge} 目录中读取. ` GMXLIB `{.language-plaintext
.highlighter-rouge} 目录中有许多预格式化的表格, 如使用普通库仑势的6-8,
6-9, 6-10, 6-11, 6-12 Lennard-Jones势. 当存在对相互作用时, 可使用
` -tablep `{.language-plaintext .highlighter-rouge}
选项读入对相互作用函数的单独表格.

当拓扑中存在表格键函数时, 可使用 ` -tableb `{.language-plaintext
.highlighter-rouge} 选项读入相互作用函数. 对每个不同的表格相互作用类型,
表格文件的名称以不同方式修饰: 文件扩展名之前会追加下划线,
后面跟着一个代表键的 ` b `{.language-plaintext .highlighter-rouge} ,
代表键角的 ` a `{.language-plaintext .highlighter-rouge} 或代表二面角的
` d `{.language-plaintext .highlighter-rouge} ,
最后是相互作用类型的表格编号.

当 ` .mdp `{.language-plaintext .highlighter-rouge} 文件中指定了牵引时,
选项 ` -px `{.language-plaintext .highlighter-rouge} 和
` -pf `{.language-plaintext .highlighter-rouge}
可用于输出牵引COM的坐标和力.

使用 ` -multi `{.language-plaintext .highlighter-rouge} 或
` -multidir `{.language-plaintext .highlighter-rouge} 选项,
可以并行方式模拟多个体系, 输入文件/目录的数目等于体系的数目.
` -multidir `{.language-plaintext .highlighter-rouge}
选项获取一个目录列表(每个体系一个), 并在其中的每一个目录中运行,
运行时使用的输入/输出文件名, 如由 ` -s `{.language-plaintext
.highlighter-rouge} 选项指定的, 是相对于这些目录的. 使用
` -multi `{.language-plaintext .highlighter-rouge} 选项,
体系编号会追加到运行输入文件与每个输出文件的名称中, 例如
` topol.tpr `{.language-plaintext .highlighter-rouge} 会变为
` topol0.tpr `{.language-plaintext .highlighter-rouge} ,
` topol1.tpr `{.language-plaintext .highlighter-rouge} 等.
每个体系的进程数为总进程数除以体系的数目. 这个选项的一个应用是NMR精修:
当存在距离或取向限制时, 可以对所有体系进行系统平均.

使用 ` -replex `{.language-plaintext .highlighter-rouge} 选项,
每经过给定的步数, 会尝试进行一次副本交换. 副本的数目由
` -multi `{.language-plaintext .highlighter-rouge} 或
` -multidir `{.language-plaintext .highlighter-rouge} 选项设置,
如上所述. 所有运行输入文件都应使用不同的耦合温度, 文件的顺序并不重要.
随机数种子由 ` -reseed `{.language-plaintext .highlighter-rouge} 设置.
每次交换后会进行速度缩放和近邻搜索.

最后, 当给出合适的选项时, 可以测试一些试验性的算法. 目前正在考察的是:
极化.

选项 ` -membed `{.language-plaintext .highlighter-rouge} 的功能与原先的
` g_membed `{.language-plaintext .highlighter-rouge} 相同,
即将蛋白质嵌入到膜中. 数据文件应包含传递给
` g_membed `{.language-plaintext .highlighter-rouge} 的选项.
` -mn `{.language-plaintext .highlighter-rouge} 和
` -mp `{.language-plaintext .highlighter-rouge} 也会应用到.

如果你怀疑模拟是由于原子受力过大而崩溃的, 选项
` -pforce `{.language-plaintext .highlighter-rouge} 可能对你有用.
使用此选项, 当原子的受力超过一定值时, 其坐标和力会被打印到
` stderr `{.language-plaintext .highlighter-rouge} .

包含体系完整状态的检查点会被定期(选项 ` -cpt `{.language-plaintext
.highlighter-rouge} )地写入文件 ` -cpo `{.language-plaintext
.highlighter-rouge} , 除非选项 ` -cpt `{.language-plaintext
.highlighter-rouge} 设置为-1. 先前的检查点会备份到
` state_prev.cpt `{.language-plaintext .highlighter-rouge}
以确保最近的体系状态始终可用, 即使在写入检查点时模拟被终止. 使用
` -cpnum `{.language-plaintext .highlighter-rouge}
选项会保存所有的检查点文件并追加步数. 通过从由选项
` -cpi `{.language-plaintext .highlighter-rouge}
指定的文件中读入全部状态, 模拟可以继续进行. 该选项的智能之处在于,
如果没有找到检查点文件, GROMACS就假定这是一个常规运行, 并从
` .tpr `{.language-plaintext .highlighter-rouge} 文件的第一步开始.
默认情况下, 输出将被追加到现有的输出文件中.
检查点文件中包含了所有输出文件的校验码, 这样你永远不会丢失数据,
即使一些输出文件被修改, 破坏或删除. ` -cpi `{.language-plaintext
.highlighter-rouge} 有三种情景:

-   不存在名称匹配的文件: 写入新的输出文件
-   所有文件都存在, 且名称和校验码与存储在检查点文件中的匹配: 追加文件
-   其他情况下, 不会修改任何文件, 并产生一个致命错误

使用 ` -noappend `{.language-plaintext .highlighter-rouge} 选项,
会打开新的输出文件, 并将模拟部分编号添加到所有输出文件的名称中.
需要注意的是, 在所有情况下检查点文件本身都不会被重命名, 并会被覆盖,
除非它的名称与 ` -cpo `{.language-plaintext .highlighter-rouge}
选项不匹配.

使用检查点时, 输出会追加到先前的输出文件中, 除非使用了
` -noappend `{.language-plaintext .highlighter-rouge}
选项或不存在任何先前的输出文件(除检查点文件外).
要追加的文件的完整性是通过验证检查点文件中存储的校验码实现的.
这保证了追加文件时不会造成混淆或损坏. 当只有部分先前的输出文件存在时,
会导致致命错误, 并且不会修改旧的输出文件, 也不会打开新的输出文件.
追加得到的结果与单独运行得到的结果相同, 文件内容是二进制相同的,
除非你使用了不同的进程数或动态负载均衡或FFT库使用了计时优化.

使用选项 ` -maxh `{.language-plaintext .highlighter-rouge} 时,
当运行时间超过 ` -maxh `{.language-plaintext .highlighter-rouge}
\*0.99小时后, 模拟会终止, 并在第一个近邻搜索步输出检查点文件.

当 ` mdrun `{.language-plaintext .highlighter-rouge} 接收到TERM信号后,
它会将 ` nsteps `{.language-plaintext .highlighter-rouge}
设置为比当前步数多一的值. 当 ` mdrun `{.language-plaintext
.highlighter-rouge} 接收到INT信号后(例如, 按下CTRL+C),
会在下一近邻搜索步后停止(下一步的 ` nstlist = 0 `{.language-plaintext
.highlighter-rouge} ). 在这两种情况下, 所有的常规输出都将被写入到文件中.
当使用MPI运行 ` mdrun `{.language-plaintext .highlighter-rouge} 时,
只要将信号发送到 ` mdrun `{.language-plaintext .highlighter-rouge}
的一个进程就足够了, 此信号不应该被发送到 ` mpirun `{.language-plaintext
.highlighter-rouge} 或 ` mdrun `{.language-plaintext .highlighter-rouge}
进程, 因为它们是其他进程的父进程.

交互式分子动力学(IMD)可以通过至少使用三个IMD开关中的一个来激活:
` -imdterm `{.language-plaintext .highlighter-rouge}
开关允许从分子查看器(如VMD)终止模拟; 使用
` -imdwait `{.language-plaintext .highlighter-rouge} ,
当没有IMD客户端连接时, ` mdrun `{.language-plaintext .highlighter-rouge}
会暂停; 可以使用 ` -imdpull `{.language-plaintext .highlighter-rouge}
打开IMD的远程操控. ` mdrun `{.language-plaintext .highlighter-rouge}
监听的端口可以使用 ` -imdport `{.language-plaintext .highlighter-rouge}
来更改. 如果使用IMD操控, 由 ` -if `{.language-plaintext
.highlighter-rouge} 指向的文件中包含了原子索引和力.

当使用MPI启动 ` mdrun `{.language-plaintext .highlighter-rouge} 时,
默认情况下, 不可改变它的优先级.

  选项                                    默认值 类型         说明
------------------------------ --------------- ------------ ---------------------------------------
  ` -s [<.tpr/.tpb/...>] `             topol.tpr 输入         运行输入文件: tpr tpb tpa
  ` -o [<.trr/.cpt/...>] `              traj.trr 输出         全精度轨迹: trr cpt trj tng
  ` -x [<.xtc/.tng>] `             traj_comp.xtc 输出, 可选   压缩轨迹(tng格式或可移植xdr格式)
  ` -cpi [<.cpt>] `                    state.cpt 输入, 可选   检查点文件
  ` -cpo [<.cpt>] `                    state.cpt 输出, 可选   检查点文件
  ` -c [<.gro/.g96/...>] `           confout.gro 输出         结构文件: gro g96 pdb brk ent esp
  ` -e [<.edr>] `                       ener.edr 输出         能量文件
  ` -g [<.log>] `                         md.log 输出         日志文件
  ` -dhdl [<.xvg>] `                    dhdl.xvg 输出, 可选   xvgr/xmgr文件
  ` -field [<.xvg>] `                  field.xvg 输出, 可选   xvgr/xmgr文件
  ` -table [<.xvg>] `                  table.xvg 输入, 可选   xvgr/xmgr文件
  ` -tabletf [<.xvg>] `              tabletf.xvg 输入, 可选   xvgr/xmgr文件
  ` -tablep [<.xvg>] `                tablep.xvg 输入, 可选   xvgr/xmgr文件
  ` -tableb [<.xvg>] `                 table.xvg 输入, 可选   xvgr/xmgr文件
  ` -rerun [<.xtc/.trr/...>] `         rerun.xtc 输入, 可选   轨迹: xtc trr cpt trj gro g96 pdb tng
  ` -tpi [<.xvg>] `                      tpi.xvg 输出, 可选   xvgr/xmgr文件
  ` -tpid [<.xvg>] `                 tpidist.xvg 输出, 可选   xvgr/xmgr文件
  ` -ei [<.edi>] `                       sam.edi 输入, 可选   ED采用输入
  ` -eo [<.xvg>] `                     edsam.xvg 输出, 可选   xvgr/xmgr文件
  ` -devout [<.xvg>] `              deviatie.xvg 输出, 可选   xvgr/xmgr文件
  ` -runav [<.xvg>] `                runaver.xvg 输出, 可选   xvgr/xmgr文件
  ` -px [<.xvg>] `                     pullx.xvg 输出, 可选   xvgr/xmgr文件
  ` -pf [<.xvg>] `                     pullf.xvg 输出, 可选   xvgr/xmgr文件
  ` -ro [<.xvg>] `                  rotation.xvg 输出, 可选   xvgr/xmgr文件
  ` -ra [<.log>] `                 rotangles.log 输出, 可选   日志文件
  ` -rs [<.log>] `                  rotslabs.log 输出, 可选   日志文件
  ` -rt [<.log>] `                 rottorque.log 输出, 可选   日志文件
  ` -mtx [<.mtx>] `                       nm.mtx 输出, 可选   Hessian矩阵
  ` -dn [<.ndx>] `                    dipole.ndx 输出, 可选   索引文件
  ` -multidir [<dir> [...]] `             rundir 输入, 可选   运行路径
  ` -membed [<.dat>] `                membed.dat 输入, 可选   通用数据文件
  ` -mp [<.top>] `                    membed.top 输入, 可选   拓扑文件
  ` -mn [<.ndx>] `                    membed.ndx 输入, 可选   索引文件
  ` -if [<.xvg>] `                 imdforces.xvg 输出, 可选   xvgr/xmgr文件
  ` -swap [<.xvg>] `                swapions.xvg 输出, 可选   xvgr/xmgr文件

  : 输入/输出文件选项 {#tab-97}

-----------------------------------------------------------------------------------------------------------
  选项                                     默认值 说明
----------------------- ----------------------- -----------------------------------------------------------
  ` -nice <int> `                               0 设置优先级

  ` -deffnm <string> `                            对所有文件选项设置默认的文件名

  ` -xvg <enum> `                         xmgrace xvg绘图格式: xmgrace, xmgr, none

  ` -dd <vector> `                          0 0 0 区域分解格点, 0为优化设置

  ` -ddorder <enum> `                  interleave DD进行顺序: interleave, pp_pme, cartesian

  ` -npme <int> `                              -1 用于PME的独立进程数, -1表示使用猜测值

  ` -nt <int> `                                 0 启动的总线程数(0表示使用猜测值)

  ` -ntmpi <int> `                              0 启动的线程MPI的线程数(0表示使用猜测值)

  ` -ntomp <int> `                              0 每个MPI进程启动的OpenMP线程数(0表示使用猜测值)

  ` -ntomp_pme <int> `                          0 每个MPI进程启动的OpenMP线程数(0表示使用猜测值)

  ` -pin <enum> `                            auto 设置线程关联: auto, on, off

  ` -pinoffset <int> `                          0 关联到核心的逻辑核心的起始编号, 用于避免将不同 ` mdrun `
                                                  实例的线程关联到相同的核心

  ` -pinstride <int> `                          0 逻辑核心上线程之间的关联距离,
                                                  使用0可以最大限度地减少每个物理核心上的线程数

  ` -gpu_id <string> `                            使用的GPU设备的ID列表, 指定每个节点上PP进程到GPU的映射

  ` -[no]ddcheck `                            yes 使用DD时, 检查所有的键合相互作用

  ` -rdd <real> `                               0 使用DD时键合相互作用的最大距离(单位: nm),
                                                  0表示由初始坐标决定

  ` -rcon <real> `                              0 P-LINCS的最大距离(单位: nm), 0为估计值

  ` -dlb <enum> `                            auto 动态负载均衡(使用DD): auto, no, yes

  ` -dds <real> `                             0.8 一个处于(0,1)之间的比例,
                                                  初始DD晶胞的尺寸会根据此数值的倒数进行放大,\
                                                  以便能进行动态负载均衡, 且同时保持最小的晶胞尺寸

  ` -gcom <int> `                              -1 全局通讯频率

  ` -nb <enum> `                             auto 计算非键相互作用的设备: auto, cpu, gpu, gpu_cpu

  ` -nstlist <int> `                            0 当使用Verlet缓冲容差时, 设置 ` nstlist ` (0为猜测值)

  ` -[no]tunepme `                            yes 优化PP/PME进程间或GPU/CPU间的PME负载

  ` -[no]testverlet `                          no 测试Verlet非键方案

  ` -[no]v `                                   no 在屏幕上输出更多信息

  ` -[no]compact `                            yes 输出紧凑的日志文件

  ` -[no]seppot `                              no 将每一相互作用类型及进程的V和dVdl项独立地输出到日志文件中

  ` -pforce <real> `                           -1 输出所有超过此值的力(单位: kJ/mol nm)

  ` -[no]reprod `                              no 尝试避免那些会影响二进制可重复性的优化

  ` -cpt <real> `                              15 保存检查点文件的间隔(单位: 分钟)

  ` -[no]cpnum `                               no 编号并保留检查点文件

  ` -[no]append `                             yes 当从检查点文件开始继续运行时, 将输出追加到先前的文件中,\
                                                  而不是将模拟部分编号添加到所有文件名中

  ` -nsteps <int> `                            -2 设置运行步数, 覆盖 ` .mdp ` 文件中的设置

  ` -maxh <real> `                             -1 时间达到设定值的99%后结束运行(单位: 小时)

  ` -multi <int> `                              0 以并行方式执行多个模拟

  ` -replex <int> `                             0 使用此周期(步数)尝试进行周期性的副本交换

  ` -nex <int> `                                0 每个交换间隔执行的随机交换数(一个建议是N\^3\^).
                                                  设置为零或不设置则使用相邻副本交换.

  ` -reseed <int> `                            -1 副本交换的种子, -1表示产生种子
  -----------------------------------------------------------------------------------------------------------

  : 控制选项 {#tab-98}

## gmx mindist: 计算两组间的最小距离

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx mindist [-f [<.xtc/.trr/...>]] [-s [<.tpr/.tpb/...>]] [-n [<.ndx>]]
            [-od [<.xvg>]] [-on [<.xvg>]] [-o [<.out>]]
            [-ox [<.xtc/.trr/...>]] [-or [<.xvg>]] [-nice ] [-b ]
            [-e ] [-dt ] [-tu ] [-[no]w] [-xvg ]
            [-[no]matrix] [-[no]max] [-d ] [-[no]group] [-[no]pi]
            [-[no]split] [-ng ] [-[no]pbc] [-[no]respertime]
            [-[no]printresname]
```
:::
:::

` gmx mindist `{.language-plaintext .highlighter-rouge}
用于计算一个组与其他组之间的距离.
程序会将(两组之间任意原子对的)最小距离和给定距离内的接触数输出到两个独立的文件.
使用 ` -group `{.language-plaintext .highlighter-rouge} 选项时,
如果另一组中的一个原子与第一组的多个原子相接触,
接触数只计为1次而不是多次. 使用 ` -or `{.language-plaintext
.highlighter-rouge} 选项时, 程序会确定到第一组中每个残基的最小距离,
并给出它与残基编号的函数关系图.

使用 ` -pi `{.language-plaintext .highlighter-rouge} 选项时,
会给出一个组与其周期映象的最小距离.
这可以用于检验蛋白质在模拟中是否可以感受到它的周期映象.
每个方向只考虑一次平移, 共26次平移.
程序也会给出组间的最大距离以及三个盒矢量的长度.

` gmx distance `{.language-plaintext .highlighter-rouge}
也可用于计算距离.

  选项                                  默认值 类型         说明
--------------------------- ---------------- ------------ ------------------------------------------------
  ` -f [<.xtc/.trr/...>] `            traj.xtc 输入         轨迹: xtc trr cpt trj gro g96 pdb tng
  ` -s [<.tpr/.tpb/...>] `           topol.tpr 输入, 可选   结构+质量(db): tpr tpb tpa gro g96 pdb brk ent
  ` -n [<.ndx>] `                    index.ndx 输入, 可选   索引文件
  ` -od [<.xvg>] `                 mindist.xvg 输出         xvgr/xmgr文件
  ` -on [<.xvg>] `                 numcont.xvg 输出, 可选   xvgr/xmgr文件
  ` -o [<.out>] `                 atm-pair.out 输出, 可选   通用输出文件
  ` -ox [<.xtc/.trr/...>] `        mindist.xtc 输出, 可选   轨迹: xtc trr trj gro g96 pdb tng
  ` -or [<.xvg>] `              mindistres.xvg 输出, 可选   xvgr/xmgr文件

  : 输入/输出文件选项 {#tab-99}

  选项                       默认值 说明
----------------------- --------- -----------------------------------------------------------------
  ` -nice <int> `                19 设置优先级
  ` -b <time> `                   0 从轨迹文件中读取的第一帧(ps)
  ` -e <time> `                   0 从轨迹文件中读取的最后一帧(ps)
  ` -dt <time> `                  0 只使用t除以dt的余数等于第一帧时间(ps)的帧, 即两帧之间的时间间隔
  ` -tu <enum> `                 ps 时间单位: fs, ps, ns, us, ms, s
  ` -[no]w `                     no 查看输出的.xvg, .xpm, .eps和.pdb文件
  ` -xvg <enum> `           xmgrace xvg绘图格式: xmgrace, xmgr, none
  ` -[no]matrix `                no 计算组与组之间距离的半个矩阵
  ` -[no]max `                   no 计算最大距离, 而不是最小距离.
  ` -d <real> `                 0.6 接触距离
  ` -[no]group `                 no 计算接触数时, 与第一组中多个原子的接触数计为1.
  ` -[no]pi `                    no 计算与映象间的最小距离
  ` -[no]split `                 no 时间为零时分割图形
  ` -ng <int> `                   1 计算到中心组的距离时, 其他组的数目
  ` -[no]pbc `                  yes 计算距离时考虑周期性边界条件
  ` -[no]respertime `            no 当输出与每个残基的距离时, 输出每个时间点的距离.
  ` -[no]printresname `          no 输出残基名称

  : 控制选项 {#tab-100}

## gmx mk_angndx: 生成用于gmx angle的索引文件

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx mk_angndx [-s [<.tpr/.tpb/...>]] [-n [<.ndx>]] [-nice ]
              [-type ] [-[no]hyd] [-hq ]
```
:::
:::

` gmx mk_angndx `{.language-plaintext .highlighter-rouge}
命令用于创建索引文件, 以计算角度分布等. 它需要使用一个运行输入文件(
` .tpx `{.language-plaintext .highlighter-rouge} )来获得键角,
二面角等的信息.

  选项                            默认值 类型   说明
-------------------------- ----------- ------ ---------------------------
  ` -s [<.tpr/.tpb/...>] `     topol.tpr 输入   运行输入文件: tpr tpb tpa
  ` -n [<.ndx>] `              angle.ndx 输出   索引文件

  : 输入/输出文件选项 {#tab-101}

  选项                 默认值 说明
------------------ -------- ---------------------------------------------------------
  ` -nice <int> `           0 设置优先级
  ` -type <enum> `      angle 角度类型: angle, dihedral, improper, ryckaert-bellemans
  ` -[no]hyd `            yes 包括质量\<1.5的原子
  ` -hq <real> `           -1 忽略质量\<1.5, 电荷大小小于此值的原子所涉及的角度

  : 控制选项 {#tab-102}

## gmx morph: 构象间的线性内插

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx morph [-f1 [<.gro/.g96/...>]] [-f2 [<.gro/.g96/...>]]
          [-o [<.xtc/.trr/...>]] [-or [<.xvg>]] [-n [<.ndx>]] [-nice ]
          [-[no]w] [-xvg ] [-ninterm ] [-first ]
          [-last ] [-[no]fit]
```
:::
:::

` gmx morph `{.language-plaintext .highlighter-rouge}
对构象进行线性内插以产生中间体构象. 当然这些构象完全是不现实的,
但你可以试着进行证明. 程序的输出形式是通用的轨迹. 中间体的数目由
` -ninterm `{.language-plaintext .highlighter-rouge} 选项进行控制.
` -first `{.language-plaintext .highlighter-rouge} 和
` -last `{.language-plaintext .highlighter-rouge} 选项用于控制插值方式:
0对应于输入结构1, 1对应于输入结构2. 如果指定的
` -first `{.language-plaintext .highlighter-rouge} \< 0或
` -last `{.language-plaintext .highlighter-rouge} \> 1,
会根据输入结构x_1到x_2的途径进行外推. 一般来说, 对总共N个中间体,
中间体i的坐标x(i)为:

` x(i) = x_1 + (first+(i/(N-1))*(last-first))*(x_2-x_1) `{.language-plaintext
.highlighter-rouge}

最后, 如果指定了 ` -or `{.language-plaintext .highlighter-rouge} 选项,
可以计算相对于两个输入结构的RMSD. 在这种情况下, 可能需要读取索引文件,
用于选择计算RMS的组.

  选项                                  默认值 类型         说明
--------------------------- ---------------- ------------ --------------------------------------------------
  ` -f1 [<.gro/.g96/...>] `          conf1.gro 输入         结构文件: gro g96 pdb brk ent esp tpr tpb tpa
  ` -f2 [<.gro/.g96/...>] `          conf2.gro 输入         晶诶够文件:: gro g96 pdb brk ent esp tpr tpb tpa
  ` -o [<.xtc/.trr/...>] `          interm.xtc 输出         轨迹: xtc trr cpt trj gro g96 pdb tng
  ` -or [<.xvg>] `              rms-interm.xvg 输出, 可选   xvgr/xmgr文件
  ` -n [<.ndx>] `                    index.ndx 输入, 可选   索引文件

  : 输入/输出文件选项 {#tab-103}

  选项                    默认值 说明
-------------------- --------- ------------------------------------------------
  ` -nice <int> `              0 设置优先级
  ` -[no]w `                  no 查看输出的.xvg, .xpm, .eps和.pdb文件
  ` -xvg <enum> `        xmgrace xvg绘图格式: xmgrace, xmgr, none
  ` -ninterm <int> `          11 中间体数目
  ` -first <real> `            0 对应于第一个产生的结构(0为输入x_1, 见上文)
  ` -last <real> `             1 对应于最后一个产生的结构(1为输入x_2, 见上文)
  ` -[no]fit `               yes 内插前将第二个结构与第一个结构进行最小二乘叠合

  : 控制选项 {#tab-104}

## gmx msd: 计算均方位移

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx msd [-f [<.xtc/.trr/...>]] [-s [<.tpr/.tpb/...>]] [-n [<.ndx>]]
        [-o [<.xvg>]] [-mol [<.xvg>]] [-pdb [<.pdb>]] [-nice ]
        [-b ] [-e ] [-tu ] [-[no]w] [-xvg ]
        [-type ] [-lateral ] [-[no]ten] [-ngroup ] [-[no]mw]
        [-[no]rmcomm] [-tpdb ] [-trestart ] [-beginfit ]
        [-endfit ]
```
:::
:::

` gmx msd `{.language-plaintext .highlighter-rouge}
根据一系列初始位置来计算原子的均方位移(MSD, mean square displacement).
这提供了一个利用爱因斯坦关系式计算扩散常数的简易方法. 计算MSD时,
参考点之间的时间可利用 ` -trestart `{.language-plaintext
.highlighter-rouge} 选项设置. 将从 ` -beginfit `{.language-plaintext
.highlighter-rouge} 到 ` -endfit `{.language-plaintext
.highlighter-rouge} 之间的MSD(t)使用最小二乘法拟合为直线(D\*t+c),
就可以得到扩散常数(注意, t为到参考点的时间, 而不是模拟时间).
程序会给出扩散常数误差的估计值, 计算时将拟合区间分为两部分,
分别拟合得到扩散系数, 这两个扩散系数的插值就是误差的估计值.

有三个相互排斥的选项来确定不同类型的均方位移:
` -type `{.language-plaintext .highlighter-rouge} ,
` -lateral `{.language-plaintext .highlighter-rouge} 和
` -ten `{.language-plaintext .highlighter-rouge} . 选项
` -ten `{.language-plaintext .highlighter-rouge}
对每组输出完整的MSD张量, 输出的顺序是: trace xx yy zz yx zx zy.

如果设置了 ` -mol `{.language-plaintext .highlighter-rouge} 选项,
` gmx msd `{.language-plaintext .highlighter-rouge}
计算单个分子的MSD(会保持跨过周期性边界的分子完整): 对每一单个分子,
会计算其质心的扩散常数. 所选的索引组会被划分为分子.

默认计算MSD的方法是使用质量加权平均, 可使用
` -nomw `{.language-plaintext .highlighter-rouge} 取消.

使用 ` -rmcomm `{.language-plaintext .highlighter-rouge} 选项,
可以移除指定组的质心运行. 对于GROMACS输出的轨迹, 通常不需要此选项, 因为
` gmx mdrun `{.language-plaintext .highlighter-rouge}
通常已经移除了质心运动. 当你使用此选项时,
请确保轨迹文件中保存了整个体系.

扩散系数由MSD的线性回归确定, 不同于D正常的输出,
时间是根据参考点的数目进行加权的, 即, 短的时间权重较高. 此外, 当
` -beginfit=-1 `{.language-plaintext .highlighter-rouge} 时,
拟合从10%处开始, 当 ` -endfit=-1 `{.language-plaintext
.highlighter-rouge} 时, 拟合结束于90%处.
使用此选项也可以得到精确的误差估计, 它基于单个分子之间的统计. 注意,
只有当MSD在 ` -beginfit `{.language-plaintext .highlighter-rouge} 到
` -endfit `{.language-plaintext .highlighter-rouge} 之间完全呈线性时,
所得的扩散常数和误差估计才准确.

使用 ` -pdb `{.language-plaintext .highlighter-rouge} 选项可输出一个
` .pdb `{.language-plaintext .highlighter-rouge} 文件, 其中包含
` -tpdb `{.language-plaintext .highlighter-rouge} 时刻体系的坐标,
B因子的值为分子扩散系数的平方根. 此选项暗含 ` -mol `{.language-plaintext
.highlighter-rouge} 选项.

  选项                               默认值 类型         说明
-------------------------- -------------- ------------ ------------------------------------------------
  ` -f [<.xtc/.trr/...>] `         traj.xtc 输入         轨迹: xtc trr cpt trj gro g96 pdb tng
  ` -s [<.tpr/.tpb/...>] `        topol.tpr 输入         结构+质量(db): tpr tpb tpa gro g96 pdb brk ent
  ` -n [<.ndx>] `                 index.ndx 输入, 可选   索引文件
  ` -o [<.xvg>] `                   msd.xvg 输出         xvgr/xmgr文件
  ` -mol [<.xvg>] `            diff_mol.xvg 输出, 可选   xvgr/xmgr文件
  ` -pdb [<.pdb>] `            diff_mol.pdb 输出, 可选   PDB文件

  : 输入/输出文件选项 {#tab-105}

  选项                      默认值 说明
---------------------- --------- -----------------------------------------
  ` -nice <int> `               19 设置优先级
  ` -b <time> `                  0 从轨迹文件中读取的第一帧(ps)
  ` -e <time> `                  0 从轨迹文件中读取的最后一帧(ps)
  ` -tu <enum> `                ps 时间单位: fs, ps, ns, us, ms, s
  ` -[no]w `                    no 查看输出.xvg, .xpm, .eps和.pdb文件
  ` -xvg <enum> `          xmgrace xvg绘图格式: xmgrace, xmgr, none
  ` -type <enum> `              no 计算某一方向的扩散系数: no, x, y, z
  ` -lateral <enum> `           no 计算横向扩散时, 平面的法向: no, x, y, z
  ` -[no]ten `                  no 计算完整的张量
  ` -ngroup <int> `              1 计算MSD的组数
  ` -[no]mw `                  yes 计算质量加权的MSD
  ` -[no]rmcomm `               no 移除质心运动
  ` -tpdb <time> `               0 用于 ` -pdb ` 选项的帧(单位: ps)
  ` -trestart <time> `          10 轨迹中重起始点之间的间隔(单位: ps)
  ` -beginfit <time> `          -1 拟合MSD的起始时间(单位: ps), -1为10%
  ` -endfit <time> `            -1 拟合MSD的终止时间(单位: ps), -1为90%

  : 控制选项 {#tab-106}

## gmx nmeig: 对角化简正模式分析的Hessian矩阵

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx nmeig [-f [<.mtx>]] [-s [<.tpr/.tpb/...>]] [-of [<.xvg>]] [-ol [<.xvg>]]
          [-os [<.xvg>]] [-qc [<.xvg>]] [-v [<.trr/.cpt/...>]] [-nice ]
          [-xvg ] [-[no]m] [-first ] [-last ]
          [-maxspec ] [-T ] [-[no]constr] [-width ]
```
:::
:::

` gmx nmeig `{.language-plaintext .highlighter-rouge}
用于计算(Hessian)矩阵的特征向量/特征值, 矩阵可由
` gmx mdrun `{.language-plaintext .highlighter-rouge} 计算.
特征向量会被写入一个轨迹文件( ` -v `{.language-plaintext
.highlighter-rouge} ), 其中的第一个结构对应t=0时的结构.
特征向量作为帧写入文件, 其序号作为时间戳. 特征向量可利用
` gmx anaeig `{.language-plaintext .highlighter-rouge} 进行分析. 使用
` gmx nmens `{.language-plaintext .highlighter-rouge}
可以根据特征向量生成结构的系综. 当使用质量加权时,
输出之前产生的特征向量会缩放为普通的直角坐标. 在这种情况下,
对标准的直角坐标形式, 它们将不再精确地正交, 但在质量加权时应该正交.

通过 ` -qcorr `{.language-plaintext .highlighter-rouge}
选项提供一个额外的参数文件, 此程序也可用于计算热容和焓的量子校正.
详细情况可以参考GROMACS手册的第一章. 结果包括在给定温度下减去简谐自由度.
总的校正值会显示在终端上. 得到校正结果的推荐方式如下:

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx nmeig -s topol.tpr -f nm.mtx -first 7 -last 10000 -T 300 -qc [-constr]
```
:::
:::

如果在模拟中 **对所有共价键** 使用了键约束, 应该使用
` -constr `{.language-plaintext .highlighter-rouge} 选项. 否则,
需要自己分析 ` quant_corr.xvg `{.language-plaintext .highlighter-rouge}
文件.

为了更加灵活, 计算量子校正时, 程序也可以考虑虚拟位点. 当选择
` -constr `{.language-plaintext .highlighter-rouge} 和
` -qc `{.language-plaintext .highlighter-rouge} 选项时, 会自动设置
` -begin `{.language-plaintext .highlighter-rouge} 和
` -end `{.language-plaintext .highlighter-rouge} 选项. 再次,
如果你认为自己知道怎样做更好, 请检查输出文件
` eigenfreq.xvg `{.language-plaintext .highlighter-rouge} .

  选项                                 默认值 类型        说明
-------------------------- ---------------- ----------- -----------------------------
  ` -f [<.mtx>] `                 hessian.mtx 输入        Hessian矩阵
  ` -s [<.tpr/.tpb/...>] `          topol.tpr 输入        运行输入文件: tpr tpb tpa
  ` -of [<.xvg>] `              eigenfreq.xvg 输入        xvgr/xmgr文件
  ` -ol [<.xvg>] `               eigenval.xvg 输入        xvgr/xmgr文件
  ` -os [<.xvg>] `               spectrum.xvg 输入,可选   xvgr/xmgr文件
  ` -qc [<.xvg>] `             quant_corr.xvg 输入,可选   xvgr/xmgr文件
  ` -v [<.trr/.cpt/...>] `       eigenvec.trr 输入        全精度轨迹: trr cpt trj tng

  : 输入/输出文件选项 {#tab-107}

--------------------------------------------------------------------------------------------------------
  选项                                     默认值 说明
----------------------- ----------------------- --------------------------------------------------------
  ` -nice <int> `                              19 设置优先级

  ` -xvg <enum> `                         xmgrace xvg绘图格式: xmgrace, xmgr, none

  ` -[no]m `                                  yes 对角化之前,
                                                  将Hessian矩阵的元素除上所有涉及原子sqrt(mass)的乘积.\
                                                  \'简正\'分析应使用此方法.

  ` -first <int> `                              1 写入的第一个特征向量

  ` -last <int> `                              50 写入的最后一个特征向量

  ` -maxspec <int> `                         4000 谱图中考虑的最高频率(1/cm)

  ` -T <real> `                            298.15 当使用简正模式计算校正经典模拟结果时,
                                                  计算量子热容和焓的温度

  ` -[no]constr `                              no 如果模拟中使用了约束而简正分析中不使用(这是推荐办法),\
                                                  计算量子校正时你需要设置此选项

  ` -width <real> `                             1 当生成谱图时, 高斯峰的宽度(σ)(1/cm)
  --------------------------------------------------------------------------------------------------------

  : 控制选项 {#tab-108}

## gmx nmens: 根据简正模式生成结构系综

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx nmens [-v [<.trr/.cpt/...>]] [-e [<.xvg>]] [-s [<.tpr/.tpb/...>]]
          [-n [<.ndx>]] [-o [<.xtc/.trr/...>]] [-nice ] [-xvg ]
          [-temp ] [-seed ] [-num ] [-first ]
          [-last ]
```
:::
:::

` gmx nmens `{.language-plaintext .highlighter-rouge}
用于生成一个平均结构周围的系综,
系综处于一组简正模式(特征向量)定义的子空间中.
特征向量被假定是质量加权的.
沿每个特征向量的位置随机地取自方差为kT/特征值的高斯分布.

默认情况下, 特征向量将从7开始, 因为前六个简正模式对应于平动和转动自由度.

  选项                               默认值 类型         说明
-------------------------- -------------- ------------ ------------------------------------------------
  ` -v [<.trr/.cpt/...>] `     eigenvec.trr 输入         全精度轨迹: trr cpt trj tng
  ` -e [<.xvg>] `              eigenval.xvg 输入         xvgr/xmgr文件
  ` -s [<.tpr/.tpb/...>] `        topol.tpr 输入         结构+质量(db): tpr tpb tpa gro g96 pdb brk ent
  ` -n [<.ndx>] `                 index.ndx 输入, 可选   索引文件
  ` -o [<.xtc/.trr/...>] `     ensemble.xtc 输出         轨迹: xtc trr trj gro g96 pdb tng

  : 输入/输出文件选项 {#tab-109}

  选项                  默认值 说明
------------------ --------- -------------------------------------------
  ` -nice <int> `           19 设置优先级
  ` -xvg <enum> `      xmgrace xvg绘图格式: xmgrace, xmgr, none
  ` -temp <real> `         300 温度, 单位K
  ` -seed <int> `           -1 随机数种子, -1表示根据时间和pid产生随机数
  ` -num <int> `           100 要产生的结构数
  ` -first <int> `           7 要使用的第一个特征向量(-1表示所选)
  ` -last <int> `           -1 要使用的最后一个特征向量(-1表示直到最后)

  : 控制选项 {#tab-110}

## gmx nmtraj: 根据本征向量生成虚拟振荡轨迹

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx nmtraj [-s [<.tpr/.tpb/...>]] [-v [<.trr/.cpt/...>]]
           [-o [<.xtc/.trr/...>]] [-nice ] [-eignr ]
           [-phases ] [-temp ] [-amplitude ]
           [-nframes ]
```
:::
:::

` gmx nmtraj `{.language-plaintext .highlighter-rouge}
根据特征向量产生虚拟的轨迹, 对应于围绕平均结构的简谐直角坐标振荡.
通常应使用质量加权的特征向量,
但你也可以使用非加权的特征向量来生成正交运动.
输出帧为一个覆盖整个周期的轨迹文件, 并且第一帧为平均结构.
如果你将轨迹输出(或转换)为PDB格式, 你可以直接在PyMol软件中观看,
还可以渲染生成逼真的动画. 假定能量均分到所有模式上,
运动振幅可以由特征值和预设温度计算. 为了在PyMol中清晰地显示运动,
你可以通过设定不现实的非常高的温度值来放大振幅. 然而, 要注意对大的振幅,
线性直角坐标位移与质量加权二者都可以导致严重的结构变形,
这只是直角简正模式模型的局限性. 默认选择的特征向量为7,
因为前六个简正模式对应于平动和转动自由度.

  选项                               默认值 类型   说明
-------------------------- -------------- ------ --------------------------------------------
  ` -s [<.tpr/.tpb/...>] `        topol.tpr 输入   结构+质量: tpr tpb tpa gro g96 pdb brk ent
  ` -v [<.trr/.cpt/...>] `     eigenvec.trr 输入   全精度轨迹: trr cpt trj tng
  ` -o [<.xtc/.trr/...>] `       nmtraj.xtc 输出   轨迹: xtc trr trj gro g96 pdb tng

  : 输入/输出文件选项 {#tab-111}

  选项                      默认值 说明
----------------------- -------- -------------------------------------
  ` -nice <int> `               19 设置优先级
  ` -eignr <string> `            7 使用的特征向量对应的字符(第一个为1)
  ` -phases <string> `         0.0 相位对应的字符(默认为0.0)
  ` -temp <real> `             300 温度 (K)
  ` -amplitude <real> `       0.25 本征值\<=0的模式对应的幅度
  ` -nframes <int> `            30 生成帧的数目

  : 控制选项 {#tab-112}

## gmx order: 计算碳末端每个原子的序参量

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx order [-f [<.xtc/.trr/...>]] [-n [<.ndx>]] [-nr [<.ndx>]]
          [-s [<.tpr/.tpb/...>]] [-o [<.xvg>]] [-od [<.xvg>]] [-ob [<.pdb>]]
          [-os [<.xvg>]] [-Sg [<.xvg>]] [-Sk [<.xvg>]] [-Sgsl [<.xvg>]]
          [-Sksl [<.xvg>]] [-nice ] [-b ] [-e ] [-dt ]
          [-[no]w] [-xvg ] [-d ] [-sl ] [-[no]szonly]
          [-[no]unsat] [-[no]permolecule] [-[no]radial] [-[no]calcdist]
```
:::
:::

` gmx orde `{.language-plaintext .highlighter-rouge}
用于计算C末端每个原子的序参量. 对原子i, 会使用连接i-1和i+1的向量与轴线.
索引文件中应只包含用于计算的组,
沿相应酰基链的等价碳原子应处于单独的组中.
索引文件不应包含通用组(如System, Protein),
以避免产生混乱(但这与四面体序参量无关, 它只适用于水).

` gmx orde `{.language-plaintext .highlighter-rouge}
可以给出序张量的所有对角线元素, 还可以计算氘代的序参量Scd(默认).
如果使用了 ` -szonly `{.language-plaintext .highlighter-rouge} 选项,
程序只会给出序张量的一个分量(由 ` -d `{.language-plaintext
.highlighter-rouge} 选项指定), 并计算每个切片的序参量. 如果不使用
` -szonly `{.language-plaintext .highlighter-rouge} 选项,
程序会给出序参量的所有对角线元素以及氘代的序参量.

可以确定一个原子周围的四面体序参量, 并计算键角和距离的序参量.
更多细节请参见 P.-L. Chau and A.J. Hardwick, *Mol. Phys.* , 93, (1998),
511-518.

  选项                                    默认值 类型         说明
-------------------------- ------------------- ------------ ---------------------------------------
  ` -f [<.xtc/.trr/...>] `              traj.xtc 输入         轨迹: xtc trr cpt trj gro g96 pdb tng
  ` -n [<.ndx>] `                      index.ndx 输入         索引文件
  ` -nr [<.ndx>] `                     index.ndx 输入         索引文件
  ` -s [<.tpr/.tpb/...>] `             topol.tpr 输入         运行输入文件: tpr tpb tpa
  ` -o [<.xvg>] `                      order.xvg 输出         xvgr/xmgr 文件
  ` -od [<.xvg>] `                    deuter.xvg 输出         xvgr/xmgr文件
  ` -ob [<.pdb>] `                     eiwit.pdb 输出         蛋白质数据库文件
  ` -os [<.xvg>] `                    sliced.xvg 输出         xvgr/xmgr文件
  ` -Sg [<.xvg>] `                    sg-ang.xvg 输出, 可选   xvgr/xmgr文件
  ` -Sk [<.xvg>] `                   sk-dist.xvg 输出, 可选   xvgr/xmgr文件
  ` -Sgsl [<.xvg>] `            sg-ang-slice.xvg 输出, 可选   xvgr/xmgr文件
  ` -Sksl [<.xvg>] `           sk-dist-slice.xvg 输出, 可选   xvgr/xmgr文件

  : 输入/输出文件选项 {#tab-113}

  选项                      默认值 说明
---------------------- --------- -----------------------------------------------------------------
  ` -nice <int> `               19 设置优先级
  ` -b `                         0 从轨迹文件中读取的第一帧(ps)
  ` -e `                         0 从轨迹文件中读取的最后一帧(ps)
  ` -dt `                        0 只使用t除以dt的余数等于第一帧时间(ps)的帧, 即两帧之间的时间间隔
  ` -[no]w `                    no 查看输出.xvg, .xpm, .eps and .pdb文件
  ` -xvg <enum> `          xmgrace xvg绘图格式: xmgrace, xmgr, none
  ` -d <enum> `                  z 膜的法线方向: z, x, y
  ` -sl <int> `                  1 计算序参量与盒子长度的函数关系, 将盒子划分为指定数目的切片
  ` -[no]szonly `               no 只给出序张量的Sz元素.(轴方向可用 ` -d ` 定义)
  ` -[no]unsat `                no 计算不饱和碳的序参量. 注意不能将它和常规序参量混合在一起.
  ` -[no]permolecule `          no 计算每个分子的Scd序参量
  ` -[no]radial `               no 计算径向膜法线
  ` -[no]calcdist `             no 计算到参考位置的距离

  : 控制选项 {#tab-114}

## gmx pdb2gmx: 将PDB坐标文件转换为拓扑文件和力场兼容的坐标文件

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx pdb2gmx [-f [<.gro/.g96/...>]] [-o [<.gro/.g96/...>]] [-p [<.top>]]
            [-i [<.itp>]] [-n [<.ndx>]] [-q [<.gro/.g96/...>]] [-nice ]
            [-chainsep ] [-merge ] [-ff ] [-water ]
            [-[no]inter] [-[no]ss] [-[no]ter] [-[no]lys] [-[no]arg]
            [-[no]asp] [-[no]glu] [-[no]gln] [-[no]his] [-angle ]
            [-dist ] [-[no]una] [-[no]ignh] [-[no]missing] [-[no]v]
            [-posrefc ] [-vsite ] [-[no]heavyh] [-[no]deuterate]
            [-[no]chargegrp] [-[no]cmap] [-[no]renum] [-[no]rtpres]
```
:::
:::

` gmx pdb2gmx `{.language-plaintext .highlighter-rouge} 读取一个
` .pdb `{.language-plaintext .highlighter-rouge} (或
` .gro `{.language-plaintext .highlighter-rouge} )文件和一些数据库文件,
为分子添加氢原子, 生成GROMACS(GROMOS)格式或可选的
` .pdb `{.language-plaintext .highlighter-rouge} 格式的坐标文件,
并生成一个GROMACS格式的拓扑文件.
对这些文件进行后续处理即可生成运行模拟需要的运行输入文件.

` gmx pdb2gmx `{.language-plaintext .highlighter-rouge} 搜索力场时,
会在当前工作目录和GROMACS库目录下的
` <forcefield>.ff `{.language-plaintext .highlighter-rouge} 子目录中搜寻
` forcefiled.itp `{.language-plaintext .highlighter-rouge} 文件,
库目录根据可执行文件的路径确定或由环境变量
` GMXLIB `{.language-plaintext .highlighter-rouge} 指定. 默认情况下,
当程序找到所有可用的 ` forcefield.itp `{.language-plaintext
.highlighter-rouge} 文件后, 会提示你选择其中的一个力场.
但你也可以在命令行中使用 ` -ff `{.language-plaintext .highlighter-rouge}
选项指定列表中某一力场的简短名称. 在这种情况下,
` gmx pdb2gmx `{.language-plaintext .highlighter-rouge}
程序只会搜寻对应的 ` <forcefield>.ff `{.language-plaintext
.highlighter-rouge} 目录.

当选择了一种力场后, 程序仅会读取对应力场目录下的所有文件.
如果要修改或添加一个残基类型,
你可以把整个力场目录复制到你的当前工作目录.
如果想增加一个新的蛋白质残基类型, 你需要修改库目录下的
` residuetype.dat `{.language-plaintext .highlighter-rouge} 文件,
或将整个库目录复制到本地的一个目录中, 修改复制后的
` residuetype.dat `{.language-plaintext .highlighter-rouge} 文件,
并将环境变量 ` GMXLIB `{.language-plaintext .highlighter-rouge}
设为新的目录. 想了解GROMASC文件类型的更多信息, 请参考手册的第五章.

注意, ` .pdb `{.language-plaintext .highlighter-rouge}
文件只是一种文件类型, 不一定非得包含蛋白质结构. 只要GROMACS的数据库支持,
任何类型的分子都可以使用 ` gmx pdb2gmx `{.language-plaintext
.highlighter-rouge} 进行转换. 如果数据库不支持, 你可以自己添加.

这个程序本身也不是万能的, 它需要读取一系列的数据库文件,
这样才能在残基之间加上特殊的化学键(如Cys-Cys, Heme-His等等).
如果你觉得有必要, 这些都可以手动完成. 当指定了一些选项后,
程序可以提示用户选择蛋白质中的LYS, ASP, GLU, CYS或HIS残基的质子化状态.
对于Lys来说, 可以选择中性(即NZ上有两个质子), 也可以选择质子化的(3个质子,
默认). 对于Asp和Glu可以选择非质子化的(默认)或质子化的. 对于His,
质子可以位于ND1或NE2或前两者之上. 默认情况下, 这些选择会自动完成.
对于His, 是根据最优的氢键构象来进行选择的.
氢键是根据简单的几何准则来定义的, 由分子构型确定. 对要判断的三个原子,
即氢供体, 氢原子, 氢受体, 若氢-供体-受体三者之间的角度小于最大角度值,
并且供体-受体原子之间的距离小于最大距离值, 则认为三个原子之间存在氢键.
最大氢键角度和最大氢键距离分别由 ` -angle `{.language-plaintext
.highlighter-rouge} 和 ` -dist `{.language-plaintext .highlighter-rouge}
选项指定.

如果使用了 ` -ter `{.language-plaintext .highlighter-rouge} 选项,
蛋白质N端和C端的质子化状态可以交互式地选择.
默认情况下蛋白质的两端是离子化的(即NH3+和COO-).
对于只有一种残基的蛋白质链, 有些力场可以把它设定为两性分子形式,
但对于多肽链, **不** 应该使用这些选项.
AMBER力场对于蛋白质两端的残基有着自己的独特形式, 与
` -ter `{.language-plaintext .highlighter-rouge} 选项不兼容.
如果要使用AMBER力场, 你需要在N或C端残基对应的名称前分别加上
` N `{.language-plaintext .highlighter-rouge} 或
` C `{.language-plaintext .highlighter-rouge} ,
并保证坐标文件的格式相同. 作为替代方法,
你也可以使用专门的末端残基的名称(如ACE, NME).

处理PDB文件时, 把不同的链分开并不是一件简单的事,
因为用户自己生成的PDB文件中链的组织方式不同, 使用的标记也不同,
有时你确实需要在PDB里面合并由TER标记隔开的两个部分,
比如你需要使用二硫键或距离限制将两条蛋白链连接起来,
或者你的蛋白质上吸附有HEMD基团. 在这种情况下, 多条链需要包含在同一个
` [ moleculetype ] `{.language-plaintext .highlighter-rouge} 定义中.
为了处理这个问题, ` gmx pdb2gmx `{.language-plaintext
.highlighter-rouge} 可以使用两个独立的选项. 首先,
` -chainsep `{.language-plaintext .highlighter-rouge}
选项允许你选择何时开始一个新的化学链, 何时为链添加末端.
这可以根据PDB文件中存在的TER记录, 或链序号的改变,
或前两个条件中的一个或两个进行. 你也可以完全交互式地进行选择.
另外一个选项是 ` -merge `{.language-plaintext .highlighter-rouge} ,
它控制添加(或不添加)所有化学末端后, 如何将多条链合并成一条链.
也可以关闭这个选项(不合并),
也可以让所有不含水分子的链都合并到一个分子中, 或交互式的选择.

` gmx pdb2gmx `{.language-plaintext .highlighter-rouge} 还会检查
` .pdb `{.language-plaintext .highlighter-rouge} 文件中的原子占有率,
如果一个原子的占有率不是1, 说明它在结构中的位置还没有很好的确定, 这时
` pdb2gmx `{.language-plaintext .highlighter-rouge} 会给出警告信息.
若一个 ` .pdb `{.language-plaintext .highlighter-rouge}
文件不是来自X射线晶体衍射确定的结构, 可能所有的占有率都是0. 不管如何,
当使用 ` pdb2gmx `{.language-plaintext .highlighter-rouge} 时,
你必须先验证输入PDB文件的正确性(读PDB文件作者的原始文章!).

处理时, 文件中的原子会使用GROMACS约定进行记录. 如果指定了
` -n `{.language-plaintext .highlighter-rouge} 选项,
程序会生成一个索引文件, 里面包含了以相同方式记录的一个原子组.
这样你就可以用将GROMOS轨迹和坐标文件转换为GROMOS. 需要注意的是,
有一个限制, 因为记录是在去除输入文件中的氢原子之后,
添加新的氢原子之前生成的, 所以你不应该再使用
` -ignh `{.language-plaintext .highlighter-rouge} 选项.

` .gro `{.language-plaintext .highlighter-rouge} 和
` .g96 `{.language-plaintext .highlighter-rouge}
文件类型不支持识别链的序号, 所以如果你要转换一个含有多条链的
` .pdb `{.language-plaintext .highlighter-rouge} 文件, 最好使用
` -o `{.language-plaintext .highlighter-rouge} 选项将结果输出为
` .pdb `{.language-plaintext .highlighter-rouge} 格式的文件.

` -vsite `{.language-plaintext .highlighter-rouge}
选项可以去除氢原子运动和快速的不当二面角运动.
通过将氢原子转换为虚拟位点并固定键角, 即固定它们相对于临近原子的位置,
可以去除键角运动以及面外运动. 此外,
标准氨基酸中芳香环上的所有原子(即PHE, TRP,
TYR和HIS)都可以转换为虚拟位点, 从而去除这些环中的快速不当二面角运动.
**注意** , 在这种情况下, 所有其他氢原子也会被转换为虚拟位点.
所有被转换为虚拟位点的原子的质量会增加到重原子上.

另外, 你也可以指定 ` -heavyh `{.language-plaintext .highlighter-rouge}
选项, 这样氢原子的质量会增加为原来的4倍, 从而可以减慢二面角的运动.
这种方法也可以用于水分子的氢原子, 以减慢水分子的转动.
应当从键合(重)原子的质量中减去氢原子增加的质量, 以维持体系的总质量不变.

  选项                            默认值 类型         说明
-------------------------- ----------- ------------ -----------------------------------------------
  ` -f [<.gro/.g96/...>] `     eiwit.pdb 输入         结构文件: gro g96 pdb brk ent esp tpr tpb tpa
  ` -o [<.gro/.g96/...>] `      conf.gro 输出         结构文件: gro g96 pdb brk ent esp
  ` -p [<.top>] `              topol.top 输出         拓扑文件
  ` -i [<.itp>] `              posre.itp 输出         拓扑的包含的文件
  ` -n [<.ndx>] `              clean.ndx 输出, 可选   索引文件
  ` -q [<.gro/.g96/...>] `     clean.pdb 输出, 可选   结构文件: gro g96 pdb brk ent esp

  : 输入/输出文件选项 {#tab-115}

-----------------------------------------------------------------------------------------------
  选项                                     默认值 说明
----------------------- ----------------------- -----------------------------------------------
  ` -nice <int> `                               0 设置优先级

  ` -chainsep <enum> `                  id_or_ter 设置通过何种方式判断一个新链开始,\
                                                  可用选项: id_or_ter, id_and_ter, ter, id,
                                                  interactive

  ` -merge <enum> `                            no 设置是否将多条链合并为单个 ` [ moleculetype ] `
                                                  ,\
                                                  可用选项: no, all, interactive

  ` -ff <string> `                         select 设置使用何种力场, 默认交互式地选择. 使用 ` -h `
                                                  查看更多信息.

  ` -water <enum> `                        select 设置使用的水分子模型,\
                                                  可用选项: select, none, spc, spce, tip3p,
                                                  tip4p, tip5p.\
                                                  使用这个参数会提前在拓扑文件中添加水分子信息.

  ` -[no]inter `                               no 如果开启了这个选项,
                                                  接下来的八个选项就会交互式地让用户选择

  ` -[no]ss `                                  no 交互式地选择二硫键

  ` -[no]ter `                                 no 交互式地选择蛋白末端, 默认带电

  ` -[no]lys `                                 no 交互式地选择lys赖氨酸类型, 默认带电

  ` -[no]arg `                                 no 交互式地选择arg精氨酸类型, 默认带电

  ` -[no]asp `                                 no 交互式地选择asp天冬氨酸类型, 默认带电

  ` -[no]glu `                                 no 交互式地选择glu谷氨酸类型, 默认带电

  ` -[no]gln `                                 no 交互式地选择gln谷氨酰胺类型, 默认中性

  ` -[no]his `                                 no 交互式地选择his组胺酸类型, 默认通过检查氢键判断

  ` -angle <real> `                           135 设置氢键中氢-氢供体-氢受体之间的最小角度,
                                                  单位度

  ` -dist <real> `                            0.3 设置氢键中氢供体-氢受体之间的最大距离, 单位nm

  ` -[no]una `                                 no 将苯丙氨酸, 色氨酸,
                                                  酪氨酸中的芳香环设为联合CH原子.

  ` -[no]ignh `                                no 忽略坐标文件中的氢原子.
                                                  因为氢原子的命名规则不统一, 有些力场无法识别.

  ` -[no]missing `                             no 当发现坐标文件中的原子有缺失时继续运行,
                                                  设置这个选项很危险.

  ` -[no]v `                                   no 在屏幕上输出更多的信息

  ` -posrefc <real> `                        1000 位置限制的力常数

  ` -vsite <enum> `                          none 设置将哪些原子转变为虚拟位点, 可用选项: none,
                                                  hydrogens, aromatics

  ` -[no]heavyh `                              no 将氢原子质量增大一些

  ` -[no]deuterate `                           no 将氢原子质量更改为2 amu

  ` -[no]chargegrp `                          yes 使用 ` .rtp ` 文件中的电荷组

  ` -[no]cmap `                               yes 使用cmap中的扭转(如果在 ` .rtp ` 文件开启)

  ` -[no]renum `                               no 对输出中的残基重新编号以保证编号连续

  ` -[no]rtpres `                              no 使用 ` .rtp ` 中的条目名称作为残基名称
  -----------------------------------------------------------------------------------------------

  : 控制选项 {#tab-116}

## gmx pme_error: 根据给定的输入文件估计使用PME的误差

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx pme_error [-s [<.tpr/.tpb/...>`]] [-o [<.out>`]] [-so [<.tpr/.tpb/...>`]]
              [-nice ] [-beta ] [-[no]tune] [-self ]
              [-seed ] [-[no]v]
```
:::
:::

如果使用sPME算法, ` gmx pme_error `{.language-plaintext
.highlighter-rouge} 可用于估计静电力的误差.
` -tune `{.language-plaintext .highlighter-rouge} 选项可确定划分参数,
以使得误差在实空间和倒易空间两部分之间均匀分布.
源于粒子自相互作用的那部分误差不易计算.
但是一个较好的近似方法是仅仅使用一部分粒子来计算此项, 这可使用
` -self `{.language-plaintext .highlighter-rouge} 选项完成.

  选项                            默认值 类型         说明
-------------------------- ----------- ------------ ---------------------------
  ` -s [<.tpr/.tpb/...>] `     topol.tpr 输入         运行输入文件: tpr tpb tpa
  ` -o [<.out>] `              error.out 输出         通用输出文件类型
  ` -so [<.tpr/.tpb/...> `     tuned.tpr 输出, 可选   运行输入文件: tpr tpb tpa

  : 输入/输出文件选项 {#tab-117}

  选项                 默认值 说明
------------------ -------- --------------------------------------------------------------------
  ` -nice <int> `           0 设置优先级
  ` -beta <real> `         -1 如果是正值, 用此值覆盖 ` .tpr ` 文件中的 ` ewald_beta ` 值
  ` -[no]tune `            no 调整划分参数, 以使得误差在实空间和倒易空间之间均匀分布
  ` -self <real> `          1 如果处于0到1之间, 只根据这部分带电粒子来确定粒子间的自相互作用误差
  ` -seed <int> `           0 当 ` -self ` 的值处于0.0到1.0之间时, 用于蒙特卡洛算法的随机数种子
  ` -[no]v `               no 屏幕上输出更多信息

  : 控制选项 {#tab-118}

## gmx polystat: 计算聚合物的静态性质

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx polystat [-s [<.tpr/.tpb/...>]] [-f [<.xtc/.trr/...>]] [-n [<.ndx>]]
             [-o [<.xvg>]] [-v [<.xvg>]] [-p [<.xvg>]] [-i [<.xvg>]]
             [-nice ] [-b ] [-e ] [-dt ] [-tu ]
             [-[no]w] [-xvg ] [-[no]mw] [-[no]pc]
```
:::
:::

` gmx polystat `{.language-plaintext .highlighter-rouge}
用于计算聚合物的静态性质与时间的函数关系, 并输出其平均值.

默认情况下, 它会计算聚合物端到端的平均距离与回旋半径. 运行时,
程序需要一个索引组并将其拆分为分子,
然后使用索引组中每个分子的第一个原子和最后一个原子来确定端到端的距离.
程序会输出总的回旋半径, 以及平均回旋张量的三个主分量.
` -v `{.language-plaintext .highlighter-rouge} 选项用于输出本征向量.
` -pc `{.language-plaintext .highlighter-rouge}
选项用于输出每个回旋张量的平均本征值. ` -i `{.language-plaintext
.highlighter-rouge} 选项用于输出内部距离的均方值.

` -p `{.language-plaintext .highlighter-rouge} 选项用于计算持续长度.
所选索引组中应包含在聚合物主链上连续键合的原子.
持续长度根据索引间距为偶数的键之间的角度的余弦值确定,
不使用奇数间距的键, 因为直聚合物的骨架通常全是反式,
因此只能每两个键对齐一次. 持续长度定义为平均余弦值达到1/e时键的数目,
根据log( )的线性内插确定.

  选项                               默认值 类型         说明
-------------------------- -------------- ------------ -------------------------------------------
  ` -s [<.tpr/.tpb/...>] `        topol.tpr 输入         运行输入文件: tpr tpb tpa
  ` -f [<.xtc/.trr/...>] `         traj.xtc 输入         轨迹文件: xtc trr cpt trj gro g96 pdb tng
  ` -n [<.ndx>] `                 index.ndx 输入, 可选   索引文件
  ` -o [<.xvg>] `              polystat.xvg 输出         xvgr/xmgr文件
  ` -v [<.xvg>] `               polyvec.xvg 输出, 可选   xvgr/xmgr文件
  ` -p [<.xvg>] `               persist.xvg 输出, 可选   xvgr/xmgr文件
  ` -i [<.xvg>] `               intdist.xvg 输出, 可选   xvgr/xmgr文件

  : 输入/输出文件选项 {#tab-119}

  选项                 默认值 说明
----------------- --------- -----------------------------------------------------------------
  ` -nice <int> `          19 设置优先级
  ` -b <time> `             0 从轨迹文件中读取的第一帧(ps)
  ` -e <time> `             0 从轨迹文件中读取的最后一帧(ps)
  ` -dt <time> `            0 只使用t除以dt的余数等于第一帧时间(ps)的帧, 即两帧之间的时间间隔
  ` -tu <enum> `           ps 时间单位: fs, ps, ns, us, ms, s
  ` -[no]w `               no 查看输出的.xvg, .xpm, .eps和.pdb文件
  ` -xvg <enum> `     xmgrace xvg绘图格式: xmgrace, xmgr, none
  ` -[no]mw `             yes 计算质量加权的回旋半径
  ` -[no]pc `              no 输出平均本征值

  : 控制选项 {#tab-120}

## gmx potential: 计算盒子内的静电势

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx potential [-f [<.xtc/.trr/...>]] [-n [<.ndx>]] [-s [<.tpr/.tpb/...>]]
              [-o [<.xvg>]] [-oc [<.xvg>]] [-of [<.xvg>]] [-nice ]
              [-b ] [-e ] [-dt ] [-[no]w] [-xvg ]
              [-d ] [-sl ] [-cb ] [-ce ] [-tz ]
              [-[no]spherical] [-ng ] [-[no]correct]
```
:::
:::

` gmx potential `{.language-plaintext .highlighter-rouge}
用于计算盒子内的静电势. 计算方法是, 首先对每个切片内的电荷进行加和,
再对这个电荷分布积分二次. 计算时不考虑周期性边界条件.
电势参考点取为盒子左边的值. 程序也可以计算球坐标中以r为自变量的静电势,
这是通过计算球形切片的电荷分布并积分二次完成的.
` epsilon_r `{.language-plaintext .highlighter-rouge} 的值取为1,
但在许多情况下取2更加合适.

  选项                                默认值 类型   说明
-------------------------- --------------- ------ -------------------------------------------
  ` -f [<.xtc/.trr/...>] `          traj.xtc 输入   轨迹文件: xtc trr cpt trj gro g96 pdb tng
  ` -n [<.ndx>] `                  index.ndx 输入   索引文件
  ` -s [<.tpr/.tpb/...>] `         topol.tpr 输入   运行输入文件: tpr tpb tpa
  ` -o [<.xvg>] `              potential.xvg 输出   xvgr/xmgr文件
  ` -oc [<.xvg>] `                charge.xvg 输出   xvgr/xmgr文件
  ` -of [<.xvg>] `                 field.xvg 输出   xvgr/xmgr文件

  : 输入/输出文件选项 {#tab-121}

  选项                    默认值 说明
-------------------- --------- -----------------------------------------------------------------
  ` -b <time> `                0 从轨迹文件中读取的第一帧(ps)
  ` -e <time> `                0 从轨迹文件中读取的最后一帧(ps)
  ` -dt <time> `               0 只使用t除以dt的余数等于第一帧时间(ps)的帧, 即两帧之间的时间间隔
  ` -[no]w `                  no 查看输出的.xvg, .xpm, .eps和.pdb文件
  ` -xvg <enum> `        xmgrace xvg绘图格式: xmgrace, xmgr, none
  ` -d <string> `              Z 将膜的法向取为X, Y或Z轴方向
  ` -sl <int> `               10 计算电势与盒子长度的函数关系, 选项值即划分盒子的切片数.
  ` -cb <int> `                0 积分时忽略盒子的前指定值个切片
  ` -ce <int> `                0 积分时忽略盒子的后指定值个切片
  ` -tz <real> `               0 沿盒子方向将所有坐标平移指定的距离
  ` -[no]spherical `          no 计算球坐标的各项值
  ` -ng <int> `                1 需要考虑的组的个数
  ` -[no]correct `            no 假定组的净电荷为零以提高精确度

  : 控制选项 {#tab-122}

### 已知问题

-   积分时忽略一些切片并非必要.

## gmx principal: 计算一组原子的惯性主轴

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx principal [-f [<.xtc/.trr/...>]] [-s [<.tpr/.tpb/...>]] [-n [<.ndx>]]
              [-a1 [<.xvg>]] [-a2 [<.xvg>]] [-a3 [<.xvg>]] [-om [<.xvg>]]
              [-nice ] [-b ] [-e ] [-dt ] [-tu ]
              [-[no]w] [-xvg ] [-[no]foo]
```
:::
:::

` gmx principal `{.language-plaintext .highlighter-rouge}
用于计算一组原子的三个惯性主轴. 注意,
老版本的GROMACS以一种奇怪的转置方式输出数据. 对GROMACS-5.0, 输出文件
` paxis1.dat `{.language-plaintext .highlighter-rouge}
中包含了每一帧第一(主)轴的x/y/z分量, 同样,
` paxis2.dat `{.language-plaintext .highlighter-rouge}
中包含中间轴的x/y/z分量, ` paxis3.dat `{.language-plaintext
.highlighter-rouge} 中包含最小轴的x/y/z分量.

  选项                             默认值 类型         说明
-------------------------- ------------ ------------ ------------------------------------------------
  ` -f [<.xtc/.trr/...>] `       traj.xtc 输入         轨迹: xtc trr cpt trj gro g96 pdb tng
  ` -s [<.tpr/.tpb/...>] `      topol.tpr 输入         结构+质量(db): tpr tpb tpa gro g96 pdb brk ent
  ` -n [<.ndx>] `               index.ndx 输入, 可选   索引file
  ` -a1 [<.xvg>] `             paxis1.xvg 输出         xvgr/xmgr文件
  ` -a2 [<.xvg>] `             paxis2.xvg 输出         xvgr/xmgr文件
  ` -a3 [<.xvg>] `             paxis3.xvg 输出         xvgr/xmgr文件
  ` -om [<.xvg>] `                moi.xvg 输出         xvgr/xmgr文件

  : 输入/输出文件选项 {#tab-123}

  选项                 默认值 说明
----------------- --------- -----------------------------------------------------------------
  ` -nice <int> `          19 设置优先级
  ` -b <time> `             0 从轨迹文件中读取的第一帧(ps)
  ` -e <time> `             0 从轨迹文件中读取的最后一帧(ps)
  ` -dt <time> `            0 只使用t除以dt的余数等于第一帧时间(ps)的帧, 即两帧之间的时间间隔
  ` -tu <enum> `           ps 时间单位: fs, ps, ns, us, ms, s
  ` -[no]w `               no 查看输出的.xvg, .xpm, .eps和.pdb文件
  ` -xvg <enum> `     xmgrace xvg绘图格式: xmgrace, xmgr, none
  ` -[no]foo `             no 用于避免空数组的哑选项

  : 控制选项 {#tab-124}

## gmx protonate: 结构质子化

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx protonate [-s [<.tpr/.tpb/...>]] [-f [<.xtc/.trr/...>]] [-n [<.ndx>]]
              [-o [<.xtc/.trr/...>]] [-nice ] [-b ] [-e ]
              [-dt ]
```
:::
:::

` gmx protonate `{.language-plaintext .highlighter-rouge} 读取构象并根据
` oplsaa.ff/aminoacids.hdb `{.language-plaintext .highlighter-rouge}
文件中的定义添加所有丢失氢原子. 如果仅仅指定 ` -s `{.language-plaintext
.highlighter-rouge} 选项, 那么构象将会被质子化, 如果也指定了
` -f `{.language-plaintext .highlighter-rouge} 选项,
那么程序会从文件中读取构象, 可以是单个构象或者轨迹.

如果提供了一个 ` .pdb `{.language-plaintext .highlighter-rouge} 文件,
那么残基名称可能与GROMACS的命名规则不一致. 在这种情况下,
这些残基很可能不会被正确地质子化.

如果指定了索引文件, 请注意原子数目应当与 **质子化** 状态相对应.

  选项                                 默认值 类型         说明
-------------------------- ---------------- ------------ -------------------------------------------
  ` -s [<.tpr/.tpb/...>] `          topol.tpr 输入         结构文件: tpr tpb tpa gro g96 pdb brk ent
  ` -f [<.xtc/.trr/...>] `           traj.xtc 输入, 可选   轨迹文件: xtc trr cpt trj gro g96 pdb tng
  ` -n [<.ndx>] `                   index.ndx 输入, 可选   索引文件
  ` -o [<.xtc/.trr/...>] `     protonated.xtc 输出         轨迹文件: xtc trr trj gro g96 pdb tng

  : 输入/输出文件选项 {#tab-125}

  选项                默认值 说明
----------------- -------- -----------------------------------------------------------------
  ` -nice <int> `          0 设置优先级
  ` -b `                   0 从轨迹文件中读取的第一帧(ps)
  ` -e `                   0 从轨迹文件中读取的最后一帧(ps)
  ` -dt `                  0 只使用t除以dt的余数等于第一帧时间(ps)的帧, 即两帧之间的时间间隔

  : 控制选项 {#tab-126}

### 已知问题

-   目前, ` -s `{.language-plaintext .highlighter-rouge} 选项仅接受
    ` .pdb `{.language-plaintext .highlighter-rouge} 文件.

## gmx rama:计算Ramachandran拉式构象图

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx rama [-f [<.xtc/.trr/...>]] [-s [<.tpr/.tpb/...>]] [-o [<.xvg>]]
         [-nice ] [-b ] [-e ] [-dt ] [-[no]w]
         [-xvg ]
```
:::
:::

` gmx rama `{.language-plaintext .highlighter-rouge}
可以从你的拓扑文件中选择出φ/ψ(α-碳与酰胺平面交角)二面角的组合,
并且计算它们随时间变化的函数.
使用简单的Unix工具如grep你就可以选出特定残基的数据.

  选项                            默认值 类型   说明
-------------------------- ----------- ------ -------------------------------------------
  ` -f [<.xtc/.trr/...>] `      traj.xtc 输入   轨迹文件: xtc trr cpt trj gro g96 pdb tng
  ` -s [<.tpr/.tpb/...>] `     topol.tpr 输入   运行输入文件: tpr tpb tpa
  ` -o [<.xvg>] `               rama.xvg 输出   xvgr/xmgr文件

  : 输入/输出文件选项 {#tab-127}

  选项                 默认值 说明
----------------- --------- -----------------------------------------------------------------
  ` -nice <int> `          19 设置优先级
  ` -b <time> `             0 从轨迹文件中读取的第一帧(ps)
  ` -e <time> `             0 从轨迹文件中读取的最后一帧(ps)
  ` -dt <time> `            0 只使用t除以dt的余数等于第一帧时间(ps)的帧, 即两帧之间的时间间隔
  ` -[no] `                no 程序运行结束查看输出文件: .xvg, .xpm, .eps和.pdb
  ` -xvg <enum> `     xmgrace xvg绘图格式: xmgrace, xmgr, none

  : 控制选项 {#tab-128}

### 补充说明

拉氏图(Ramachandran图)是通过统计蛋白质结构残基的φ/ψ二面角绘制的,
集中分布在几个角度范围内的区域. 物质都具有自发朝能量最低方向变化的特点,
自然界的蛋白也是, 所以拉氏标准分布图中, 统计分布密集的区域,
对应于蛋白能量低, 稳定的构象, 在这些区域中, 残基侧链彼此间斥力小.
模拟得到的结果如果绝大多数落在这些范围中, 也可以说明具有这样的特征.
但分布另一方面也和残基类型有关, 侧链越小所受的斥力制约越小,
在拉氏图中分布范围越广.

一些可视化软件可以直接给出拉氏图. 在VMD中, 使用
` VMD Main `{.language-plaintext .highlighter-rouge} -\>
` Extensions `{.language-plaintext .highlighter-rouge} -\>
` Analysis `{.language-plaintext .highlighter-rouge} -\>
` Ramachandran Plot `{.language-plaintext .highlighter-rouge}
即可得到类似下面的拉氏图.

![](/GMX/gmx_rama.png)

## gmx rdf: 计算径向分布函数

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx rdf [-f [<.xtc/.trr/...>]] [-s [<.tpr/.tpb/...>]] [-n [<.ndx>]]
        [-o [<.xvg>]] [-cn [<.xvg>]] [-hq [<.xvg>]] [-nice ] [-b ]
        [-e ] [-dt ] [-[no]w] [-xvg ] [-bin ]
        [-[no]com] [-surf ] [-rdf ] [-[no]pbc] [-[no]norm]
        [-[no]xy] [-cut ] [-ng ] [-fade ]
```
:::
:::

流体的结构可以通过中子散射或者X射线散射进行研究.
描述流体结构的最常用方法是径向分布函数. 但是,
通过散射实验获得径向分布函数并不容易.

` gmx rdf `{.language-plaintext .highlighter-rouge}
可利用几种不同的方法来计算径向分布函数.
通常的方法是计算一个(组)粒子周围的径向分布函数,
其他方法包括计算一组粒子质心周围的径向分布函数(
` -com `{.language-plaintext .highlighter-rouge} ),
或到最近一组粒子的径向分布函数( ` -surf `{.language-plaintext
.highlighter-rouge} ). 所有这些方法都可以利用
` -xy `{.language-plaintext .highlighter-rouge}
选项计算围绕与z轴平行的轴的RDF. 使用选项 ` -surf `{.language-plaintext
.highlighter-rouge} 时, 不能使用归一化.

选项 ` -rdf `{.language-plaintext .highlighter-rouge}
用来设置要计算RDF的类型. 默认为原子或粒子,
但也可以选择分子或残基的质心或几何中心. 无论哪种情况,
都只会考虑索引组中的原子. 对于分子和/或质心选项, 需要输入文件.
除COM(质心)或COG(几何中心)外,
其他的加权方法目前只能通过提供具有不同质量的输入文件来实现. 参数
` -com `{.language-plaintext .highlighter-rouge} 与
` -surf `{.language-plaintext .highlighter-rouge} 也可以与
` -rdf `{.language-plaintext .highlighter-rouge} 选项一同使用.

如果已经提供了一个输入文件( ` -s `{.language-plaintext
.highlighter-rouge} ), 并且 ` -rdf `{.language-plaintext
.highlighter-rouge} 设置为 ` atom `{.language-plaintext
.highlighter-rouge} , 那么在计算RDF的时候, 会考虑到输入文件中定义的排除.
选项 ` -cut `{.language-plaintext .highlighter-rouge}
是另外一种可以避免RDF图中出现分子内峰的方法,
但最好还是将输入文件中的排除数设置得高一些. 比如, 对于苯的拓扑,
将nrexcl设置为5就可以全部消除分子内距离对RDF的贡献. 注意,
在计算时会使用已选组中的所有原子,
还包括那些没有Lennard-Jones相互作用的原子.

选项 ` -cn `{.language-plaintext .highlighter-rouge} 生成RDF累积数,
也就是在r距离范围内的平均粒子数.

  选项                             默认值 类型         说明
-------------------------- ------------ ------------ ------------------------------------------------
  ` -f [<.xtc/.trr/...>] `       traj.xtc 输入         轨迹文件: xtc trr cpt trj gro g96 pdb tng
  ` -s [<.tpr/.tpb/...>] `      topol.tpr 输入, 可选   结构+质量(db): tpr tpb tpa gro g96 pdb brk ent
  ` -n [<.ndx>] `               index.ndx 输入, 可选   索引文件
  ` -o [<.xvg>] `                 rdf.xvg 输出         xvgr/xmgr文件
  ` -cn [<.xvg>] `             rdf_cn.xvg 输出, 可选   xvgr/xmgr文件
  ` -hq [<.xvg>] `                 hq.xvg 输出, 可选   xvgr/xmgr文件

  : 输入/输出文件选项 {#tab-129}

--------------------------------------------------------------------------------------------
  选项                                     默认值 说明
----------------------- ----------------------- --------------------------------------------
  ` -nice `                                    19 设置优先级

  ` -b `                                        0 从轨迹文件中读取的第一帧(ps)

  ` -e `                                        0 从轨迹文件中读取的最后一帧(ps)

  ` -dt `                                       0 只使用t除以dt的余数等于第一帧时间(ps)的帧,
                                                  即两帧之间的时间间隔

  ` -[no]w `                                   no 查看输出.xvg, .xpm, .eps and .pdb文件

  ` -xvg <enum> `                         xmgrace xvg绘图格式: xmgrace, xmgr, none

  ` -bin `                                  0.002 分格宽度(nm)

  ` -[no]com `                                 no 相对于第一个组质心的RDF

  ` -surf `                                    no 相对于第一组表面的RDF: no, mol, res

  ` -rdf `                                   atom RDF类型: atom, mol_com, mol_cog, res_com,
                                                  res_cog

  ` -[no]pbc `                                yes 计算距离时考虑周期性边界条件(PBC).\
                                                  如果不使用PBC,
                                                  距离的最大值为盒子最长边的三倍.

  ` -[no]norm `                               yes 对体积和密度进行归一化

  ` -[no]xy `                                  no 只使用距离的x和y分量

  ` -cut `                                      0 计算时所考虑的最短距离(nm)

  ` -ng `                                       1 计算中心组的RDF时, 其周围的次要组的数目

  ` -fade `                                     0 从此距离开始, 将使用g\'(r) = 1 + \[g(r)-1\]
                                                  exp(-(r/fade-1)\^2) 对RDF进行变换,\
                                                  以使RDF曲线光滑地趋向于1, 如果fade设置为0.0,
                                                  将不做任何处理.
  --------------------------------------------------------------------------------------------

  : 控制选项 {#tab-130}

## gmx rms: 计算与参考结构之间的RMSD及其矩阵

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx rms [-s [<.tpr/.tpb/...>]] [-f [<.xtc/.trr/...>]]
        [-f2 [<.xtc/.trr/...>]] [-n [<.ndx>]] [-o [<.xvg>]] [-mir [<.xvg>]]
        [-a [<.xvg>]] [-dist [<.xvg>]] [-m [<.xpm>]] [-bin [<.dat>]]
        [-bm [<.xpm>]] [-nice ] [-b ] [-e ] [-dt ]
        [-tu ] [-[no]w] [-xvg ] [-what ] [-[no]pbc]
        [-fit ] [-prev ] [-[no]split] [-skip ] [-skip2 ]
        [-max ] [-min ] [-bmax ] [-bmin ] [-[no]mw]
        [-nlevels ] [-ng ]
```
:::
:::

` gmx rms `{.language-plaintext .highlighter-rouge}
通过计算均方根偏差(RMSD, root mean square deviation),
尺寸无关的ρ相似性参数( ` rho `{.language-plaintext .highlighter-rouge}
)或标度ρ参数( ` rhosc `{.language-plaintext .highlighter-rouge}
)来比较两个结构. 请参考Maiorov & Crippen, *Proteins* **22** , 273
(1995). 可利用 ` -what `{.language-plaintext .highlighter-rouge}
选项来选择计算那个参数.

程序会将轨迹( ` -f `{.language-plaintext .highlighter-rouge}
)中的每个结构与参考结构进行比较. 参考结构取自结构文件(
` -s `{.language-plaintext .highlighter-rouge} ).

使用 ` -mir `{.language-plaintext .highlighter-rouge} 选项,
还会与参考结构的镜像进行比较. 这可以作为一个很有用的参考'显著'值.
详见Maiorov & Crippen, *Proteins* **22** , 273 (1995).

选项 ` -prev `{.language-plaintext .highlighter-rouge}
会对当前帧的结构与前面指定帧中的结构进行比较.

选项 ` -m `{.language-plaintext .highlighter-rouge} 将生成一个
` .xpm `{.language-plaintext .highlighter-rouge} 格式的矩阵,
其值为轨迹中所有结构彼此之间的比较值. 这个矩阵文件可以使用如
` xv `{.language-plaintext .highlighter-rouge} 之类的程序进查看,
也可以使用 ` gmx xpm2ps `{.language-plaintext .highlighter-rouge}
将其转换为postscript格式.

选项 ` -fit `{.language-plaintext .highlighter-rouge}
控制结构彼此之间的最小二乘叠合: 完全叠合(旋转和平移), 仅平移, 或不叠合.

选项 ` -mw `{.language-plaintext .highlighter-rouge}
控制是否使用质量加权. 如果你选择了这个选项(默认), 并提供一个有效的
` .tpr `{.language-plaintext .highlighter-rouge} 文件, 程序会读取
` .tpr `{.language-plaintext .highlighter-rouge} 文件中的质量,
否则将会从 ` GMXLIB `{.language-plaintext .highlighter-rouge} 目录下的
` atommass.dat `{.language-plaintext .highlighter-rouge} 文件中获取质量.
对于蛋白质这还可以, 但对于别的分子来说就未必了. 对未知的原子,
会分配默认的质量12.011 amu(碳原子). 你可以通过打开
` -debug `{.language-plaintext .highlighter-rouge} 选项并检查
` log `{.language-plaintext .highlighter-rouge} 文件来判断是否这样.

使用 ` -f2 `{.language-plaintext .highlighter-rouge} 选项,
程序会从第二个轨迹文件中读取'其他结构', 并生成两个轨迹之间的比较矩阵.

选项 ` -bin `{.language-plaintext .highlighter-rouge}
会对比较矩阵进行二进制转储.

选项 ` -bm `{.language-plaintext .highlighter-rouge}
会产生平均键角偏差的矩阵, 类似 ` -m `{.language-plaintext
.highlighter-rouge} 选项. 比较时只会考虑比较组中原子之间的键.

  选项                                 默认值 类型         说明
--------------------------- --------------- ------------ ------------------------------------------------
  ` -s [<.tpr/.tpb/...>] `          topol.tpr 输入         结构+质量(db): tpr tpb tpa gro g96 pdb brk ent
  ` -f [<.xtc/.trr/...>] `           traj.xtc 输入         轨迹: xtc trr cpt trj gro g96 pdb tng
  ` -f2 [<.xtc/.trr/...>] `          traj.xtc 输入, 可选   轨迹: xtc trr cpt trj gro g96 pdb tng
  ` -n [<.ndx>] `                   index.ndx 输入, 可选   索引文件
  ` -o [<.xvg>] `                    rmsd.xvg 输出         xvgr/xmgr文件
  ` -mir [<.xvg>] `               rmsdmir.xvg 输出, 可选   xvgr/xmgr文件
  ` -a [<.xvg>] `                   avgrp.xvg 输出, 可选   xvgr/xmgr文件
  ` -dist [<.xvg>] `            rmsd-dist.xvg 输出, 可选   xvgr/xmgr文件
  ` -m [<.xpm>] `                    rmsd.xpm 输出, 可选   X PixMap兼容矩阵文件
  ` -bin [<.dat>] `                  rmsd.dat 输出, 可选   通用数据文件
  ` -bm [<.xpm>] `                   bond.xpm 输出, 可选   X PixMap兼容矩阵文件

  : 输入/输出文件选项 {#tab-131}

  选项                      默认值 说明
-------------------- ----------- -----------------------------------------------------------------
  ` -nice <int> `               19 设置优先级
  ` -b `                         0 从轨迹文件中读取的第一帧(ps)
  ` -e `                         0 从轨迹文件中读取的最后一帧(ps)
  ` -dt `                        0 只使用t除以dt的余数等于第一帧时间(ps)的帧, 即两帧之间的时间间隔
  ` -tu <enum> `                ps 时间单位: fs, ps, ns, us, ms, s
  ` -[no]w `                    no 程序结束后查看输出的.xvg, .xpm, .eps和.pdb文件
  ` -xvg <enum> `          xmgrace xvg绘图格式: xmgrace, xmgr, none
  ` -what <enum> `            rmsd 结构差异类型: rmsd, rho, rhosc
  ` -[no]pbc `                 yes PBC检查
  ` -fit <enum> `        rot+trans 叠合到参考结构: rot+trans, translation, none
  ` -prev <int> `                0 和前面的帧进行比较
  ` -[no]split `                no 在时间为0的地方分割图
  ` -skip <int> `                1 每nr帧写入矩阵一次
  ` -skip2 <int> `               1 每nr帧写入矩阵一次
  ` -max <real> `               -1 比较矩阵的最大水平
  ` -min <real> `               -1 比较矩阵的最小水平
  ` -bmax <real> `              -1 键角矩阵的最大水平
  ` -bmin <real> `              -1 键角矩阵的最小水平
  ` -[no]mw `                  yes 重叠部分使用质量权重
  ` -nlevels <int> `            80 矩阵的水平数
  ` -ng <int> `                  1 计算RMS的组数

  : 控制选项 {#tab-132}

## gmx rmsdist: 计算-2, -3或-6次平均的原子对距离

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx rmsdist [-f [<.xtc/.trr/...>]] [-s [<.tpr/.tpb/...>]] [-n [<.ndx>]]
            [-equiv [<.dat>]] [-o [<.xvg>]] [-rms [<.xpm>]] [-scl [<.xpm>]]
            [-mean [<.xpm>]] [-nmr3 [<.xpm>]] [-nmr6 [<.xpm>]]
            [-noe [<.dat>]] [-nice ] [-b ] [-e ]
            [-dt ] [-[no]w] [-xvg ] [-nlevels ]
            [-max ] [-[no]sumh] [-[no]pbc]
```
:::
:::

` gmx rmsdist `{.language-plaintext .highlighter-rouge}
用于计算原子距离的根均方偏差(RMSD, root mean square deviation).
该程序的优势在于计算时不需要叠合, 而 ` gmx rms `{.language-plaintext
.highlighter-rouge} 计算标准RMSD时则需要叠合. 参考结构取自结构文件,
t时刻的RMSD定义为参考结构与t时刻结构原子对之间距离差值的RMS.

` gmx rmsdist `{.language-plaintext .highlighter-rouge}
也可用于生成RMS距离的矩阵, 使用平均距离标度的RMS距离矩阵, 平均距离矩阵,
NMR平均距离矩阵(1/r\^3和1/r\^6平均). 最终, 程序可以生成一个原子对的列表,
其中包含所有1/r\^3和1/r\^6平均距离小于最大距离(
` -max `{.language-plaintext .highlighter-rouge} 指定,
默认为0.6)的原子对. 默认情况下,
平均是对等价氢原子(以\*\[123\]命名的所有氢原子三联对)进行的. 此外,
还可以提供其他等价原子的列表( ` -equiv `{.language-plaintext
.highlighter-rouge} ), 列表中每行包含一组等价原子, 使用残基序号,
残基名称, 原子名字指定, 如:

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
HB* 3 SER HB1 3 SER HB2
```
:::
:::

残基名称和原子名称必须与结构文件中的精确匹配, 包括大小写.
程序没有规定如何指定非连续的原子.

  选项                               默认值 类型         说明
-------------------------- -------------- ------------ ------------------------------------------------
  ` -f [<.xtc/.trr/...>] `         traj.xtc 输入         轨迹文件: xtc trr cpt trj gro g96 pdb tng
  ` -s [<.tpr/.tpb/...>] `        topol.tpr 输入         结构+质量(db): tpr tpb tpa gro g96 pdb brk ent
  ` -n [<.ndx>] `                 index.ndx 输入, 可选   索引文件
  ` -equiv [<.dat>] `             equiv.dat 输入, 可选   通用数据文件
  ` -o [<.xvg>] `              distrmsd.xvg 输出         xvgr/xmgr文件
  ` -rms [<.xpm>] `             rmsdist.xpm 输出, 可选   X PixMap兼容矩阵文件
  ` -scl [<.xpm>] `            rmsscale.xpm 输出, 可选   X PixMap兼容矩阵文件
  ` -mean [<.xpm>] `            rmsmean.xpm 输出, 可选   X PixMap兼容矩阵文件
  ` -nmr3 [<.xpm>] `               nmr3.xpm 输出, 可选   X PixMap兼容矩阵文件
  ` -nmr6 [<.xpm>] `               nmr6.xpm 输出, 可选   X PixMap兼容矩阵文件
  ` -noe [<.dat>] `                 noe.dat 输出, 可选   通用数据文件

  : 输入/输出文件选项 {#tab-133}

  选项                    默认值 说明
-------------------- --------- -----------------------------------------------------------------
  ` -nice <int> `             19 设置优先级
  ` -b <time> `                0 从轨迹文件中读取的第一帧(ps)
  ` -e <time> `                0 从轨迹文件中读取的最后一帧(ps)
  ` -dt <time> `               0 只使用t除以dt的余数等于第一帧时间(ps)的帧, 即两帧之间的时间间隔
  ` -[no] `                   no 程序运行结束查看输出的.xvg, .xpm, .eps和.pdb文件
  ` -xvg <enum> `        xmgrace xvg绘图格式: xmgrace, xmgr, none
  ` -nlevels <int> `          40 离散化RMS的水平数
  ` -max <real> `             -1 矩阵中的最大水平数
  ` -[no]sumh `              yes 对等价氢原子进行平均
  ` -[no]pbc `               yes 计算距离时使用周期性边界条件

  : 控制选项 {#tab-134}

## gmx rmsf: 计算原子涨落

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx rmsf [-f [<.xtc/.trr/...>]] [-s [<.tpr/.tpb/...>]] [-n [<.ndx>]]
         [-q [<.pdb>]] [-oq [<.pdb>]] [-ox [<.pdb>]] [-o [<.xvg>]]
         [-od [<.xvg>]] [-oc [<.xvg>]] [-dir [<.log>]] [-nice ]
         [-b ] [-e ] [-dt ] [-[no]w] [-xvg ]
         [-[no]res] [-[no]aniso] [-[no]fit]
```
:::
:::

` gmx rmsf `{.language-plaintext .highlighter-rouge} 计算轨迹(使用
` -f `{.language-plaintext .highlighter-rouge}
提供)中原子位置的根均方涨落(RMSF, root mean square fluctuation,
即标准偏差), 计算前可以先将构型与参考帧(使用 ` -s `{.language-plaintext
.highlighter-rouge} 提供)的构型进行叠合(并非必须).

使用选项 ` -oq `{.language-plaintext .highlighter-rouge}
时会将RMSF值转换为B因子值, 并将其与坐标一起写入
` .pdb `{.language-plaintext .highlighter-rouge} 文件中,
其中坐标来自结构文件, 或是由 ` -q `{.language-plaintext
.highlighter-rouge} 指定的 ` .pdb `{.language-plaintext
.highlighter-rouge} 文件. 选项 ` -ox `{.language-plaintext
.highlighter-rouge} 会将B因子与平均坐标写入文件中.

使用选项 ` -od `{.language-plaintext .highlighter-rouge}
时会计算相对于参考结构的根均方偏差.

使用选项 ` -aniso `{.language-plaintext .highlighter-rouge} 时,
` gmx rmsf `{.language-plaintext .highlighter-rouge}
将会计算各项异性温度因子, 还会输出平均坐标和含有ANISOU记录的
` .pdb `{.language-plaintext .highlighter-rouge} 文件(对应于
` -oq `{.language-plaintext .highlighter-rouge} 或
` -ox `{.language-plaintext .highlighter-rouge} 选项). 注意,
U值与取向有关, 因此在与实验数据对比之前请确认已经与实验坐标进行了叠合.

当传递给程序一个 ` .pdb `{.language-plaintext .highlighter-rouge} 文件,
并且设置了 ` -aniso `{.language-plaintext .highlighter-rouge} 选项时,
如果 ` .pdb `{.language-plaintext .highlighter-rouge}
文件中含有任何各向异性温度因子, 将会创建Uij的相关图.

使用选项 ` -dir `{.language-plaintext .highlighter-rouge}
时会对平均MSF(3x3)矩阵进行对角化. 这可用于显示原子在哪个方向上涨落最大,
哪个方向上涨落最小.

  选项                                默认值 类型         说明
----------------------------- ------------ ------------ ------------------------------------------------
  ` -f [<.xtc/.trr/...>] `          traj.xtc 输入         轨迹文件: xtc trr cpt trj gro g96 pdb tng
  ` -s [<.tpr/.tpb/...>] `         topol.tpr 输入         结构+质量(db): tpr tpb tpa gro g96 pdb brk ent
  ` -n [<.ndx>] `                  index.ndx 输入, 可选   索引文件
  ` -q [<.pdb>] `                  eiwit.pdb 输入, 可选   蛋白质数据信息文件
  ` -oq [<.pdb>] (bfac.pdb) `       bfac.pdb 输出, 可选   蛋白质数据信息文件
  ` -ox [<.pdb>] `                 xaver.pdb 输出, 可选   蛋白质数据信息文件
  ` -o [<.xvg>] `                   rmsf.xvg 输出         xvgr/xmgr 文件
  ` -od [<.xvg>] `                rmsdev.xvg 输出, 可选   xvgr/xmgr文件
  ` -oc [<.xvg>] `                correl.xvg 输出, 可选   xvgr/xmgr文件
  ` -dir [<.log>] `                 rmsf.log 输出, 可选   Log文件

  : 输入/输出文件选项 {#tab-135}

  选项                 默认值 说明
----------------- --------- ---------------------------------------------------------------------------------
  ` -nice <int> `          19 设置优先级
  ` -b <time> `             0 从轨迹文件中读取的第一帧(ps)
  ` -e <time> `             0 从轨迹文件中读取的最后一帧(ps)
  ` -dt <time> `            0 只使用t除以dt的余数等于第一帧时间(ps)的帧, 即两帧之间的时间间隔
  ` -[no]w `               no 查看输出文件 .xvg, .xpm, .eps和.pdb
  ` -xvg <enum> `     xmgrace xvg绘图格式: xmgrace, xmgr, none
  ` -[no]res `             no 计算每个残基的均值
  ` -[no]aniso `           no 计算各向异性温度因子
  ` -[no]fit `            yes 计算RMSF之前进行最小二乘叠合. 如果不使用这个选项, 你必须确保参考结构与轨迹匹配.

  : 控制选项 {#tab-136}

## gmx rotacf: 计算分子的转动相关函数

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx rotacf [-f [<.xtc/.trr/...>]] [-s [<.tpr/.tpb/...>]] [-n [<.ndx>]]
           [-o [<.xvg>]] [-nice ] [-b ] [-e ] [-dt ]
           [-[no]w] [-xvg ] [-[no]d] [-[no]aver] [-acflen ]
           [-[no]normalize] [-P ] [-fitfn ] [-beginfit ]
           [-endfit ]
```
:::
:::

` gmx rotacf `{.language-plaintext .highlighter-rouge}
用于计算分子的旋转相关函数. 必须在索引文件中给出原子三联对(i,j,k),
它们定义了ij和jk两个向量. 旋转ACF根据向量n = ij x jk,
即两个向量叉积的自相关函数计算得到. 由于三个原子可张成一个平面,
因此三个原子的顺序并不重要. 作为可选, 通过使用
` -d `{.language-plaintext .highlighter-rouge} 选项,
并在索引文件中指定原子对(i,j), 你可以计算线性分子的旋转相关函数.

示例:

` gmx rotacf -P 1 -nparm 2 -fft -n index -o rotacf-x-P1 -fa expfit-x-P1 -beginfit 2.5 -endfit 20.0 `{.language-plaintext
.highlighter-rouge}

上面的命令将利用索引文件中定义的向量间的夹角的一阶勒让德多项式计算旋转相关函数,
并根据2.5 ps到20.0 ps的数据, 将相关函数拟合为双参数指数形式.

  选项                             默认值 类型   说明
-------------------------- ------------ ------ ---------------------------------------
  ` -f [<.xtc/.trr/...>] `       traj.xtc 输入   轨迹: xtc trr cpt trj gro g96 pdb tng
  ` -s [<.tpr/.tpb/...>] `      topol.tpr 输入   运行输入文件: tpr tpb tpa
  ` -n [<.ndx>] `               index.ndx 输入   索引文件
  ` -o [<.xvg>] `              rotacf.xvg 输出   xvgr/xmgr文件

  : 输入/输出文件选项 {#tab-137}

  选项                      默认值 说明
---------------------- --------- -------------------------------------------------------------------
  ` -nice <int> `                0 设置优先级
  ` -b <time> `                  0 从轨迹文件中读取的第一帧(ps)
  ` -e <time> `                  0 从轨迹文件中读取的最后一帧(ps)
  ` -dt <time> `                 0 只使用t除以dt的余数等于第一帧时间(ps)的帧, 即两帧之间的时间间隔
  ` -[no]w `                    no 查看输出的.xvg, .xpm, .eps和.pdb文件
  ` -xvg <enum> `          xmgrace xvg绘图格式: xmgrace, xmgr, none
  ` -[no]d `                    no 计算相关函数时使用索引双联对(向量)而不是三联对(平面)
  ` -[no]aver `                yes 对所有分子进行平均
  ` -acflen <int> `             -1 ACF的长度, 默认为帧数的一半.
  ` -[no]normalize `           yes 对ACF进行归一化
  ` -P <enum> `                  0 用于ACF的Legendre多项式的阶数(0代表不使用): 0, 1, 2, 3
  ` -fitfn <enum> `           none 拟合函数: none, exp, aexp, exp_exp, vac, exp5, exp7, exp9, erffit
  ` -beginfit <real> `           0 相关函数指数拟合的起始时间
  ` -endfit <real> `            -1 相关函数指数拟合的终止时间, -1代表直到最后

  : 控制选项 {#tab-138}

## gmx rotmat: 计算叠合到参考结构的旋转矩阵

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx rotmat [-f [<.xtc/.trr/...>]] [-s [<.tpr/.tpb/...>]] [-n [<.ndx>]]
           [-o [<.xvg>]] [-nice ] [-b ] [-e ] [-dt ]
           [-[no]w] [-xvg ] [-ref ] [-skip ] [-[no]fitxy]
           [-[no]mw]
```
:::
:::

` gmx rotmat `{.language-plaintext .highlighter-rouge}
用于输出将一个构象最小二乘叠合到参考构象所需要的旋转矩阵, 参考构象由
` -s `{.language-plaintext .highlighter-rouge} 选项提供.
叠合前会移除平动自由度. 输出为三个向量, 给出了 参考构象x,
y和z方向的新的方向, 例如, (zx,zy,zz)为轨迹帧中参考z轴的取向.

此工具对于某些情况可能有用, 例如, 确定界面处分子的取向, 可能在轨迹中, 由
` gmx trjconv -fit rotxy+transxy `{.language-plaintext
.highlighter-rouge} 移除在x-y平面内的旋转.

` -ref `{.language-plaintext .highlighter-rouge}
选项可用于确定叠合的参考结构, 而不是使用来自 ` -s `{.language-plaintext
.highlighter-rouge} 的结构.
程序会使用到所有其他结构的RMSD总和最小的结构作为参考结构.
由于此过程的计算代价与帧数的平方根成正比, 使用
` -skip `{.language-plaintext .highlighter-rouge} 选项可能有帮助.
程序可以进行完全叠合或只进行x-y平面内的叠合.

使用选项 ` -fitxy `{.language-plaintext .highlighter-rouge} 时,
在确定旋转矩阵前会先在x-y平面进行叠合.

  选项                             默认值 类型         说明
-------------------------- ------------ ------------ ------------------------------------------------
  ` -f [<.xtc/.trr/...>] `       traj.xtc 输入         轨迹: xtc trr cpt trj gro g96 pdb tng
  ` -s [<.tpr/.tpb/...>] `      topol.tpr 输入         结构+质量(db): tpr tpb tpa gro g96 pdb brk ent
  ` -n [<.ndx>] `               index.ndx 输入, 可选   索引文件
  ` -o [<.xvg>] `              rotmat.xvg 输出         xvgr/xmgr文件

  : 输入/输出文件选项 {#tab-139}

  选项                 默认值 说明
----------------- --------- -----------------------------------------------------------------
  ` -nice <int> `           0 设置优先级
  ` -b <time> `             0 从轨迹文件中读取的第一帧(ps)
  ` -e <time> `             0 从轨迹文件中读取的最后一帧(ps)
  ` -dt <time> `            0 只使用t除以dt的余数等于第一帧时间(ps)的帧, 即两帧之间的时间间隔
  ` -[no]w `               no 查看输出的 ` .xvg ` , ` .xpm ` , ` .eps ` 以及 ` .pdb ` 文件
  ` -xvg <enum> `     xmgrace xvg绘图格式: xmgrace, xmgr, none
  ` -ref <enum> `        none 确定最优参考结构的方式: none, xyz, xy
  ` -skip <int> `           1 对 ` -ref ` 每n帧使用一次
  ` -[no]fitxy `           no 确定旋转前先叠合x/y旋转
  ` -[no]mw `             yes 使用质量加权叠合

  : 控制选项 {#tab-140}

## gmx saltbr: 计算盐桥

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx saltbr [-f [<.xtc/.trr/...>]] [-s [<.tpr/.tpb/...>]] [-nice ]
           [-b ] [-e ] [-dt ] [-t ] [-[no]sep]
```
:::
:::

` gmx saltbr `{.language-plaintext .highlighter-rouge}
用于计算带电组所有组合之间的距离随时间的变化,
这些组可以不同的方式进行组合. 可给出一个最小距离(也即截断距离),
计算时不会考虑距离从未小于此值的组.

程序会输出一些具有固定名称的文件: ` min-min.xvg `{.language-plaintext
.highlighter-rouge} , ` plus-min.xvg `{.language-plaintext
.highlighter-rouge} 和 ` plus-plus.xvg `{.language-plaintext
.highlighter-rouge} . 如果使用了 ` -sep `{.language-plaintext
.highlighter-rouge} 选项, 还会输出单个离子对的文件. 在这种情况下,
文件名格式为 ` sb-(Resname)(Resnr)-(Atomnr) `{.language-plaintext
.highlighter-rouge} . 这种文件的个数 **非常多** .

  选项                          默认值 类型   说明
------------------------ ----------- ------ ---------------------------------------
  ` -f [<.xtc/.trr/…>] `      traj.xtc 输入   轨迹: xtc trr cpt trj gro g96 pdb tng
  ` -s [<.tpr/.tpb/…>] `     topol.tpr 输入   运行输入文件: tpr tpb tpa

  : 输入/输出文件选项 {#tab-141}

  选项                默认值 说明
----------------- -------- -----------------------------------------------------------------
  ` -nice <int> `         19 设置优先级
  ` -b <time> `            0 从轨迹文件中读取的第一帧(ps)
  ` -e <time> `            0 从轨迹文件中读取的最后一帧(ps)
  ` -dt <time> `           0 只使用t除以dt的余数等于第一帧时间(ps)的帧, 即两帧之间的时间间隔
  ` -t <real> `         1000 不考虑从未小于此距离的组
  ` -[no]step `           no 对每个相互作用使用独立的文件(可能会有 **很多** ).

  : 控制选项 {#tab-142}

## gmx sans: 计算小角中子散射谱

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx sans [-s [<.tpr/.tpb/...>]] [-f [<.xtc/.trr/...>]] [-n [<.ndx>]]
         [-d [<.dat>]] [-pr [<.xvg>]] [-sq [<.xvg>]] [-prframe [<.xvg>]]
         [-sqframe [<.xvg>]] [-nice ] [-b ] [-e ]
         [-dt ] [-tu ] [-xvg ] [-mode ]
         [-mcover ] [-[no]pbc] [-startq ] [-endq ]
         [-qstep ] [-seed ]
```
:::
:::

` gmx sans `{.language-plaintext .highlighter-rouge}
利用Debye公式计算SANS光谱(Small Angle Neutron Scattering,
小角度中子衍射). 目前,
使用时需要提供拓扑文件(因为需要指定每个原子的元素).

参数:

-   ` -pr `{.language-plaintext .highlighter-rouge} :
    计算轨迹平均的归一化g(r)函数
-   ` -prframe `{.language-plaintext .highlighter-rouge} :
    计算每帧的归一化g(r)函数
-   ` -sq `{.language-plaintext .highlighter-rouge} :
    计算轨迹平均的SANS强度曲线
-   ` -sqframe `{.language-plaintext .highlighter-rouge} :
    计算每帧的SANS强度曲线
-   ` -startq `{.language-plaintext .highlighter-rouge} : 初始q值,
    单位1/nm
-   ` -endq `{.language-plaintext .highlighter-rouge} : 终止q值,
    单位1/nm
-   ` -qstep `{.language-plaintext .highlighter-rouge} : q值的间距

注意: 当使用Debye直接方法时, 计算代价以1/2 \* N \* (N - 1)增长,
其中N为要研究的原子数目.

警告: 如果指定了 ` sq `{.language-plaintext .highlighter-rouge} 或
` pr `{.language-plaintext .highlighter-rouge} 选项,
这个工具会产生大量的文件! 可达总帧数的两倍大!

  选项                               默认值 类型         说明
-------------------------- -------------- ------------ ---------------------------------------
  ` -s [<.tpr/.tpb/...>] `        topol.tpr 输入         运行输入文件: tpr tpb tpa
  ` -f [<.xtc/.trr/...>] `         traj.xtc 输入         轨迹: xtc trr cpt trj gro g96 pdb tng
  ` -n [<.ndx>] `                 index.ndx 输入, 可选   索引文件
  ` -d [<.dat>] `              nsfactor.dat 输入, 可选   通用数据文件
  ` -pr [<.xvg>] `                   pr.xvg 输出         xvgr/xmgr文件
  ` -sq [<.xvg>] `                   sq.xvg 输出         xvgr/xmgr文件
  ` -prframe [<.xvg>] `         prframe.xvg 输出, 可选   xvgr/xmgr文件
  ` -sqframe [<.xvg>] `         sqframe.xvg 输出, 可选   xvgr/xmgr文件

  : 输入/输出文件选项 {#tab-143}

  选项                    默认值 说明
-------------------- --------- -----------------------------------------------------------------
  ` -nice <int> `              0 设置优先级
  ` -b <time> `                0 从轨迹文件中读取的第一帧(ps)
  ` -e <time> `                0 从轨迹文件中读取的最后一帧(ps)
  ` -dt <time> `               0 只使用t除以dt的余数等于第一帧时间(ps)的帧, 即两帧之间的时间间隔
  ` -tu <enum> `              ps 时间单位: fs, ps, ns, us, ms, s
  ` -xvg <enum> `        xmgrace xvg绘图格式: xmgrace, xmgr, none
  ` -mode <enum> `        direct SANS谱的计算模式: direct, mc
  ` -mcover <real> `          -1 蒙特卡洛覆盖, 应为-1(默认)或者(0, 1\]
  ` -[no]pbc `               yes 计算距离时考虑周期性边界条件
  ` -startq <real> `           0 初始q值(1/nm)
  ` -endq <real> `             2 终止q值(1/nm)
  ` -qstep <real> `         0.01 q值递增值(1/nm)
  ` -seed <int> `              0 Monte-Carlo的随机种子

  : 控制选项 {#tab-144}

## gmx sasa: 计算溶剂可及表面积

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx sasa [-f [<.xtc/.trr/...>]] [-s [<.tpr/.tpb/...>]] [-n [<.ndx>]]
         [-o [<.xvg>]] [-odg [<.xvg>]] [-or [<.xvg>]] [-oa [<.xvg>]]
         [-tv [<.xvg>]] [-q [<.pdb>]] [-b ] [-e ] [-dt ]
         [-tu ] [-xvg ] [-[no]rmpbc] [-[no]pbc] [-sf ]
         [-selrpos ] [-probe ] [-ndots ] [-[no]prot]
         [-dgs ] [-surface ] [-output ]
```
:::
:::

` gmx sasa `{.language-plaintext .highlighter-rouge}
用于计算溶剂可及表面积, 所用的算法可参考Eisenhaber F, Lijnzaad P, Argos
P, Sander C, Scharf M, *J. Comput. Chem.* 16, 273-284 (1995). 使用
` -q `{.language-plaintext .highlighter-rouge} 选项时,
还会将产生Connolly表面输出到.pdb文件中, 其中节点以原子表示,
连接最近节点的边作为CONECT记录. ` -odg `{.language-plaintext
.highlighter-rouge} 选项用于估计溶剂化自由能,
估计时根据每单位暴露表面积每原子的溶剂化能进行计算.

此程序需要使用 ` -surface `{.language-plaintext .highlighter-rouge}
选项来指定进行表面积计算的组. 体系内所有的非溶剂原子都包括在内,
并始终计算该组的表面积. 作为可选, ` -output `{.language-plaintext
.highlighter-rouge} 可用于指定额外的选择, 它应该是整个计算组的一部分.
这些组的溶剂可及表面积会从整个表面积中抽取出来.

可使用 ` -or `{.language-plaintext .highlighter-rouge} 和
` -oa `{.language-plaintext .highlighter-rouge}
选项来计算整个轨迹中每个残基和每个原子表面积的的平均值与标准偏差.

使用 ` -tv `{.language-plaintext .highlighter-rouge}
选项可以计算分子的总体积和密度.
请注意在这种情况下正常的探针半径是否适合, 或者你是否要使用其他值, 如0.
请记住体积和密度的计算结果是非常粗糙的. 例如, 在冰Ih中,
可以很容易地将水分子放于孔道中, 这样得到的体积或过小,
而表面积和密度都过大.

  选项                               默认值 类型         说明
-------------------------- -------------- ------------ -----------------------------------------------------
  ` -f [<.xtc/.trr/...>] `         traj.xtc 输入, 可选   输入轨迹或单个构型: xtc trr cpt trj gro g96 pdb tng
  ` -s [<.tpr/.tpb/...>] `        topol.tpr 输入, 可选   输入结构: tpr tpb tpa gro g96 pdb brk ent
  ` -n [<.ndx>] `                 index.ndx 输入, 可选   额外的索引组
  ` -o [<.xvg>] `                  area.xvg 输出         总表面积随时间的变化
  ` -odg [<.xvg>] `              dgsolv.xvg 输出, 可选   溶剂化自由能估计值随时间的变化
  ` -or [<.xvg>] `              resarea.xvg 输出, 可选   每个残基的平均表面积
  ` -oa [<.xvg>] `             atomarea.xvg 输出, 可选   每个原子的平均表面积
  ` -tv [<.xvg>] `               volume.xvg 输出, 可选   总体积和密度随时间的变化
  ` -q [<.pdb>] `              connolly.pdb 输出, 可选   Connolly表面的PDB文件

  : 输入/输出文件选项 {#tab-145}

-------------------------------------------------------------------------------------------------
  选项                                        默认值 说明
-------------------------- ----------------------- ----------------------------------------------
  ` -b <time> `                                    0 从轨迹文件中读取的第一帧(ps)

  ` -e <time> `                                    0 从轨迹文件中读取的最后一帧(ps)

  ` -dt <time> `                                   0 只使用t除以dt的余数等于第一帧时间(ps)的帧,
                                                     即两帧之间的时间间隔

  ` -tu <enum> `                                  ps 时间单位: fs, ps, ns, us, ms, s

  ` -xvg <enum> `                            xmgrace 绘图格式: none, xmgrace, xmgr

  ` -[no]rmpbc `                                 yes 保持每帧中的分子完整

  ` -[no]pbc `                                   yes 计算距离时使用周期性边界条件

  ` -sf <file> `                                     使用文件提供的选择

  ` -selrpos <enum> `                           atom 选择参考位置: atom, res_com, res_cog, mol_com,
                                                     mol_cog,\
                                                     whole_res_com, whole_res_cog, whole_mol_com,
                                                     whole_mol_cog,\
                                                     part_res_com,part_res_cog, part_mol_com,
                                                     part_mol_cog,\
                                                     dyn_res_com, dyn_res_cog, dyn_mol_com,
                                                     dyn_mol_cog

  ` -probe <real> `                             0.14 溶剂探针的半径(nm)

  ` -ndots <int> `                                24 每个球面的点数, 点数越多越精确

  ` -[no]prot `                                  yes 同时将蛋白质也输出到 ` Connolly.pdb ` 文件

  ` -dgs <real> `                                  0 单位面积溶剂化自由能的默认值(kJ/mol/nm\^2\^)

  ` -surface <selection> `                           表面计算选择

  ` -output <selection> `                            输出选择
  -------------------------------------------------------------------------------------------------

  : 控制选项 {#tab-146}

### 补充说明

溶剂可及表面积是描述蛋白质疏水性的重要参数,
氨基酸残基的疏水性是影响蛋白质折叠的重要物理作用.

输出文件 ` area.xvg `{.language-plaintext .highlighter-rouge} 中有四列,
分别代表: 总表面积, 极性表面积, 非极性表面积, 溶剂化自由能.
最后一项是根据原子所属类型来定义的.

## gmx saxs: 计算小角X射线散射谱

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx saxs [-f [<.xtc/.trr/...>]] [-s [<.tpr/.tpb/...>]] [-n [<.ndx>]]
         [-d [<.dat>]] [-sq [<.xvg>]] [-nice ] [-b ] [-e ]
         [-dt ] [-xvg ] [-ng ] [-startq ]
         [-endq ] [-energy ]
```
:::
:::

` gmx saxs `{.language-plaintext .highlighter-rouge}
用于计算给定索引组的SAXS结构因子. 计算基于Cromer方法,
需要拓扑文件和轨迹文件.

  选项                              默认值 类型         说明
-------------------------- ------------- ------------ ------------------------------------------------
  ` -f [<.xtc/.trr/...>] `        traj.xtc 输入         轨迹: xtc trr cpt trj gro g96 pdb tng
  ` -s [<.tpr/.tpb/...>] `       topol.tpr 输入         结构+质量(db): tpr tpb tpa gro g96 pdb brk ent
  ` -n [<.ndx>] `                index.ndx 输入, 可选   索引文件
  ` -d [<.dat>] `              sfactor.dat 输入, 可选   通用数据文件
  ` -sq [<.xvg>] `                  sq.xvg 输出         xvgr/xmgr文件

  : 输入/输出文件选项 {#tab-147}

  选项                    默认值 说明
-------------------- --------- -----------------------------------------------------------------
  ` -nice <int> `              0 设置优先级
  ` -b <time> `                0 从轨迹读取第一帧的时间(ps)
  ` -e <time> `                0 轨迹读取最后一帧的时间(ps)
  ` -dt <time> `               0 只使用t除以dt的余数等于第一帧时间(ps)的帧, 即两帧之间的时间间隔
  ` -xvg <enum> `        xmgrace 绘制的格式: none, xmgrace, xmgr
  ` -ng <int> `                1 计算SAXS时组的数目
  ` -startq <real> `           0 起始q值(1/nm)
  ` -endq <real> `            60 终止q值(1/nm)
  ` -energy <real> `          12 入射X射线的能量(keV)

  : 控制选项 {#tab-148}

## gmx select: 打印选区的通用信息

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx select [-f [<.xtc/.trr/...>]] [-s [<.tpr/.tpb/...>]] [-n [<.ndx>]]
           [-os [<.xvg>]] [-oc [<.xvg>]] [-oi [<.dat>]] [-on [<.ndx>]]
           [-om [<.xvg>]] [-of [<.xvg>]] [-ofpdb [<.pdb>]] [-olt [<.xvg>]]
           [-b ] [-e ] [-dt ] [-tu ] [-xvg ]
           [-[no]rmpbc] [-[no]pbc] [-sf ] [-selrpos ]
           [-select ] [-[no]norm] [-[no]cfnorm] [-resnr ]
           [-pdbatoms ] [-[no]cumlt]
```
:::
:::

` gmx select `{.language-plaintext .highlighter-rouge}
输出与动态选区相关的基本数据. 它可以用于一些简单分析,
它的输出也可以与其他程序和/或外部分析程序的输出组合起来,
用以计算更复杂的数据. 输出选项可以任意组合, 但需要注意
` -om `{.language-plaintext .highlighter-rouge} 仅对第一个选区进行操作.
还需要注意, 如果没有提供输出选项, 则不会有任何输出.

使用 ` -os `{.language-plaintext .highlighter-rouge} 时,
会逐帧计算每个选区中的位置(position)数目. 使用
` -norm `{.language-plaintext .highlighter-rouge} 时,
输出值会介于0和1之间, 代表相对于最大位置数的比例(例如, 对于选区
` resname RA and x < 5 `{.language-plaintext .highlighter-rouge} ,
最大位置数就是RA残基内的原子数). 使用 ` -cfnorm `{.language-plaintext
.highlighter-rouge} 时, ( ` -os `{.language-plaintext
.highlighter-rouge} 的)输出值则会除以选区覆盖(全局位置数的)比例.
` -norm `{.language-plaintext .highlighter-rouge} 和
` -cfnorm `{.language-plaintext .highlighter-rouge} 可以互相独立地指定.

使用 ` -oc `{.language-plaintext .highlighter-rouge} 时,
以时间函数的形式输出每个选区的覆盖比例.

使用 ` -oi `{.language-plaintext .highlighter-rouge} 时,
以时间函数的形式输出选中的原子/残基/分子. 输出中, 第一列是帧时间,
第二列是位置数, 后续列是原子/残基/分子编号. 如果指定的选区数大于1,
则第二组的位置数紧邻第一组的最后一个数字输出, 并以此类推.

使用 ` -on `{.language-plaintext .highlighter-rouge} 时,
会将选中的原子输出为索引文件, 此文件与 ` make_ndx `{.language-plaintext
.highlighter-rouge} 和分析工具兼容. 每个选区会输出为一个选区组,
对于动态选区, 每帧都会输出一个组.

要得到残基编号, 可以使用 ` -resnr `{.language-plaintext
.highlighter-rouge} 控制 ` -oi `{.language-plaintext .highlighter-rouge}
的输出: ` number `{.language-plaintext .highlighter-rouge}
(默认)会按照残基在输入文件中的编号输出, 而 ` index `{.language-plaintext
.highlighter-rouge} 则会按残基在输入文件中出现的顺序, 从1开始,
赋予残基唯一的编号并输出. 前者更加直观,
但如果输入中含有多个同一编号的残基, 得到的输出就没那么有用了.

使用 ` -om `{.language-plaintext .highlighter-rouge} 时,
以时间函数的形式, 针对第一选区输出一套掩码(mask).
输出中的每一行对应一帧, 为每一个可能被选中的原子/残基/分子赋予0或1的值.
1表示该原子/残基/分子在当前帧中被选中, 0表示未选中.

使用 ` -of `{.language-plaintext .highlighter-rouge} 时,
输出每个位置的占据比例(即该位置被选中的帧所占的比例).

使用 ` -ofpdb `{.language-plaintext .highlighter-rouge} 时,
输出一个PDB文件, 其中占有率列的值是选区中每个原子的占据分数.
PDB文件中的坐标则是输入拓扑中的值. ` -pdbatoms `{.language-plaintext
.highlighter-rouge} 可以用来控制哪些原子会出现在输出的PDB文件中: 使用
` all `{.language-plaintext .highlighter-rouge} 时, 所有原子都会出现;
使用 ` maxsel `{.language-plaintext .highlighter-rouge} 时,
所有可能被选区选中的原子都会出现; 使用 ` selected `{.language-plaintext
.highlighter-rouge} 时, 只有在至少一帧中被选中的原子才会出现.

使用 ` -olt `{.language-plaintext .highlighter-rouge} 时,
生成一个直方图, 显示了被选中位置数与某位置持续被选中时间的函数关系.
` -cumlt `{.language-plaintext .highlighter-rouge}
可以用来控制是否在直方图中包含较长间隔的子间隔.

` -om `{.language-plaintext .highlighter-rouge} ,
` -of `{.language-plaintext .highlighter-rouge} 和
` -olt `{.language-plaintext .highlighter-rouge}
只有在处理动态选区时才有意义.

  选项                                默认值 类型         说明
-------------------------- --------------- ------------ -----------------------------------------------------
  ` -f [<.xtc/.trr/...>] `          traj.xtc 输入, 可选   输入轨迹或单个构型: xtc trr cpt trj gro g96 pdb tng
  ` -s [<.tpr/.tpb/...>] `         topol.tpr 输入, 可选   输入结构拓扑: tpr tpb tpa gro g96 pdb brk ent
  ` -n [<.ndx>] `                  index.ndx 输入, 可选   额外的索引组
  ` -os [<.xvg>] `                  size.xvg 输出, 可选   每个选区中的位置数
  ` -oc [<.xvg>] `                 cfrac.xvg 输出, 可选   每个选区的覆盖比例
  ` -oi [<.dat>] `                 index.dat 输出, 可选   每个选区所选中的索引
  ` -on [<.ndx>] `                 index.ndx 输出, 可选   由选区生成的索引文件
  ` -om [<.xvg>] `                  mask.xvg 输出, 可选   被选中位置的掩码
  ` -of [<.xvg>] `             occupancy.xvg 输出, 可选   被选中位置的占据比例
  ` -ofpdb [<.pdb>] `          occupancy.pdb 输出, 可选   含有被选中位置占据比例的PDB文件
  ` -olt [<.xvg>] `             lifetime.xvg 输出, 可选   生命周期的直方图

  : 输入/输出文件选项 {#tab-149}

----------------------------------------------------------------------------------------
  选项                                       默认值 说明
------------------------- ----------------------- --------------------------------------
  ` -b <time> `                                   0 从轨迹中读取的第一帧(ps)

  ` -e <time> `                                   0 从轨迹中读取的最后一帧(ps)

  ` -dt <time> `                                  0 只使用t除以dt等于第一帧时间(ps)的帧,
                                                    即两帧之间的时间间隔

  ` -tu <enum> `                                 ps 时间值的单位: fs, ps, ns, us, ms, s

  ` -xvg <enum> `                           xmgrace xvg绘图格式: none, xmgrace, xmgr

  ` -[no]rmpbc `                                yes 保持每帧中的分子完整

  ` -[no]pbc `                                  yes 在距离计算中使用周期性边界条件

  ` -sf <file> `                                    由文件提供选区

  ` -selrpos <enum> `                          atom 选区的参考位置: atom, res_com,
                                                    res_cog, mol_com, mol_cog,\
                                                    whole_res_com, whole_res_cog,
                                                    whole_mol_com, whole_mol_cog,\
                                                    part_res_com, part_res_cog,
                                                    part_mol_com, part_mol_cog,\
                                                    dyn_res_com, dyn_res_cog, dyn_mol_com,
                                                    dyn_mol_cog

  ` -select <selection> `                           要分析的选区

  ` -[no]norm `                                  no 启用 ` -os ` 选项时,
                                                    用总位置数进行归一化

  ` -[no]cfnorm `                                no 启用 ` -os ` 选项时,
                                                    用覆盖比例进行归一化

  ` -resnr <enum> `                          number 启用 ` -oi ` 或 ` -on ` 时,
                                                    残基编号的输出类型: number, index

  ` -pdbatoms <enum> `                          all 启用 ` -ofpdb ` 选项时, 要输出的原子:
                                                    all, maxsel, selected

  ` -[no]cumlt `                                yes 启用 ` -olt ` 选项时,
                                                    累积计入较长间隔的子间隔
  ----------------------------------------------------------------------------------------

  : 控制选项 {#tab-150}

## gmx sham: 根据直方图计算自由能或其他直方图

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx sham [-f [<.xvg>]] [-ge [<.xvg>]] [-ene [<.xvg>]] [-dist [<.xvg>]]
         [-histo [<.xvg>]] [-bin [<.ndx>]] [-lp [<.xpm>]] [-ls [<.xpm>]]
         [-lsh [<.xpm>]] [-lss [<.xpm>]] [-ls3 [<.pdb>]] [-g [<.log>]]
         [-nice ] [-[no]w] [-xvg ] [-[no]time] [-b ]
         [-e ] [-ttol ] [-n ] [-[no]d] [-[no]sham]
         [-tsham ] [-pmin ] [-dim ] [-ngrid ]
         [-xmin ] [-xmax ] [-pmax ] [-gmax ]
         [-emin ] [-emax ] [-nlevels ]
```
:::
:::

` gmx sham `{.language-plaintext .highlighter-rouge}
用于计算多维的自由能, 焓和熵. ` gmx sham `{.language-plaintext
.highlighter-rouge} 会读取一个或多个 ` .xvg `{.language-plaintext
.highlighter-rouge} 文件并分析数据集. ` gmx sham `{.language-plaintext
.highlighter-rouge} 的基本功能是利用玻尔兹曼反转多维直方图方法(
` -lp `{.language-plaintext .highlighter-rouge}
选项)计算Gibbs自由能形貌图( ` -ls `{.language-plaintext
.highlighter-rouge} 选项), 但也可用于计算焓(
` -lsh `{.language-plaintext .highlighter-rouge} 选项)和熵(
` -lss `{.language-plaintext .highlighter-rouge} 选项)的形貌图.
程序可以给出用户提供的任意量的直方图.
输入文件中的一行可能以时间开头(参看选项 ` -time `{.language-plaintext
.highlighter-rouge} ), 后面跟着任意多个y值. 当使用&隔开时(
` -n `{.language-plaintext .highlighter-rouge} 选项),
可以读入多个数据集, 在这种情况下每行只会读取一个y值.
所有以#和@开头的行都会被忽略.

当系综并非玻尔兹曼系综, 但又需要使用自由能进行偏置时, 可使用
` -ge `{.language-plaintext .highlighter-rouge} 选项提供一个自由能文件.
对由 ` -f `{.language-plaintext .highlighter-rouge}
选项指定的输入文件中, 每个(多维)数据点需要一个自由能值.

可利用 ` -ene `{.language-plaintext .highlighter-rouge}
选项提供一个能量文件. 在使用Kumar等人提出的单直方图分析方法时,
这些能量可用作权重函数. 如果提供了温度(处于文件中的第二列),
会应用实验的加权方案. 此外, 这些值还会用于计算焓和熵.

可使用选项 ` -dim `{.language-plaintext .highlighter-rouge}
给出距离的维度. 当距离为2维或3维时,
由两个粒子所采样的圆周或表面会随着距离的增加而增加. 依据想要展示的量,
可以选择是否修正直方图和自由能的体积效应. 对2维或3维,
概率可分别利用r或r\^2\^进行归一化.
可使用-1值来指示两个向量间以度为单位的夹角: 应用角度的正弦进行归一化.
**注意** , 对两个向量间的夹角, 内积或余弦是很自然的量,
因为它可以产生相同体积的分格.

  选项                          默认值 类型         说明
--------------------- -------------- ------------ ------------------------
  ` -f [<.xvg>] `            graph.xvg 输入         xvgr/xmgr文件
  ` -ge [<.xvg>] `           gibbs.xvg 输入, 可选   xvgr/xmgr文件
  ` -ene [<.xvg>] `          esham.xvg 输入, 可选   xvgr/xmgr文件
  ` -dist [<.xvg>] `          ener.xvg 输出, 可选   xvgr/xmgr文件
  ` -histo [<.xvg>] `        edist.xvg 输出, 可选   xvgr/xmgr文件
  ` -bin [<.ndx>] `         bindex.ndx 输出, 可选   索引文件
  ` -lp [<.xpm>] `            prob.xpm 输出, 可选   X PixMap兼容的矩阵文件
  ` -ls [<.xpm>] `           gibbs.xpm 输出, 可选   X PixMap兼容的矩阵文件
  ` -lsh [<.xpm>] `       enthalpy.xpm 输出, 可选   X PixMap兼容的矩阵文件
  ` -lss [<.xpm>] `        entropy.xpm 输出, 可选   X PixMap兼容的矩阵文件
  ` -ls3 [<.pdb>] `         gibbs3.pdb 输出, 可选   PDB文件
  ` -g [<.log>] `          shamlog.log 输出, 可选   日志文件

  : 输入/输出文件选项 {#tab-151}

  选项                      默认值 说明
--------------------- ---------- ----------------------------------------------------------------------------
  ` -nice <int> `               19 设置优先级
  ` -[no]w `                    no 查看输出的.xvg, .xpm, .eps和.pdb文件
  ` -xvg <enum> `          xmgrace xvg绘图格式: xmgrace, xmgr, none
  ` -[no]time `                yes 输入文件中包含时间
  ` -b <real> `                 -1 从数据集中读取的第一帧
  ` -e <real> `                 -1 从数据集中读取的最后一帧
  ` -ttol <real> `               0 时间的容差, 适宜的单位(通常为ps)
  ` -n <int> `                   1 读取的数据集的数目, 不同数据集间以只含&的行分隔
  ` -[no]d `                    no 使用导数
  ` -[no]sham `                yes 不使用能量加权, 即使提供了能量文件
  ` -tsham <real> `         298.15 用于单直方图分析的温度
  ` -pmin <real> `               0 最小概率. 小于此值的任何值都设置为零
  ` -dim <vector> `          1 1 1 计算距离的维数, 用于体积修正(最多3个值, 维数大于3时将得到和最后的一样的值)
  ` -ngrid <vector> `     32 32 32 能量形貌的分格数(最多3个值, 维数大于3时将得到和最后的一样的值)
  ` -xmin <vector> `         0 0 0 能量形貌图轴的最小值(维数大于3时, 见上)
  ` -xmax <vector> `         1 1 1 能量形貌图轴的最大值(维数大于3时, 见上)
  ` -pmax <real> `               0 输出概率的最大值, 默认为计算值
  ` -gmax <real> `               0 输出自由能的最大值, 默认为计算值
  ` -emin <real> `               0 输出焓的最小值, 默认为计算值
  ` -emax <real> `               0 输出焓的最大值, 默认为计算值
  ` -nlevels <int> `            25 能量形貌的水平数

  : 控制选项 {#tab-152}

## gmx sigeps: 将C6/12或C6/Cn组合转换为sigma/epsilon组合, 或反过来 

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx sigeps [-o [<.xvg>]] [-nice ] [-[no]w] [-xvg ] [-c6 ]
           [-cn ] [-pow ] [-sig ] [-eps ] [-A ]
           [-B ] [-C ] [-qi ] [-qj ] [-sigfac ]
```
:::
:::

` gmx sigeps `{.language-plaintext .highlighter-rouge} 是一个简单的工具,
可以将C6/C12或C6/Cn组合转换成σ和ε, 或者反过来.
它也可以在文件中绘制出势能. 此外,
它还能把一个Buckingham势近似地转成一个Lennard-Jones势.

  选项                   默认值 类型   说明
----------------- ----------- ------ ---------------
  ` -o [<.xvg>] `     potje.xvg 输出   xvgr/xmgr文件

  : 输入/输出文件选项 {#tab-153}

  选项                    默认值 说明
-------------------- --------- ------------------------------------
  ` -nice <int> `              0 设置优先级
  ` -[no]w `                  no 查看.xvg, .xpm, .eps和.pdb输出文件
  ` -xvg <enum> `        xmgrace xvg绘图格式: xmgrace, xmgr, none
  ` -c6 <real> `           0.001 C6
  ` -cn <real> `           1e-06 排斥常数
  ` -pow <int> `              12 排斥项的次数
  ` -sig <real> `            0.3 σ
  ` -eps <real> `              1 ε
  ` -A <real> `           100000 Buckingham势的A
  ` -B <real> `               32 Buckingham势的B
  ` -C <real> `            0.001 Buckingham势的C
  ` -qi <real> `               0 粒子i的电荷qi
  ` -qj <real> `               0 粒子j的电荷qj
  ` -sigfac <real> `         0.7 开始绘制时, σ前的因子

  : 控制选项 {#tab-154}

## gmx solvate: 体系溶剂化

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx solvate [-cp [<.gro/.g96/..>]] [-cs [<.gro/.g96/…>]]
            [-o [<.gro/.g96/…>]] [-p [<.top>]] [-nice ]
            [-box ] [-radius ] [-scale ] [-shell ]
            [-maxsol ] [-[no]vel]
```
:::
:::

` gmx solvate `{.language-plaintext .highlighter-rouge}
能够完成以下两项任务:

1.  创建一个充满溶剂的盒子. 可以通过指定 ` -cs `{.language-plaintext
    .highlighter-rouge} 和 ` -box `{.language-plaintext
    .highlighter-rouge} 选项来完成.
    对具有盒子信息但不含原子的结构文件则可以通过指定
    ` -cs `{.language-plaintext .highlighter-rouge} 和
    ` -cp `{.language-plaintext .highlighter-rouge} 来实现.
2.  将溶质分子, 如蛋白质进行溶剂化, 使其处于溶剂分子的包围之中.
    ` -cp `{.language-plaintext .highlighter-rouge} 和
    ` -cs `{.language-plaintext .highlighter-rouge}
    分别用于指定溶质和溶剂. 不设定 ` -box `{.language-plaintext
    .highlighter-rouge} 时, 会使用溶质坐标文件(
    ` -cp `{.language-plaintext .highlighter-rouge} )中的盒子信息.
    如果你希望将溶质置于盒子的中心, 可以使用
    ` gmx editconf `{.language-plaintext .highlighter-rouge} 命令,
    它有非常多的选项用于改变盒子的规格和使分子居中. 对某一位置,
    若溶质分子中任意原子与溶剂分子中任意原子之间的距离小于这两个原子的范德华半径之和,
    则会将溶剂分子从盒子中移除. 程序会读取数据文件(
    ` vdwradii.dat `{.language-plaintext .highlighter-rouge}
    )中的范德华半径, 并根据 ` -scale `{.language-plaintext
    .highlighter-rouge} 选项的设置进行缩放.
    若不能在数据文件中找到所需的半径值, 相应的原子将通过
    ` -radius `{.language-plaintext .highlighter-rouge}
    来设定(未缩放)距离.

默认使用的溶剂是简单点电荷水模型(SPC, Simple Point Charge Water),
坐标文件为 ` $GMXLIB/spc216.gro `{.language-plaintext
.highlighter-rouge} . 这些坐标同样可以用于其他的三点水模型,
因为通过短时间的平衡就可以去除这些模型之间的差异.
程序也支持其余的溶剂分子和混合溶剂.
对溶剂类型的唯一限制是一个溶剂分子只包含一种残基.
程序会使用坐标文件中的残基信息, 因此这些信息应保持一定程度的一致性.
实际使用中,
这就意味着坐标文件中两个连续的溶剂分子应该具有不同的残基编号.
溶质盒子是根据坐标文件中的坐标进行堆积构建而成,
这意味着这些坐标应该在周期性边界条件下进行平衡,
以确保分子在堆积界面上具有良好的排列. ` -maxsol `{.language-plaintext
.highlighter-rouge} 选项可以设置加入的最大溶剂分子数, 程序只添加前
` -maxsol `{.language-plaintext .highlighter-rouge}
个溶剂分子而忽略其余的. 这样在盒子中形成了一部分真空,
这在后面可能会引起一些问题. 请明智地选择最大分子数和盒子体积.

该程序还可以旋转溶质分子, 使其最长的分子轴与盒子边缘对齐.
这样可以减少所需要的溶剂分子. 值得注意的是这只适用于短时间的模拟, 如500
ps内溶液中的α-螺旋多肽可以旋转90度. 因此,
通常来说选用接近立方体的盒子会好一些.

` -shell `{.language-plaintext .highlighter-rouge} 的设定值大于零时,
将会在溶质周围放置指定厚度(nm)的水层. 提示:
最好先将蛋白质分子置于盒子中央(使用 ` gmx editconf `{.language-plaintext
.highlighter-rouge} ).

最后, ` gmx solvate `{.language-plaintext .highlighter-rouge}
命令还可以去除拓扑文件中说明已添加的溶剂分子数的行,
并在坐标文件中添加包含溶剂分子总数的新行.

  选项                               默认值 类型              说明
--------------------------- ------------- ----------------- -----------------------------------------------
  ` -cp [<.gro/.g96/...>] `     protein.gro 输入, 可选        结构文件: gro g96 pdb brk ent esp tpr tpb tpa
  ` -cs [<.gro/.g96/...>] `      spc216.gro 输入, 库          结构文件: gro g96 pdb brk ent esp tpr tpb tpa
  ` -o [<.gro/.g96/...>] `          out.gro 输出              结构文件: gro g96 pdb brk ent esp
  ` -p [<.top>] `                 topol.top 输入/输出, 可选   拓扑文件

  : 输入/输出文件选项 {#tab-155}

------------------------------------------------------------------------------------
  选项                                     默认值 说明
----------------------- ----------------------- ------------------------------------
  ` -nice <int> `                              19 设置优先级

  ` -box <vector> `                         0 0 0 盒子尺寸(单位nm)

  ` -radius <real> `                        0.105 默认的范德华距离

  ` -scale <real> `                          0.57 用于数据文件
                                                  ` share/gromacs/top/vdwradii.dat `
                                                  中范德华半径的缩放因子.\
                                                  对水中的蛋白质,
                                                  使用默认值0.57可以得到接近1000
                                                  g/l的密度值.

  ` -shell <real> `                             0 溶质周围水层的可选厚度

  ` -maxsol <int> `                             0 加入的最大溶剂分子数.
                                                  若为零(默认)则忽略此选项.

  ` -[no]vel `                                 no 保持溶质和溶剂分子输入文件中的速度
  ------------------------------------------------------------------------------------

  : 控制选项 {#tab-156}

### 已知问题

-   对初始构型所有分子必须保持完整.

### 补充说明

` gmx solvate `{.language-plaintext .highlighter-rouge}
可以为模拟分子添加溶剂环境

-   ` -cp `{.language-plaintext .highlighter-rouge} :
    带盒子参数的分子坐标文件, 一般是 ` editconf `{.language-plaintext
    .highlighter-rouge} 的输出文件
-   ` -cs `{.language-plaintext .highlighter-rouge} : 添加的水分子模型,
    如spc216, spce, tip3p, tip4p等
-   ` -o `{.language-plaintext .highlighter-rouge} : 输出坐标文件,
    就是添加水分子之后的分子坐标文件, 默认为
    ` .gro `{.language-plaintext .highlighter-rouge} 文件,
    但也可以为其他格式, 如pdb
-   ` -p `{.language-plaintext .highlighter-rouge} : 体系拓扑文件,
    ` gmx solvate `{.language-plaintext .highlighter-rouge}
    会往里面写入添加水分子的个数. 这个不要忘记, 不然在进行下一步计算时,
    会出现坐标文件和拓扑文件中原子数不一致的错误

添加水分子后需要用VMD等软件查看结果, 因为有时产生的构型不尽合理.
若发现某一水分子出现在蛋白结构中, 而此位置本来不希望有水分子存在,
那么可以找出这个水分子的残基标号, 进行删除,
同时减少拓扑文件中水分子的数目.

### 使用范例

-   ` -box a b c `{.language-plaintext .highlighter-rouge} 空盒子
-   ` -cs slv.gro -box a b c `{.language-plaintext .highlighter-rouge}
    以slv.gro中分子填充盒子, -maxsol N可用
-   ` -cp slu.gro -box a b c `{.language-plaintext .highlighter-rouge}
    指定box, 否则用slu.gro的box
-   ` -cp slu.gro -cs slv.gro `{.language-plaintext .highlighter-rouge}
    以slv填充slu的box
-   ` -cp slu.gro -cs slv.gro -shell a b `{.language-plaintext
    .highlighter-rouge} 表面填充
-   ` -cp slu.gro -cs slv.gro -maxsol N -box a b c `{.language-plaintext
    .highlighter-rouge}

## gmx sorient: 分析溶质周围的溶剂取向

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx sorient [-f [<.xtc/.trr/...>]] [-s [<.tpr/.tpb/...>]] [-n [<.ndx>]]
            [-o [<.xvg>]] [-no [<.xvg>]] [-ro [<.xvg>]] [-co [<.xvg>]]
            [-rc [<.xvg>]] [-nice ] [-b ] [-e ] [-dt ]
            [-[no]w] [-xvg ] [-[no]com] [-[no]v23] [-rmin ]
            [-rmax ] [-cbin ] [-rbin ] [-[no]pbc]
```
:::
:::

` gmx sorient `{.language-plaintext .highlighter-rouge}
用于分析溶质分子周围的溶剂分子的取向.
它可以计算从一个或多个参考位置到每个溶剂分子第一个原子的向量(向量
\$\\vec A\$)与另外两个向量之间的角度:

-   \$\\q_1\$: 向量 \$\\vec A\$
    与从溶剂分子第一个原子到第二和第三个原子中点的向量之间的夹角
-   \$\\q_2\$: 向量 \$\\vec A\$
    与由三个原子定义的溶剂分子平面的法线之间的夹角, 或者, 当使用
    ` -v23 `{.language-plaintext .highlighter-rouge} 选项时, 向量
    \$\\vec A\$ 与从原子2到原子3的向量之间的夹角.

参考位置可以是一组原子或是一组原子的质心.
溶剂原子组中的每个溶剂分子只能包含3个原子. 对每一帧,
` -o `{.language-plaintext .highlighter-rouge} 和
` -no `{.language-plaintext .highlighter-rouge} 选项只会考虑处于
` -rmin `{.language-plaintext .highlighter-rouge} 和
` -rmax `{.language-plaintext .highlighter-rouge} 之间的溶剂分子.

-   ` -o `{.language-plaintext .highlighter-rouge} :
    \$r\_\\text{min}\\le r \\le r\_\\text{max}\$ 范围内 \$\\cos\\q_1\$
    的分布
-   ` -no `{.language-plaintext .highlighter-rouge} : \$r\_\\text{min}
    \\le r \\le r\_\\text{max}\$ 范围内 \$\\cos\\q_2\$ 的分布
-   ` -ro `{.language-plaintext .highlighter-rouge} : \$\\langle \\cos
    \\q_1 \\rangle\$ 和 \$\\langle 3\\cos\^2\\q_2-1 \\rangle\$ 与距离
    \$r\$ 的函数关系
-   ` -co `{.language-plaintext .highlighter-rouge} : 对距离 \$r\$
    范围内所有溶剂分子的 \$\\cos\\q_1\$ 和 \$3\\cos\^2\\q_2-1\$
    进行加和, 得到它们与 \$r\$ 的函数关系
-   ` -rc `{.language-plaintext .highlighter-rouge} : 溶剂分子的分布与
    \$r\$ 的函数关系

  选项                             默认值 类型         说明
  -------------------------- ------------ ------------ ------------------------------------------------
  ` -f [<.xtc/.trr/...>] `       traj.xtc 输入         轨迹: xtc trr cpt trj gro g96 pdb tng
  ` -s [<.tpr/.tpb/...>] `      topol.tpr 输入         结构+质量(db): tpr tpb tpa gro g96 pdb brk ent
  ` -n [<.ndx>] `               index.ndx 输入, 可选   索引文件
  ` -o [<.xvg>] `                sori.xvg 输出         xvgr/xmgr文件
  ` -no [<.xvg>] `               snor.xvg 输出         xvgr/xmgr文件
  ` -ro [<.xvg>] `               sord.xvg 输出         xvgr/xmgr文件
  ` -co [<.xvg>] `               scum.xvg 输出         xvgr/xmgr文件
  ` -rc [<.xvg>] `             scount.xvg 输出         xvgr/xmgr文件

  : 输入/输出文件选项 {#tab-157}

  选项                  默认值 说明
  ------------------ --------- ----------------------------------------------------------------------
  ` -nice <int> `           19 设置优先级
  ` -b <time> `              0 从轨迹文件中读取的第一帧(ps)
  ` -e <time> `              0 从轨迹文件中读取的最后一帧(ps)
  ` -dt <time> `             0 只使用t除以dt的余数等于第一帧时间(ps)的帧, 即两帧之间的时间间隔
  ` -[no]w `                no 查看输出的.xvg, .xpm, .eps和.pdb文件
  ` -xvg <enum> `      xmgrace xvg绘图格式: xmgrace, xmgr, none
  ` -[no]com `              no 使用质心作为参考位置
  ` -[no]v23 `              no 使用原子2和3之间的向量
  ` -rmin <real> `           0 最小距离(nm)
  ` -rmax <real> `         0.5 最大距离(nm)
  ` -cbin <real> `        0.02 余弦的分格宽度
  ` -rbin <real> `        0.02 距离 \$r\$ 的分格宽度(nm)
  ` -[no]pbc `              no 计算质心时检查PBC. 只有当你的参考组包含多个分子时, 才需要使用此选项.

  : 控制选项 {#tab-158}

### 补充说明

此程序特别适用于计算溶质分子周围水分子的角度分布.

![](/GMX/gmx_sorient.png)

设溶质为单原子离子或分子质心Ref, 溶剂为水分子原子1为O, 原子2和3为H, 则
\$\\q_1\$ 对应Ref至O的向量 \$\\vec A=\\vec R\_\\text{Ref}-\\vec
R\_\\text{O}\$ 与O至两个H连线中点的向量 \${\\vec R\_\\text{OH2}+\\vec
R\_\\text{OH3} \\over 2}\$ 之间的夹角,
后一向量的方向与水分子偶极矩的方向相同. 因此, \$\\q_1\$
可视为溶质分子周围水分子偶极矩的取向. \$\\q_2\$ 对应 \$\\vec A\$
与水分子平面法线的夹角. 当使用 ` -v23 `{.language-plaintext
.highlighter-rouge} 选项时, 则为 \$\\vec A\$ 与两个H连线 \$\\vec
R\_\\text{H3}-\\vec R\_\\text{H2}\$ 之间的夹角.

## gmx spatial: 计算空间分布函数

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx spatial [-s [<.tpr/.tpb/...>]] [-f [<.xtc/.trr/...>]] [-n [<.ndx>]]
            [-nice ] [-b ] [-e ] [-dt ] [-[no]w]
            [-[no]pbc] [-[no]div] [-ign ] [-bin ] [-nab ]
```
:::
:::

` gmx spatial `{.language-plaintext .highlighter-rouge}
用于计算空间分布函数(SDF, spatial distribution function),
其输出文件为Gaussian98 cube格式, 可用VMD读取. 对含有32,000个原子,
运行了50 ns的轨迹, 计算SDF大约需要30分钟. 其中的大部分时间都消耗在了运行
` trjconv `{.language-plaintext .highlighter-rouge} 上, 它需要运行两次,
以便恰当地对体系进行居中, 同时也需要很多空间(会复制三份轨迹文件).
如果选择了正确的叠合, 得到的结果非常漂亮, 而且也包含了很多有用信息.
程序可处理运动范围很广的组中的3-4原子(如溶液中的自由氨基酸),
也可以选择稳定折叠结构的蛋白质骨架, 计算溶剂分子的的SDF,
得到时间平均的溶剂壳层. 这个程序还可用于计算任意直角坐标的SDF,
只需要忽略前面的 ` gmx trjconv `{.language-plaintext .highlighter-rouge}
步骤即可.

使用:

为得到有意义的SDF, 整个轨迹中溶质分子必须在盒子内居中,
并去除其平动和转动. 也就是说,
统计周围分子的SDF时必须基于相对固定的参考坐标系. 为此, 可能需要使用
` gmx trjconv `{.language-plaintext .highlighter-rouge}
对轨迹进行多次处理. 此外, 可能还需要定义特殊的分析组, 并使用
` -n `{.language-plaintext .highlighter-rouge} 选项传递给
` gmx trjconv `{.language-plaintext .highlighter-rouge} .

1.  使用 ` gmx make_ndx `{.language-plaintext .highlighter-rouge}
    创建两个组, 一个包含中心分子, 一个包含要统计SDF的原子

2.  使中心分子在盒子内居中, 同时所有其他分子处于盒子内

    ` gmx trjconv -s topol.tpr -f traj -n index.ndx -o traj~cnt.xtc -pbc mol -ur compact -center `{.language-plaintext
    .highlighter-rouge}

    ` Select group for centering `{.language-plaintext
    .highlighter-rouge} 时选择中心分子组,
    ` Select group for output `{.language-plaintext .highlighter-rouge}
    时选择System组

3.  按中心分子对轨迹进行叠合, 移除中心分子的转动和平动:

    ` gmx trjconv -s topol.tpr -f traj~cnt.xtc -n index.ndx -o traj~cnt~fit.xtc -fit rot+trans `{.language-plaintext
    .highlighter-rouge}

    ` Select group for least squares fit `{.language-plaintext
    .highlighter-rouge} 时选择中心分子组,
    ` Select group for output `{.language-plaintext .highlighter-rouge}
    是选择System组

4.  统计分布:

    ` gmx spatial -f traj~cnt~fit.xtc -n index.ndx `{.language-plaintext
    .highlighter-rouge}

    ` Select group to generate SDF: `{.language-plaintext
    .highlighter-rouge} 时选择要统计SDF的组,
    ` Select group to output coords (e.g. solute): `{.language-plaintext
    .highlighter-rouge} 时选择中心分子组

5.  使用VMD或其他可视化软件载入得到的 ` grid.cube `{.language-plaintext
    .highlighter-rouge} 文件, 以等值面模式查看结果

**注意** , 对一些体系, 如胶束体系, 在第1步和第2步之间可能还需要运行
` gmx trjconv -pbc cluster `{.language-plaintext .highlighter-rouge} .

警告:

SDF生成的cube文件包含了具有非零占据的所有格点. 然而,
` gmx trjconv `{.language-plaintext .highlighter-rouge} 使用的
` -fit rot+trans `{.language-plaintext .highlighter-rouge}
选项意味着你的体系会在空间中旋转和平移(选中的组不会). 因此,
返回值只在所选中心组/坐标周围的一定区域内有意义, 在整个轨迹中,
这些区域与平移/旋转后的体系之间存在重叠. 请你确保能满足这一条件.

漏洞:

当分配的内存不够时, 可能会出现段错误. 通常会检测这一错误,
并在出错前终止程序, 同时给出一条警告消息, 建议使用
` -nab `{.language-plaintext .highlighter-rouge} 选项(指定附加分格数).
然而, 程序并不能检测到所有此类事件. 如果你遇到段错误, 请试着增加
` -nab `{.language-plaintext .highlighter-rouge} 的值, 并再次运行程序.

激进选项:

为减少计算所需的空间和时间, 你可以只输出运行
` gmx trjconv `{.language-plaintext .highlighter-rouge} 所需的坐标.
然而, 请确保 ` -nab `{.language-plaintext .highlighter-rouge}
的设定值足够高, 因为程序会基于初始坐标和 ` -nab `{.language-plaintext
.highlighter-rouge} 选项的值分配cube分格所需要的内存.

  选项                            默认值 类型         说明
-------------------------- ----------- ------------ ------------------------------------------------
  ` -s [<.tpr/.tpb/...>] `     topol.tpr 输入         结构+质量(db): tpr tpb tpa gro g96 pdb brk ent
  ` -f [<.xtc/.trr/...>] `      traj.xtc 输入         轨迹: xtc trr cpt trj gro g96 pdb tng
  ` -n [<.ndx>] `              index.ndx 输入, 可选   索引文件

  : 输入/输出文件选项 {#tab-159}

-----------------------------------------------------------------------------------------------
  选项                                     默认值 说明
----------------------- ----------------------- -----------------------------------------------
  ` -nice <int> `                               0 设置优先级

  ` -b `                                        0 从轨迹文件中读取的第一帧(ps)

  ` -e `                                        0 从轨迹文件中读取的最后一帧(ps)

  ` -dt `                                       0 只使用t除以dt的余数等于第一帧时间(ps)的帧,
                                                  即两帧之间的时间间隔

  ` -[no]w `                                   no 查看输出的 .xvg, .xpm, .eps和.pdb文件

  ` -[no]pbc `                                 no 计算距离时考虑周期性边界条件(PBC).

  ` -[no]div `                                yes 基于原子/最小cube尺寸计算施加分格占据率因子.\
                                                  TRUE用于可视化, FALSE( ` -nodiv `
                                                  )可得到每帧的精确计数

  ` -ign <int> `                               -1 不显示的外部cube的数目(正值可能降低边界斑点;
                                                  -1保证外部表面可见)

  ` -bin <real> `                            0.05 分格宽度(单位: nm)

  ` -nab <int> `                                4 附加的分格数目, 用于保证分配的内存足够大
  -----------------------------------------------------------------------------------------------

  : 控制选项 {#tab-160}

### 补充说明

-   如果得到的SDF等值面不够光滑, 请增加轨迹的帧数, 并检查
    ` -bin `{.language-plaintext .highlighter-rouge} 的取值时并不是合适
-   此程序计算SDF的方式不够高效. 如果体系含有多个中心分子类型,
    则每帧可使用每个中心分子进行居中, 得到更多的统计结果.
-   一些说明请参考
    [空间分布函数SDF的计算及三维图示](http://jerkwin.github.io/2014/05/13/空间分布函数SDF的计算及三维图示/)
    .
-   一个处理工具请参考 [Gromacs的g_spatial产生的格点文件分析工具gmxgrid
    v1.2](http://sobereva.com/38) .

## gmx spol: 分析溶质周围溶剂的偶极取向及极化

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx spol [-f [<.xtc/.trr/...>]] [-s [<.tpr/.tpb/...>]] [-n [<.ndx>]]
         [-o [<.xvg>]] [-nice ] [-b ] [-e ] [-dt ]
         [-[no]w] [-xvg ] [-[no]com] [-refat ] [-rmin ]
         [-rmax ] [-dip ] [-bw ]
```
:::
:::

` gmx spol `{.language-plaintext .highlighter-rouge}
程序用于分析溶质分子周围的偶极, 特别适用于极化水模型.
计算时需要一组参考原子或参考质心( ` -com `{.language-plaintext
.highlighter-rouge} 选项), 还有一组溶剂原子,
程序会先将溶剂原子组划分为分子,
然后确定每一溶剂分子到参考组原子或其质心的最近距离,
并给出这些距离的累积分布. 对处于 ` -rmin `{.language-plaintext
.highlighter-rouge} 和 ` -rmax `{.language-plaintext .highlighter-rouge}
之间的每一距离, 确定距离向量与溶剂分子偶极的內积.
对带有净电荷的溶剂分子(离子),
会均匀地将净电荷从每一所选离子的所有原子中会减去.
输出这些偶极分量的平均值. 对极化的处理类似, 并从瞬时偶极中减去平均偶极.
平均偶极的大小由 ` -dip `{.language-plaintext .highlighter-rouge}
选项指定,
方向由从所选溶剂组的第一个原子到第二和第三个原子连线中点的向量确定.

  选项                             默认值 类型         说明
-------------------------- ------------ ------------ ---------------------------------------
  ` -f [<.xtc/.trr/...>] `       traj.xtc 输入         轨迹: xtc trr cpt trj gro g96 pdb tng
  ` -s [<.tpr/.tpb/...>] `      topol.tpr 输入         运行输入文件: tpr tpb tpa
  ` -n [<.ndx>] `               index.ndx 输入, 可选   索引文件
  ` -o [<.xvg>] `              scdist.xvg 输出         xvgr/xmgr文件

  : 输入/输出文件选项 {#tab-161}

  选项                  默认值 说明
------------------ --------- -----------------------------------------------------------------
  ` -nice <int> `           19 设置优先级
  ` -b <time> `              0 从轨迹文件中读取的第一帧(ps)
  ` -e <time> `              0 从轨迹文件中读取的最后一帧(ps)
  ` -dt <time> `             0 只使用t除以dt的余数等于第一帧时间(ps)的帧, 即两帧之间的时间间隔
  ` -[no]w `                no 查看输出的.xvg, .xpm, .eps和.pdb文件
  ` -xvg <enum> `      xmgrace xvg绘图格式: xmgrace, xmgr, none
  ` -[no]com `              no 使用质心作为参考位置
  ` -refat <int> `           1 溶剂分子的参考原子
  ` -rmin <real> `           0 最小距离(nm)
  ` -rmax <real> `        0.32 最大距离(nm)
  ` -dip <real> `            0 平均偶极(D)
  ` -bw <real> `          0.01 分格宽度(nm)

  : 控制选项 {#tab-162}

## gmx tcaf: 计算液体的粘度

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx tcaf [-f [<.trr/.cpt/...>]] [-s [<.tpr/.tpb/...>]] [-n [<.ndx>]]
         [-ot [<.xvg>]] [-oa [<.xvg>]] [-o [<.xvg>]] [-of [<.xvg>]]
         [-oc [<.xvg>]] [-ov [<.xvg>]] [-nice ] [-b ] [-e ]
         [-dt ] [-[no]w] [-xvg ] [-[no]mol] [-[no]k34]
         [-wt ] [-acflen ] [-[no]normalize] [-P ]
         [-fitfn ] [-beginfit ] [-endfit ]
```
:::
:::

` gmx tcaf `{.language-plaintext .highlighter-rouge}
用于计算横向电流自相关(TCAF, tranverse current autocorrelation),
并可以其来估算剪切粘度η. 详细信息请参考: Palmer, *Phys. Rev. E* 49
(1994) pp 359-366.

计算横向电流时会使用k矢量(1,0,0)和(2,0,0), 它们同时也处于y方向和z方向,
也会使用(1,1,0)和(1,-1,0),
它们同时也处于在2个其他平面(这些矢量不是独立的),
还会使用(1,1,1)以及三个其他的盒子体对角线(也是相关的). 对于每一个k矢量,
会使用正弦和余弦以及两个垂直方向上的速度. 这样共有16 *2* 2=64个横向电流.
对每个k矢量会计算并拟合一个自相关, 这就得到了16个TCAF.
每个TCAF会拟合为f(t) = exp(-v)(cosh(Wv) + 1/W sinh(Wv)), v = -t/(2τ), W
= sqrt(1 - 4τη/ρk\^2), 这样得到16个τ值和η值.
拟合的权重以指数形式exp(-t/w)衰减, 时间常数为w(由
` -wt `{.language-plaintext .highlighter-rouge} 指定),
计算TACF与拟合的时间为5\*w. η的值应拟合为1 - aη(k)k\^2,
这样就可以根据k=0时的值估计剪切粘度.

当选用立方体盒子时, 可以使用选项 ` -oc `{.language-plaintext
.highlighter-rouge} , 这样TCAF会对所有长度相同的k矢量进行平均.
这样得到的TCAF更精确. 立方TCAF与拟合都会写入由
` -oc `{.language-plaintext .highlighter-rouge} 指定的文件,
立方η估计值也会写入有 ` -ov `{.language-plaintext .highlighter-rouge}
指定的文件.

使用选项 ` -mol `{.language-plaintext .highlighter-rouge} 时,
会根据分子而不是原子来确定横向电流. 在这种情况下,
索引组应包含分子编号而不是原子编号.

为获得无限波长时的粘度, ` -ov `{.language-plaintext .highlighter-rouge}
文件中与k依赖的粘度应根据η(k) = η_0 (1 - a k\^2)进行拟合.

**注意** : 请确保坐标与速度的输出频率足够高.
自相关函数初始的非指数部分对于获得好的拟合结果非常重要.

  选项                               默认值 类型             说明
-------------------------- -------------- ---------------- ------------------------------------------------
  ` -f [<.trr/.cpt/...>] `         traj.trr 输入文件         全精度轨迹文件: trr cpt trj tng
  ` -s [<.tpr/.tpb/...>] `        topol.tpr 输入文件, 可选   结构+质量(db): tpr tpb tpa gro g96 pdb brk ent
  ` -n [<.ndx>] `                 index.ndx 输入文件, 可选   索引文件
  ` -ot [<.xvg>] `             transcur.xvg 输出文件, 可选   xvgr/xmgrfile
  ` -oa [<.xvg>] `             tcaf_all.xvg 输出文件         xvgr/xmgr文件
  ` -o [<.xvg>] `                  tcaf.xvg 输出文件         xvgr/xmgr文件
  ` -of [<.xvg>] `             tcaf_fit.xvg 输出文件         xvgr/xmgr文件
  ` -oc [<.xvg>] `             tcaf_cub.xvg 输出文件, 可选   xvgr/xmgr文件
  ` -ov [<.xvg>] `               visc_k.xvg 输出文件         xvgr/xmgr文件

  : 输入/输出文件选项 {#tab-163}

  选项                      默认值 说明
---------------------- --------- ------------------------------------------------------------------
  ` -nice <int> `               19 设置优先级
  ` -b <time> `                  0 从轨迹文件中读取的第一帧(ps)
  ` -e <time> `                  0 从轨迹文件中读取的最后一帧(ps)
  ` -dt <time> `                 0 只使用t除以dt的余数等于第一帧时间(ps)的帧, 即两帧之间的时间间隔
  ` -[no]w `                    no 查看输出的.xvg, .xpm, .eps和.pdb文件
  ` -xvg <enum> `          xmgrace xvg绘图格式: xmgrace, xmgr, none
  ` -[no]mol `                  no 计算分子的TCAF
  ` -[no]k34 `                  no 也使用k=(3,0,0)和k=(4,0,0)
  ` -wt <real> `                 5 TCAF拟合权重的指数衰减时间
  ` -acflen <int> `             -1 ACF的长度, 默认为帧数的一半
  ` -[no]normalize `           yes 归一化ACF
  ` -P <enum> `                  0 ACF Legendre多项式的阶数(0表示不使用): 0, 1, 2, 3
  ` -fitfn <enum> `           none 拟合函数: none, exp, aexp, exp_exp, vac, exp5, exp7, exp9, erfit
  ` -beginfit <real> `           0 对相关函数进行指数拟合的起始时间
  ` -endfit <real> `            -1 对相关函数进行指数拟合的终止时间, -1表示直到最后

  : 控制选项 {#tab-164}

## gmx traj: 输出轨迹文件中的坐标x, 速度v, 力f, 盒子, 温度和转动能

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx traj [-f [<.xtc/.trr/...>]] [-s [<.tpr/.tpb/...>]] [-n [<.ndx>]]
         [-ox [<.xvg>]] [-oxt [<.xtc/.trr/...>]] [-ov [<.xvg>]]
         [-of [<.xvg>]] [-ob [<.xvg>]] [-ot [<.xvg>]] [-ekt [<.xvg>]]
         [-ekr [<.xvg>]] [-vd [<.xvg>]] [-cv [<.pdb>]] [-cf [<.pdb>]]
         [-av [<.xvg>]] [-af [<.xvg>]] [-nice ] [-b ] [-e ]
         [-dt ] [-tu ] [-[no]w] [-xvg ] [-[no]com]
         [-[no]pbc] [-[no]mol] [-[no]nojump] [-[no]x] [-[no]y] [-[no]z]
         [-ng ] [-[no]len] [-[no]fp] [-bin ] [-ctime ]
         [-scale ]
```
:::
:::

` gmx traj `{.language-plaintext .highlighter-rouge} 用于输出坐标, 速度,
力和/或盒子. 使用 ` -com `{.language-plaintext .highlighter-rouge}
选项可计算各个组质心的坐标, 速度和力. 当指定
` -mol `{.language-plaintext .highlighter-rouge} 选项时,
索引文件中的数目被视为分子个数, 并对每一分子使用与
` -com `{.language-plaintext .highlighter-rouge} 选项相同的过程.

选项 ` -ot `{.language-plaintext .highlighter-rouge} 输出每个组的温度,
如果轨迹文件中含有速度信息. 计算时没有对约束自由度进行修正! 此选项暗含
` -com `{.language-plaintext .highlighter-rouge} 选项.

选项 ` -ekt `{.language-plaintext .highlighter-rouge} 和选项
` -ekr `{.language-plaintext .highlighter-rouge}
用来画每一个组的平东和转动动能, 同时在轨迹文件中提供当前的速度信息.

选项 ` -cv `{.language-plaintext .highlighter-rouge} 和
` -cf `{.language-plaintext .highlighter-rouge}
可将平均速度和平均力作为温度因子输出到一个 ` .pdb `{.language-plaintext
.highlighter-rouge} 文件中, 其中的坐标为平均坐标或
` -ctime `{.language-plaintext .highlighter-rouge} 时刻的坐标.
程序会对温度因子进行标度, 使其最大值为10. 标度因子可以通过选项
` -scale `{.language-plaintext .highlighter-rouge} 来改变.
为得到某一帧的速度或力, 可以将选项 ` -b `{.language-plaintext
.highlighter-rouge} 和 ` -e `{.language-plaintext .highlighter-rouge}
都指定为那一帧的时间值. 当对帧进行平均时, 你可能需要使用
` -nojump `{.language-plaintext .highlighter-rouge}
选项以得到正确的平均坐标. 如果你选择了这些选项中一个,
还会将每个原子的平均力和平均速度写入一个 ` .xvg `{.language-plaintext
.highlighter-rouge} 文件(由 ` -av `{.language-plaintext
.highlighter-rouge} 和 ` -af `{.language-plaintext .highlighter-rouge}
选项指定).

选项 ` -vd `{.language-plaintext .highlighter-rouge} 可用于计算速度分布,
即, 输出向量的模. 另外, 同时会给出动能的分布.

  选项                                  默认值 类型         说明
---------------------------- --------------- ------------ ------------------------------------------------
  ` -f [<.xtc/.trr/...>] `            traj.xtc 输入         轨迹: xtc trr cpt trj gro g96 pdb tng
  ` -s [<.tpr/.tpb/...>] `           topol.tpr 输入         结构+质量(db): tpr tpb tpa gro g96 pdb brk ent
  ` -n [<.ndx>] `                    index.ndx 输入, 可选   索引文件
  ` -ox [<.xvg>] `                   coord.xvg 输出, 可选   xvgr/xmgr文件
  ` -oxt [<.xtc/.trr/...>] `         coord.xtc 输出, 可选   轨迹: xtc trr cpt trj gro g96 pdb tng
  ` -ov [<.xvg>] `                   veloc.xvg 输出, 可选   xvgr/xmgr文件
  ` -of [<.xvg>] `                   force.xvg 输出, 可选   xvgr/xmgr文件
  ` -ob [<.xvg>] `                     box.xvg 输出, 可选   xvgr/xmgr文件
  ` -ot [<.xvg>] `                    temp.xvg 输出, 可选   xvgr/xmgr文件
  ` -ekt [<.xvg>] `                ektrans.xvg 输出, 可选   xvgr/xmgr文件
  ` -ekr [<.xvg>] `                  ekrot.xvg 输出, 可选   xvgr/xmgr文件
  ` -vd [<.xvg>] `                 veldist.xvg 输出, 可选   xvgr/xmgr文件
  ` -cv [<.pdb>] `                   veloc.pdb 输出, 可选   Protein data bank文件
  ` -cf [<.pdb>] `                   force.pdb 输出, 可选   PDB文件
  ` -av [<.xvg>] `               all_veloc.xvg 输出, 可选   xvgr/xmgr文件
  ` -af [<.xvg>] `               all_force.xvg 输出, 可选   xvgr/xmgr文件

  : 输入/输出文件选项 {#tab-165}

  选项                   默认值 说明
------------------- --------- -----------------------------------------------------------------
  ` -nice `                  19 设置优先级
  ` -b `                      0 从轨迹文件中读取的第一帧(ps)
  ` -e `                      0 从轨迹文件中读取的最后一帧(ps)
  ` -dt `                     0 只使用t除以dt的余数等于第一帧时间(ps)的帧, 即两帧之间的时间间隔
  ` -tu <enum> `             ps 时间单位: fs, ps, ns, us, ms, s
  ` -[no]w `                 no 查看输出.xvg, .xpm, .eps and .pdb文件
  ` -xvg <enum> `       xmgrace xvg绘图格式: xmgrace, xmgr, none
  ` -[no]com `               no 输出每组质心的数据
  ` -[no]pbc `              yes 对质心, 使分子保持完整
  ` -[no]mol `               no 索引包含了分子数, iso原子数
  ` -[no]nojump `            no 移除原子对盒子边界的跨越
  ` -[no]x `                yes 输出x分量
  ` -[no]y `                yes 输出y分量
  ` -[no]z `                yes 输出z分量
  ` -ng <int> `               1 考虑的组的数目
  ` -[no]len `               no 输出向量的长度
  ` -[no]fp `                no 全精度输出
  ` -bin <real> `             1 速度直方图的分格宽度(单位: nm/ps)
  ` -ctime <real> `          -1 对 ` -cv ` 和 ` -cf ` 使用此时刻帧的x, 而不是平均的x
  ` -scale <real> `           0 ` .pdb ` 输出的标度因子, 0表示自动选择标度

  : 控制选项 {#tab-166}

## gmx trjcat: 连接轨迹文件

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx trjcat [-f [<.xtc/.trr/...> [...]]] [-o [<.xtc/.trr/...> [...]]]
           [-n [<.ndx>]] [-demux [<.xvg>]] [-nice ] [-tu ]
           [-xvg ] [-b ] [-e ] [-dt ] [-[no]vel]
           [-[no]settime] [-[no]sort] [-[no]keeplast] [-[no]overwrite]
           [-[no]cat]
```
:::
:::

` gmx trjcat `{.language-plaintext .highlighter-rouge}
可按顺序将几个输入轨迹文件合并在一起. 当发现同一时刻存在两帧时,
会使用后一文件中的帧. 通过使用 ` -settime `{.language-plaintext
.highlighter-rouge} , 你可以指定每一轨迹文件的起始时间.
输入文件由命令行得到, 你可能要使用像
` gmx trjcat -f *.trr -o fixed.trr `{.language-plaintext
.highlighter-rouge} 这样的技巧. 使用 ` -cat `{.language-plaintext
.highlighter-rouge} 选项,
你可以简单地将几个文件粘帖在一起而不会移除具有系统时间戳的帧.

当输出文件为输入文件之一时, 需要特别注意一点. 在这种情况下,
那个特定的输入文件会被追加, 这样就不需要存储双倍的数据. 显然,
要追加的文件必须具有最小的起始时间, 因为只能在文件末尾追加.

当给定 ` -demux `{.language-plaintext .highlighter-rouge} 选项时,
会读入N个轨迹, 并将它们按 ` .xvg `{.language-plaintext
.highlighter-rouge} 文件中指定的顺序写入另一个文件中.
` .xvg `{.language-plaintext .highlighter-rouge} 文件的内容类似于:

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
0 0 1 2 3 4 5
2 1 0 2 3 5 4
```
:::
:::

其中, 第一个数字为时间, 接下来的数字为轨迹编号,
对应于第一行数字的帧会写入输出轨迹中. 如果轨迹中帧的数目与
` .xvg `{.language-plaintext .highlighter-rouge} 文件中的不匹配,
程序会自行决定如何处理. 请小心.

  选项                                    默认值 类型         说明
-------------------------------- ------------- ------------ ---------------------------------------
  ` -f [<.xtc/.trr/...> [...]] `        traj.xtc 输入         轨迹: xtc trr cpt trj gro g96 pdb tng
  ` -o [<.xtc/.trr/...> [...]] `     trajout.xtc 输出         轨迹: xtc trr trj gro g96 pdb tng
  ` -n [<.ndx>] `                      index.ndx 输入, 可选   索引文件
  ` -demux [<.xvg>] `                   remd.xvg 输入, 可选   xvgr/xmgr文件

  : 输入/输出文件选项 {#tab-167}

  选项                    默认值 说明
-------------------- --------- -----------------------------------------------------------------
  ` -nice <int> `             19 设置优先级
  ` -tu <enum> `              ps 时间单位: fs, ps, ns, us, ms, s
  ` -xvg <enum> `        xmgrace xvg绘图格式: xmgrace, xmgr, none
  ` -b `                       0 从轨迹文件中读取的第一帧(ps)
  ` -e `                       0 从轨迹文件中读取的最后一帧(ps)
  ` -dt `                      0 只使用t除以dt的余数等于第一帧时间(ps)的帧, 即两帧之间的时间间隔
  ` -[no]vel `               yes 如果可能读入并输出速度
  ` -[no]settime `            no 交互式地设定每一输入文件在新输出文件中的起始时间
  ` -[no]sort `              yes 自动排序输入轨迹文件(而不是帧)
  ` -[no]keeplast `           no 将重复帧输出值轨迹末尾
  ` -[no]overwrite `          no 追加时覆盖重复帧
  ` -[no]cat `                no 不丢弃重复帧

  : 控制选项 {#tab-168}

## gmx trjconv: 转换和操控轨迹文件

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx trjconv [-f [<.xtc/.trr/...>]] [-o [<.xtc/.trr/...>]]
            [-s [<.tpr/.tpb/...>]] [-n [<.ndx>]] [-fr [<.ndx>]]
            [-sub [<.ndx>]] [-drop [<.xvg>]] [-nice ] [-b ]
            [-e ] [-tu ] [-[no]w] [-xvg ] [-skip ]
            [-dt ] [-[no]round] [-dump ] [-t0 ]
            [-timestep ] [-pbc ] [-ur ] [-[no]center]
            [-boxcenter ] [-box ] [-trans ]
            [-shift ] [-fit ] [-ndec ] [-[no]vel]
            [-[no]force] [-trunc ] [-exec ] [-split ]
            [-[no]sep] [-nzero ] [-dropunder ] [-dropover ]
            [-[no]conect]
```
:::
:::

` gmx trjconv `{.language-plaintext .highlighter-rouge}
可以以多种方式来转换轨迹文件:

-   从一种格式转换为另一种格式
-   选择一组原子集合
-   改变周期性的表示方式
-   将多聚体分子保持一起
-   将原子在盒子内居中
-   将原子叠合到参考结构
-   减少帧数
-   改变每帧的时间戳( ` -t0 `{.language-plaintext .highlighter-rouge} 和
    ` -timestep `{.language-plaintext .highlighter-rouge} )
-   根据索引文件中的信息把轨迹分割为小的子轨迹,
    这样对子轨迹的后续分析就变为对团簇的分析. 需要使用选项
    ` -sub `{.language-plaintext .highlighter-rouge} .
    处理时假定索引文件中的条目为帧数,
    并将把索引文件中的每个组输出为单独的轨迹.
-   选取某个量处于一定范围内的帧, 这个量由 ` .xvg `{.language-plaintext
    .highlighter-rouge} 文件给出

` gmx trjconv `{.language-plaintext .highlighter-rouge}
更适用于将多个轨迹文件拼合起来.

` gmx trjconv `{.language-plaintext .highlighter-rouge}
支持以下格式的输入和输出文件: ` .xtc `{.language-plaintext
.highlighter-rouge} , ` .trr `{.language-plaintext .highlighter-rouge} ,
` .trj `{.language-plaintext .highlighter-rouge} ,
` .gro `{.language-plaintext .highlighter-rouge} ,
` .g96 `{.language-plaintext .highlighter-rouge} 和
` .pdb `{.language-plaintext .highlighter-rouge} .
文件格式由文件的扩展名决定. 对 ` .xtc `{.language-plaintext
.highlighter-rouge} , ` .gro `{.language-plaintext .highlighter-rouge}
和 ` .pdb `{.language-plaintext .highlighter-rouge} 输入格式,
` .xtc `{.language-plaintext .highlighter-rouge} 和
` .gro `{.language-plaintext .highlighter-rouge}
输出文件的精度取决于输入文件; 对其他输入格式, 输出文件的精度由
` -ndec `{.language-plaintext .highlighter-rouge} 选项决定. 如果设定了
` -ndec `{.language-plaintext .highlighter-rouge} 选项,
输出格式的精度总是取决于 ` -ndec `{.language-plaintext
.highlighter-rouge} . 所有其他格式的精度都是固定的.
` .trr `{.language-plaintext .highlighter-rouge} 和
` .trj `{.language-plaintext .highlighter-rouge}
输出格式的精度可以是单精度或双精度, 取决于
` gmx trjconv `{.language-plaintext .highlighter-rouge} 程序的精度.
注意, 只有 ` .trr `{.language-plaintext .highlighter-rouge} ,
` .trj `{.language-plaintext .highlighter-rouge} ,
` .gro `{.language-plaintext .highlighter-rouge} 和
` .g96 `{.language-plaintext .highlighter-rouge} 格式的文件支持速度.

` -sep `{.language-plaintext .highlighter-rouge}
选项可将每一帧写入到单独的 ` .gro `{.language-plaintext
.highlighter-rouge} , ` .g96 `{.language-plaintext .highlighter-rouge}
或 ` .pdb `{.language-plaintext .highlighter-rouge} 文件. 默认情况下,
所有帧都被写入到一个文件中. 拼合了所有帧的 ` .pdb `{.language-plaintext
.highlighter-rouge} 文件可以使用 ` rasmol –nmrpdb `{.language-plaintext
.highlighter-rouge} 来查看.

为了节省磁盘空间, 可以选择部分轨迹并将其写入到一个新的轨迹文件中. 例如,
去除蛋白质水溶液轨迹中的水分子. **始终** 要保存原始的轨迹文件!
我们推荐使用可移植的 ` .xtc `{.language-plaintext .highlighter-rouge}
格式进行分析以节省磁盘空间并得到可移植的文件.

有两个选项可用于将轨迹叠合到参考结构或进行主成分动力学分析.
第一个选项仅仅将结构简单地叠合到结构文件中的参考结构.
第二个选项是逐步叠合: 第一时间步的结构叠合到结构文件中的参考结构,
后续时间步的结构则叠合到前一步的叠合结构. 与常规的叠合方法不同,
利用这种方式可以产生连续的轨迹, 例如当蛋白质的构象转变很大时.

选项 ` -pbc `{.language-plaintext .highlighter-rouge}
用于设置周期性边界条件的处理方式:

-   ` mol `{.language-plaintext .highlighter-rouge} :
    将分子的质心置于盒子中, 需要使用 ` -s `{.language-plaintext
    .highlighter-rouge} 提供一个运行输入文件
-   ` res `{.language-plaintext .highlighter-rouge} :
    将残基的质心置于盒子中
-   ` atom `{.language-plaintext .highlighter-rouge} :
    将所有原子置于盒子中
-   ` nojump `{.language-plaintext .highlighter-rouge} :
    检查原子是否跳过了盒子边缘, 如果是则将它们放回来.
    这样所有分子都可以保持完整(如果在初始构型中它们是完整的). **注意** ,
    这样可以确保轨迹连续, 但分子可能扩散出盒子. 如果提供了结构文件,
    此过程的起始构型将来自结构文件, 否则将使用第一帧的构型.
-   ` cluster `{.language-plaintext .highlighter-rouge} :
    将选定索引中的所有原子团簇化, 这样它们到团簇质心的距离最近,
    团簇质心会迭代更新. **注意** , 只有确实存在一个团簇时,
    这种方法才能给出有意义的结果.
    幸运的是你以后可以使用轨迹查看器来检查是否存在一个团簇.
    同时也要注意, 如果分子破碎了, 这个选项也不会起作用.\
    单独的选项 ` -clustrcenter `{.language-plaintext .highlighter-rouge}
    可用于指定团簇的近似质心. 这适用于一些情况, 例如存在两个大囊泡,
    你需要保持他们的相对位置.
-   ` whole `{.language-plaintext .highlighter-rouge} :
    将破碎的分子恢复完整

对 ` -pbc `{.language-plaintext .highlighter-rouge} 的
` mol `{.language-plaintext .highlighter-rouge} ,
` res `{.language-plaintext .highlighter-rouge} 和
` atom `{.language-plaintext .highlighter-rouge} 选项,
` -ur `{.language-plaintext .highlighter-rouge}
选项设置单元晶胞的表示方式. 对于三斜盒子这三个选项会给出不同的结果,
而对于长方盒子, 给出的结构相同. ` rect `{.language-plaintext
.highlighter-rouge} 是普通的长方体形状, ` tric `{.language-plaintext
.highlighter-rouge} 是三斜晶胞, ` compact `{.language-plaintext
.highlighter-rouge} 将所有原子置于离盒子中心距离最近的位置. 这有利于,
例如对截断八面体和菱形十二面体的可视化. 对 ` tric `{.language-plaintext
.highlighter-rouge} 和 ` compact `{.language-plaintext
.highlighter-rouge} 选项的中心是 ` tric `{.language-plaintext
.highlighter-rouge} (见下文), 除非选项
` -boxcenter `{.language-plaintext .highlighter-rouge} 设置了不同的值.

选项 ` -center `{.language-plaintext .highlighter-rouge}
将体系在盒子内居中, 用户可以选择用于确定几何中心的组. 对
` -pbc `{.language-plaintext .highlighter-rouge} 和
` -center `{.language-plaintext .highlighter-rouge} 选项,
` -boxcenter `{.language-plaintext .highlighter-rouge}
设置盒子的中心位置. 中心的选项为: ` tric `{.language-plaintext
.highlighter-rouge} : 盒向量总和的一半, ` rect `{.language-plaintext
.highlighter-rouge} : 盒子对角线的一半, ` zero `{.language-plaintext
.highlighter-rouge} : 0. 如果居中后你想使所有分子都处于盒子中, 可以使用
` -center `{.language-plaintext .highlighter-rouge} 和
` -pbc mol `{.language-plaintext .highlighter-rouge} 选项.

选项 ` -box `{.language-plaintext .highlighter-rouge} 设置新盒子的大小.
此选项只用于主维度, 因此通常只用于长方盒子. 如果你只想修改某些维度,
例如读取轨迹时, 你可以使用-1使某一维度保持不变. 当仅调用一次
` gmx trjconv `{.language-plaintext .highlighter-rouge} 时, 使用
` -pbc `{.language-plaintext .highlighter-rouge} ,
` -fit `{.language-plaintext .highlighter-rouge} ,
` -ur `{.language-plaintext .highlighter-rouge} 和
` -center `{.language-plaintext .highlighter-rouge}
选项的组合并不总能精确地达到你的目的. 这种情况下可考虑使用多次调用,
可参考GROMACS网站的一些建议.

使用 ` -dt `{.language-plaintext .highlighter-rouge}
选项可以减少输出中的帧数. 此选项依赖于输入轨迹中时间的精确度, 因此,
如果它们不够精确, 可以使用 ` -timestep `{.language-plaintext
.highlighter-rouge} 选项来修改时间(可以同时进行). 为了制作平滑的电影,
` gmx filter `{.language-plaintext .highlighter-rouge}
程序可以使用低通频率滤波器来减少帧的数目, 从而减少了高频运动的走样.

使用 ` -trunc `{.language-plaintext .highlighter-rouge} 选项,
` gmx trjconv `{.language-plaintext .highlighter-rouge} 可以就地截断
` .trj `{.language-plaintext .highlighter-rouge} 文件, 即不需要复制文件.
当在磁盘I/O过程中运行崩溃时(即磁盘已满),
或者当拼合两个邻近的轨迹但不能重帧时, 此选项很有用.

选项 ` -dump `{.language-plaintext .highlighter-rouge}
用于从你的轨迹文件中抽取处于或邻近指定时间的帧.

选项 ` -drop `{.language-plaintext .highlighter-rouge} 读取
` .xvg `{.language-plaintext .highlighter-rouge} 文件中的时间和数值.
当设置了选项 ` -dropunder `{.language-plaintext .highlighter-rouge}
和/或 ` -dropover `{.language-plaintext .highlighter-rouge} ,
不会输出低于或高于相应选项设定值的帧.

  选项                              默认值 类型         说明
-------------------------- ------------- ------------ ------------------------------------------------
  ` -f [<.xtc/.trr/...>] `        traj.xtc 输入         轨迹: xtc trr cpt trj gro g96 pdb tng
  ` -o [<.xtc/.trr/...>] `     trajout.xtc 输出         轨迹: xtc trr trj gro g96 pdb tng
  ` -s [<.tpr/.tpb/...>] `       topol.tpr 输入, 可选   结构+质量(db): tpr tpb tpa gro g96 pdb brk ent
  ` -n [<.ndx>] `                index.ndx 输入, 可选   索引文件
  ` -fr [<.ndx>] `              frames.ndx 输入, 可选   索引文件
  ` -sub [<.ndx>] `            cluster.ndx 输入, 可选   索引文件
  ` -drop [<.xvg>] `              drop.xvg 输入, 可选   xvgr/xmgr文件

  : 输入/输出文件选项 {#tab-169}

------------------------------------------------------------------------------------------------------
  选项                                     默认值 说明
----------------------- ----------------------- ------------------------------------------------------
  ` -nice <int> `                              19 设置优先级

  ` -b `                                        0 从轨迹文件中读取的第一帧(ps)

  ` -e `                                        0 从轨迹文件中读取的最后一帧(ps)

  ` -tu `                                      ps 时间值的单位: fs, ps, ns, us, ms, s

  ` -[no]w `                                   no 程序结束后查看输出的.xvg, .xpm, .eps和.pdb文件

  ` -xvg <enum> `                         xmgrace xvg绘图格式: xmgrace, xmgr, none

  ` -skip <int> `                               1 每nr帧输出一次

  ` -dt `                                       0 只使用t除以dt的余数等于第一帧时间(ps)的帧,
                                                  即两帧之间的时间间隔

  ` -[no]round `                               no 将测量四舍五入至最接近的皮秒

  ` -dump <time> `                             -1 重复最接近指定时间(ps)的帧

  ` -t0 <time> `                                0 起始时间(ps) (默认: 不改变)

  ` -timestep <time> `                          0 更改输入帧之间的时间步长(ps)

  ` -pbc <enum> `                            none PBC处理方式(完整说明见帮助文件): none, mol, res, atom,
                                                  nojump, cluster, whole

  ` -ur <enum> `                             rect 单元晶胞的表示方式: rect, tric, compact

  ` -[no]center `                              no 将盒子内的原子居中

  ` -boxcenter <enum> `                      tric ` -pbc ` 和 ` -center ` 的中心: tric, rect, zero

  ` -box <vector> `                         0 0 0 新立方盒子的尺寸(默认读取自输入文件)

  ` -trans <vector> `                       0 0 0 所有坐标将被平移 trans. 适用于与
                                                  ` -pbc mol -ur compact ` 组合使用.

  ` -shift <vector> `                       0 0 0 所有坐标将被偏移 framenr\*shift

  ` -fit <enum> `                            none 将分子叠合到结构文件中的参考结构.\
                                                  可用选项: none, rot+trans, rotxy+transxy, translation,
                                                  transxy, progressive

  ` -ndec <int> `                               3 输出 ` .xtc ` 和 ` .gro ` 时, 小数位的精度

  ` -[no]vel `                                yes 如果可能, 读取并输出速度

  ` -[no]force `                               no 如果可能, 读取并输出力

  ` -trunc <time> `                            -1 在此时间(ps)后截断输入轨迹文件

  ` -exec <string> `                              对每个输出帧执行命令, 帧号作为命令的参数

  ` -split <time> `                             0 当t除以split的余数等于第一帧时间(ps)时开始输出新文件

  ` -[no]sep `                                 no 将每一帧输出为独立的 ` .gro ` , ` .g96 ` 或 ` .pdb `
                                                  文件

  ` -nzero <int> `                              0 如果设置 ` -sep ` , 文件编号的数字位数, 如果需要,
                                                  数字签名会添加0

  ` -dropunder <real> `                         0 舍弃低于此值的所有帧

  ` -dropover <real> `                          0 舍弃高于此值的所有帧

  ` -[no]conect `                              no 当输出 ` .pdb ` 文件时增加连接记录. 对于非标准分子,
                                                  例如粗粒化分子的可视化会有用.
  ------------------------------------------------------------------------------------------------------

  : 控制选项 {#tab-170}

### 补充说明

` gmx trjconv `{.language-plaintext .highlighter-rouge}
可能是最常用的后处理工具, 用来处理坐标, 处理周期性或者手动调整轨迹.
利用它抽取特定的轨迹比较简单, 但使用它处理轨迹的周期性时,
一些选项不容易理解. 下面对其中的一些进行说明.

` -pbc mol|res|atom `{.language-plaintext .highlighter-rouge}
指定以何种方式考虑PBC, 是使分子的质心, 残基的质心,
还是每个原子处于盒子中. 如果使用 ` -pbc atom `{.language-plaintext
.highlighter-rouge} 所有原子都处于盒子之中,
这样边界上的分子看起来破碎了. 如果对破碎后的分子再使用一次
` -pbc whole `{.language-plaintext .highlighter-rouge} , 将分子恢复完整,
其效果与 ` -pbc mol `{.language-plaintext .highlighter-rouge} 类似.

` -pbc nojump `{.language-plaintext .highlighter-rouge}
可以保证分子的运动是连续的, 就像体系处于真空中一样,
分子连续地向各个方向扩散. 在计算MSD这样的量的时候, 需要这样考虑. 但
` gmx msd `{.language-plaintext .highlighter-rouge}
在计算时已经考虑了这点, 所以我们就无须先利用此选项对轨迹进行处理了.
此选项对单个构型没有意义.

使用 ` -pbc mol|res|atom `{.language-plaintext .highlighter-rouge}
选项时, 会使相应的中心处于盒子中, 而盒子的显示方法则使用
` -ur `{.language-plaintext .highlighter-rouge} 来控制.
如果使用长方体盒子, ` -ur `{.language-plaintext .highlighter-rouge}
的三种选项给出的结果相同, 所以无需考虑此项. 如果使用了三斜盒子,
` -ur `{.language-plaintext .highlighter-rouge}
的三种选项给出的结果不同: ` -ur tric `{.language-plaintext
.highlighter-rouge} 粒子处于三斜盒子中, ` -ur rect `{.language-plaintext
.highlighter-rouge} 粒子处于长方盒子中,
` -ur compact `{.language-plaintext .highlighter-rouge}
粒子处于距盒子中心最近的位置, 近似球形.

利用 ` -center `{.language-plaintext .highlighter-rouge}
选项可使某组原子在盒子内居中, 运行时, 会提示你选择要居中的组.
此选项可以和 ` -pbc mol|res|atom `{.language-plaintext
.highlighter-rouge} 一起使用, 达到使某组原子居中,
同时其他原子都处于盒子内的目的.

在使用 ` -ur tric|compact `{.language-plaintext .highlighter-rouge} ,
` -pbc mol|res|atom| `{.language-plaintext .highlighter-rouge} ,
` -center `{.language-plaintext .highlighter-rouge} 选项时,
都需要定义盒子的中心. 默认使用的盒子中心处于盒向量的一半处. 但可以使用
` -boxcenter `{.language-plaintext .highlighter-rouge} 改变:
` tric `{.language-plaintext .highlighter-rouge} 盒向量总和的一半,
` rect `{.language-plaintext .highlighter-rouge} 盒子对角线的一半,
` zero `{.language-plaintext .highlighter-rouge} 0.

上面的这几个选项可组合使用, 但不能保证一定能满足需要, 有时可能需要使用
` gmx trjconv `{.language-plaintext .highlighter-rouge} 多次.

注意, ` -pbc `{.language-plaintext .highlighter-rouge} 和
` -fit rot `{.language-plaintext .highlighter-rouge}
两个选项不能一起使用. 否则程序运行错误, 给出如下信息:

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
PBC condition treatment does not work together with rotational fit.
Please do the PBC condition treatment first and then run trjconv in a second step for the rotational fit.
First doing the rotational fit and then doing the PBC treatment gives incorrect results!
```
:::
:::

这意味着凡同时涉及周期性和叠合的处理都需要分两次进行,
而且必须先进行周期性处理, 再进行叠合, 否则结果错误.

` -pbc `{.language-plaintext .highlighter-rouge} 几种处理的效果可参看
[gmx trjconv选项测试](/GMX/GMXpbc)

## gmx trjorder: 根据到参考组原子的距离对分子排序

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx trjorder [-f [<.xtc/.trr/...>]] [-s [<.tpr/.tpb/...>]] [-n [<.ndx>]]
             [-o [<.xtc/.trr/...>]] [-nshell [<.xvg>]] [-nice ]
             [-b ] [-e ] [-dt ] [-xvg ] [-na ]
             [-da ] [-[no]com] [-r ] [-[no]z]
```
:::
:::

` gmx trjorder `{.language-plaintext .highlighter-rouge}
可根据到参考组原子的最小距离或z坐标( ` -z `{.language-plaintext
.highlighter-rouge} 选项)对分子排序. 使用距离进行排序时,
需要指定参考原子组以及分子组. 对轨迹中的每一帧,
所选分子会根据分子中编号为 ` -da `{.language-plaintext
.highlighter-rouge} 的原子与参考组中所有原子之间距离的最小值进行重排序.
通过将 ` -da `{.language-plaintext .highlighter-rouge} 设定为0,
可使用分子的质心而不是参考原子. 轨迹中的所有原子都会写入输出轨迹.

对某些分析, ` gmx trjorder `{.language-plaintext .highlighter-rouge}
可能会有用, 例如分析离蛋白最近的n个水分子. 在这种情况下, 参考组为蛋白质,
分子组为所有水分子的原子. 当得到了前n个水分子的索引组后,
排序后的轨迹可使用任何GROMACS工具分析最近的n个水分子.

如果输出文件为 ` .pdb `{.language-plaintext .highlighter-rouge} 文件,
到参考目标的距离会存放于B因子字段, 以便用于使用一些可视化程序加色,
如Rasmol

使用 ` -nshell `{.language-plaintext .highlighter-rouge} 选项,
会输出参考组周围一定半径 ` -r `{.language-plaintext .highlighter-rouge}
壳层内的分子数.

  选项                              默认值 类型         说明
-------------------------- ------------- ------------ ------------------------------------------------
  ` -f [<.xtc/.trr/...>] `        traj.xtc 输入         轨迹: xtc trr cpt trj gro g96 pdb tng
  ` -s [<.tpr/.tpb/...>] `       topol.tpr 输入         结构+质量(db): tpr tpb tpa gro g96 pdb brk ent
  ` -n [<.ndx>] `                index.ndx 输入, 可选   索引文件
  ` -o [<.xtc/.trr/...>] `     ordered.xtc 输出, 可选   轨迹: xtc trr trj gro g96 pdb tng
  ` -nshell [<.xvg>] `          nshell.xvg 输出, 可选   xvgr/xmgr文件

  : 输入/输出文件选项 {#tab-171}

  选项                 默认值 说明
----------------- --------- -----------------------------------------------------------------
  ` -nice <int> `          19 设置优先级
  ` -b <time> `             0 从轨迹文件中读取的第一帧(ps)
  ` -e <time> `             0 从轨迹文件中读取的最后一帧(ps)
  ` -dt <time> `            0 只使用t除以dt的余数等于第一帧时间(ps)的帧, 即两帧之间的时间间隔
  ` -xvg <enum> `     xmgrace xvg绘图格式: xmgrace, xmgr, none
  ` -na <int> `             3 分子中的原子个数
  ` -da <int> `             1 计算距离时所用原子的编号, 0表示使用质心
  ` -[no]com `             no 使用到参考组质心的距离
  ` -r <real> `             0 当计算围绕蛋白等的壳层内的分子数时, 距离的截断值
  ` -[no]z `               no 根据z坐标排序分子

  : 控制选项 {#tab-172}

## gmx tune_pme: 计算 ` mdrun `{.language-plaintext .highlighter-rouge} 的运行时间与PME进程数的关系以优化设置 {#gmx-tune_pme-计算mdrun的运行时间与pme进程数的关系以优化设置翻译-嘉晔}

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx tune_pme [-p [<.out>]] [-err [<.log>]] [-so [<.tpr/.tpb/...>]]
             [-s [<.tpr/.tpb/...>]] [-o [<.trr/.cpt/...>]] [-x [<.xtc/.tng>]]
             [-cpi [<.cpt>]] [-cpo [<.cpt>]] [-c [<.gro/.g96/...>]]
             [-e [<.edr>]] [-g [<.log>]] [-dhdl [<.xvg>]] [-field [<.xvg>]]
             [-table [<.xvg>]] [-tabletf [<.xvg>]] [-tablep [<.xvg>]]
             [-tableb [<.xvg>]] [-rerun [<.xtc/.trr/...>]] [-tpi [<.xvg>]]
             [-tpid [<.xvg>]] [-ei [<.edi>]] [-eo [<.xvg>]]
             [-devout [<.xvg>]] [-runav [<.xvg>]] [-px [<.xvg>]]
             [-pf [<.xvg>]] [-ro [<.xvg>]] [-ra [<.log>]] [-rs [<.log>]]
             [-rt [<.log>]] [-mtx [<.mtx>]] [-dn [<.ndx>]] [-swap [<.xvg>]]
             [-bo [<.trr/.cpt/...>]] [-bx [<.xtc>]] [-bcpo [<.cpt>]]
             [-bc [<.gro/.g96/...>]] [-be [<.edr>]] [-bg [<.log>]]
             [-beo [<.xvg>]] [-bdhdl [<.xvg>]] [-bfield [<.xvg>]]
             [-btpi [<.xvg>]] [-btpid [<.xvg>]] [-bdevout [<.xvg>]]
             [-brunav [<.xvg>]] [-bpx [<.xvg>]] [-bpf [<.xvg>]]
             [-bro [<.xvg>]] [-bra [<.log>]] [-brs [<.log>]] [-brt [<.log>]]
             [-bmtx [<.mtx>]] [-bdn [<.ndx>]] [-bswap [<.xvg>]] [-nice ]
             [-xvg ] [-np ] [-npstring ] [-ntmpi ]
             [-r ] [-max ] [-min ] [-npme ]
             [-fix ] [-rmax ] [-rmin ] [-[no]scalevdw]
             [-ntpr ] [-steps ] [-resetstep ] [-nsteps ]
             [-[no]launch] [-[no]bench] [-[no]check] [-[no]append]
             [-[no]cpnum]
```
:::
:::

对于给定数目 ` -np `{.language-plaintext .highlighter-rouge} 或
` -ntmpi `{.language-plaintext .highlighter-rouge} 的总进程数,
` gmx tune_pme `{.language-plaintext .highlighter-rouge}
可以系统地测试不同PME进程数对 ` gmx mdrun `{.language-plaintext
.highlighter-rouge} 运行时间的影响, 并确定哪种设置最快.
通过将负载从Ewald加和的倒易空间部分转移到实空间部分,
它也可以测试是否能提升性能. 测试时, 你只需要将
` .tpr `{.language-plaintext .highlighter-rouge} 文件和
` gmx mdrun `{.language-plaintext .highlighter-rouge} 的运行选项一起传给
` gmx tune_pme `{.language-plaintext .highlighter-rouge} 即可.

测试使用的可执行文件可以通过环境变量 ` MPIRUN `{.language-plaintext
.highlighter-rouge} 和 ` MDRUN `{.language-plaintext .highlighter-rouge}
进行设置. 如果这些设置不存在, 默认将使用 ` mpirun `{.language-plaintext
.highlighter-rouge} 和 ` mdrun `{.language-plaintext .highlighter-rouge}
. 注意, 对某些MPI框架, 你需要提供机器号或者主机名. 也可以通过
` MPIRUN `{.language-plaintext .highlighter-rouge} 变量传递这些设置,
例如,

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
export MPIRUN="/usr/local/mpirun -machinefile hosts"
```
:::
:::

在实际的基准测试运行之前, 如果激活了 ` -check `{.language-plaintext
.highlighter-rouge} 选项(默认激活), ` gmx tune_pme `{.language-plaintext
.highlighter-rouge} 会进行一个快速的检测, 以确定对提供的并行设置
` mdrun `{.language-plaintext .highlighter-rouge} 是否如预期的那样运行.
请使用你要传递给 ` gmx mdrun `{.language-plaintext .highlighter-rouge}
的正常选项去调用 ` gmx tune_pme `{.language-plaintext
.highlighter-rouge} , 并且增加执行测试的进程数选项
` -np `{.language-plaintext .highlighter-rouge} , 或线程数选项
` -ntmpi `{.language-plaintext .highlighter-rouge} . 你也可以增加
` -r `{.language-plaintext .highlighter-rouge}
选项对每个测试重复多次以便得到更好的统计结果.

` gmx tune_pme `{.language-plaintext .highlighter-rouge}
能够测试各种实空间/倒空间的工作负载. 使用 ` -ntpr `{.language-plaintext
.highlighter-rouge} 选项, 你可以控制额外输出的
` .tpr `{.language-plaintext .highlighter-rouge} 文件的数目,
每个文件分别对应了增大的截断距离和更小的傅里叶格点. 通常,
首次测试(0号)的设置来自输入的 ` .tpr `{.language-plaintext
.highlighter-rouge} 文件; 最后一次测试( ` ntpr `{.language-plaintext
.highlighter-rouge} 号)使用了由 ` -rmax `{.language-plaintext
.highlighter-rouge} 指定的库伦截断, 同时使用了略小的PME格点.
在最后的测试中, 傅里叶间距会变为原来的 ` rmax `{.language-plaintext
.highlighter-rouge} / ` rcoulomb `{.language-plaintext
.highlighter-rouge} 倍. 其余 ` .tpr `{.language-plaintext
.highlighter-rouge}
文件使用了处于这两个极值之间的等间距的库伦布半径(以及傅里叶间距).
**注意** , 如果你只想搜寻最佳的PME进程数, 可以将
` -ntpr `{.language-plaintext .highlighter-rouge} 设为1. 在这种情况下,
输入文件 ` .tpr `{.language-plaintext .highlighter-rouge} 将保持不变.

对于基准测试, 默认的1000个时间步对大多数MD体系应该足够了.
动态负载平衡大约需要100个时间步长来适应本地的负载失衡, 因此默认情况下,
100步之后时间步计数器会被重置. 对于大的体系(\>1M个原子)以及高精度测量,
你应该将 ` -resetstep `{.language-plaintext .highlighter-rouge}
设置为更大的值. 由 ` md.log `{.language-plaintext .highlighter-rouge}
输出文件中的 ` DD `{.language-plaintext .highlighter-rouge} 负载失衡项,
你可以知道多少步之后负载已经充分均衡了. 例如, 你可以调用

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx tune_pme -np 64 -s protein.tpr -launch
```
:::
:::

调用 ` gmx mdrun `{.language-plaintext .highlighter-rouge}
命令若干次之后, 详细的性能信息会保存在输出文件
` perf.out `{.language-plaintext .highlighter-rouge} 中. **注意** ,
在基准测试运行期间, 会产生一些临时文件(选项 ` -b* `{.language-plaintext
.highlighter-rouge} ), 每个测试完成之后它们会被自动删除.

如果你想使用最佳参数自动启动模拟, 可以使用命令行选项
` -launch `{.language-plaintext .highlighter-rouge} .

  选项                                    默认值 类型         说明
------------------------------ --------------- ------------ ---------------------------------------
  ` -p [<.out>] `                       perf.out 输出         通用输出文件
  ` -err [<.log>] `                 bencherr.log 输出         日志文件
  ` -so [<.tpr/.tpb/...>] `            tuned.tpr 输出         运行输入文件: tpr tpb tpa
  ` -s [<.tpr/.tpb/...>] `             topol.tpr 输入         运行输入文件: tpr tpb tpa
  ` -o [<.trr/.cpt/...>] `              traj.trr 输出         全精度轨迹: trr cpt trj tng
  ` -x [<.xtc/.tng>] `             traj_comp.xtc 输出, 可选   压缩轨迹(tng格式或可移植的xdr格式)
  ` -cpi [<.cpt>] `                    state.cpt 输入, 可选   检查点文件
  ` -cpo [<.cpt>] `                    state.cpt 输出, 可选   检查点文件
  ` -c [<.gro/.g96/...>] `           confout.gro 输出         结构文件: gro g96 pdb brk ent esp
  ` -e [<.edr>] `                       ener.edr 输出         能量文件
  ` -g [<.log>] `                         md.log 输出         日志文件
  ` -dhdl [<.xvg>] `                    dhdl.xvg 输出, 可选   xvgr/xmgr文件
  ` -field [<.xvg>] `                  field.xvg 输出, 可选   xvgr/xmgr文件
  ` -table [<.xvg>] `                  table.xvg 输入, 可选   xvgr/xmgr文件
  ` -tabletf [<.xvg>] `              tabletf.xvg 输入, 可选   xvgr/xmgr文件
  ` -tablep [<.xvg>] `                tablep.xvg 输入, 可选   xvgr/xmgr文件
  ` -tableb [<.xvg>] `                 table.xvg 输入, 可选   xvgr/xmgr文件
  ` -rerun [<.xtc/.trr/...>] `         rerun.xtc 输入, 可选   轨迹: xtc trr cpt trj gro g96 pdb tng
  ` -tpi [<.xvg>] `                      tpi.xvg 输出, 可选   xvgr/xmgr文件
  ` -tpid [<.xvg>] `                 tpidist.xvg 输出, 可选   xvgr/xmgr文件
  ` -ei [<.edi>] `                       sam.edi 输入, 可选   ED采样输入
  ` -eo [<.xvg>] `                     edsam.xvg 输出, 可选   xvgr/xmgr文件
  ` -devout [<.xvg>] `              deviatie.xvg 输出, 可选   xvgr/xmgr文件
  ` -runav [<.xvg>] `                runaver.xvg 输出, 可选   xvgr/xmgr文件
  ` -px [<.xvg>] `                     pullx.xvg 输出, 可选   xvgr/xmgr文件
  ` -pf [<.xvg>] `                     pullf.xvg 输出, 可选   xvgr/xmgr文件
  ` -ro [<.xvg>] `                  rotation.xvg 输出, 可选   xvgr/xmgr文件
  ` -ra [<.log>] `                 rotangles.log 输出, 可选   日志文件
  ` -rs [<.log>] `                  rotslabs.log 输出, 可选   日志文件
  ` -rt [<.log>] `                 rottorque.log 输出, 可选   日志文件
  ` -mtx [<.mtx>] `                       nm.mtx 输出, 可选   Hessian矩阵
  ` -dn [<.ndx>] `                    dipole.ndx 输出, 可选   索引文件
  ` -swap [<.xvg>] `                swapions.xvg 输出, 可选   xvgr/xmgr文件
  ` -bo [<.trr/.cpt/...>] `            bench.trr 输出         全精度轨迹: trr cpt trj tng
  ` -bx [<.xtc>] `                     bench.xtc 输出         压缩轨迹(可移植xdr格式): xtc
  ` -bcpo [<.cpt>] `                   bench.cpt 输出         检查点文件
  ` -bc [<.gro/.g96/...>] `            bench.gro 输出         结构文件: gro g96 pdb brk ent esp
  ` -be [<.edr>] `                     bench.edr 输出         能量文件
  ` -bg [<.log>] `                     bench.log 输出         日志文件
  ` -beo [<.xvg>] `                 benchedo.xvg 输出, 可选   xvgr/xmgr文件
  ` -bdhdl [<.xvg>] `              benchdhdl.xvg 输出, 可选   xvgr/xmgr文件
  ` -bfield [<.xvg>] `              benchfld.xvg 输出, 可选   xvgr/xmgr文件
  ` -btpi [<.xvg>] `                benchtpi.xvg 输出, 可选   xvgr/xmgr文件
  ` -btpid [<.xvg>] `              benchtpid.xvg 输出, 可选   xvgr/xmgr文件
  ` -bdevout [<.xvg>] `             benchdev.xvg 输出, 可选   xvgr/xmgr文件
  ` -brunav [<.xvg>] `             benchrnav.xvg 输出, 可选   xvgr/xmgr文件
  ` -bpx [<.xvg>] `                  benchpx.xvg 输出, 可选   xvgr/xmgr文件
  ` -bpf [<.xvg>] `                  benchpf.xvg 输出, 可选   xvgr/xmgr文件
  ` -bro [<.xvg>] `                 benchrot.xvg 输出, 可选   xvgr/xmgr文件
  ` -bra [<.log>] `                benchrota.log 输出, 可选   日志文件
  ` -brs [<.log>] `                benchrots.log 输出, 可选   日志文件
  ` -brt [<.log>] `                benchrott.log 输出, 可选   日志文件
  ` -bmtx [<.mtx>] `                  benchn.mtx 输出, 可选   Hessian矩阵
  ` -bdn [<.ndx>] `                    bench.ndx 输出, 可选   索引文件
  ` -bswap [<.xvg>] `               benchswp.xvg 输出, 可选   xvgr/xmgr文件

  : 输入/输出文件选项 {#tab-173}

-------------------------------------------------------------------------------------------------
  选项                                     默认值 说明
----------------------- ----------------------- -------------------------------------------------
  ` -nice <int> `                               0 设置优先级

  ` -xvg <enum> `                         xmgrace xvg绘图格式: xmgrace, xmgr, none

  ` -np <int> `                                 1 运行测试的进程数(对单独的PME进行, 必须大于2)

  ` -npstring <enum> `                        -np 使用此字符串指定 ` $MPIRUN ` 的进程数: -np, -n,
                                                  none

  ` -ntmpi <int> `                              1 运行测试的MPI线程数(关闭MPI和mpirun)

  ` -r <int> `                                  2 每次测试的重复次数

  ` -max <real> `                             0.5 要测试的PME进程数的最大比例

  ` -min <real> `                            0.25 要测试的PME进程数的最小比例

  ` -npme <enum> `                           auto 在 ` -min ` 和 ` -max ` 之间, 对 ` -npme `
                                                  的所有可能值或其合理子集执行基准测试.\
                                                  ` auto ` 会忽略 ` -min ` 和 ` -max ` , 根据
                                                  ` .tpr ` 文件中 ` npme ` 推测一个值,
                                                  并由此选择一个合理的值. 可用选项: auto, all,
                                                  subset

  ` -fix <int> `                               -2 若此参数的值大于等于-1, 不改变PME进程的数目,
                                                  而是使用此固定值, 并只改变 ` rcoulomb `
                                                  和PME格点间距.

  ` -rmax <real> `                              0 若此参数的值大于0, 对 ` -ntpr ` \>1使用的最大
                                                  ` rcoulomb ` (增大 ` rcoulomb `
                                                  会导致傅立叶格点减小)

  ` -rmin <real> `                              0 若此参数的值大于0, 对 ` -ntpr ` \>1使用的最小
                                                  ` rcoulomb `

  ` -[no]scalevdw `                           yes 与 ` rcoulomb ` 一起, 缩放 ` rvdw `

  ` -ntpr <int> `                               0 基准测试的 ` .tpr ` 文件的数目. 创建这么多文件,
                                                  每个文件使用的库仑缩放因子不同, 并取决于
                                                  ` -rmin ` 和 ` -rmax ` 参数.\
                                                  若此值\<1, 会自动选择 ` .tpr `
                                                  文件的数目进行测试.

  ` -steps <int> `                           1000 在基准测试运行中, 对这么多步进行计时.

  ` -resetstep <int> `                        100 开始计时前,
                                                  让dlb平衡这么多步(在这么多步之后重置循环计数器)

  ` -nsteps <int> `                            -1 如果该参数值非负, 在实际模拟中执行这么多步(覆盖
                                                  ` .tpr ` 文件中的 ` nsteps ` , 添加 ` .cpt `
                                                  中的步数)

  ` -[no]launch `                              no 优化后启动实际模拟

  ` -[no]bench `                              yes 运行基准测试还是仅仅创建输入的 ` .tpr ` 文件

  ` -[no]check `                              yes 基准测试运行前, 检查 ` mdrun ` 是否可以并行

  ` -[no]append `                             yes 当从检查点继续运行时,
                                                  输出将追加到之前的输出文件中,
                                                  而不是将模拟的部分编号添加到所有文件名称中(仅与
                                                  ` -launch ` 同用)

  ` -[no]cpnum `                               no 保留检查点文件并对其进行编号(仅与 ` -launch `
                                                  同用)
  -------------------------------------------------------------------------------------------------

  : 控制选项 {#tab-174}

### 补充说明(吕康杰)

这个命令使用时实际有两个分支, 按进程运行, 按线程运行:

` -np 8 `{.language-plaintext .highlighter-rouge} 实际会变成
` mpirun -np 8 `{.language-plaintext .highlighter-rouge} 放到最前面,
` -nmpi 8 `{.language-plaintext .highlighter-rouge} 直接就是
` -nmpi 8 `{.language-plaintext .highlighter-rouge} , 然后才调节
` npme `{.language-plaintext .highlighter-rouge} 的数目变化.

虽然原理上明白了, 但我尝试了依然只有gmx 2016的
` nmpi `{.language-plaintext .highlighter-rouge} 运行成功,
` np `{.language-plaintext .highlighter-rouge} 的任务, 单独用
` mpirun `{.language-plaintext .highlighter-rouge} 都可以运行,
` tune_pme `{.language-plaintext .highlighter-rouge} 里面还是用不了.

## gmx vanhove: 计算Van Hove位移及相关函数

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx vanhove [-f [<.xtc/.trr/...>]] [-s [<.tpr/.tpb/...>]] [-n [<.ndx>]]
            [-om [<.xpm>]] [-or [<.xvg>]] [-ot [<.xvg>]] [-nice ]
            [-b ] [-e ] [-dt ] [-[no]w] [-xvg ]
            [-sqrt ] [-fm ] [-rmax ] [-rbin ]
            [-mmax ] [-nlevels ] [-nr ] [-fr ]
            [-rt ] [-ft ]
```
:::
:::

` gmx vanhove `{.language-plaintext .highlighter-rouge} 用于计算Van
Hove相关函数G(r,t), 它表示在0时刻处于r_0的粒子在t时刻位于r_0+r处的概率.
` gmx vanhove `{.language-plaintext .highlighter-rouge}
是以向量r的长度而不是r来确定G, 因此给出了粒子在时间t内移动距离r的概率.
计算时会移除对周期性边界的跨越,
并会对因各项同性或各项异性压力耦合导致缩放进行校正.

使用选项 ` -om `{.language-plaintext .highlighter-rouge}
可输出整个矩阵与t和r的函数关系, 或与sqrt(t)和r的函数关系(选项
` -sqrt `{.language-plaintext .highlighter-rouge} )

使用选项 ` -or `{.language-plaintext .highlighter-rouge}
可输出一个或多个t值的Van Hove函数. 选项 ` -nr `{.language-plaintext
.highlighter-rouge} 用以设置时间数, 选项 ` -fr `{.language-plaintext
.highlighter-rouge} 设置时间之间的间隔. 分格宽度可用选项
` -rbin `{.language-plaintext .highlighter-rouge} 设置.
分格数目自动确定.

使用选项 ` -ot `{.language-plaintext .highlighter-rouge}
可输出函数到某一距离(选项 ` -rt `{.language-plaintext
.highlighter-rouge} 指定)的积分与时间的函数关系.

对所有读入的帧, 所选粒子的坐标放于在内存中, 因此程序可能会占用大量内存.
使用选项 ` -om `{.language-plaintext .highlighter-rouge} 和
` -ot `{.language-plaintext .highlighter-rouge} 时程序可能会变得很慢,
这是因为计算标度为帧数与 ` -fm `{.language-plaintext .highlighter-rouge}
或 ` -ft `{.language-plaintext .highlighter-rouge} 的乘积. 需要注意的是,
使用 ` -dt `{.language-plaintext .highlighter-rouge}
选项可以减少内存使用量和计算时间.

  选项                                默认值 类型         说明
-------------------------- --------------- ------------ ------------------------------------------------
  ` -f [<.xtc/.trr/...>] `          traj.xtc 输入         轨迹: xtc trr cpt trj gro g96 pdb tng
  ` -s [<.tpr/.tpb/...>] `         topol.tpr 输入         结构+质量(db): tpr tpb tpa gro g96 pdb brk ent
  ` -n [<.ndx>] `                  index.ndx 输入, 可选   索引文件
  ` -om [<.xpm>] `               vanhove.xpm 输出, 可选   X PixMap兼容矩阵文件
  ` -or [<.xvg>] `             vanhove_r.xvg 输出, 可选   xvgr/xmgr文件
  ` -ot [<.xvg>] `             vanhove_t.xvg 输出, 可选   xvgr/xmgr文件

  : 输入/输出文件选项 {#tab-175}

  选项                    默认值 说明
-------------------- --------- -----------------------------------------------------------------
  ` -nice `                   19 设置优先级
  ` -b `                       0 从轨迹文件中读取的第一帧(ps)
  ` -e `                       0 从轨迹文件中读取的最后一帧(ps)
  ` -dt `                      0 只使用t除以dt的余数等于第一帧时间(ps)的帧, 即两帧之间的时间间隔
  ` -[no]w `                  no 查看输出.xvg, .xpm, .eps and .pdb文件
  ` -xvg <enum> `        xmgrace xvg绘图格式: xmgrace, xmgr, none
  ` -sqrt <real> `             0 矩阵轴使用sqrt(t), 分格间距数以sqrt(ps)为单位
  ` -fm <int> `                0 矩阵中的帧数, 0表示输出所有帧
  ` -rmax <real> `             2 矩阵中最大r(nm)
  ` -rbin <real> `          0.01 矩阵和 ` -or ` 的分格宽度(nm)
  ` -mmax <real> `             0 矩阵的最大密度, 0表示使用计算值(1/nm)
  ` -nlevels <int> `          81 矩阵的水平数
  ` -nr <int> `                1 ` -or ` 输出的曲线数目
  ` -fr <int> `                0 ` -or ` 输出的帧间距
  ` -rt <real> `               0 ` -ot ` 输出的积分上限(nm)
  ` -ft <int> `                0 ` -ot ` 输出的帧数, 0表示使用所有帧

  : 控制选项 {#tab-176}

## gmx velacc: 计算速度自相关函数

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx velacc [-f [<.trr/.cpt/...>]] [-s [<.tpr/.tpb/...>]] [-n [<.ndx>]]
           [-o [<.xvg>]] [-os [<.xvg>]] [-nice ] [-b ] [-e ]
           [-dt ] [-[no]w] [-xvg ] [-[no]m] [-[no]recip]
           [-[no]mol] [-acflen ] [-[no]normalize] [-P ]
           [-fitfn ] [-beginfit ] [-endfit ]
```
:::
:::

` gmx velacc `{.language-plaintext .highlighter-rouge}
用于计算速度自相关函数. 当使用 ` -m `{.language-plaintext
.highlighter-rouge} 选项时, 可以计算动量自相关函数.

使用 ` -mol `{.language-plaintext .highlighter-rouge} 选项,
可计算分子的速度自相关函数. 在这种情况下, 索引组应由分子编号组成,
而不是原子编号.

请确保你的轨迹包含具有速度信息的帧(即, 原始的
` .mdp `{.language-plaintext .highlighter-rouge} 文件中应设置了
` nstvout `{.language-plaintext .highlighter-rouge} ),
数据采集点之间的时间间隔远远短于自相关的时间尺度.

  选项                               默认值 类型         说明
-------------------------- -------------- ------------ ------------------------------------------------
  ` -f [<.trr/.cpt/...>] `         traj.trr 输入         全精度轨迹: trr cpt trj tng
  ` -s [<.tpr/.tpb/...>] `        topol.tpr 输入, 可选   结构+质量(db): tpr tpb tpa gro g96 pdb brk ent
  ` -o [<.xvg>] `                   vac.xvg 输出         xvgr/xmgr文件
  ` -os [<.xvg>] `             spectrum.xvg 输出, 可选   xvgr/xmgr文件

  : 输入/输出文件选项 {#tab-177}

  选项                      默认值 说明
---------------------- --------- ------------------------------------------------------------------
  ` -nice `                     19 设置优先级
  ` -b `                         0 从轨迹文件中读取的第一帧(ps)
  ` -e `                         0 从轨迹文件中读取的最后一帧(ps)
  ` -dt `                        0 只使用t除以dt的余数等于第一帧时间(ps)的帧, 即两帧之间的时间间隔
  ` -[no]w `                    no 查看输出.xvg, .xpm, .eps and .pdb文件
  ` -xvg <enum> `          xmgrace xvg绘图格式: xmgrace, xmgr, none
  ` -[no]m `                    no 计算动量自相关函数
  ` -[no]recip `               yes 在谱图中, x轴使用cm\^-1为单位, 而不是1/ps
  ` -[no]mol `                  no 计算分子的速度自相关函数
  ` -acflen <int> `             -1 ACF的长度, 默认为帧数的一半
  ` -[no]normalize `           yes 归一化ACF
  ` -P <enum> `                  0 ACF Legendre多项式的阶数(0表示不使用): 0, 1, 2, 3
  ` -fitfn <enum> `           none 拟合函数: none, exp, aexp, exp_exp, vac, exp5, exp7, exp9, erfit
  ` -beginfit <real> `           0 对相关函数进行指数拟合的起始时间
  ` -endfit <real> `            -1 对相关函数进行指数拟合的终止时间, -1表示直到最后

  : 控制选项 {#tab-178}

## gmx view: 在X-Windows终端显示轨迹

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx view [-f [<.xtc/.trr/...>]] [-s [<.tpr/.tpb/...>]] [-n [<.ndx>]]
         [-nice ] [-b ] [-e ] [-dt ]
```
:::
:::

` gmx view `{.language-plaintext .highlighter-rouge}
是GROMACS的轨迹查看器. 该程序可以读取一个轨迹文件,
运行输入文件和索引文件, 并在标准的X Windows屏幕上绘制分子的三维结构图.
此程序不需要高级的图形工作站, 它甚至可以在单色屏幕下工作.

此程序已经实现了以下功能: 3D视图, 旋转, 平移和缩放分子, 标记原子,
轨迹动画, 以PostScript格式复制, 在MIT-X(real X)下用户可自定义原子过滤器,
打开窗口和主题, 用户友好的菜单, 去除周期性的选项, 显示计算盒子的选项.

可以使用一些更常见的X命令行选项: ` -bg `{.language-plaintext
.highlighter-rouge} , ` -fg `{.language-plaintext .highlighter-rouge}
更改颜色; ` -font fontname `{.language-plaintext .highlighter-rouge}
更改字体.

  选项                            默认值 类型         说明
-------------------------- ----------- ------------ ---------------------------------------
  ` -f [<.xtc/.trr/...>] `      traj.xtc 输入         轨迹: xtc trr cpt trj gro g96 pdb tng
  ` -s [<.tpr/.tpb/...>] `     topol.tpr 输入         运行输入文件: tpr tpb tpa
  ` -n [<.ndx>] `              index.ndx 输入, 可选   索引文件

  : 输入/输出文件选项 {#tab-179}

  选项                默认值 说明
----------------- -------- -----------------------------------------------------------------
  ` -nice <int> `          0 设置优先级
  ` -b <time> `            0 从轨迹文件中读取的第一帧(ps)
  ` -e <time> `            0 从轨迹文件中读取的最后一帧(ps)
  ` -dt <time> `           0 只使用t除以dt的余数等于第一帧时间(ps)的帧, 即两帧之间的时间间隔

  : 控制选项 {#tab-180}

### 已知问题

-   Balls选项暂时不可用
-   有时候会吐核, 原因不明

## gmx wham: 伞形抽样后进行加权直方分析

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx wham [-ix [<.dat>]] [-if [<.dat>]] [-it [<.dat>]] [-ip [<.dat>]]
         [-is [<.dat>]] [-o [<.xvg>]] [-hist [<.xvg>]] [-oiact [<.xvg>]]
         [-iiact [<.dat>]] [-bsres [<.xvg>]] [-bsprof [<.xvg>]]
         [-tab [<.dat>]] [-nice ] [-xvg ] [-min ]
         [-max ] [-[no]auto] [-bins ] [-temp ] [-tol ]
         [-[no]v] [-b ] [-e ] [-dt ] [-[no]histonly]
         [-[no]boundsonly] [-[no]log] [-unit ] [-zprof0 ]
         [-[no]cycl] [-[no]sym] [-[no]ac] [-acsig ]
         [-ac-trestart ] [-nBootstrap ] [-bs-method ]
         [-bs-tau ] [-bs-seed ] [-histbs-block ] [-[no]vbs]
```
:::
:::

` gmx wham `{.language-plaintext .highlighter-rouge}
一个用于实现加权直方图分析方法(WHAM, Weighted Histogram Analysis
Method)的分析程序, 用于分析伞形抽样模拟的输出文件以计算平均力势(PMF,
potential of mean force).

目前此程序支持三种输入模式:

-   使用选项 ` -it `{.language-plaintext .highlighter-rouge} ,
    用户需要提供一个文件, 其中包含伞形抽样模拟的运行输入文件(
    ` .tpr `{.language-plaintext .highlighter-rouge} 文件)的文件名,
    **还要** 使用选项 ` -ix `{.language-plaintext .highlighter-rouge}
    提供另一个文件, 其中包含pullx ` mdrun `{.language-plaintext
    .highlighter-rouge} 输出文件的文件名. ` .tpr `{.language-plaintext
    .highlighter-rouge} 文件和pullx文件的顺序必须对应, 即第一个
    ` .tpr `{.language-plaintext .highlighter-rouge}
    文件生成了第一个pullx文件, 并以此类推.

-   除用户使用选项 ` -if `{.language-plaintext .highlighter-rouge}
    提供牵引力输出文件名称( ` pullf.xvg `{.language-plaintext
    .highlighter-rouge} )以外, 与前述输入模式相同.
    伞形势中的位置由牵引力计算得到. 无法用于表格形式的伞形势.

-   使用选项 ` -ip `{.language-plaintext .highlighter-rouge} ,
    用户需提供(gzip压缩的) ` .pdo `{.language-plaintext
    .highlighter-rouge} 文件的文件名, 即GROMACS 3.3的伞形输出文件.
    如果你使用某些特殊的反应坐标, 你也可以生成自己的
    ` .pdo `{.language-plaintext .highlighter-rouge} 文件并使用
    ` -ip `{.language-plaintext .highlighter-rouge} 选项将其提供给
    ` gmx wham `{.language-plaintext .highlighter-rouge} .
    ` .pdo `{.language-plaintext .highlighter-rouge}
    文件的文件头必须类似于以下形式:

    ::: {.language-plaintext .highlighter-rouge}
    ::: highlight
    ``` highlight
      # UMBRELLA 3.0
      # Component selection: 0 0 1
      # nSkip 1
      # Ref. Group 'TestAtom'
      # Nr. of pull groups 2
      # Group 1 'GR1' Umb. Pos. 5.0 Umb. Cons. 1000.0
      # Group 2 'GR2' Umb. Pos. 2.0 Umb. Cons. 500.0
      #####
    ```
    :::
    :::

牵引组(pull group)的个数, 伞形势位置(umbrella position), 力常数(force
constant)和名称(当然)都可以不同. 文件头以下,
需要为每个牵引组提供一个时间列和一个数据列(即相对于伞形势中心的位移).
目前每个 ` .pdo `{.language-plaintext .highlighter-rouge}
文件最多可以包含四个牵引组.

默认情况下, 在WHAM中会使用所有pullx/pullf文件中找到的所有牵引组.
如果只使用其中的某些牵引组, 用户可以提供一个牵引组选择文件(使用选项
` -is `{.language-plaintext .highlighter-rouge} ). 选择文件必须为
` tpr-files.dat `{.language-plaintext .highlighter-rouge} 中的每个
` .tpr `{.language-plaintext .highlighter-rouge} 文件提供一行说明,
内容必须为相应于 ` .tpr `{.language-plaintext .highlighter-rouge}
文件中每个牵引组的一位数字(0或1). 在这里1表示该牵引组会在WHAM中使用,
0表示忽略. 例如, 如果你有3个 ` .tpr `{.language-plaintext
.highlighter-rouge} 文件, 每个包含4个牵引组, 但只使用牵引组1和2, 则
` groupsel.dat `{.language-plaintext .highlighter-rouge} 文件内容如下:

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
1 1 0 0
1 1 0 0
1 1 0 0
```
:::
:::

默认情况下, 输出文件有:

` -o `{.language-plaintext .highlighter-rouge} : PMF输出文件

` -hist `{.language-plaintext .highlighter-rouge} : 直方图输出文件

请注意, 始终要检查直方图是否充分重叠.

程序假定伞形势为简谐势, 力常数从 ` .tpr `{.language-plaintext
.highlighter-rouge} 或 ` .pdo `{.language-plaintext .highlighter-rouge}
文件中读取. 如果使用了非简谐的伞形力, 可以用
` -tab `{.language-plaintext .highlighter-rouge}
提供一个表格式的势能函数.

**WHAM选项**

` -bins `{.language-plaintext .highlighter-rouge} : 分析中使用的分格数

` -temp `{.language-plaintext .highlighter-rouge} : 模拟温度

` -tol `{.language-plaintext .highlighter-rouge} :
剖面(概率)的变化小于所给容差时停止迭代

` -auto `{.language-plaintext .highlighter-rouge} : 自动决定边界

` -min `{.language-plaintext .highlighter-rouge} ,
` -max `{.language-plaintext .highlighter-rouge} : 剖面的边界

可以使用选项 ` -b `{.language-plaintext .highlighter-rouge} ,
` -e `{.language-plaintext .highlighter-rouge} 和
` -dt `{.language-plaintext .highlighter-rouge}
筛选用于计算剖面的数据点. 调整 ` -b `{.language-plaintext
.highlighter-rouge} 以保证每个伞形窗口都达到充分平衡.

使用选项 ` -log `{.language-plaintext .highlighter-rouge} 时(默认),
会以能量单位输出剖面, 否则(使用 ` -nolog `{.language-plaintext
.highlighter-rouge} 选项)会输出概率. 可以使用选项
` -unit `{.language-plaintext .highlighter-rouge} 指定单位.
以能量单位输出时, 第一分格中的能量定义为零.
如果你希望其他位置自由能为零, 可以设置 ` -zprof0 `{.language-plaintext
.highlighter-rouge} (在使用自展法时很有用, 见下文).

对于环形或周期性的反应坐标(二面角, 无渗透梯度的通道PMF), 选项
` -cycl `{.language-plaintext .highlighter-rouge} 很有用.
` gmx wham `{.language-plaintext .highlighter-rouge} 会利用体系的周期性,
生成一个周期性的PMF. 反应坐标的第一个和最后一个分格会被假定为相邻.

使用选项 ` -sym `{.language-plaintext .highlighter-rouge} 时,
在输出前会使剖面关于z=0对称, 在某些情况下, 如用于膜体系时很有用.

**自相关**

使用 ` -ac `{.language-plaintext .highlighter-rouge} 选项时,
` gmx wham `{.language-plaintext .highlighter-rouge}
会估计每个伞形窗口的积分自相关时间(IACT, integrated autocorrelation
time)τ, 并使用1/\[1+2\*τ/dt\]作为各个窗口的权重. IACT会写入由选项
` -oiact `{.language-plaintext .highlighter-rouge} 指定的文件中.
在冗长(verbose)输出模式下, 所有自相关函数(ACF, autocorrelation
functions)都会写入 ` hist_autocorr.xvg `{.language-plaintext
.highlighter-rouge} 文件. 由于在采样不足的情况下可能会严重低估IACT, 利用
` -acsig `{.language-plaintext .highlighter-rouge} 选项,
用户可使用高斯函数沿反应坐标对IACT进行平滑(高斯函数的σ由
` -acsig `{.language-plaintext .highlighter-rouge} 提供, 见
` iact.xvg `{.language-plaintext .highlighter-rouge} 中的输出). 注意,
程序使用简单的积分方法估计IACT, 且只考虑大于0.05的ACF.
如果你想使用更复杂(但可能不那么稳健)的方法, 比如拟合到双指数函数,
来计算IACT, 你可以使用 ` gmx analyze `{.language-plaintext
.highlighter-rouge} 来计算IACT, 并通过
` iact-in.dat `{.language-plaintext .highlighter-rouge} 文件(选项
` -iiact `{.language-plaintext .highlighter-rouge} )将其提供给
` gmx wham `{.language-plaintext .highlighter-rouge} .
在这个文件中每个输入文件( ` .pdo `{.language-plaintext
.highlighter-rouge} 或pullx/f文件)对应一行,
各输入文件的每个牵引组对应一列.

**误差分析**

可以使用自展分析(bootstrap analysis)来估计统计误差. 请小心使用,
否则实质上可能会低估统计误差. 自展技术的更多背景知识和例子可以在Hub, de
Groot and Van der Spoel, JCTC (2010) 6: 3713-3720中找到.

` -nBootstrap `{.language-plaintext .highlighter-rouge}
定义自展的个数(比如使用100). 本程序支持四种自展方法, 通过
` -bs-method `{.language-plaintext .highlighter-rouge} 进行选择.

\(1\) ` b-hist `{.language-plaintext .highlighter-rouge} 默认方法:
将完整的直方图视为独立的数据点,
给直方图赋予随机权重来实现自展("贝叶斯自展"). 注意,
沿反应坐标轴上的每个点都必须被多个独立直方图所覆盖(比如10个直方图),
否则会低估统计误差.

\(2\) ` hist `{.language-plaintext .highlighter-rouge} :
将完整的直方图视为独立的数据点. 对每个自展,
从给定的N个直方图中随机选取N个直方图(允许重复, 即, 放回抽样).
为避免沿反应坐标轴上无数据的空隙, 可以定义直方图块(
` -histbs-block `{.language-plaintext .highlighter-rouge} ).
在那种情况下, 会将给定的直方图划分为块, 只有各块内部的直方图才会混合.
注意, 每块内的直方图必须能代表所有可能出现的直方图, 否则会低估统计误差.

\(3\) ` traj `{.language-plaintext .highlighter-rouge} :
用给定的直方图产生新的随机轨迹, 这样产生的数据点遵从给定直方图的分布,
并具有适当的自相关. 每个窗口的自相关时间(ACT)必须是已知的, 所以要使用
` -ac `{.language-plaintext .highlighter-rouge} 选项或者利用
` -iiact `{.language-plaintext .highlighter-rouge} 手动提供ACT.
如果所有窗口的ACT都相同(并且已知), 你也可以用
` -bs-tau `{.language-plaintext .highlighter-rouge} 提供ACT. 注意,
在采样不足的情况下, 即如果各个直方图在各自的位置不能代表整个相空间,
此方法可能严重低估误差.

\(4\) ` traj-gauss `{.language-plaintext .highlighter-rouge} : 与
` traj `{.language-plaintext .highlighter-rouge} 方法相同,
但轨迹不是根据伞形直方图自展得到,
而是从均值和宽度与伞形直方图相同的高斯函数得到.
此方法给出的误差估计类似于 ` traj `{.language-plaintext
.highlighter-rouge} 方法.

自展法的输出:

` -bsres `{.language-plaintext .highlighter-rouge} : 平均剖面和标准偏差

` -bsprof `{.language-plaintext .highlighter-rouge} : 所有自展剖面

使用 ` -vbs `{.language-plaintext .highlighter-rouge}
选项(冗长自展)会输出每个自展使用的直方图, 并且, 使用
` traj `{.language-plaintext .highlighter-rouge} 自展方法时,
还会输出直方图的累积分布函数.

  选项                              默认值 类型         说明
---------------------- ----------------- ------------ ----------------
  ` -ix [<.dat>] `         pullx-files.dat 输入, 可选   通用数据文件
  ` -if [<.dat>] `         pullf-files.dat 输入, 可选   通用数据文件
  ` -it [<.dat>] `           tpr-files.dat 输入, 可选   通用数据文件
  ` -ip [<.dat>] `           pdo-files.dat 输入, 可选   通用数据文件
  ` -is [<.dat>] `            groupsel.dat 输入, 可选   通用数据文件
  ` -o [<.xvg>] `              profile.xvg 输出         xvgr/xmgr 文件
  ` -hist [<.xvg>] `             histo.xvg 输出         xvgr/xmgr文件
  ` -oiact [<.xvg>] `             iact.xvg 输出, 可选   xvgr/xmgr文件
  ` -iiact [<.dat>] `          iact-in.dat 输入, 可选   通用数据文件
  ` -bsres [<.xvg>] `         bsResult.xvg 输出, 可选   xvgr/xmgr文件
  ` -bsprof [<.xvg>] `         bsProfs.xvg 输出, 可选   xvgr/xmgr文件
  ` -tab [<.dat>] `            umb-pot.dat 输入, 可选   通用数据文件

  : 输入/输出文件选项 {#tab-181}

  选项                         默认值 说明
------------------------- --------- ----------------------------------------------------------------------
  ` -nice <int> `                  19 设置优先级
  ` -xvg <enum> `             xmgrace xvg绘图格式: xmgrace, xmgr, none
  ` -min <real> `                   0 剖面的最小坐标
  ` -max <real> `                   0 剖面的最大坐标
  ` -[no]auto `                   yes 自动确定min和max
  ` -bins <int> `                 200 剖面使用的分格数
  ` -temp <real> `                298 温度
  ` -tol <real> `               1e-06 容差
  ` -[no]v `                       no 冗长模式
  ` -b <real> `                    50 要分析的起始时间(ps)
  ` -e <real> `                 1e+20 要分析的终止时间(ps)
  ` -dt <real> `                    0 每隔dt ps分析一次
  ` -[no]histonly `                no 输出直方图即退出
  ` -[no]boundsonly `              no 确定min和max后即退出(使用 ` -auto ` 选项)
  ` -[no]log `                    yes 计算剖面的对数值后再打印
  ` -unit <enum> `                 kJ 对数输出时的能量单位: kJ, kCal, kT
  ` -zprof0 <real> `                0 将此位置的剖面值定义为0.0(使用 ` -log ` 选项)
  ` -[no]cycl `                    no 产生环形/周期性的剖面. 假定min和max是同一点.
  ` -[no]sym `                     no 使剖面关于z=0对称
  ` -[no]ac `                      no 计算积分自相关时间并在wham中使用
  ` -acsig <real> `                 0 沿反应坐标轴, 使用以选项值为σ的高斯函数对自相关时间进行平滑
  ` -ac-trestart <real> `           1 计算自相关函数时, 不同数据点之间的间隔ps数
  ` -nBootstrap <int> `             0 自展的个数, 用以估计统计不确定性(如, 200)
  ` -bs-method <enum> `        b-hist 自展方法: b-hist, hist, traj, traj-gauss
  ` -bs-tau <real> `                0 假定适用于所有直方图的自相关时间(ACT). 如果ACT未知, 使用选项 ` -ac `
  ` -bs-seed <int> `               -1 自展的种子(-1表示使用时间值)
  ` -histbs-block <int> `           8 混合直方图时, 仅混合在 ` -histbs-block ` 指定块内的直方图.
  ` -[no]vbs `                     no 冗长自展. 输出每个自展的CDF和直方图文件.

  : 控制选项 {#tab-182}

## gmx wheel: 绘制螺旋轮图

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx wheel [-f [<.dat>]] [-o [<.eps>]] [-nice ] [-r0 ]
          [-rot0 ] [-T ] [-[no]nn]
```
:::
:::

` gmx wheel `{.language-plaintext .highlighter-rouge}
用于绘制指定序列的螺旋轮示意图. 输入序列来自于
` .dat `{.language-plaintext .highlighter-rouge} 文件,
其中的第一行为残基的总数目, 接下来的每一行包含一个残基名称.

  选项                    默认值 类型   说明
----------------- ------------ ------ -------------------------
  ` -f [<.dat>] `     nnnice.dat 输入   通用数据文件
  ` -o [<.eps>] `       plot.eps 输出   封装PostScript (tm)文件

  : 输入/输出文件选项 {#tab-183}

  选项                 默认值 说明
------------------ -------- --------------------------------------------------
  ` -nice <int> `          19 指定优先级
  ` -r0 <int> `             1 序列中的第一个残基编号
  ` -rot0 <real> `          0 旋转的初始角度(90度即可)
  ` -T <string> `             旋轮中心的文字(必须小于10个字符, 否则会覆盖旋轮)
  ` -[no]nn `             yes 是否显示编号

  : 控制选项 {#tab-184}

## gmx x2top: 根据坐标生成原始拓扑文件

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx x2top [-f [<.gro/.g96/...>]] [-o [<.top>]] [-r [<.rtp>]] [-nice ]
          [-ff ] [-[no]v] [-nexcl ] [-[no]H14] [-[no]alldih]
          [-[no]remdih] [-[no]pairs] [-name ] [-[no]pbc] [-[no]pdbq]
          [-[no]param] [-[no]round] [-kb ] [-kt ] [-kp ]
```
:::
:::

` gmx x2top `{.language-plaintext .highlighter-rouge}
可以根据坐标文件生成原始的拓扑文件.
当根据原子名称和键的数目定义杂化状态时,
程序会假定所有的氢原子都出现在构型中. 这个程序也可以生成
` .rtp `{.language-plaintext .highlighter-rouge} 文件中的条目,
你可以将它们添加到力场目录下的 ` .rtp `{.language-plaintext
.highlighter-rouge} 数据库中.

当设置了 ` -param `{.language-plaintext .highlighter-rouge} 选项的时候,
所有相互作用的平衡距离, 键角和力常数都会写入拓扑中的相应位置.
平衡距离和键角由输入坐标得到, 力常数根据命令行选项设定.
目前支持的力场主要有以下几类:

-   G53a5: GROMOS96 53a5力场(官方发布)
-   oplsaa: OPLS-AA/L 全原子力场(2001氨基酸二面角版本)

使用 ` gmx x2top `{.language-plaintext .highlighter-rouge}
时需要一个对应的 ` .n2t `{.language-plaintext .highlighter-rouge} 文件,
它位于力场库目录下, 名称为 ` atomname2type.n2t `{.language-plaintext
.highlighter-rouge} . 该文件的格式在手册的第五章有详细介绍. 默认情况下,
力场的选择是交互式的, 但可以使用 ` -ff `{.language-plaintext
.highlighter-rouge} 选项在命令行中指定上面力场的简短名称. 在这种情况下,
` gmx x2top `{.language-plaintext .highlighter-rouge}
会到指定的力场目录下查找对应的文件.

  选项                           默认值 类型         说明
-------------------------- ---------- ------------ -----------------------------------------------
  ` -f [<.gro/.g96/...>] `     conf.gro 输入         结构文件: gro g96 pdb brk ent esp tpr tpb tpa
  ` -o [<.top>] `               out.top 输出, 可选   输出拓扑文件
  ` -r [<.rtp>] `               out.rtp 输出, 可选   pdb2gmx使用的残基类型文件

  : 输入/输出文件选项 {#tab-185}

  选项                   默认值 说明
-------------------- -------- ---------------------------------------------------------------------------
  ` -nice <int> `             0 设置优先级
  ` -ff <string> `       oplsaa 模拟使用的力场, 默认OPLS-AA力场. 键入 ` select ` 以交互式的进行选择
  ` -[no]v `                 no 在 ` top ` 文件中输出详细的生成信息
  ` -nexcl <int> `            3 相互作用排除数
  ` -[no]H14 `              yes 对氢原子使用第3个近邻相互作用
  ` -[no]alldih `            no 生成所有恰当二面角
  ` -[no]remdih `            no 去除同一键上的不当二面角
  ` -[no]pairs `            yes 在拓扑文件中输出1-4相互作用(原子对)
  ` -name <string> `        ICE 指定分子名称, 默认使用ICE
  ` -[no]pbc `              yes 使用周期性边界条件
  ` -[no]pdbq `              no 使用 ` .pdb ` 文件提供的B因子作为原子电荷(前提是输入文件格式为 ` .pdb ` )
  ` -[no]param `            yes 将参数输出到拓扑文件中
  ` -[no]round `            yes 将测量值进行四舍五入
  ` -kb <real> `         400000 键的力常数, 单位kJ/mol/nm\^2\^
  ` -kt <real> `            400 键角的力常数, 单位kJ/mol/rad\^2\^
  ` -kp <real> `              5 二面角的力常数, 单位kJ/mol/rad\^2\^

  : 控制选项 {#tab-186}

### 已知问题

-   原子类型的选择方法很原始, 没有使用化学信息.
-   周期性边界条件会卷曲键
-   不会生成不当二面角
-   原子到原子类型的转换表不完整(数据目录下的
    ` atomname2type.n2t `{.language-plaintext .highlighter-rouge} 文件).
    请扩展此文件并将其提供给GROMACS团队.

### 补充说明

理论上只要能在对应的力场中找到构型中的各个原子类型, 那么
` gmx x2top `{.language-plaintext .highlighter-rouge}
可以支持所有GROMACS的力场. 当然输出的原始拓扑文件需要进行很多修改,
因此在使用此工具需要对拓扑文件足够熟悉.

## gmx xpm2ps: 将XPM(XPixelMap)矩阵转换为postscript或XPM

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
gmx xpm2ps [-f [<.xpm>]] [-f2 [<.xpm>]] [-di [<.m2p>]] [-do [<.m2p>]]
           [-o [<.eps>]] [-xpm [<.xpm>]] [-nice ] [-[no]w] [-[no]frame]
           [-title ] [-[no]yonce] [-legend ] [-diag ]
           [-size ] [-bx ] [-by ] [-rainbow ]
           [-gradient ] [-skip ] [-[no]zeroline]
           [-legoffset ] [-combine ] [-cmin ] [-cmax ]
```
:::
:::

` gmx xpm2ps `{.language-plaintext .highlighter-rouge}
能够将XPM(XPixelMap)矩阵文件转换为漂亮的颜色映射图.
只要提供了正确的矩阵格式, 还可以显示标签和坐标轴.
矩阵数据可以通过一些程序得到, 如 ` gmx do_dssp `{.language-plaintext
.highlighter-rouge} , ` gmx rms `{.language-plaintext
.highlighter-rouge} 或 ` gmx mdmat `{.language-plaintext
.highlighter-rouge} .

可以选择性的使用 ` -di `{.language-plaintext .highlighter-rouge}
选项提供 ` .m2p `{.language-plaintext .highlighter-rouge} 文件,
里面包含了设定的参数, 并提供了合理的默认值. Y轴的默认设置与X轴相同.
字体名称的默认等级为: 标题字体 -\> 图例字体; 标题字体 -\> (x字体 -\>
y字体 -\> y刻度字体) -\> x刻度字体, 例如,
设置标题字体相当于设置了所有字体, 设置x轴字体相对于设置了y轴字体,
y刻度字体和x刻度字体.

未提供 ` .m2p `{.language-plaintext .highlighter-rouge} 文件时,
可以通过命令行选项设定多数设置. 其中最重要的选项是
` -size `{.language-plaintext .highlighter-rouge} ,
它以postscript的单位设定了整个矩阵的大小. 此选项也可以使用
` -bx `{.language-plaintext .highlighter-rouge} 和
` -by `{.language-plaintext .highlighter-rouge} 选项(以及
` .m2p `{.language-plaintext .highlighter-rouge} 文件中的相应参数)覆盖,
它们设定了单个矩阵元素的大小.

使用 ` -f2 `{.language-plaintext .highlighter-rouge}
选项可以提供第二个矩阵文件. 程序会同时读取两个矩阵文件,
并绘制出第一个矩阵( ` -f `{.language-plaintext .highlighter-rouge}
)的左上半部分与第二个矩阵( ` -f2 `{.language-plaintext
.highlighter-rouge} )的右下半部分. 对角部分的值来自由
` -diag `{.language-plaintext .highlighter-rouge} 选项选择的矩阵文件.
将选项 ` -diag `{.language-plaintext .highlighter-rouge} 设置为
` none `{.language-plaintext .highlighter-rouge} 可以不显示对角线上的值.
在这种情况下, 会生成一个新的颜色映射图,
其中红和蓝的渐变色分别代表负值和正值.
如果两个矩阵的颜色代码和图例标签完全相同, 那么只会显示一个图例说明,
否则会显示两个分开的图例说明. 使用 ` -combine `{.language-plaintext
.highlighter-rouge} 选项可以选择另外的操作, 以将矩阵进行组合.
输出值的范围会自动设置为组合矩阵的实际范围, 但可以使用
` -cmin `{.language-plaintext .highlighter-rouge} 和
` -cmax `{.language-plaintext .highlighter-rouge} 选项来覆盖所用的范围.

` -title `{.language-plaintext .highlighter-rouge} 可设置为
` none `{.language-plaintext .highlighter-rouge} 以忽略标题, 或设置为
` ylabel `{.language-plaintext .highlighter-rouge}
以便在Y轴标签位置显示标题(平行于Y轴).

使用 ` -rainbow `{.language-plaintext .highlighter-rouge}
选项可以将暗色的灰度矩阵变成更吸引人的彩色图片.

使用 ` -xpm `{.language-plaintext .highlighter-rouge}
选项可以将溶合或彩虹映射的矩阵输出到XPixelMap文件.

  选项                     默认值 类型             说明
------------------- ----------- ---------------- --------------------------
  ` -f [<.xpm>] `        root.xpm 输入             XPixMap兼容的矩阵文件
  ` -f2 [<.xpm>] `      root2.xpm 输入, 可选       X PixMap兼容的矩阵文件
  ` -di [<.m2p>] `         ps.m2p 输入, 可选, 库   \`mat2ps\`的输入文件
  ` -do [<.m2p>] `        out.m2p 输出, 可选       \`mat2ps\`的输入文件
  ` -o [<.eps>] `        plot.eps 输出, 可选       封装的PostScript(tm)文件
  ` -xpm [<.xpm>] `      root.xpm 输出, 可选       XPixMap兼容的矩阵文件

  : 输入/输出文件选项 {#tab-187}

  选项                       默认值 说明
------------------------ -------- --------------------------------------------------------------------
  ` -nice <int> `                 0 设置优先级
  ` -[no]w `                     no 程序结束自动打开输出的.xvg, .xpm, .eps和.pdb文件
  ` -[no]frame `                yes 显示帧, 刻度, 标签, 标题, 图例
  ` -title <enum> `             top 显示标题的位置: top, once, ylabel, none
  ` -[no]yonce `                 no y轴标签只显示一次
  ` -legend <enum> `           both 显示图例说明: both, first, second, none
  ` -diag <enum> `            first 对角元素: first, second, none
  ` -size <real> `              400 矩阵的水平尺寸, ps单位
  ` -bx <real> `                  0 元素的x大小, 覆盖 ` -size ` 选项(当未设置 ` -by ` 时还会覆盖y大小)
  ` -by <real> `                  0 元素的y大小
  ` -rainbow <enum> `            no 彩虹颜色, 将白色转成为: no, blue, red
  ` -gradient <vector> `      0 0 0 将颜色映射重新标度为平滑的渐变, 从白色{1,1,1}到{r,g,b}
  ` -skip <int> `                 1 每nr行和nr列输出一次
  ` -[no]zeroline `              no 在 ` .xpm ` 矩阵中坐标轴标签为零的位置插入一条线
  ` -legoffset <int> `            0 对图例, 忽略 ` .xpm ` 文件中的前N个颜色
  ` -combine <enum> `        halves 组合两个矩阵: halves, add, sub, mult, div
  ` -cmin <real> `                0 组合输出的最小值
  ` -cmax <real> `                0 组合输出的最大值

  : 控制选项 {#tab-188}

### 补充说明

The m2p file format contains input options for the xpm2ps program. All
of these options are very easy to comprehend when you look at the
PosScript(tm) output from xpm2ps.

::: {.language-plaintext .highlighter-rouge}
::: highlight
``` highlight
; Command line options of xpm2ps override the parameters in this file
black&white              = no           ; Obsolete
titlefont                = Times-Roman  ; A PostScript Font
titlefontsize            = 20           ; Font size (pt)
legend                   = yes          ; Show the legend
legendfont               = Times-Roman  ; A PostScript Font
legendlabel              =              ; Used when there is none in the .xpm
legend2label             =              ; Used when merging two xpm's
legendfontsize           = 14           ; Font size (pt)
xbox                     = 2.0          ; x-size of a matrix element
ybox                     = 2.0          ; y-size of a matrix element
matrixspacing            = 20.0         ; Space between 2 matrices
xoffset                  = 0.0          ; Between matrix and bounding box
yoffset                  = 0.0          ; Between matrix and bounding box
x-major                  = 20           ; Major ticks on x axis every .. frames
x-minor                  = 5            ; Id. Minor ticks
x-firstmajor             = 0            ; First frame for major tick
x-majorat0               = no           ; Major tick at first frame
x-majorticklen           = 8.0          ; x-majorticklength
x-minorticklen           = 4.0          ; x-minorticklength
x-label                  =              ; Used when there is none in the .xpm
x-fontsize               = 16           ; Font size (pt)
x-font                   = Times-Roman  ; A PostScript Font
x-tickfontsize           = 10           ; Font size (pt)
x-tickfont               = Helvetica    ; A PostScript Font
y-major                  = 20
y-minor                  = 5
y-firstmajor             = 0
y-majorat0               = no
y-majorticklen           = 8.0
y-minorticklen           = 4.0
y-label                  =
y-fontsize               = 16
y-font                   = Times-Roman
y-tickfontsize           = 10
y-tickfont               = Helvetica
```





Building Biphasic Systems  

##  GROMACS Tutorial

###  Building Biphasic Systems

**Justin A. Lemkul, Ph.D.**  

![](./Images/biphasic.png)  

The purpose of this tutorial is to guide the user through the process of
building a heterogeneous biphasic system composed of hydrophobic (cyclohexane)
and hydrophilic (water) layers. Several other types of systems will be
discussed. The scope of the tutorial is simply in building these systems.
Details will not be given for simulation methodology, as there are numerous
other tutorials that describe such workflows.

This tutorial is designed to be compatible with any GROMACS version in the
2018.x series.

  
  
  
  
---  
  

 
Building Biphasic Systems  

##  GROMACS Tutorial

**Step One: Prepare the Hydrophobic Layer**

The hydrophobic layer that will be generated in this tutorial will be composed
of cyclohexane, modeled under the GROMOS96 43A1 force field. Use your favorite
molecule-editing software to obtain a coordinate file. The topology is
straightforward to produce, but can be generated from online servers like , if
you prefer. Be sure to assign zero charges to all the united CH  2  atoms,
rather than use the partial charges that PRODRG gives you. To save time, you
can download my cylohexane and .

There are two ways to construct the box. Method 1 randomly inserts molecules
into a box of a given size, and Method 2 builds a grid of molecules in
specified dimensions. Both methods are presented here.

** Method 1. Random Insertion  **

You can use the insert-molecules module to insert molecules randomly into a
box of fixed size. For instance, to build a 5-nm cubic box filled with
cyclohexane, issue:

    
    
    gmx insert-molecules -ci chx.gro -nmol 1200 -box 5 5 5 -o chx_box.gro
    

The value passed to the -nmol flag is somewhat arbitrary. You can set some
large number, and insert-molecules will fit as many of those molecules into
the box as possible. You are advised to try several (increasing) numbers to
ensure that you are actually filling the box. Once the number of added
molecules converges, you know you have added as many as possible. With the
above command, I obtained a box with 1114 cyclohexane molecules. This was the
procedure used in one of our recent .

** Method 2. Specific Insertion  **

If you prefer a less haphazard way of building your box, you can use the
genconf module to build a grid of molecules in specified dimensions. The
advantage of Method 1 is that there is less artificial order in the system,
speeding up equilibration. The advantage of Method 2 is that you have somewhat
more control of how many molecules are added, and you know exactly where they
will be. Issue the following:

    
    
    gmx genconf -f chx.gro -nbox 8 8 8 -o chx_box.gro
    

This command will give you an output box containing 512 (8  3  ) cyclohexane
molecules. It is not necessary to provide identical numbers in the and
dimensions. You can build rectangular slabs of arbitrary size. For the
purposes of this tutorial, however, a cubic box will suffice.

At this point, you should simulate the cyclohexane box such that its density
stabilizes. Following steepest descent minimization, 100 ps each of (298 K)
and equilibration (298 K, 1 bar), I was able to obtain a reasonable density
with an additional 10 ns of simulation under these same conditions. My
equilibrated box (obtained from Method 1 above) can be downloaded .

|  |  
---|---  
  

 
Building Biphasic Systems  

##  GROMACS Tutorial

**Step Two: Add Water to Construct**

Placing two layers of solvent relative to one another is a simple matter of
using the editconf module. We will define a unit cell of desired dimensions
and place the cyclohexane layer at a specific location within it. Once
satisfied with the placement, we can fill the rest of the box with water.

Following the equilibration of my 466-molecule cyclohexane layer, the box
dimensions were 4.30795 nm in each dimension. The goal of this exercise will
be to build the biphasic system such that it has a water layer of equivalent
size. Thus, we will keep the and dimensions fixed, and double the system size
in . The trick here is that if we define such a box for our cyclohexane
system, editconf will automatically center the cyclohexane layer in it. While
not incorrect (since, because of periodicity, the proper interfaces will still
form), such a position is not advantageous if we want to add, for example, a
small protein or peptide into the water layer. A divided layer will not easily
allow us to do this.

Fortunately, editconf allows us to manually specify a center for our system.
Since we want to keep the cyclohexane layer essentially in the same place
while we just increase the box, we will specify a system center at (x/2, y/2,
z/4), which is normal centering within the original box (x/2, y/2, z/2), since
GROMACS builds all boxes from the coordinate origin.

    
    
    gmx editconf -f chx_10ns.gro -o chx_newbox.gro -box 4.30795 4.30795 8.6159 -center 2.153975 2.153975 2.153975
    

We now have a system aligned in the following way:

![](./Images/chx_box.png)

Now, the only remaining task is to solvate the empty space with water. This is
easily done with solvate:

    
    
    gmx solvate -cp chx_newbox.gro -cs spc216.gro -p chx.top -o chx_solv.gro
    

The solvate module will place some water molecules within the cyclohexane
layer, so make a copy of the file ` vdwradii.dat ` (normally in ) in your
working directory. Change the value of the C radius from 0.17 to 0.35 and run
solvate again. There may be a few stray water molecules still in the
cyclohexane layer but these will come out during equilibration. Do not be
concerned with water molecules that appear at the "bottom" of the box, as
these will be part of the continuous solvent layer across the periodic
boundary in the plane.

|  |  
---|---  
  

 
Building Biphasic Systems  

##  GROMACS Tutorial

**Final Notes: Tips & Tricks **

**Adding a Protein to the Aqueous Layer**

Interested in how a protein or peptide might interact with such a biphasic
system? The same principles as before apply to positioning the protein: place
the protein in the unit cell of desired dimensions, and manually set its
center. For our system, we can assign a generic peptide to a position in the
"top" half of the box with editconf like so:

    
    
    gmx editconf -f peptide.gro -o peptide_newbox.gro -box 4.30795 4.30795 8.6159 -center 2.153975 2.153975 6.461925
    

The assigned position for the protein center is three-quarters of the box
length (original cyclohexane box plus one-half).

How do we place that protein in the same unit cell as our cyclohexane layer?
We could use the Unix comand ` cat ` , but then there's internal cleanup to do
(removal of unnecessary lines, counting numbers of atoms, etc). All of that is
pretty easy, but why do several steps when we can just do one? What we can do
is actually use chx_newbox.gro as a solvent. It has the same dimensions as the
box in which we have positioned our fictional peptide, so it should assemble
quite nicely:

    
    
    gmx solvate -cp peptide_newbox.gro -cs chx_newbox.gro -o peptide_chx.gro
    

Using the KALP  15  peptide from the , the system would look something like
this:

![](./Images/peptide_chx.png)

Then proceed with another round of solvate to add water, as before. Energy-
minimize, equilibrate, and simulate.

** Expanding the Box  **

Let's say your protein is too large for a box that is only ~4.3 nm in the
plane. It is possible to expand your system simply by using genconf:

    
    
    gmx genconf -f chx_10ns.gro -nbox 2 2 2 -o chx_bigbox.gro
    

The above command will create a new, 8.6-nm cube of cyclohexane with 8 times
the number of molecules in it. Again, it is not necessary to create a cube.
Then follow all the steps outlined previously for positioning this new, larger
layer in a box, adding whatever protein or solute you desire, and filling the
box with water.

In lieu of a new, cubic box, an expanded layer can be created along the plane
with a slightly different command:

    
    
    gmx genconf -f chx_10ns.gro -nbox 2 2 1 -o chx_biglayer.gro
    

** Summary  **

You have now built a biphasic cyclohexane-water system, and hopefully
understand the basic principles of how to place any arbitrary molecule into
such a system in a desired location.

If you have suggestions for improving this tutorial, if you notice a mistake,
or if anything is otherwise unclear, please feel free to . Please note: this
is not an invitation to email me for GROMACS problems. I do not advertise
myself as a private tutor or personal help service. That's what the is for. I
may help you there, but only in the context of providing service to the
community as a whole, not just the end user.

Happy simulating!

|  |  
---|---  
  

 
Building Biphasic Systems  

##  GROMACS Tutorial

###  Building Biphasic Systems

**Justin A. Lemkul, Ph.D.**  

![](./Images/biphasic.png)  

The purpose of this tutorial is to guide the user through the process of
building a heterogeneous biphasic system composed of hydrophobic (cyclohexane)
and hydrophilic (water) layers. Several other types of systems will be
discussed. The scope of the tutorial is simply in building these systems.
Details will not be given for simulation methodology, as there are numerous
other tutorials that describe such workflows.

This tutorial is designed to be compatible with any GROMACS version in the
2018.x series.

  
  
  
  
---  
  

 
Building Biphasic Systems  

##  GROMACS Tutorial

**Step One: Prepare the Hydrophobic Layer**

The hydrophobic layer that will be generated in this tutorial will be composed
of cyclohexane, modeled under the GROMOS96 43A1 force field. Use your favorite
molecule-editing software to obtain a coordinate file. The topology is
straightforward to produce, but can be generated from online servers like , if
you prefer. Be sure to assign zero charges to all the united CH  2  atoms,
rather than use the partial charges that PRODRG gives you. To save time, you
can download my cylohexane and .

There are two ways to construct the box. Method 1 randomly inserts molecules
into a box of a given size, and Method 2 builds a grid of molecules in
specified dimensions. Both methods are presented here.

** Method 1. Random Insertion  **

You can use the insert-molecules module to insert molecules randomly into a
box of fixed size. For instance, to build a 5-nm cubic box filled with
cyclohexane, issue:

    
    
    gmx insert-molecules -ci chx.gro -nmol 1200 -box 5 5 5 -o chx_box.gro
    

The value passed to the -nmol flag is somewhat arbitrary. You can set some
large number, and insert-molecules will fit as many of those molecules into
the box as possible. You are advised to try several (increasing) numbers to
ensure that you are actually filling the box. Once the number of added
molecules converges, you know you have added as many as possible. With the
above command, I obtained a box with 1114 cyclohexane molecules. This was the
procedure used in one of our recent .

** Method 2. Specific Insertion  **

If you prefer a less haphazard way of building your box, you can use the
genconf module to build a grid of molecules in specified dimensions. The
advantage of Method 1 is that there is less artificial order in the system,
speeding up equilibration. The advantage of Method 2 is that you have somewhat
more control of how many molecules are added, and you know exactly where they
will be. Issue the following:

    
    
    gmx genconf -f chx.gro -nbox 8 8 8 -o chx_box.gro
    

This command will give you an output box containing 512 (8  3  ) cyclohexane
molecules. It is not necessary to provide identical numbers in the and
dimensions. You can build rectangular slabs of arbitrary size. For the
purposes of this tutorial, however, a cubic box will suffice.

At this point, you should simulate the cyclohexane box such that its density
stabilizes. Following steepest descent minimization, 100 ps each of (298 K)
and equilibration (298 K, 1 bar), I was able to obtain a reasonable density
with an additional 10 ns of simulation under these same conditions. My
equilibrated box (obtained from Method 1 above) can be downloaded .

|  |  
---|---  
  

 
Building Biphasic Systems  

##  GROMACS Tutorial

**Step Two: Add Water to Construct**

Placing two layers of solvent relative to one another is a simple matter of
using the editconf module. We will define a unit cell of desired dimensions
and place the cyclohexane layer at a specific location within it. Once
satisfied with the placement, we can fill the rest of the box with water.

Following the equilibration of my 466-molecule cyclohexane layer, the box
dimensions were 4.30795 nm in each dimension. The goal of this exercise will
be to build the biphasic system such that it has a water layer of equivalent
size. Thus, we will keep the and dimensions fixed, and double the system size
in . The trick here is that if we define such a box for our cyclohexane
system, editconf will automatically center the cyclohexane layer in it. While
not incorrect (since, because of periodicity, the proper interfaces will still
form), such a position is not advantageous if we want to add, for example, a
small protein or peptide into the water layer. A divided layer will not easily
allow us to do this.

Fortunately, editconf allows us to manually specify a center for our system.
Since we want to keep the cyclohexane layer essentially in the same place
while we just increase the box, we will specify a system center at (x/2, y/2,
z/4), which is normal centering within the original box (x/2, y/2, z/2), since
GROMACS builds all boxes from the coordinate origin.

    
    
    gmx editconf -f chx_10ns.gro -o chx_newbox.gro -box 4.30795 4.30795 8.6159 -center 2.153975 2.153975 2.153975
    

We now have a system aligned in the following way:

![](./Images/chx_box.png)

Now, the only remaining task is to solvate the empty space with water. This is
easily done with solvate:

    
    
    gmx solvate -cp chx_newbox.gro -cs spc216.gro -p chx.top -o chx_solv.gro
    

The solvate module will place some water molecules within the cyclohexane
layer, so make a copy of the file ` vdwradii.dat ` (normally in ) in your
working directory. Change the value of the C radius from 0.17 to 0.35 and run
solvate again. There may be a few stray water molecules still in the
cyclohexane layer but these will come out during equilibration. Do not be
concerned with water molecules that appear at the "bottom" of the box, as
these will be part of the continuous solvent layer across the periodic
boundary in the plane.

|  |  
---|---  
  

 
Building Biphasic Systems  

##  GROMACS Tutorial

**Final Notes: Tips & Tricks **

**Adding a Protein to the Aqueous Layer**

Interested in how a protein or peptide might interact with such a biphasic
system? The same principles as before apply to positioning the protein: place
the protein in the unit cell of desired dimensions, and manually set its
center. For our system, we can assign a generic peptide to a position in the
"top" half of the box with editconf like so:

    
    
    gmx editconf -f peptide.gro -o peptide_newbox.gro -box 4.30795 4.30795 8.6159 -center 2.153975 2.153975 6.461925
    

The assigned position for the protein center is three-quarters of the box
length (original cyclohexane box plus one-half).

How do we place that protein in the same unit cell as our cyclohexane layer?
We could use the Unix comand ` cat ` , but then there's internal cleanup to do
(removal of unnecessary lines, counting numbers of atoms, etc). All of that is
pretty easy, but why do several steps when we can just do one? What we can do
is actually use chx_newbox.gro as a solvent. It has the same dimensions as the
box in which we have positioned our fictional peptide, so it should assemble
quite nicely:

    
    
    gmx solvate -cp peptide_newbox.gro -cs chx_newbox.gro -o peptide_chx.gro
    

Using the KALP  15  peptide from the , the system would look something like
this:

![](./Images/peptide_chx.png)

Then proceed with another round of solvate to add water, as before. Energy-
minimize, equilibrate, and simulate.

** Expanding the Box  **

Let's say your protein is too large for a box that is only ~4.3 nm in the
plane. It is possible to expand your system simply by using genconf:

    
    
    gmx genconf -f chx_10ns.gro -nbox 2 2 2 -o chx_bigbox.gro
    

The above command will create a new, 8.6-nm cube of cyclohexane with 8 times
the number of molecules in it. Again, it is not necessary to create a cube.
Then follow all the steps outlined previously for positioning this new, larger
layer in a box, adding whatever protein or solute you desire, and filling the
box with water.

In lieu of a new, cubic box, an expanded layer can be created along the plane
with a slightly different command:

    
    
    gmx genconf -f chx_10ns.gro -nbox 2 2 1 -o chx_biglayer.gro
    

** Summary  **

You have now built a biphasic cyclohexane-water system, and hopefully
understand the basic principles of how to place any arbitrary molecule into
such a system in a desired location.

If you have suggestions for improving this tutorial, if you notice a mistake,
or if anything is otherwise unclear, please feel free to . Please note: this
is not an invitation to email me for GROMACS problems. I do not advertise
myself as a private tutor or personal help service. That's what the is for. I
may help you there, but only in the context of providing service to the
community as a whole, not just the end user.

Happy simulating!

|  |  
---|---  
  

 
Building Biphasic Systems  

##  GROMACS Tutorial

###  Building Biphasic Systems

**Justin A. Lemkul, Ph.D.**  

! 

Virtual Sites  

##  GROMACS Tutorial

###  Virtual Sites

**Justin A. Lemkul, Ph.D.**  

![](./Images/CO2_CPK_2.png)  

This example will guide a new user through the process of building a linear
molecule using virtual sites. The tutorial assumes the user is familiar with
basic GROMACS workflows and topology organization.

This tutorial assumes you are using GROMACS version in the 2018.x series.
While some older versions may work, pre-4.5 versions of GROMACS _**will not
work** _ with the example shown here due to changes to the topology format and
nomenclature.

  
  
  
---  
  

 
Virtual Sites  

##  GROMACS Tutorial

**Step One: Introduction**

This tutorial assumes that the reader is familiar with the concept of virtual
sites and all the information contained in the GROMACS manual, sections 4.7
and 5.2.2. If not, please familiarize yourself with this information. In this
tutorial, instructions will be provided to build a simple linear molecule,
carbon dioxide (CO  2  ). One cannot effectively build this molecule in the
traditional sense, as there are algorithmic reasons why an angle of 180° is
not stable during a simulation.

To summarize a few key points regarding virtual sites:

  1. Virtual sites have no mass 
  2. Virtual sites can have LJ and charge interactions 
  3. Forces acting on virtual sites are projected onto constructing mass centers 
  4. The positions of virtual sites are not updated via integration, they are constructed from the updated positions of the mass centers 

Therefore, we approach this issue in the following way. The CO  2  molecule
will be constructed from two massive atoms with no charges or van der Waals
parameters. The C and O atoms are converted to virtual sites, with their
positions constructed from the positions of the massive atoms.

There are a few things to be considered when constructing a molecule in this
way:

  1. The molecule must have the same mass as if it were constructed of normal atoms 
  2. The molecule must have the same moment of inertia as if it were constructed of normal atoms 

These issues will be addressed when considering the topology.

|  |  
---|---  
  

 
Virtual Sites  

##  GROMACS Tutorial

**Step Two: Construct the Topology**

In contrast to a normal GROMACS workflow, in this example we will not invoke
pdb2gmx to build the topology. It will be constructed completely by hand using
a simple text editor. The force field chosen for this exercise is OPLS-AA. The
topology can be downloaded . In this step, we will examine its contents to
explain the logic behind its construction. The corresponding coordinate file
for a single CO  2  molecule can be downloaded .

First, we consider the distribution of mass in the molecule. Two mass centers
are used to desribe the complete mass of the CO  2  molecule. From the
topology, it can be seen how the total mass of the molecule was calculated in
order to be redistributed between the two mass centers.

    
    
    ; Moment of inertia and total mass must be correct
    ; Mass is easy - virtual sites are 1/2 * mass(CO2)
    ;
    ; Total mass = (2 * 15.9994) + 12.011 = 44.0098 amu
    ;    each M particle has a mass of 22.0049 amu
    

The calculation for the moment of inertia is more difficult, but can be
calculated from basic equations. The moment of inertia for a linear molecule
consisting of three atoms (essentially a triatomic linear rotor) is:

![](./Images/triatomic_full.png)

The moment of inertia for a diatomic molecule is:

![](./Images/diatomic_full.png)

The value that is most straightforward to calculate first is the moment of
inertia for CO  2  , since we know all the quantities involved. The mass of an
oxygen atom in OPLS-AA is 15.9994 amu and the C=O bond length is 0.125 nm.
Substituting these values into the triatomic linear rotor moment of inertia
equation above (and ignoring SI units because we will just have to convert
back later), we obtain a value of 0.500 amu nm  2  . We can then solve the
diatomic molecule moment of inertia equation to obtain the separation of the
two mass centers. Using a mass of 22.0049 amu for each mass center, we obtain
a separation of 0.213173 nm for the distance between the mass centers. We set
this value as a constraint in the topology. We use a constraint rather than a
normal harmonic bond because (1) this value should remain invariant and (2) we
eliminate the need to define new bonded parameters in the force field.

Now that we know the separation of the mass centers that reproduces the moment
of inertia of our CO  2  molecule, we need to define the mechanism by which
the virtual C and O sites are to be constructed. Virtual sites can be
constructed in a linear fashion (using type 2 virtual site geometry and
defined in a ` [ virtual_sites2 ] ` directive) as a fraction of the distance
between two mass centers. In the topology, a value of is given, corresponding
to this fraction. The virtual site is then placed at a distance of from the
first of the two given reference atoms, where is the bond length between the
two atoms.

  
**Defining the position of carbon**

We begin with the easiest virtual site to place. The carbon atom is placed in
the center of the molecule, exactly in the middle of the two mass centers.
Thus in the topology, we define this site as occurring at a value of = 0.5 and
hence in the topology we define:

    
    
         2   4   5      1   0.5000      ; right in the middle
    

  
**Defining the positions of oxygens**

Constructing the positions of the oxygen virtual sites is more difficult.
These virtual sites do not occur between the two mass centers, rather they are
beyond the distance between atoms M1 and M2. Thus, the value of must be larger
than 1, such that the virtual site position is outside the M1--M2 length.
Since the value of is given as a fraction of the total length between the
relevant mass centers, we need to calculate its value. This calculation is
given in the topology. Briefly:

  1. The C=O bond length is 0.125 nm 
  2. The M1--M2 constraint length is 0.213173 nm, therefore half this distance is 0.1065865 nm 
  3. Therefore, the O virtual site extends 0.0184135 nm beyond the M1--M2 distance 
  4. Thus, the value of is (0.213173+0.0184135)/0.213173 = 1.0851116 

In the topology, there are two lines for these O virtual sites, relative to
each mass center, M1 (atom 4) and M2 (atom 5):

    
    
         1   4   5      1   1.0851116   ; relative to mass center 4, extends beyond mass center 5
         3   5   4      1   1.0851116   ; as in the case of site 1
    

|  |  
---|---  
  

 
Virtual Sites  

##  GROMACS Tutorial

**Step Three: Simple Simulations**

We will now generate a simple system to simulate. Create a simple box of CO  2
molecules using insert-molecules:

    
    
    gmx insert-molecules -ci co2.pdb -nmol 10 -box 10 10 10 -o box.pdb
    

We do this because if we attempt to simulate only a single molecule, there are
no degrees of freedom and the simulation is effectively conducted at 0 K, so
nothing moves. That's not very useful or effective at demonstrating that this
model works, so we work with a small test system. Now, update the ` [
molecules ] ` section of topol.top to reflect the fact that there are now 10
total CO  2  molecules in the system.

Run energy minimization using .

    
    
    gmx grompp -f em.mdp -c box.pdb -p topol.top -o em.tpr
    gmx mdrun -nt 1 -nb cpu -deffnm em 
    

The system is very small (50 particles) and thus it does not make sense to try
to parallelize the simulation, so only one thread is used.

Now run a short simulation on the system using .

    
    
    gmx grompp -f md.mdp -c em.gro -p topol.top -o md.tpr
    gmx mdrun -nt 1 -nb cpu -deffnm md
    

The CO  2  molecules float around in space, which is expected but not
particularly important. What is important to note is that the geometry of the
molecules is constructed correctly in each frame. Additionally, we can verify
that the moment of inertia of each molecule was correct using the principal
module. For ease of understanding, we can analyze each molecule separately:

    
    
    gmx make_ndx -f em.gro
    ...
     > splitres 0
     > q
    
    
    
    gmx principal -s md.tpr -f md.trr -n index.ndx
    (choose any molecule for analysis when prompted)
    

The output in moi.dat contains the moment of inertia along the , , and axes.
The moment of inertia along the axis of CO  2  (along the C=O bonds) is zero,
while the values of the moments of inertia along the and axes are
approximately 0.500, which is in perfect agreement with the value calculated
before when setting up the topology. Therefore, we conclude that this model of
CO  2  adequately reproduces the expected moment of inertia.  |  |  
---|---  
  
  

 
Virtual Sites  

##  GROMACS Tutorial

**Summary**

You have now succeeded in creating a custom topology for a linear molecule
using virtual sites and used a simple simulation to confirm that the moment of
inertia was reproduced correctly. This tutorial can serve as a basis for
creating topologies for other linear molecules or functional groups.

If you have suggestions for improving this tutorial, if you notice a mistake,
or if anything is otherwise unclear, please feel free to . Please note: this
is not an invitation to email me for GROMACS problems. I do not advertise
myself as a private tutor or personal help service. That's what the is for. I
may help you there, but only in the context of providing service to the
community as a whole, not just the end user.

Happy simulating!

|  |  
---|---  
  

 
Virtual Sites  

##  GROMACS Tutorial

###  Virtual Sites

**Justin A. Lemkul, Ph.D.**  

![](./Images/CO2_CPK_2.png)  

This example will guide a new user through the process of building a linear
molecule using virtual sites. The tutorial assumes the user is familiar with
basic GROMACS workflows and topology organization.

This tutorial assumes you are using GROMACS version in the 2018.x series.
While some older versions may work, pre-4.5 versions of GROMACS _**will not
work** _ with the example shown here due to changes to the topology format and
nomenclature.

  
  
  
---  
  

 
Virtual Sites  

##  GROMACS Tutorial

**Step One: Introduction**

This tutorial assumes that the reader is familiar with the concept of virtual
sites and all the information contained in the GROMACS manual, sections 4.7
and 5.2.2. If not, please familiarize yourself with this information. In this
tutorial, instructions will be provided to build a simple linear molecule,
carbon dioxide (CO  2  ). One cannot effectively build this molecule in the
traditional sense, as there are algorithmic reasons why an angle of 180° is
not stable during a simulation.

To summarize a few key points regarding virtual sites:

  1. Virtual sites have no mass 
  2. Virtual sites can have LJ and charge interactions 
  3. Forces acting on virtual sites are projected onto constructing mass centers 
  4. The positions of virtual sites are not updated via integration, they are constructed from the updated positions of the mass centers 

Therefore, we approach this issue in the following way. The CO  2  molecule
will be constructed from two massive atoms with no charges or van der Waals
parameters. The C and O atoms are converted to virtual sites, with their
positions constructed from the positions of the massive atoms.

There are a few things to be considered when constructing a molecule in this
way:

  1. The molecule must have the same mass as if it were constructed of normal atoms 
  2. The molecule must have the same moment of inertia as if it were constructed of normal atoms 

These issues will be addressed when considering the topology.

|  |  
---|---  
  

 
Virtual Sites  

##  GROMACS Tutorial

**Step Two: Construct the Topology**

In contrast to a normal GROMACS workflow, in this example we will not invoke
pdb2gmx to build the topology. It will be constructed completely by hand using
a simple text editor. The force field chosen for this exercise is OPLS-AA. The
topology can be downloaded . In this step, we will examine its contents to
explain the logic behind its construction. The corresponding coordinate file
for a single CO  2  molecule can be downloaded .

First, we consider the distribution of mass in the molecule. Two mass centers
are used to desribe the complete mass of the CO  2  molecule. From the
topology, it can be seen how the total mass of the molecule was calculated in
order to be redistributed between the two mass centers.

    
    
    ; Moment of inertia and total mass must be correct
    ; Mass is easy - virtual sites are 1/2 * mass(CO2)
    ;
    ; Total mass = (2 * 15.9994) + 12.011 = 44.0098 amu
    ;    each M particle has a mass of 22.0049 amu
    

The calculation for the moment of inertia is more difficult, but can be
calculated from basic equations. The moment of inertia for a linear molecule
consisting of three atoms (essentially a triatomic linear rotor) is:

![](./Images/triatomic_full.png)

The moment of inertia for a diatomic molecule is:

![](./Images/diatomic_full.png)

The value that is most straightforward to calculate first is the moment of
inertia for CO  2  , since we know all the quantities involved. The mass of an
oxygen atom in OPLS-AA is 15.9994 amu and the C=O bond length is 0.125 nm.
Substituting these values into the triatomic linear rotor moment of inertia
equation above (and ignoring SI units because we will just have to convert
back later), we obtain a value of 0.500 amu nm  2  . We can then solve the
diatomic molecule moment of inertia equation to obtain the separation of the
two mass centers. Using a mass of 22.0049 amu for each mass center, we obtain
a separation of 0.213173 nm for the distance between the mass centers. We set
this value as a constraint in the topology. We use a constraint rather than a
normal harmonic bond because (1) this value should remain invariant and (2) we
eliminate the need to define new bonded parameters in the force field.

Now that we know the separation of the mass centers that reproduces the moment
of inertia of our CO  2  molecule, we need to define the mechanism by which
the virtual C and O sites are to be constructed. Virtual sites can be
constructed in a linear fashion (using type 2 virtual site geometry and
defined in a ` [ virtual_sites2 ] ` directive) as a fraction of the distance
between two mass centers. In the topology, a value of is given, corresponding
to this fraction. The virtual site is then placed at a distance of from the
first of the two given reference atoms, where is the bond length between the
two atoms.

  
**Defining the position of carbon**

We begin with the easiest virtual site to place. The carbon atom is placed in
the center of the molecule, exactly in the middle of the two mass centers.
Thus in the topology, we define this site as occurring at a value of = 0.5 and
hence in the topology we define:

    
    
         2   4   5      1   0.5000      ; right in the middle
    

  
**Defining the positions of oxygens**

Constructing the positions of the oxygen virtual sites is more difficult.
These virtual sites do not occur between the two mass centers, rather they are
beyond the distance between atoms M1 and M2. Thus, the value of must be larger
than 1, such that the virtual site position is outside the M1--M2 length.
Since the value of is given as a fraction of the total length between the
relevant mass centers, we need to calculate its value. This calculation is
given in the topology. Briefly:

  1. The C=O bond length is 0.125 nm 
  2. The M1--M2 constraint length is 0.213173 nm, therefore half this distance is 0.1065865 nm 
  3. Therefore, the O virtual site extends 0.0184135 nm beyond the M1--M2 distance 
  4. Thus, the value of is (0.213173+0.0184135)/0.213173 = 1.0851116 

In the topology, there are two lines for these O virtual sites, relative to
each mass center, M1 (atom 4) and M2 (atom 5):

    
    
         1   4   5      1   1.0851116   ; relative to mass center 4, extends beyond mass center 5
         3   5   4      1   1.0851116   ; as in the case of site 1
    

|  |  
---|---  
  

 
Virtual Sites  

##  GROMACS Tutorial

**Step Three: Simple Simulations**

We will now generate a simple system to simulate. Create a simple box of CO  2
molecules using insert-molecules:

    
    
    gmx insert-molecules -ci co2.pdb -nmol 10 -box 10 10 10 -o box.pdb
    

We do this because if we attempt to simulate only a single molecule, there are
no degrees of freedom and the simulation is effectively conducted at 0 K, so
nothing moves. That's not very useful or effective at demonstrating that this
model works, so we work with a small test system. Now, update the ` [
molecules ] ` section of topol.top to reflect the fact that there are now 10
total CO  2  molecules in the system.

Run energy minimization using .

    
    
    gmx grompp -f em.mdp -c box.pdb -p topol.top -o em.tpr
    gmx mdrun -nt 1 -nb cpu -deffnm em 
    

The system is very small (50 particles) and thus it does not make sense to try
to parallelize the simulation, so only one thread is used.

Now run a short simulation on the system using .

    
    
    gmx grompp -f md.mdp -c em.gro -p topol.top -o md.tpr
    gmx mdrun -nt 1 -nb cpu -deffnm md
    

The CO  2  molecules float around in space, which is expected but not
particularly important. What is important to note is that the geometry of the
molecules is constructed correctly in each frame. Additionally, we can verify
that the moment of inertia of each molecule was correct using the principal
module. For ease of understanding, we can analyze each molecule separately:

    
    
    gmx make_ndx -f em.gro
    ...
     > splitres 0
     > q
    
    
    
    gmx principal -s md.tpr -f md.trr -n index.ndx
    (choose any molecule for analysis when prompted)
    

The output in moi.dat contains the moment of inertia along the , , and axes.
The moment of inertia along the axis of CO  2  (along the C=O bonds) is zero,
while the values of the moments of inertia along the and axes are
approximately 0.500, which is in perfect agreement with the value calculated
before when setting up the topology. Therefore, we conclude that this model of
CO  2  adequately reproduces the expected moment of inertia.  |  |  
---|---  
  
  

 
Virtual Sites  

##  GROMACS Tutorial

**Summary**

You have now succeeded in creating a custom topology for a linear molecule
using virtual sites and used a simple simulation to confirm that the moment of
inertia was reproduced correctly. This tutorial can serve as a basis for
creating topologies for other linear molecules or functional groups.

If you have suggestions for improving this tutorial, if you notice a mistake,
or if anything is otherwise unclear, please feel free to . Please note: this
is not an invitation to email me for GROMACS problems. I do not advertise
myself as a private tutor or personal help service. That's what the is for. I
may help you there, but only in the context of providing service to the
community as a whole, not just the end user.

Happy simulating!

|  |  
---|---  
  

 
Virtual Sites  

##  GROMACS Tutorial

###  Virtual Sites

**Justin A. Lemkul, Ph.D.**  

![](./Images/CO2_CPK_2.png)  

This example will guide a new user through the process of building a linear
molecule using virtual sites. The tutorial assumes the user is familiar with
basic GROMACS workflows and topology organization.

This tutorial assumes you are using  



Free Energy Calculations  

##  GROMACS Tutorial

###  Free Energy Calculations: Methane in Water

**Justin A. Lemkul, Ph.D.**  

![](./Images/system.png)  

This tutorial will guide the user through the process of calculating a simple
free energy change, the decoupling removal of van der Waals interactions
between neutral methane and a box of water. This quantity was previously
calculated by in a systematic evaluation of free energies of solvation of
amino acid side chains using different atomistic force fields.

This tutorial requires a GROMACS version in the 2018.x series.

  
  
  
  
  
---  
  

 
Free Energy Calculations  

##  GROMACS Tutorial

**Step One: Theory**

This tutorial will assume you have a reasonable understanding of what free
energy calculations are, the different types that exist, and the underlying
theory of the technique. It is neither practical nor possible to provide a
complete education here. Instead, I will focus this tutorial on practical
aspects of running free energy calculations in GROMACS, highlighting relevant
theoretical points as necessary throughout the tutorial. I will provide here a
list of useful papers for those who are new to free energy calculations. Do
not consider this list exhaustive. It should also not supplant proper study of
statistical mechanics and the many books and papers that have been written on
related topics.

  1. C. D. Christ, A. E. Mark, and W. F. van Gunsteren (2010) **31** : 1569-1582. 
  2. A. Pohorille, C. Jarzynski, and C. Chipot (2010) **114** : 10235-10253. 
  3. A. Villa and A. E. Mark (2002) **23** : 548-553. 

The objective of this tutorial is to reproduce the results of a very simple
system for which an accurate free energy estimate exists. The system of choice
(methane in water) is one dealt with by Shirts in a systematic study of force
fields and the free energies of hydration of amino acid side chain analogs.
The complete publication can be found . This tutorial will assume you have
read and understood the broader points of this paper.

Rather than use the thermodynamic integration approach for evaluating free
energy differences, the data analysis conducted here will utilize the GROMACS
"bar" module, which was introduced in GROMACS version 4.5 (and previously
called g_bar). It uses the Bennett Acceptance Ratio (BAR, hence the name of
the module) method for calculating free energy differences. The corresponding
paper for BAR can be found . Knowledge of this method is also assumed and will
not be discussed in great detail here.

Free energy calculations have a number of practical applications, of which
some of the more common ones include free energies of solvation/hydration and
free energy of binding for a small molecule to some larger receptor
biomolecule (usually a protein). Both of these procedures involve the need to
either add (introduce/couple) or remove (decouple/annihilate) the small
molecule of interest from the system and calculate the resulting free energy
change.

There are two types of nonbonded interactions that can be transformed during
free energy calculations, Coulombic and van der Waals interactions. Bonded
interactions can also be manipulated, but for simplicity, will not be
addressed here. For this tutorial, we will calculate the free energy of a very
simple process: turning off the Lennard-Jones interactions between the atomic
sites of a molecule of interest (in this case, methane) in water. This
quantity was calculated very precisely by Shirts and thus it is the quantity
we seek to reproduce here.

|  |  
---|---  
  
  

 
Free Energy Calculations  

##  GROMACS Tutorial

**Step Two: Examine the Topology**

Download the and for this system. These files were provided as part of David
Mobley's tutorial for this system (which is no longer online), and are the
original files (modified slightly for compatibility with recent GROMACS
versions) used by Michael Shirts in the paper referenced on the previous page.

The system contains a single molecule of methane (called "ALAB" in the
coordinate file, for the β-carbon of alanine) in a box of 596 TIP3P water
molecules. Looking into the topology, we find:

    
    
    ; Topology for methane in TIP3P
    
    #include "oplsaa.ff/forcefield.itp"
    
    [ moleculetype ]
    ; Name                       nrexcl
    Methane                      3
    
    [ atoms ]
    ;   nr       type  resnr residue  atom   cgnr     charge       mass  typeB    chargeB  massB
         1   opls_138      1   ALAB     CB      1      0.000       12.011   
         2   opls_140      1   ALAB    HB1      2      0.000       1.008   
         3   opls_140      1   ALAB    HB2      3      0.000       1.008   
         4   opls_140      1   ALAB    HB3      4      0.000       1.008   
         5   opls_140      1   ALAB    HB4      5      0.000       1.008   
    
    [ bonds ]
    ;  ai    aj funct            c0            c1            c2            c3
        1     2     1 
        1     3     1 
        1     4     1 
        1     5     1 
    
    [ angles ]
    ;  ai    aj    ak funct            c0            c1            c2            c3
        2     1     3     1 
        2     1     4     1 
        2     1     5     1 
        3     1     4     1 
        3     1     5     1 
        4     1     5     1 
    
    ; water topology
    #include "oplsaa.ff/tip3p.itp"
    
    [ system ]
    ; Name
    Methane in water
    
    [ molecules ]
    ; Compound             #mols
    Methane                1
    SOL                    596
    

You will note that all charges are set to zero. There is a practial reason
behind this setup. Normally, charge interactions between the solute and water
are turned off prior to the van der Waals terms. If charge interactions are
left on when Lennard-Jones terms are turned off, positive and negative charges
would be allowed to approach one another at infinitely close distances,
resulting in a very unstable system that would probably just blow up. The
procedure in this tutorial essentially assumes that charges have been properly
been turned off prior to this point, and we will be turning off only van der
Waals interactions between the solute and solvent.

Note that in previous versions of GROMACS, the contents of the ` typeB ` , `
chargeB ` , and ` massB ` headings had to correspond to a B-state of the
molecule. As of GROMACS version 4.0, topology modifications for simple
(de)couplings are no longer required (hooray!), but in the case of mutating
one molecule to another, wherein bonded and nonbonded terms may change, the
old-style modifications (the so-called "dual topology approach") would still
be required. The GROMACS manual, section 5.8.4, provides an example of such a
transformation.

|  |  
---|---  
  

 
Free Energy Calculations  

##  GROMACS Tutorial

**Step Three: The Workflow**

The free energy change of transforming a system from state A to state B, ΔG
AB  , is a function of a coupling parameter, λ, which indicates the level of
change that has taken place between states A and B, that is, the extent to
which the Hamiltonian has been perturbed and the system has been transformed.
Simulations conducted at different values of λ allow us to plot a ∂H/∂λ curve,
from which ΔG  AB  is derived. The first step in planning free energy
calculations is how many λ points will be used to describe the transformation
from state A (λ = 0) to state B (λ = 1), with the goal of collecting adequate
data to exhaustively sample phase space and produce a reliable ∂H/∂λ curve.

|  ![](./Images/lambda0.png) |  ![](./Images/lambda0.5.png) |
![](./Images/lambda1.png)  
---|---|---  
λ = 0  |  λ = 0.5  |  λ = 1  
  
For decoupling Coulombic interactions, which depend linearly upon λ, an
equidistant λ spacing from 0 to 1 should usually suffice, with λ spacing
values of of 0.05-0.1 being common. Note that this is a broad generalization,
and in fact many molecules will require a great deal more finesse, such as
those that interact very strongly with the surrounding environment through
hydrogen bonding. In this case, λ spacing may need to be decreased, such that
more points are used, perhaps even in an asymmetric fashion.

For decoupling van der Waals interactions, λ spacing can be much trickier. For
reasons described by Shirts and elsewhere, a great deal of λ points may be
necessary to properly describe the transformation. Clustering λ points in
regions where the slope of the ∂H/∂λ curve is steep may be necessary. For the
purposes of this tutorial, we will use equidistant λ spacing of 0.05, but in
many cases, one may need to use different spacing, especially clustering
values in the range of 0.6 ≤ λ ≤ 0.8.

For each value of λ, a complete workflow (energy minimization, equilibration,
and data collection) must be conducted. I generally find it most efficient to
run these jobs as batches, passing the output of one step directly into the
next. The workflow utilized here will be:

  1. Steepest descents minimization 
  2. equilibration 
  3. equilibration 
  4. Data collection under an ensemble 

The .mdp files for the different steps of the tutorial (for λ = 0 only) are
provided at the following links:

  *   *   *   * 

I am also making available an accessory Perl script, , that you can use to
very quickly produce all of the input files needed for running these
simulations.

You can also download a shell script ( ) for running these jobs according to
the workflow I will describe.

If you issue:

    
    
    perl write_mdp.pl em_steep.mdp
    

You will receive files named em_steep_0.mdp, em_steep_1.mdp, ...
em_steep_20.mdp, with the relevant values of init_lambda_state inserted into
the filename. Analogously, you can produce the rest of your .mdp files in the
same way (nvt.mdp, npt.mdp, and md.mdp).

In job.sh, you will need to change the values of ` $FREE_ENERGY ` and ` $MDP `
, otherwise the script certainly won't work.

  

###  Notes on .mdp settings

Before proceeding, it is important to understand the free energy-related
settings in the .mdp files (using em_steep_0.mdp as an example). They are the
same for all steps in the workflow. I will assume that you are familiar with
the other settings found in the .mdp file. If this is not the case, please
refer to some before proceeding.

* * *  
  
---  
free_energy = yes  |  Indicates that we are doing a free energy calculation,
and that interpolation between the A and B states of the chosen molecule
(defined below) will occur.  
  
* * *  
  
init_lambda_state = 0  |  In previous GROMACS versions, the "init_lambda"
keyword specified a single value of λ directly. Since version 5.0, λ is now a
vector that allows for transformation of bonded and nonbonded interactions.
With the init_lambda_state keyword, we specify an index (starting from zero)
of the vector to be utilized in the simulation (more on this later).  
  
* * *  
  
delta_lambda = 0  |  The value of λ can be incremented by some amount per
timestep (i.e., δλ/δt) in a technique called "slow growth." This method can
have significant errors associated with it, and thus we will make no time-
dependent changes to our λ values.  
  
* * *  
  
fep_lambdas = (nothing)  |  You will note that this keyword is not specified.
In previous GROMACS versions, the use of init_lambda and foreign_lambda
controlled the value of λ  i  and the additional values of λ for which energy
differences would be evaluated for configurations at λ  i  . This is no longer
the case. One can explicitly set values of λ in the fep_lambdas keyword, but
instead we allow the calc_lambda_neighbors keyword (see below) to
automatically determine these additional values.  
  
* * *  
  
calc_lambda_neighbors = 1  |  The number of neighboring windows for which
energy differences are computed with respect to λ  i  . For instance, if
init_lambda_state is set to 10, then energy differences with respect to λ
states 9 and 11 are computed during the run with calc_lambda_neighbors = 1.  
  
* * *  
  
vdw_lambdas = ...  |  An array of λ values for the transformation of van der
Waals interactions.  
  
* * *  
  
coul_lambdas = ...  |  An array of λ values for the transformation of
Coulombic (electrostatic) interactions.  
  
* * *  
  
bonded_lambdas = ...  |  An array of λ values for the transformation of bonded
interactions.  
  
* * *  
  
restraint_lambdas = ...  |  An array of λ values for the transformation of
restraints.  
  
* * *  
  
mass_lambdas = ...  |  An array of λ values for the transformation of atomic
masses; used if tranforming the chemical nature of the molecule.  
  
* * *  
  
temperature_lambdas = ...  |  An array of λ values for the transformation of
temperatures; used only for simulated tempering.  
  
* * *  
  
sc-alpha = 0.5  |  The value of the α scaling factor used in the "soft-core"
Lennard-Jones equation. See equations 4.124 - 4.126 in the GROMACS manual,
section 4.5.1, for a complete description of this term, as well as the next
three.  
  
* * *  
  
sc-coul = no  |  Transform Coulombic interactions linearly. This is the
default behavior, but is written out for clarity.  
  
* * *  
  
sc-power = 1.0  |  The power for λ in the soft-core equation.  
  
* * *  
  
sc-sigma = 0.3  |  The value of σ assigned to any atom types that have C6 or
C12 parameters equal to zero or σ < sc-sigma (typically H atoms). This value
is used in the soft-core Lennard-Jones equation.  
  
* * *  
  
couple-moltype = Methane  |  The name of the [moleculetype] in that will have
its topology interpolated from state A to state B. Note that the name given
here must match a [moleculetype] name, and not the residue name. In some cases
these may be the same, but I have maintained different names for the
[moleculetype] and component residue for instructive purposes.  
  
* * *  
  
couple-lambda0 = vdw  |  The types of nonbonded interactions that are present
in state A between the interpolated [moleculetype] and the remainder of the
system. The value "vdw" indicates that only van der Waals terms are active
between methane and water; there are no solute-solvent Coulombic interactions.  
  
* * *  
  
couple-lambda1 = none  |  The types of nonbonded interactions that are present
in state B between the interpolated [moleculetype] and the remainder of the
system. The value "none" indicates that both van der Waals and Coulombic
interactions are off in state B. Relative to couple-lambda0, this indicates
that only van der Waals terms have been turned off.  
  
* * *  
  
couple-intramol = no  |  Do not decouple intramolecular interactions. That is,
the λ factor is applied to only solute-solvent nonbonded interactions and not
solute-solute nonbonded interactions.  
  
Setting "couple-intramol = yes" is useful for larger molecules that may have
intramolecular interactions occuring at longer distance (e.g. peptides or
other polymers). Otherwise, distal parts of the molecule will interact via
explicit pair interactions in an unnaturally strong manner (since solute-
solvent interactions are weakened as a function of λ, but the intramolecular
terms would not be), giving rise to configurations that will incorrectly bias
the resulting free energy.  
  
* * *  
  
nstdhdl = 10  |  The frequency with which ∂H/∂λ and ΔH are written to
dhdl.xvg. A value of 100 would probably suffice, since the resulting values
will be highly correlated and the files will get very large. You may wish to
increase this value to 100 for your own work.  
  
* * *  
  
There are also several differences in the .mdp settings that will be used here
relative to the settings used by Shirts :

  1. rlist=rcoulomb=rvdw=1.2. In order to use PME, rlist must be equal to rcoulomb, a check that was enforced in grompp sometime after the release of version 3.3.1. The Verlet cutoff scheme introduced in version 4.6 that allows for buffered neighbor lists also requires rvdw=rcoulomb. The value of rlist will be tuned during the run for the purposes of energy conservation, thus providing the necessary buffer for the switched van der Waals interactions. The switching range (from 1.0-1.2 nm) agrees with the methods of Shirts for the treatment of solute-solvent interactions. 
  2. Temperature coupling is handled through the use of the Langevin integrator (the "sd" setting specifies "stochastic dynamics," e.g. with a random friction force), rather than an Andersen thermostat. 
  3. tau_t = 1.0. It is important to illustrate this particular value, because when using the Langevin integrator, this value corresponds to an inverse friction coefficient, therefore in ps  -1  . The value of 1.0 avoids over-damping the dynamics of water. 

Let us take a moment to dissect the λ vectors a bit more closely. As an
example, for init_lambda_state = 0, that means we are specifying that the
state in the transformation corresponds to the vector with index 0 in the
*_lambdas keywords, like so:

    
    
    ; init_lambda_state        0    1    2    3    4    5    6    7    8    9    10   11   12   13   14   15   16   17   18   19   20
    vdw_lambdas              = **0.00** 0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00
    coul_lambdas             = **0.00** 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00
    bonded_lambdas           = **0.00** 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00
    restraint_lambdas        = **0.00** 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00
    mass_lambdas             = **0.00** 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00
    temperature_lambdas      = **0.00** 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00
    

Setting initial_lambda_state = 1 would correspond to the next column to the
right (λ for van der Waals = 0.05), while initial_lambda_state = 20 would
specify the final column (λ vector), in which the value of λ for van der Waals
= 1.0. For the purposes of this tutorial, we are only transforming van der
Waals interactions, leaving everything related to charges, bonded parameters,
restraints, etc. alone. **Please note** that, in this example, where charges
are zero in the topology and the .mdp settings never indicate that charges
should be present (neither couple-lambda0 nor couple-lambda1 include 'q'), the
choice of values for coul_lambdas is irrelevant, but for the sake of being
pedantic, the .mdp files make clear that no charge transformation is taking
place.

|  
---|---  
  
  

 
Free Energy Calculations  

##  GROMACS Tutorial

**Step Four: Energy Minimization**

The job.sh script I provide for running these calculations will create the
following directory hierarchy:

    
    
    Lambda_0/
    Lambda_0/EM/
    Lambda_0/NVT/
    Lambda_0/NPT/
    Lambda_0/Production_MD/
    

This way, all steps in the workflow are executed within a single directory for
each value of init_lambda_state. I find this to be a convenient way to
organize the jobs and their output.

The script also assumes that the .mdp files are also organized hierarchically
within some directory ` $MDP ` , which is set as an environment variable in
the script:

    
    
    $MDP/
    $MDP/EM/
    $MDP/NVT/
    $MDP/NPT/
    $MDP/Production_MD/
    

As described before, energy minimization will be conducted using the steepest
descent method. The relevant section in the job.sh script is:

    
    
    mkdir Lambda_$LAMBDA
    cd Lambda_$LAMBDA
    
    #################################
    # ENERGY MINIMIZATION 1: STEEP  #
    #################################
    echo "Starting minimization for lambda = $LAMBDA..."
    
    mkdir EM
    cd EM
    
    # Iterative calls to grompp and mdrun to run the simulations
    
    gmx grompp -f $MDP/em_steep_$LAMBDA.mdp -c $FREE_ENERGY/methane_water.gro 
    -p $FREE_ENERGY/topol.top -o min$LAMBDA.tpr
    
    gmx mdrun -deffnm min$LAMBDA
    
    echo "Minimization complete."
    

|  |  
---|---  
  

 
Free Energy Calculations  

##  GROMACS Tutorial

**Step Five: Equilibration**

The system will be equilibrated in two phases, the first at constant volume (
), the second at constant pressure ( ).

    
    
    #####################
    # NVT EQUILIBRATION #
    #####################
    echo "Starting constant volume equilibration..."
    
    cd ../
    mkdir NVT
    cd NVT
    
    gmx grompp -f $MDP/nvt_$LAMBDA.mdp -c ../EM/min$LAMBDA.gro 
    -p $FREE_ENERGY/topol.top -o nvt$LAMBDA.tpr
    
    gmx mdrun -deffnm nvt$LAMBDA
    
    echo "Constant volume equilibration complete."
    
    #####################
    # NPT EQUILIBRATION #
    #####################
    echo "Starting constant pressure equilibration..."
    
    cd ../
    mkdir NPT
    cd NPT
    
    gmx grompp -f $MDP/npt_$LAMBDA.mdp -c ../NVT/nvt$LAMBDA.gro 
    -p $FREE_ENERGY/topol.top -t ../NVT/nvt$LAMBDA.cpt -o npt$LAMBDA.tpr
    
    gmx mdrun -deffnm npt$LAMBDA
    
    echo "Constant pressure equilibration complete."
    

|  |  
---|---  
  

 
Free Energy Calculations  

##  GROMACS Tutorial

**Step Six: Production MD**

Now that the system is equilibrated, we can begin production MD simulations,
during which time we will collect ∂H/∂λ data.

    
    
    #################
    # PRODUCTION MD #
    #################
    echo "Starting production MD simulation..."
    
    cd ../
    mkdir Production_MD
    cd Production_MD
    
    gmx grompp -f $MDP/md_$LAMBDA.mdp -c ../NPT/npt$LAMBDA.gro 
    -p $FREE_ENERGY/topol.top -t ../NPT/npt$LAMBDA.cpt -o md$LAMBDA.tpr
    
    gmx mdrun -deffnm md$LAMBDA
    
    echo "Production MD complete."
    

The whole workflow should take about 2.5 hours to complete on a GPU
workstation. Since there are many simulations to run (21 sets of λ vectors),
it is best to run these jobs on clusters where more processors are available
such that jobs can be run simultaneously. Once all of the production
simulations are complete, we can analyze the resulting data.

|  |  
---|---  
  

 
Free Energy Calculations  

##  GROMACS Tutorial

**Step Seven: Analysis**

The bar module of GROMACS makes the calculation of ΔG  AB  very simple. Simply
collect all of the md*.xvg files that were produced by mdrun (one for each
value of λ) in the working directory and run gmx bar:

    
    
    gmx bar -f md*.xvg -o -oi
    

The program will print lots of useful information to the screen, in addition
to producing three output files: bar.xvg, barint.xvg, and histogram.xvg. The
screen output from gmx bar should look something like:

    
    
    Detailed results in kT (see help for explanation):
    
     lam_A  lam_B      DG   +/-     s_A   +/-     s_B   +/-   stdev   +/- 
         0      1    0.08  0.00    0.03  0.00    0.03  0.00    0.25  0.00
         1      2    0.07  0.00    0.03  0.00    0.03  0.00    0.25  0.00
         2      3    0.06  0.00    0.03  0.00    0.04  0.00    0.26  0.00
         3      4    0.04  0.00    0.04  0.00    0.05  0.00    0.28  0.00
         4      5    0.02  0.00    0.03  0.00    0.04  0.00    0.29  0.00
         5      6    0.00  0.00    0.05  0.00    0.06  0.00    0.30  0.00
         6      7   -0.02  0.00    0.05  0.00    0.06  0.00    0.32  0.00
         7      8   -0.06  0.01    0.06  0.00    0.07  0.00    0.35  0.01
         8      9   -0.09  0.01    0.06  0.00    0.07  0.00    0.37  0.00
         9     10   -0.14  0.01    0.08  0.00    0.10  0.01    0.41  0.01
        10     11   -0.22  0.01    0.09  0.01    0.12  0.01    0.46  0.00
        11     12   -0.31  0.01    0.12  0.01    0.15  0.01    0.51  0.01
        12     13   -0.45  0.01    0.17  0.01    0.20  0.01    0.57  0.00
        13     14   -0.59  0.01    0.16  0.02    0.17  0.02    0.58  0.01
        14     15   -0.62  0.01    0.11  0.01    0.11  0.01    0.47  0.00
        15     16   -0.54  0.01    0.06  0.01    0.06  0.01    0.35  0.00
        16     17   -0.42  0.00    0.03  0.01    0.03  0.01    0.25  0.00
        17     18   -0.28  0.00    0.02  0.00    0.02  0.00    0.18  0.00
        18     19   -0.16  0.00    0.01  0.00    0.01  0.00    0.13  0.00
        19     20   -0.05  0.00    0.00  0.00    0.00  0.00    0.10  0.00
    
    Final results in kJ/mol:
    
    point      0 -      1,   DG  0.19 +/-  0.00
    point      1 -      2,   DG  0.17 +/-  0.01
    point      2 -      3,   DG  0.14 +/-  0.00
    point      3 -      4,   DG  0.09 +/-  0.01
    point      4 -      5,   DG  0.06 +/-  0.00
    point      5 -      6,   DG  0.01 +/-  0.01
    point      6 -      7,   DG -0.06 +/-  0.01
    point      7 -      8,   DG -0.14 +/-  0.02
    point      8 -      9,   DG -0.23 +/-  0.01
    point      9 -     10,   DG -0.35 +/-  0.01
    point     10 -     11,   DG -0.53 +/-  0.01
    point     11 -     12,   DG -0.77 +/-  0.03
    point     12 -     13,   DG -1.12 +/-  0.03
    point     13 -     14,   DG -1.46 +/-  0.02
    point     14 -     15,   DG -1.53 +/-  0.04
    point     15 -     16,   DG -1.35 +/-  0.02
    point     16 -     17,   DG -1.04 +/-  0.01
    point     17 -     18,   DG -0.70 +/-  0.01
    point     18 -     19,   DG -0.40 +/-  0.00
    point     19 -     20,   DG -0.13 +/-  0.00
    
    total      0 -     20,   DG -9.13 +/-  0.09
    
    

The value of ΔG  AB  I obtained is -9.13 ± 0.09 kJ mol  -1  , or -2.18 ± 0.02
kcal mol  -1  . Since the process I conducted for this demonstration was the
decoupling of methane, the reverse process (the introduction of uncharged
methane into water, thus the actual hydration energy of the process)
corresponds to a ΔG  AB  of 2.18 ± 0.02 kcal mol  -1  (assuming
reversibility), in good agreement with the value obtained by Shirts of 2.24 ±
0.01 kcal mol  -1  (per Table II of the of that paper), despite the fact that
I used about half the number of λ vectors for the van der Waals transformation
than the original authors did, in addition to the other changes described
previously.

Technically, this is all we need to do to arrive at our answer, but gmx bar
also prints a number of useful output files (all of which are optional). Their
contents are worth exploring here, as they provide a great level of detail
into the decoupling process and the success of sampling.

  

###  Output file 1: bar.xvg

Let's take a look at the other output files that gmx bar gave us, starting
with bar.xvg. This output file plots the relative free energy differences for
each interval of λ (i.e., between neighboring Hamiltonians), and should look
something like this (after re-plotting as a bar graph rather than the default
line representation, and adding a few grid lines for perspective):

![](./Images/plot_bar.png)

The vertical gray lines indicate the values of λ utilized in the decoupling
process conducted here. Thus, each black bar indicates the free energy
difference between neighboring values of λ. In bar.xvg, we get the first look
at what calc_lambda_neighbors was doing during the simulations. For example,
in our simulation of init_lambda_state = 0, the free energy at λ = 0.05 (the
nearest neighboring window, as specified by calc_lambda_neighbors = 1) was
evaluated every nstdhdl (10) steps. These "foreign" λ calculations result in
energetic overlap between the values of λ, such that we have phase space
overlap and adequate sampling. Interested readers should refer to the by Wu
and Kofke cited in the gmx bar description for a discussion of this concept as
well as the interpretation of the entropy values and .

Thus, the free energy change from λ = 0 to λ = 1 is simply the sum of the free
energy changes of each pair of neighboring λ simulations, which are plotted in
bar.xvg.

The values of ΔG correspond to the first half of the output printed to the
screen by gmx bar. The second half of the screen output contains these same
values of ΔG, converted to kJ mol  -1  (1 = 2.478 kJ mol  -1  at 298 K).

  

###  Output file 2: barint.xvg

The barint.xvg file plots the cumulative ΔG as a function of λ. In barint.xvg,
the point at λ = 1 corresponds to the sum of ΔG from λ vector 0 to λ vector 1,
as indicated in the screen output above:

    
    
     lam_A  lam_B      DG   +/-     s_A   +/-     s_B   +/-   stdev   +/-
         0      1    0.08  0.00    0.03  0.00    0.03  0.00    0.25  0.00
         1      2    0.07  0.00    0.03  0.00    0.03  0.00    0.25  0.00
    

Therefore, the value of the cumulative ΔG in barint.xvg at λ = 0 is zero, and
the value at λ = 0.1 is 0.0 + 0.08 = 0.08, and this is the value we find in
barint.xvg. Below is the plot of barint.xvg (blue) alongside the contents of
bar.xvg (black, the values of ΔG between λ values) to illustrate the
cumulative ΔG. By taking the value of ΔG at λ = 20 (-3.69 ), we can recover
the value of ΔG shown above (-9.14 kJ mol  -1  ). The difference between the
value here (-9.14) and above (-9.13) is due to rounding error from using only
two decimal places, whereas the bar program is using full precision in its
calculations above, but printing only two decimal places for all output.

![](./Images/plot_barint.png)  
|  |  
---|---  
  

 
Free Energy Calculations  

##  GROMACS Tutorial

**Advanced Applications**

One common application of calculating free energies is to determine the of ΔG
of binding between a ligand and a receptor (e.g., a protein), you would need
to perform (de)coupling of the ligand in complex with the receptor and in bulk
solution, since ΔG is (in this case) the sum of the free energy change of
complexation of the ligand and receptor (i.e. the introduction of the ligand
into the binding site) and the free energy of desolvating the ligand (i.e.
removing it from solution):

ΔG  bind  = ΔG  complexation  \+ ΔG  desolvation

ΔG  solvation  = -ΔG  desolvation

∴ ΔG  bind  = ΔG  complexation  \- ΔG  solvation

ΔG of binding will be the difference between these two states, and can be
calculated through the use of the following (somewhat simplified)
thermodynamic cycle, wherein ΔG  1  is ΔG  solvation  and ΔG  3  is ΔG
complexation  in the equations above.

![](./Images/TI_cycle.jpg)

A particularly detailed thermodynamic cycle for this type of process can be
found in Figure 1 of .

The transformation of a fully-interacting species (e.g., the ligand) into a
"dummy" (a set of atomic centers in the configuration of the ligand that does
not engage in any nonbonded interactions with its surroundings) requires
turning off both van der Waals interactions (as demonstrated in this tutorial)
and Coulombic interactions between the solute of interest and its surrounding
environment. The complete series of transformations for methane is shown
below:

|  ![](./Images/methane_full.png) |  ![](./Images/methane_noQ.png) |
![](./Images/methane_none.png)  
---|---|---  
**Fully-interacting** |  **No charges, full LJ** |  **Dummy molecule**  
  
In the above thermodynamic cycle, ΔG  1  and ΔG  3  actually represent the
introduction of the ligand (starting as a dummy molecule), i.e. coupling
rather than decoupling. The thermodynamic cycle above is extremely basic, and
does not account for considerations like , , etc. None of this literature will
be discussed here. For most small molecules (generically named "LIG" below),
the following settings might seem attractive:

    
    
         couple-moltype    = LIG
         couple-intramol   = no
         couple-lambda0    = none
         couple-lambda1    = vdw-q 
    

Special care must be taken in this case. In previous versions of GROMACS, such
an approach was likely to be very unstable because removal of van der Waals
terms while a system retains some charge allows oppositely-charged atoms to
interact very closely (in the absence of the full effects of an electron
cloud). The result would be unstable configurations and unreliable energies,
even if the systems didn't collapse. Thus, it is more sound to approach the
(de)coupling sequentially. In version 5.0, this is very easily done with the
new λ vector capabilities:

    
    
        couple-moltype          = LIG
        couple-intramol         = no
        couple-lambda0          = none
        couple-lambda1          = vdw-q
        init_lambda_state       = 0
        calc_lambda_neighbors   = 1
        vdw_lambdas             = 0.00 0.05 0.10 ... 1.00 1.00 1.00 ... 1.00
        coul_lambdas            = 0.00 0.00 0.00 ... 0.00 0.05 0.10 ... 1.00
    

In this case, the λ value for Coulombic interactions is always zero while the
λ value for transforming van der Waals interactions changes. Then, the van der
Waals interactions are fully on (λ = 1.00) while the Coulombic interactions
are gradually turned on. Keeping track of the states to which λ = 0 and λ = 1
correspond is key to this process. In the above case, couple-lambda0 says
interactions are off, while couple-lambda1 means interactions are on.

These types of transformations can be useful for calculating
hydration/solvation free energies, since this quantity is often used as target
data in force field parametrization.

|  
---|---  
  

 
Free Energy Calculations  

##  GROMACS Tutorial

**Summary**

You have now calculated the free energy change for a simple transformation
that has previously been calculated with high precision, the decoupling of van
der Waals interactions between a simple solute (uncharged methane) and solvent
(water). Hopefully this tutorial will provide you with the understanding
necessary to take on more complex systems.

If you have suggestions for improving this tutorial, if you notice a mistake,
or if anything is otherwise unclear, please feel free to . Please note: this
is not an invitation to email me for GROMACS problems. I do not advertise
myself as a private tutor or personal help service. That's what the is for. I
may help you there, but only in the context of providing service to the
community as a whole, not just the end user.

Happy simulating!

|  |  
---|---  
  

 
Free Energy Calculations  

##  GROMACS Tutorial

###  Free Energy Calculations: Methane in Water

**Justin A. Lemkul, Ph.D.**  

![](./Images/system.png)  

This tutorial will guide the user through the process of calculating a simple
free energy change, the decoupling removal of van der Waals interactions
between neutral methane and a box of water. This quantity was previously
calculated by in a systematic evaluation of free energies of solvation of
amino acid side chains using different atomistic force fields.

This tutorial requires a GROMACS version in the 2018.x series.

  
  
  
  
  
---  
  

 
Free Energy Calculations  

##  GROMACS Tutorial

**Step One: Theory**

This tutorial will assume you have a reasonable understanding of what free
energy calculations are, the different types that exist, and the underlying
theory of the technique. It is neither practical nor possible to provide a
complete education here. Instead, I will focus this tutorial on practical
aspects of running free energy calculations in GROMACS, highlighting relevant
theoretical points as necessary throughout the tutorial. I will provide here a
list of useful papers for those who are new to free energy calculations. Do
not consider this list exhaustive. It should also not supplant proper study of
statistical mechanics and the many books and papers that have been written on
related topics.

  1. C. D. Christ, A. E. Mark, and W. F. van Gunsteren (2010) **31** : 1569-1582. 
  2. A. Pohorille, C. Jarzynski, and C. Chipot (2010) **114** : 10235-10253. 
  3. A. Villa and A. E. Mark (2002) **23** : 548-553. 

The objective of this tutorial is to reproduce the results of a very simple
system for which an accurate free energy estimate exists. The system of choice
(methane in water) is one dealt with by Shirts in a systematic study of force
fields and the free energies of hydration of amino acid side chain analogs.
The complete publication can be found . This tutorial will assume you have
read and understood the broader points of this paper.

Rather than use the thermodynamic integration approach for evaluating free
energy differences, the data analysis conducted here will utilize the GROMACS
"bar" module, which was introduced in GROMACS version 4.5 (and previously
called g_bar). It uses the Bennett Acceptance Ratio (BAR, hence the name of
the module) method for calculating free energy differences. The corresponding
paper for BAR can be found . Knowledge of this method is also assumed and will
not be discussed in great detail here.

Free energy calculations have a number of practical applications, of which
some of the more common ones include free energies of solvation/hydration and
free energy of binding for a small molecule to some larger receptor
biomolecule (usually a protein). Both of these procedures involve the need to
either add (introduce/couple) or remove (decouple/annihilate) the small
molecule of interest from the system and calculate the resulting free energy
change.

There are two types of nonbonded interactions that can be transformed during
free energy calculations, Coulombic and van der Waals interactions. Bonded
interactions can also be manipulated, but for simplicity, will not be
addressed here. For this tutorial, we will calculate the free energy of a very
simple process: turning off the Lennard-Jones interactions between the atomic
sites of a molecule of interest (in this case, methane) in water. This
quantity was calculated very precisely by Shirts and thus it is the quantity
we seek to reproduce here.

|  |  
---|---  
  
  

 
Free Energy Calculations  

##  GROMACS Tutorial

**Step Two: Examine the Topology**

Download the and for this system. These files were provided as part of David
Mobley's tutorial for this system (which is no longer online), and are the
original files (modified slightly for compatibility with recent GROMACS
versions) used by Michael Shirts in the paper referenced on the previous page.

The system contains a single molecule of methane (called "ALAB" in the
coordinate file, for the β-carbon of alanine) in a box of 596 TIP3P water
molecules. Looking into the topology, we find:

    
    
    ; Topology for methane in TIP3P
    
    #include "oplsaa.ff/forcefield.itp"
    
    [ moleculetype ]
    ; Name                       nrexcl
    Methane                      3
    
    [ atoms ]
    ;   nr       type  resnr residue  atom   cgnr     charge       mass  typeB    chargeB  massB
         1   opls_138      1   ALAB     CB      1      0.000       12.011   
         2   opls_140      1   ALAB    HB1      2      0.000       1.008   
         3   opls_140      1   ALAB    HB2      3      0.000       1.008   
         4   opls_140      1   ALAB    HB3      4      0.000       1.008   
         5   opls_140      1   ALAB    HB4      5      0.000       1.008   
    
    [ bonds ]
    ;  ai    aj funct            c0            c1            c2            c3
        1     2     1 
        1     3     1 
        1     4     1 
        1     5     1 
    
    [ angles ]
    ;  ai    aj    ak funct            c0            c1            c2            c3
        2     1     3     1 
        2     1     4     1 
        2     1     5     1 
        3     1     4     1 
        3     1     5     1 
        4     1     5     1 
    
    ; water topology
    #include "oplsaa.ff/tip3p.itp"
    
    [ system ]
    ; Name
    Methane in water
    
    [ molecules ]
    ; Compound             #mols
    Methane                1
    SOL                    596
    

You will note that all charges are set to zero. There is a practial reason
behind this setup. Normally, charge interactions between the solute and water
are turned off prior to the van der Waals terms. If charge interactions are
left on when Lennard-Jones terms are turned off, positive and negative charges
would be allowed to approach one another at infinitely close distances,
resulting in a very unstable system that would probably just blow up. The
procedure in this tutorial essentially assumes that charges have been properly
been turned off prior to this point, and we will be turning off only van der
Waals interactions between the solute and solvent.

Note that in previous versions of GROMACS, the contents of the ` typeB ` , `
chargeB ` , and ` massB ` headings had to correspond to a B-state of the
molecule. As of GROMACS version 4.0, topology modifications for simple
(de)couplings are no longer required (hooray!), but in the case of mutating
one molecule to another, wherein bonded and nonbonded terms may change, the
old-style modifications (the so-called "dual topology approach") would still
be required. The GROMACS manual, section 5.8.4, provides an example of such a
transformation.

|  |  
---|---  
  

 
Free Energy Calculations  

##  GROMACS Tutorial

**Step Three: The Workflow**

The free energy change of transforming a system from state A to state B, ΔG
AB  , is a function of a coupling parameter, λ, which indicates the level of
change that has taken place between states A and B, that is, the extent to
which the Hamiltonian has been perturbed and the system has been transformed.
Simulations conducted at different values of λ allow us to plot a ∂H/∂λ curve,
from which ΔG  AB  is derived. The first step in planning free energy
calculations is how many λ points will be used to describe the transformation
from state A (λ = 0) to state B (λ = 1), with the goal of collecting adequate
data to exhaustively sample phase space and produce a reliable ∂H/∂λ curve.

|  ![](./Images/lambda0.png) |  ![](./Images/lambda0.5.png) |
![](./Images/lambda1.png)  
---|---|---  
λ = 0  |  λ = 0.5  |  λ = 1  
  
For decoupling Coulombic interactions, which depend linearly upon λ, an
equidistant λ spacing from 0 to 1 should usually suffice, with λ spacing
values of of 0.05-0.1 being common. Note that this is a broad generalization,
and in fact many molecules will require a great deal more finesse, such as
those that interact very strongly with the surrounding environment through
hydrogen bonding. In this case, λ spacing may need to be decreased, such that
more points are used, perhaps even in an asymmetric fashion.

For decoupling van der Waals interactions, λ spacing can be much trickier. For
reasons described by Shirts and elsewhere, a great deal of λ points may be
necessary to properly describe the transformation. Clustering λ points in
regions where the slope of the ∂H/∂λ curve is steep may be necessary. For the
purposes of this tutorial, we will use equidistant λ spacing of 0.05, but in
many cases, one may need to use different spacing, especially clustering
values in the range of 0.6 ≤ λ ≤ 0.8.

For each value of λ, a complete workflow (energy minimization, equilibration,
and data collection) must be conducted. I generally find it most efficient to
run these jobs as batches, passing the output of one step directly into the
next. The workflow utilized here will be:

  1. Steepest descents minimization 
  2. equilibration 
  3. equilibration 
  4. Data collection under an ensemble 

The .mdp files for the different steps of the tutorial (for λ = 0 only) are
provided at the following links:

  *   *   *   * 

I am also making available an accessory Perl script, , that you can use to
very quickly produce all of the input files needed for running these
simulations.

You can also download a shell script ( ) for running these jobs according to
the workflow I will describe.

If you issue:

    
    
    perl write_mdp.pl em_steep.mdp
    

You will receive files named em_steep_0.mdp, em_steep_1.mdp, ...
em_steep_20.mdp, with the relevant values of init_lambda_state inserted into
the filename. Analogously, you can produce the rest of your .mdp files in the
same way (nvt.mdp, npt.mdp, and md.mdp).

In job.sh, you will need to change the values of ` $FREE_ENERGY ` and ` $MDP `
, otherwise the script certainly won't work.

  

###  Notes on .mdp settings

Before proceeding, it is important to understand the free energy-related
settings in the .mdp files (using em_steep_0.mdp as an example). They are the
same for all steps in the workflow. I will assume that you are familiar with
the other settings found in the .mdp file. If this is not the case, please
refer to some before proceeding.

* * *  
  
---  
free_energy = yes  |  Indicates that we are doing a free energy calculation,
and that interpolation between the A and B states of the chosen molecule
(defined below) will occur.  
  
* * *  
  
init_lambda_state = 0  |  In previous GROMACS versions, the "init_lambda"
keyword specified a single value of λ directly. Since version 5.0, λ is now a
vector that allows for transformation of bonded and nonbonded interactions.
With the init_lambda_state keyword, we specify an index (starting from zero)
of the vector to be utilized in the simulation (more on this later).  
  
* * *  
  
delta_lambda = 0  |  The value of λ can be incremented by some amount per
timestep (i.e., δλ/δt) in a technique called "slow growth." This method can
have significant errors associated with it, and thus we will make no time-
dependent changes to our λ values.  
  
* * *  
  
fep_lambdas = (nothing)  |  You will note that this keyword is not specified.
In previous GROMACS versions, the use of init_lambda and foreign_lambda
controlled the value of λ  i  and the additional values of λ for which energy
differences would be evaluated for configurations at λ  i  . This is no longer
the case. One can explicitly set values of λ in the fep_lambdas keyword, but
instead we allow the calc_lambda_neighbors keyword (see below) to
automatically determine these additional values.  
  
* * *  
  
calc_lambda_neighbors = 1  |  The number of neighboring windows for which
energy differences are computed with respect to λ  i  . For instance, if
init_lambda_state is set to 10, then energy differences with respect to λ
states 9 and 11 are computed during the run with calc_lambda_neighbors = 1.  
  
* * *  
  
vdw_lambdas = ...  |  An array of λ values for the transformation of van der
Waals interactions.  
  
* * *  
  
coul_lambdas = ...  |  An array of λ values for the transformation of
Coulombic (electrostatic) interactions.  
  
* * *  
  
bonded_lambdas = ...  |  An array of λ values for the transformation of bonded
interactions.  
  
* * *  
  
restraint_lambdas = ...  |  An array of λ values for the transformation of
restraints.  
  
* * *  
  
mass_lambdas = ...  |  An array of λ values for the transformation of atomic
masses; used if tranforming the chemical nature of the molecule.  
  
* * *  
  
temperature_lambdas = ...  |  An array of λ values for the transformation of
temperatures; used only for simulated tempering.  
  
* * *  
  
sc-alpha = 0.5  |  The value of the α scaling factor used in the "soft-core"
Lennard-Jones equation. See equations 4.124 - 4.126 in the GROMACS manual,
section 4.5.1, for a complete description of this term, as well as the next
three.  
  
* * *  
  
sc-coul = no  |  Transform Coulombic interactions linearly. This is the
default behavior, but is written out for clarity.  
  
* * *  
  
sc-power = 1.0  |  The power for λ in the soft-core equation.  
  
* * *  
  
sc-sigma = 0.3  |  The value of σ assigned to any atom types that have C6 or
C12 parameters equal to zero or σ < sc-sigma (typically H atoms). This value
is used in the soft-core Lennard-Jones equation.  
  
* * *  
  
couple-moltype = Methane  |  The name of the [moleculetype] in that will have
its topology interpolated from state A to state B. Note that the name given
here must match a [moleculetype] name, and not the residue name. In some cases
these may be the same, but I have maintained different names for the
[moleculetype] and component residue for instructive purposes.  
  
* * *  
  
couple-lambda0 = vdw  |  The types of nonbonded interactions that are present
in state A between the interpolated [moleculetype] and the remainder of the
system. The value "vdw" indicates that only van der Waals terms are active
between methane and water; there are no solute-solvent Coulombic interactions.  
  
* * *  
  
couple-lambda1 = none  |  The types of nonbonded interactions that are present
in state B between the interpolated [moleculetype] and the remainder of the
system. The value "none" indicates that both van der Waals and Coulombic
interactions are off in state B. Relative to couple-lambda0, this indicates
that only van der Waals terms have been turned off.  
  
* * *  
  
couple-intramol = no  |  Do not decouple intramolecular interactions. That is,
the λ factor is applied to only solute-solvent nonbonded interactions and not
solute-solute nonbonded interactions.  
  
Setting "couple-intramol = yes" is useful for larger molecules that may have
intramolecular interactions occuring at longer distance (e.g. peptides or
other polymers). Otherwise, distal parts of the molecule will interact via
explicit pair interactions in an unnaturally strong manner (since solute-
solvent interactions are weakened as a function of λ, but the intramolecular
terms would not be), giving rise to configurations that will incorrectly bias
the resulting free energy.  
  
* * *  
  
nstdhdl = 10  |  The frequency with which ∂H/∂λ and ΔH are written to
dhdl.xvg. A value of 100 would probably suffice, since the resulting values
will be highly correlated and the files will get very large. You may wish to
increase this value to 100 for your own work.  
  
* * *  
  
There are also several differences in the .mdp settings that will be used here
relative to the settings used by Shirts :

  1. rlist=rcoulomb=rvdw=1.2. In order to use PME, rlist must be equal to rcoulomb, a check that was enforced in grompp sometime after the release of version 3.3.1. The Verlet cutoff scheme introduced in version 4.6 that allows for buffered neighbor lists also requires rvdw=rcoulomb. The value of rlist will be tuned during the run for the purposes of energy conservation, thus providing the necessary buffer for the switched van der Waals interactions. The switching range (from 1.0-1.2 nm) agrees with the methods of Shirts for the treatment of solute-solvent interactions. 
  2. Temperature coupling is handled through the use of the Langevin integrator (the "sd" setting specifies "stochastic dynamics," e.g. with a random friction force), rather than an Andersen thermostat. 
  3. tau_t = 1.0. It is important to illustrate this particular value, because when using the Langevin integrator, this value corresponds to an inverse friction coefficient, therefore in ps  -1  . The value of 1.0 avoids over-damping the dynamics of water. 

Let us take a moment to dissect the λ vectors a bit more closely. As an
example, for init_lambda_state = 0, that means we are specifying that the
state in the transformation corresponds to the vector with index 0 in the
*_lambdas keywords, like so:

    
    
    ; init_lambda_state        0    1    2    3    4    5    6    7    8    9    10   11   12   13   14   15   16   17   18   19   20
    vdw_lambdas              = **0.00** 0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00
    coul_lambdas             = **0.00** 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00
    bonded_lambdas           = **0.00** 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00
    restraint_lambdas        = **0.00** 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00
    mass_lambdas             = **0.00** 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00
    temperature_lambdas      = **0.00** 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00
    

Setting initial_lambda_state = 1 would correspond to the next column to the
right (λ for van der Waals = 0.05), while initial_lambda_state = 20 would
specify the final column (λ vector), in which the value of λ for van der Waals
= 1.0. For the purposes of this tutorial, we are only transforming van der
Waals interactions, leaving everything related to charges, bonded parameters,
restraints, etc. alone. **Please note** that, in this example, where charges
are zero in the topology and the .mdp settings never indicate that charges
should be present (neither couple-lambda0 nor couple-lambda1 include 'q'), the
choice of values for coul_lambdas is irrelevant, but for the sake of being
pedantic, the .mdp files make clear that no charge transformation is taking
place.

|  
---|---  
  
  

 
Free Energy Calculations  

##  GROMACS Tutorial

**Step Four: Energy Minimization**

The job.sh script I provide for running these calculations will create the
following directory hierarchy:

    
    
    Lambda_0/
    Lambda_0/EM/
    Lambda_0/NVT/
    Lambda_0/NPT/
    Lambda_0/Production_MD/
    

This way, all steps in the workflow are executed within a single directory for
each value of init_lambda_state. I find this to be a convenient way to
organize the jobs and their output.

The script also assumes that the .mdp files are also organized hierarchically
within some directory ` $MDP ` , which is set as an environment variable in
the script:

    
    
    $MDP/
    $MDP/EM/
    $MDP/NVT/
    $MDP/NPT/
    $MDP/Production_MD/
    

As described before, energy minimization will be conducted using the steepest
descent method. The relevant section in the job.sh script is:

    
    
    mkdir Lambda_$LAMBDA
    cd Lambda_$LAMBDA
    
    #################################
    # ENERGY MINIMIZATION 1: STEEP  #
    #################################
    echo "Starting minimization for lambda = $LAMBDA..."
    
    mkdir EM
    cd EM
    
    # Iterative calls to grompp and mdrun to run the simulations
    
    gmx grompp -f $MDP/em_steep_$LAMBDA.mdp -c $FREE_ENERGY/methane_water.gro 
    -p $FREE_ENERGY/topol.top -o min$LAMBDA.tpr
    
    gmx mdrun -deffnm min$LAMBDA
    
    echo "Minimization complete."
    

|  |  
---|---  
  

 
Free Energy Calculations  

##  GROMACS Tutorial

**Step Five: Equilibration**

The system will be equilibrated in two phases, the first at constant volume (
), the second at constant pressure ( ).

    
    
    #####################
    # NVT EQUILIBRATION #
    #####################
    echo "Starting constant volume equilibration..."
    
    cd ../
    mkdir NVT
    cd NVT
    
    gmx grompp -f $MDP/nvt_$LAMBDA.mdp -c ../EM/min$LAMBDA.gro 
    -p $FREE_ENERGY/topol.top -o nvt$LAMBDA.tpr
    
    gmx mdrun -deffnm nvt$LAMBDA
    
    echo "Constant volume equilibration complete."
    
    #####################
    # NPT EQUILIBRATION #
    #####################
    echo "Starting constant pressure equilibration..."
    
    cd ../
    mkdir NPT
    cd NPT
    
    gmx grompp -f $MDP/npt_$LAMBDA.mdp -c ../NVT/nvt$LAMBDA.gro 
    -p $FREE_ENERGY/topol.top -t ../NVT/nvt$LAMBDA.cpt -o npt$LAMBDA.tpr
    
    gmx mdrun -deffnm npt$LAMBDA
    
    echo "Constant pressure equilibration complete."
    

|  |  
---|---  
  

 
Free Energy Calculations  

##  GROMACS Tutorial

**Step Six: Production MD**

Now that the system is equilibrated, we can begin production MD simulations,
during which time we will collect ∂H/∂λ data.

    
    
    #################
    # PRODUCTION MD #
    #################
    echo "Starting production MD simulation..."
    
    cd ../
    mkdir Production_MD
    cd Production_MD
    
    gmx grompp -f $MDP/md_$LAMBDA.mdp -c ../NPT/npt$LAMBDA.gro 
    -p $FREE_ENERGY/topol.top -t ../NPT/npt$LAMBDA.cpt -o md$LAMBDA.tpr
    
    gmx mdrun -deffnm md$LAMBDA
    
    echo "Production MD complete."
    

The whole workflow should take about 2.5 hours to complete on a GPU
workstation. Since there are many simulations to run (21 sets of λ vectors),
it is best to run these jobs on clusters where more processors are available
such that jobs can be run simultaneously. Once all of the production
simulations are complete, we can analyze the resulting data.

|  |  
---|---  
  

 
Free Energy Calculations  

##  GROMACS Tutorial

**Step Seven: Analysis**

The bar module of GROMACS makes the calculation of ΔG  AB  very simple. Simply
collect all of the md*.xvg files that were produced by mdrun (one for each
value of λ) in the working directory and run gmx bar:

    
    
    gmx bar -f md*.xvg -o -oi
    

The program will print lots of useful information to the screen, in addition
to producing three output files: bar.xvg, barint.xvg, and histogram.xvg. The
screen output from gmx bar should look something like:

    
    
    Detailed results in kT (see help for explanation):
    
     lam_A  lam_B      DG   +/-     s_A   +/-     s_B   +/-   stdev   +/- 
         0      1    0.08  0.00    0.03  0.00    0.03  0.00    0.25  0.00
         1      2    0.07  0.00    0.03  0.00    0.03  0.00    0.25  0.00
         2      3    0.06  0.00    0.03  0.00    0.04  0.00    0.26  0.00
         3      4    0.04  0.00    0.04  0.00    0.05  0.00    0.28  0.00
         4      5    0.02  0.00    0.03  0.00    0.04  0.00    0.29  0.00
         5      6    0.00  0.00    0.05  0.00    0.06  0.00    0.30  0.00
         6      7   -0.02  0.00    0.05  0.00    0.06  0.00    0.32  0.00
         7      8   -0.06  0.01    0.06  0.00    0.07  0.00    0.35  0.01
         8      9   -0.09  0.01    0.06  0.00    0.07  0.00    0.37  0.00
         9     10   -0.14  0.01    0.08  0.00    0.10  0.01    0.41  0.01
        10     11   -0.22  0.01    0.09  0.01    0.12  0.01    0.46  0.00
        11     12   -0.31  0.01    0.12  0.01    0.15  0.01    0.51  0.01
        12     13   -0.45  0.01    0.17  0.01    0.20  0.01    0.57  0.00
        13     14   -0.59  0.01    0.16  0.02    0.17  0.02    0.58  0.01
        14     15   -0.62  0.01    0.11  0.01    0.11  0.01    0.47  0.00
        15     16   -0.54  0.01    0.06  0.01    0.06  0.01    0.35  0.00
        16     17   -0.42  0.00    0.03  0.01    0.03  0.01    0.25  0.00
        17     18   -0.28  0.00    0.02  0.00    0.02  0.00    0.18  0.00
        18     19   -0.16  0.00    0.01  0.00    0.01  0.00    0.13  0.00
        19     20   -0.05  0.00    0.00  0.00    0.00  0.00    0.10  0.00
    
    Final results in kJ/mol:
    
    point      0 -      1,   DG  0.19 +/-  0.00
    point      1 -      2,   DG  0.17 +/-  0.01
    point      2 -      3,   DG  0.14 +/-  0.00
    point      3 -      4,   DG  0.09 +/-  0.01
    point      4 -      5,   DG  0.06 +/-  0.00
    point      5 -      6,   DG  0.01 +/-  0.01
    point      6 -      7,   DG -0.06 +/-  0.01
    point      7 -      8,   DG -0.14 +/-  0.02
    point      8 -      9,   DG -0.23 +/-  0.01
    point      9 -     10,   DG -0.35 +/-  0.01
    point     10 -     11,   DG -0.53 +/-  0.01
    point     11 -     12,   DG -0.77 +/-  0.03
    point     12 -     13,   DG -1.12 +/-  0.03
    point     13 -     14,   DG -1.46 +/-  0.02
    point     14 -     15,   DG -1.53 +/-  0.04
    point     15 -     16,   DG -1.35 +/-  0.02
    point     16 -     17,   DG -1.04 +/-  0.01
    point     17 -     18,   DG -0.70 +/-  0.01
    point     18 -     19,   DG -0.40 +/-  0.00
    point     19 -     20,   DG -0.13 +/-  0.00
    
    total      0 -     20,   DG -9.13 +/-  0.09
    
    

The value of ΔG  AB  I obtained is -9.13 ± 0.09 kJ mol  -1  , or -2.18 ± 0.02
kcal mol  -1  . Since the process I conducted for this demonstration was the
decoupling of methane, the reverse process (the introduction of uncharged
methane into water, thus the actual hydration energy of the process)
corresponds to a ΔG  AB  of 2.18 ± 0.02 kcal mol  -1  (assuming
reversibility), in good agreement with the value obtained by Shirts of 2.24 ±
0.01 kcal mol  -1  (per Table II of the of that paper), despite the fact that
I used about half the number of λ vectors for the van der Waals transformation
than the original authors did, in addition to the other changes described
previously.

Technically, this is all we need to do to arrive at our answer, but gmx bar
also prints a number of useful output files (all of which are optional). Their
contents are worth exploring here, as they provide a great level of detail
into the decoupling process and the success of sampling.

  

###  Output file 1: bar.xvg

Let's take a look at the other output files that gmx bar gave us, starting
with bar.xvg. This output file plots the relative free energy differences for
each interval of λ (i.e., between neighboring Hamiltonians), and should look
something like this (after re-plotting as a bar graph rather than the default
line representation, and adding a few grid lines for perspective):

![](./Images/plot_bar.png)

The vertical gray lines indicate the values of λ utilized in the decoupling
process conducted here. Thus, each black bar indicates the free energy
difference between neighboring values of λ. In bar.xvg, we get the first look
at what calc_lambda_neighbors was doing during the simulations. For example,
in our simulation of init_lambda_state = 0, the free energy at λ = 0.05 (the
nearest neighboring window, as specified by calc_lambda_neighbors = 1) was
evaluated every nstdhdl (10) steps. These "foreign" λ calculations result in
energetic overlap between the values of λ, such that we have phase space
overlap and adequate sampling. Interested readers should refer to the by Wu
and Kofke cited in the gmx bar description for a discussion of this concept as
well as the interpretation of the entropy values and .

Thus, the free energy change from λ = 0 to λ = 1 is simply the sum of the free
energy changes of each pair of neighboring λ simulations, which are plotted in
bar.xvg.

The values of ΔG correspond to the first half of the output printed to the
screen by gmx bar. The second half of the screen output contains these same
values of ΔG, converted to kJ mol  -1  (1 = 2.478 kJ mol  -1  at 298 K).

  

###  Output file 2: barint.xvg

The barint.xvg file plots the cumulative ΔG as a function of λ. In barint.xvg,
the point at λ = 1 corresponds to the sum of ΔG from λ vector 0 to λ vector 1,
as indicated in the screen output above:

    
    
     lam_A  lam_B      DG   +/-     s_A   +/-     s_B   +/-   stdev   +/-
         0      1    0.08  0.00    0.03  0.00    0.03  0.00    0.25  0.00
         1      2    0.07  0.00    0.03  0.00    0.03  0.00    0.25  0.00
    

Therefore, the value of the cumulative ΔG in barint.xvg at λ = 0 is zero, and
the value at λ = 0.1 is 0.0 + 0.08 = 0.08, and this is the value we find in
barint.xvg. Below is the plot of barint.xvg (blue) alongside the contents of
bar.xvg (black, the values of ΔG between λ values) to illustrate the
cumulative ΔG. By taking the value of ΔG at λ = 20 (-3.69 ), we can recover
the value of ΔG shown above (-9.14 kJ mol  -1  ). The difference between the
value here (-9.14) and above (-9.13) is due to rounding error from using only
two decimal places, whereas the bar program is using full precision in its
calculations above, but printing only two decimal places for all output.

![](./Images/plot_barint.png)  
|  |  
---|---  
  

 
Free Energy Calculations  

##  GROMACS Tutorial

**Advanced Applications**

One common application of calculating free energies is to determine the of ΔG
of binding between a ligand and a receptor (e.g., a protein), you would need
to perform (de)coupling of the ligand in complex with the receptor and in bulk
solution, since ΔG is (in this case) the sum of the free energy change of
complexation of the ligand and receptor (i.e. the introduction of the ligand
into the binding site) and the free energy of desolvating the ligand (i.e.
removing it from solution):

ΔG  bind  = ΔG  complexation  \+ ΔG  desolvation

ΔG  solvation  = -ΔG  desolvation

∴ ΔG  bind  = ΔG  complexation  \- ΔG  solvation

ΔG of binding will be the difference between these two states, and can be
calculated through the use of the following (somewhat simplified)
thermodynamic cycle, wherein ΔG  1  is ΔG  solvation  and ΔG  3  is ΔG
complexation  in the equations above.

![](./Images/TI_cycle.jpg)

A particularly detailed thermodynamic cycle for this type of process can be
found in Figure 1 of .

The transformation of a fully-interacting species (e.g., the ligand) into a
"dummy" (a set of atomic centers in the configuration of the ligand that does
not engage in any nonbonded interactions with its surroundings) requires
turning off both van der Waals interactions (as demonstrated in this tutorial)
and Coulombic interactions between the solute of interest and its surrounding
environment. The complete series of transformations for methane is shown
below:

|  ![](./Images/methane_full.png) |  ![](./Images/methane_noQ.png) |
![](./Images/methane_none.png)  
---|---|---  
**Fully-interacting** |  **No charges, full LJ** |  **Dummy molecule**  
  
In the above thermodynamic cycle, ΔG  1  and ΔG  3  actually represent the
introduction of the ligand (starting as a dummy molecule), i.e. coupling
rather than decoupling. The thermodynamic cycle above is extremely basic, and
does not account for considerations like , , etc. None of this literature will
be discussed here. For most small molecules (generically named "LIG" below),
the following settings might seem attractive:

    
    
         couple-moltype    = LIG
         couple-intramol   = no
         couple-lambda0    = none
         couple-lambda1    = vdw-q 
    

Special care must be taken in this case. In previous versions of GROMACS, such
an approach was likely to be very unstable because removal of van der Waals
terms while a system retains some charge allows oppositely-charged atoms to
interact very closely (in the absence of the full effects of an electron
cloud). The result would be unstable configurations and unreliable energies,
even if the systems didn't collapse. Thus, it is more sound to approach the
(de)coupling sequentially. In version 5.0, this is very easily done with the
new λ vector capabilities:

    
    
        couple-moltype          = LIG
        couple-intramol         = no
        couple-lambda0          = none
        couple-lambda1          = vdw-q
        init_lambda_state       = 0
        calc_lambda_neighbors   = 1
        vdw_lambdas             = 0.00 0.05 0.10 ... 1.00 1.00 1.00 ... 1.00
        coul_lambdas            = 0.00 0.00 0.00 ... 0.00 0.05 0.10 ... 1.00
    

In this case, the λ value for Coulombic interactions is always zero while the
λ value for transforming van der Waals interactions changes. Then, the van der
Waals interactions are fully on (λ = 1.00) while the Coulombic interactions
are gradually turned on. Keeping track of the states to which λ = 0 and λ = 1
correspond is key to this process. In the above case, couple-lambda0 says
interactions are off, while couple-lambda1 means interactions are on.

These types of transformations can be useful for calculating
hydration/solvation free energies, since this quantity is often used as target
data in force field parametrization.

|  
---|---  
  

 
Free Energy Calculations  

##  GROMACS Tutorial

**Summary**

You have now calculated the free energy change for a simple transformation
that has previously been calculated with high precision, the decoupling of van
der Waals interactions between a simple solute (uncharged methane) and solvent
(water). Hopefully this tutorial will provide you with the understanding
necessary to take on more complex systems.

If you have suggestions for improving this tutorial, if you notice a mistake,
or if anything is otherwise unclear, please feel free to . Please note: this
is not an invitation to email me for GROMACS problems. I do not advertise
myself as a private tutor or personal help service. That's what the is for. I
may help you there, but only in the context of providing service to the
community as a whole, not just the end user.

Happy simulating!

|  |  
---|---  
  

 
Free Energy Calculations  

##  GROMACS Tutorial

###  Free Energy Calculations: Methane in Water

**Justin A. Lemkul, Ph.D.**  

![](./Images/system.png)  

This tutorial will guide the user through the process of calculating a simple
free energy change, 


::: {#answers-to-frequently-asked-questions-faqs .section}
# Answers to frequently asked questions (FAQs)

::: {.toctree-wrapper .compound}
:::

::: {#questions-regarding-gromacs-installation .section}
## Questions regarding GROMACS installation

1.  Do I need to compile all utilities with MPI?

    With one rarely-used exception ( ), only is able to use the
    parallelism. So you only need to use the ` `{.docutils .literal
    .notranslate}[` -DGMX_MPI=on `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} flag when
    for a build intended to run the main simulation engine . Generally
    that is desirable when running on a multi-node cluster, and
    necessary when using multi-simulation algorithms. Usually also
    installing a build of GROMACS configured without MPI is convenient
    for users.

2.  Should my version be compiled using double precision?

    In general, GROMACS only needs to be build in its default
    mixed-precision mode. For more details, see the discussion in
    Chapter 2 of the . Sometimes, usage may also depend on your target
    system, and should be decided upon according to the .
:::

::: {#questions-concerning-system-preparation-and-preprocessing .section}
## Questions concerning system preparation and preprocessing

1.  Where can I find a solvent for use with ?

    Suitable equilibrated boxes of solvent can be found in the
    ` `{.docutils .literal
    .notranslate}[` $GMXDIR/share/gromacs/top `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} directory.
    That location will be searched by default by , for example by using
    ` `{.docutils .literal .notranslate}[` -cs `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` spc216.gro `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} as an
    argument. Other solvent boxes can be prepared by the user as
    described on the manual page for and elsewhere. Note that suitable
    topology files will be needed for the solvent boxes to be useful in
    . These are available for some force fields, and may be found in the
    respective subfolder of ` `{.docutils .literal
    .notranslate}[` $GMXDIR/share/gromacs/top `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} .

2.  How to prevent from placing waters in undesired places?

    Water placement is generally well behaved when solvating proteins,
    but can be difficult when setting up membrane or micelle
    simulations. In those cases, waters may be placed in between the
    alkyl chains of the lipids, leading to problems later . You can
    either remove those waters by hand (and do the accounting for
    molecule types in the file), or set up a local copy of the
    ` `{.docutils .literal .notranslate}[` vdwradii.dat `{.docutils
    .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}
    file from the ` `{.docutils .literal
    .notranslate}[` $GMXLIB `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} directory,
    specific for your project and located in your working directory. In
    it, you can increase the vdW radius of the atoms, to suppress such
    interstitial insertions. Recommended e.g. at a common is the use of
    0.375 instead of 0.15.

```{=html}
<!-- -->
```
1.  How do I provide multiple definitions of bonds / dihedrals in a
    topology?

    You can add additional bonded terms beyond those that are normally
    defined for a residue (e.g. when defining a special ligand) by
    including additional copies of the respective lines under the
    ` `{.docutils .literal .notranslate}[` [ `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` bonds `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` ] `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} ,
    ` `{.docutils .literal .notranslate}[` [ `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` pairs `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` ] `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} ,
    ` `{.docutils .literal .notranslate}[` [ `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` angles `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` ] `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} and
    ` `{.docutils .literal .notranslate}[` [ `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` dihedrals `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` ] `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} sections in
    the ` `{.docutils .literal .notranslate}[` [ `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` moleculetype `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` ] `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} section for
    your molecule, found either in the file or the file. This will
    **add** those extra terms to the potential energy evaluation, but
    **will not** remove the previous ones. So be careful with duplicate
    entries. Also keep in mind that this **does not** apply to
    duplicated entries for ` `{.docutils .literal
    .notranslate}[` [ `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` bondtypes `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` ] `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} ,
    ` `{.docutils .literal .notranslate}[` [ `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` angletypes `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` ] `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} , or
    ` `{.docutils .literal .notranslate}[` [ `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` dihedraltypes `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` ] `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} , in
    force-field definition files, where duplicates overwrite the
    previous values.

2.  Do I really need a file?

    The file is used in GROMACS as a unified format that can be read by
    all utilities. The large majority of GROMACS routines can also use
    other file types such as , with the limitations that no velocities
    are available in . If you need a text-based format with more digits
    of precision, the format is suitable and supported.

3.  Do I always need to run when I already produced an file elsewhere?

    You donâ€™t need to prepare additional files if you already have all
    and files prepared through other tools.

    Examples for those can be found in the .

4.  How can I build in missing atoms?

    GROMACS has no support for building coordinates of missing
    non-hydrogen atoms. If your system is missing some part, you will
    have to add the missing pieces using external programs to avoid the
    error. This can be done using programs such as in combination with ,
    , . **Do not run** a simulation that had missing atoms unless you
    know exactly why it will be stable.

5.  Why is the total charge of my system not an integer like it should
    be?

    In math, real numbers can not be displayed to arbitrary precision
    (for more on this, see e.g. ). This means that very small
    differences to the final integer value will persist, and GROMACS
    will not lie to you and round those values up or down. If your
    charge differs from the integer value by a larger amount, e.g. at
    least 0.01, this usually means that something went wrong during your
    system preparation
:::

::: {#questions-regarding-simulation-methodology .section}
## Questions regarding simulation methodology

1.  Should I couple a handful of ions to their own temperature-coupling
    bath?

    **No** . You need to consider the minimal size of your temperature
    coupling groups, as explained in and more specifically in , as well
    as the implementation of your chosen thermostat as described in the
    .

2.  Why do my grompp restarts always start from time zero?

    You can choose different values for and .

3.  Why canâ€™t I do conjugate gradient minimization with constraints?

    Minimization with the conjugate gradient scheme can not be performed
    with constraints as described in the , and some additional
    information on .

4.  How do I hold atoms in place in my energy minimization or
    simulation?

    Groups may be frozen in place using ` `{.docutils .literal
    .notranslate}[` freeze `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` groups `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} (see the ).
    It is more common to use a set of position restraints, to place
    penalties on movement of the atoms. Files that control this kind of
    behaviour can be created using .

5.  How do I extend a completed a simulation to longer times?

    Please see the section on . You can either prepare a new file, or
    extend the simulation time in the original file using .

6.  How should I compute a single-point energy?

    This is best achieved with the ` `{.docutils .literal
    .notranslate}[` -rerun `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} option to .
    See the section.
:::

::: {#parameterization-and-force-fields .section}
## Parameterization and Force Fields

1.  I want to simulate a molecule (protein, DNA, etc.) which complexes
    with various transition metal ions, iron-sulfur clusters, or other
    exotic species. Parameters for these exotic species arenâ€™t
    available in force field X. What should I do?

    First, you should consider how well will actually describe your
    system (e.g. see some of the ). Many species are infeasible to model
    without either atomic polarizability, or QM treatments. Then you
    need to prepare your own set of parameters and add a new residue to
    your of choice. Then you will have to validate that your system
    behaves in a physical way, before continuing your simulation
    studies. You could also try to build a more simplified model that
    does not rely on the complicated additions, as long as it still
    represents the correct *real* object in the laboratory.

2.  Should I take parameters from one force field and apply them inside
    another that is missing them?

    **NO** . Molecules parametrized for a given will not behave in a
    physical manner when interacting with other molecules that have been
    parametrized according to different standards. If your required
    molecule is not included in the force field you need to use, you
    will have to parametrize it yourself according to the methodology of
    this force field.
:::

::: {#analysis-and-visualization .section}
## Analysis and Visualization

1.  Why am I seeing bonds being created when I watch the trajectory?

    Most visualization softwares determine the bond status of atoms
    depending on a set of predefined distances. So the bonding pattern
    created by them might not be the one defined in your file. What
    matters is the information encoded in there. If the software has
    read a file, then the information is in reliable agreement with the
    topology you supplied to .

2.  When visualizing a trajectory from a simulation using PBC, why are
    there holes or my peptide leaving the simulation box?

    Those holes and molecules moving around are just a result of
    molecules ranging over the , and are not a reason for concern. You
    can fix the visualization using to prepare the structure for
    analysis.

3.  Why is my total simulation time not an integer like it should be?

    As the simulation time is calculated using , rounding errors can
    occur but are not of concern.
:::
:::
::: {#command-line-reference .section}
[ ]{#gmx-cmdline}

# Command-line reference

::: {.toctree-wrapper .compound}
:::

GROMACS includes many tools for preparing, running and analyzing
molecular dynamics simulations. These are all structured as part of a
single **gmx** wrapper binary, and invoked with commands like **gmx
grompp** . or **gmx mdrun** . Documentation for these can be found at
the respective sections below, as well as on man pages (e.g.,
*gmx-grompp(1)* ) and with ` `{.samp .docutils .literal
.notranslate}[` gmx `{.samp .docutils .literal
.notranslate}]{.pre}` `{.samp .docutils .literal
.notranslate}[` help `{.samp .docutils .literal
.notranslate}]{.pre}` `{.samp .docutils .literal
.notranslate}*[` command `{.samp .docutils .literal
.notranslate}]{.pre}*` `{.samp .docutils .literal .notranslate} or
` `{.samp .docutils .literal .notranslate}[` gmx `{.samp .docutils
.literal .notranslate}]{.pre}` `{.samp .docutils .literal
.notranslate}*[` command `{.samp .docutils .literal
.notranslate}]{.pre}*` `{.samp .docutils .literal
.notranslate}[` -h `{.samp .docutils .literal
.notranslate}]{.pre}` `{.samp .docutils .literal .notranslate} .

If youâ€™ve installed an MPI version of GROMACS, by default the **gmx**
binary is called **gmx_mpi** and you should adapt accordingly.

::: {#command-line-interface-and-conventions .section}
## Command-line interface and conventions

All GROMACS commands require an option before any arguments (i.e., all
command-line arguments need to be preceded by an argument starting with
a dash, and values not starting with a dash are arguments to the
preceding option). Most options, except for boolean flags, expect an
argument (or multiple in some cases) after the option name. The argument
must be a separate command-line argument, i.e., separated by space, as
in ` `{.docutils .literal .notranslate}[` -f `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` traj.xtc `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . If more than
one argument needs to be given to an option, they should be similarly
separated from each other. Some options also have default arguments,
i.e., just specifying the option without any argument uses the default
argument. If an option is not specified at all, a default value is used;
in the case of optional files, the default might be not to use that file
(see below).

All GROMACS command options start with a single dash, whether they are
single- or multiple-letter options. However, two dashes are also
recognized (starting from 5.1).

In addition to command-specific options, some options are handled by the
**gmx** wrapper, and can be specified for any command. See for the list
of such options. These options are recognized both before the command
name (e.g., **gmx -quiet grompp** ) as well as after the command name
(e.g., **gmx grompp -quiet** ). There is also a ` `{.docutils .literal
.notranslate}[` -hidden `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} option that can
be specified in combination with ` `{.docutils .literal
.notranslate}[` -h `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} to show help
for advanced/developer-targeted options.

Most analysis commands can process a trajectory with fewer atoms than
the run input or structure file, but only if the trajectory consists of
the first *n* atoms of the run input or structure file.

::: {#handling-specific-types-of-command-line-options .section}
### Handling specific types of command-line options

boolean options

:   Boolean flags can be specified like ` `{.docutils .literal
    .notranslate}[` -pbc `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} and negated
    like ` `{.docutils .literal .notranslate}[` -nopbc `{.docutils
    .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} .
    It is also possible to use an explicit value like ` `{.docutils
    .literal .notranslate}[` -pbc `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` no `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} and
    ` `{.docutils .literal .notranslate}[` -pbc `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` yes `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} .

file name options

:   Options that accept files names have features that support using
    default file names (where the default file name is specific to that
    option):

    -   If a required option is not set, the default is used.

    -   If an option is marked optional, the file is not used unless the
        option is set (or other conditions make the file required).

    -   If an option is set, and no file name is provided, the default
        is used.

    All such options will accept file names without a file extension.
    The extension is automatically appended in such a case. When
    multiple input formats are accepted, such as a generic structure
    format, the directory will be searched for files of each type with
    the supplied or default name. When no file with a recognized
    extension is found, an error is given. For output files with
    multiple formats, a default file type will be used.

    Some file formats can also be read from compressed ( ` `{.file
    .docutils .literal .notranslate}[` .Z `{.file .docutils .literal
    .notranslate}]{.pre}` `{.file .docutils .literal .notranslate} or
    ` `{.file .docutils .literal .notranslate}[` .gz `{.file .docutils
    .literal .notranslate}]{.pre}` `{.file .docutils .literal
    .notranslate} ) formats.

enum options

:   Enumerated options (enum) should be used with one of the arguments
    listed in the option description. The argument may be abbreviated,
    and the first match to the shortest argument in the list will be
    selected.

vector options

:   Some options accept a vector of values. Either 1 or 3 parameters can
    be supplied; when only one parameter is supplied the two other
    values are also set to this value.

selection options

:   See .
:::
:::

::: {#commands-by-name .section}
## Commands by name

-   \- molecular dynamics simulation suite

-   \- Analyze eigenvectors/normal modes

-   \- Analyze data sets

-   \- Calculate distributions and correlations for angles and dihedrals

-   \- Extract data from an accelerated weight histogram (AWH) run

-   \- Calculate free energy difference estimates through Bennettâ€™s
    acceptance ratio

-   \- Analyze bundles of axes, e.g., helices

-   \- Check and compare files

-   \- Calculate everything you want to know about chi and other
    dihedrals

-   \- Cluster structures

-   \- Calculate size distributions of atomic clusters

-   \- Fit two structures and calculates the RMSD

-   \- Make a modified run-input file

-   \- Converts between different trajectory types

-   \- Calculate and diagonalize the covariance matrix

-   \- Calculate dielectric constants and current autocorrelation
    function

-   \- Calculate the density of the system

-   \- Calculate 2D planar or axial-radial density maps

-   \- Calculate surface fluctuations

-   \- Calculate frequency dependent dielectric constants

-   \- Compute the total dipole plus fluctuations

-   \- Analyze distance restraints

-   \- Calculate distances between pairs of positions

-   \- Analyze density of states and properties based on that

-   \- Calculate protein secondary structure via DSSP algorithm

-   \- Make binary files human readable

-   \- Extract dye dynamics from trajectories

-   \- Convert and manipulates structure files

-   \- Convert energy files

-   \- Extract an energy matrix from an energy file

-   \- Writes energies to xvg files and display averages

-   \- Allows extracting frames corresponding to clusters from
    trajectory

-   \- Frequency filter trajectories, useful for making smooth movies

-   \- Calculate free volume

-   \- Calculate angles

-   \- Multiply a conformation in â€˜randomâ€™ orientations

-   \- Generate monoatomic ions on energetically favorable positions

-   \- Generate position restraints or distance restraints for index
    groups

-   \- Make a run input file

-   \- Calculate radius of gyration of a molecule

-   \- Calculate the radius of gyration

-   \- Compute the orientation of water molecules

-   \- Compute and analyze hydrogen bonds.

-   \- Compute and analyze hydrogen bonds

-   \- Calculate basic properties of alpha helices

-   \- Calculate local pitch/bending/rotation/orientation inside helices

-   \- Print help information

-   \- Compute tetrahedrality parameters around a given atom

-   \- Insert molecules into existing vacancies

-   \- Estimate free energy from linear combinations

-   \- Generate input files for essential dynamics sampling

-   \- Make index files

-   \- Calculate residue contact maps

-   \- Perform a simulation, do a normal mode analysis or an energy
    minimization

-   \- Calculate the minimum distance between two groups

-   \- Generate index files for â€˜gmx angleâ€™

-   \- Compute mean squared displacements

-   \- Diagonalize the Hessian for normal mode analysis

-   \- Generate an ensemble of structures from the normal modes

-   \- Analyze nuclear magnetic resonance properties from an energy file

-   \- Generate a virtual oscillating trajectory from an eigenvector

-   \- Benchmarking tool for the non-bonded pair kernels.

-   \- Compute the order parameter per atom for carbon tails

-   \- Calculate pairwise distances between groups of positions

-   \- Convert coordinate files to topology and FF-compliant coordinate
    files

-   \- Estimate the error of using PME with a given input file

-   \- Calculate static properties of polymers

-   \- Calculate the electrostatic potential across the box

-   \- Calculate principal axes of inertia for a group of atoms

-   \- Compute Ramachandran plots

-   \- Calculate radial distribution functions

-   \- Write short summary about the simulation setup to a text file
    and/or to the standard output.

-   \- Calculate RMSDs with a reference structure and RMSD matrices

-   \- Calculate atom pair distances averaged with power -2, -3 or -6

-   \- Calculate atomic fluctuations

-   \- Calculate the rotational correlation function for molecules

-   \- Plot the rotation matrix for fitting to a reference structure

-   \- Compute salt bridges

-   \- Compute small angle neutron scattering spectra

-   \- Compute solvent accessible surface area

-   \- Compute small angle X-ray scattering spectra

-   \- Calculate small angle scattering profiles for SANS or SAXS

-   \- Print general information about selections

-   \- Compute free energies or other histograms from histograms

-   \- Convert c6/12 or c6/cn combinations to and from sigma/epsilon

-   \- Solvate a system

-   \- Analyze solvent orientation around solutes

-   \- Calculate the spatial distribution function

-   \- Analyze solvent dipole orientation and polarization around
    solutes

-   \- Calculate viscosities of liquids

-   \- Plot x, v, f, box, temperature and rotational energy from
    trajectories

-   \- Print coordinates, velocities, and/or forces for selections

-   \- Concatenate trajectory files

-   \- Convert and manipulates trajectory files

-   \- Order molecules according to their distance to a group

-   \- Time mdrun as a function of PME ranks to optimize settings

-   \- Compute Van Hove displacement and correlation functions

-   \- Calculate velocity autocorrelation functions

-   \- Perform weighted histogram analysis after umbrella sampling

-   \- Plot helical wheels

-   \- Generate a primitive topology from coordinates

-   \- Convert XPM (XPixelMap) matrices to postscript or XPM
:::

::: {#commands-by-topic .section}
## Commands by topic

::: {#trajectory-analysis .section}
### Trajectory analysis

:   Calculate angles

:   Converts between different trajectory types

:   Calculate distances between pairs of positions

:   Calculate protein secondary structure via DSSP algorithm

:   Allows extracting frames corresponding to clusters from trajectory

:   Calculate free volume

:   Compute and analyze hydrogen bonds.

:   Compute mean squared displacements

:   Calculate pairwise distances between groups of positions

:   Calculate radial distribution functions

:   Compute solvent accessible surface area

:   Calculate small angle scattering profiles for SANS or SAXS

:   Print general information about selections

:   Print coordinates, velocities, and/or forces for selections

:   Calculate radius of gyration of a molecule
:::

::: {#generating-topologies-and-coordinates .section}
### Generating topologies and coordinates

:   Edit the box and write subgroups

:   Generate a primitive topology from coordinates

:   Solvate a system

:   Insert molecules into existing vacancies

:   Multiply a conformation in â€˜randomâ€™ orientations

:   Generate monoatomic ions on energetically favorable positions

:   Generate position restraints or distance restraints for index groups

:   Convert coordinate files to topology and FF-compliant coordinate
    files
:::

::: {#running-a-simulation .section}
### Running a simulation

:   Make a run input file

:   Perform a simulation, do a normal mode analysis or an energy
    minimization

:   Make a modified run-input file
:::

::: {#viewing-trajectories .section}
### Viewing trajectories

:   Generate a virtual oscillating trajectory from an eigenvector
:::

::: {#processing-energies .section}
### Processing energies

:   Extract an energy matrix from an energy file

:   Writes energies to xvg files and display averages

:   (Re)calculate energies for trajectory frames with -rerun
:::

::: {#converting-files .section}
### Converting files

:   Convert and manipulates structure files

:   Convert energy files

:   Convert c6/12 or c6/cn combinations to and from sigma/epsilon

:   Concatenate trajectory files

:   Convert and manipulates trajectory files

:   Convert XPM (XPixelMap) matrices to postscript or XPM
:::

::: {#tools .section}
### Tools

:   Analyze data sets

:   Extract data from an accelerated weight histogram (AWH) run

:   Frequency filter trajectories, useful for making smooth movies

:   Estimate free energy from linear combinations

:   Estimate the error of using PME with a given input file

:   Compute free energies or other histograms from histograms

:   Calculate the spatial distribution function

:   Plot x, v, f, box, temperature and rotational energy from
    trajectories

:   Time mdrun as a function of PME ranks to optimize settings

:   Perform weighted histogram analysis after umbrella sampling

:   Check and compare files

:   Make binary files human readable

:   Make index files

:   Generate index files for â€˜gmx angleâ€™

:   Order molecules according to their distance to a group

:   Convert XPM (XPixelMap) matrices to postscript or XPM

:   Write short summary about the simulation setup to a text file and/or
    to the standard output.
:::

::: {#distances-between-structures .section}
### Distances between structures

:   Cluster structures

:   Fit two structures and calculates the RMSD

:   Calculate RMSDs with a reference structure and RMSD matrices

:   Calculate atomic fluctuations
:::

::: {#distances-in-structures-over-time .section}
### Distances in structures over time

:   Calculate the minimum distance between two groups

:   Calculate residue contact maps

:   Calculate static properties of polymers

:   Calculate atom pair distances averaged with power -2, -3 or -6
:::

::: {#mass-distribution-properties-over-time .section}
### Mass distribution properties over time

:   Calculate the radius of gyration

:   Calculate static properties of polymers

:   Calculate radial distribution functions

:   Calculate the rotational correlation function for molecules

:   Plot the rotation matrix for fitting to a reference structure

:   Compute small angle neutron scattering spectra

:   Compute small angle X-ray scattering spectra

:   Plot x, v, f, box, temperature and rotational energy from
    trajectories

:   Compute Van Hove displacement and correlation functions
:::

::: {#analyzing-bonded-interactions .section}
### Analyzing bonded interactions

:   Calculate distributions and correlations for angles and dihedrals

:   Generate index files for â€˜gmx angleâ€™
:::

::: {#structural-properties .section}
### Structural properties

:   Analyze bundles of axes, e.g., helices

:   Calculate size distributions of atomic clusters

:   Analyze distance restraints

:   Compute and analyze hydrogen bonds

:   Compute the order parameter per atom for carbon tails

:   Calculate principal axes of inertia for a group of atoms

:   Calculate radial distribution functions

:   Compute salt bridges

:   Analyze solvent orientation around solutes

:   Analyze solvent dipole orientation and polarization around solutes
:::

::: {#kinetic-properties .section}
### Kinetic properties

:   Calculate free energy difference estimates through Bennettâ€™s
    acceptance ratio

:   Calculate dielectric constants and current autocorrelation function

:   Analyze density of states and properties based on that

:   Extract dye dynamics from trajectories

:   Calculate principal axes of inertia for a group of atoms

:   Calculate viscosities of liquids

:   Plot x, v, f, box, temperature and rotational energy from
    trajectories

:   Compute Van Hove displacement and correlation functions

:   Calculate velocity autocorrelation functions
:::

::: {#electrostatic-properties .section}
### Electrostatic properties

:   Calculate dielectric constants and current autocorrelation function

:   Calculate frequency dependent dielectric constants

:   Compute the total dipole plus fluctuations

:   Calculate the electrostatic potential across the box

:   Analyze solvent dipole orientation and polarization around solutes

:   Generate monoatomic ions on energetically favorable positions
:::

::: {#protein-specific-analysis .section}
### Protein-specific analysis

:   Calculate everything you want to know about chi and other dihedrals

:   Calculate basic properties of alpha helices

:   Calculate local pitch/bending/rotation/orientation inside helices

:   Compute Ramachandran plots

:   Plot helical wheels
:::

::: {#interfaces .section}
### Interfaces

:   Analyze bundles of axes, e.g., helices

:   Calculate the density of the system

:   Calculate 2D planar or axial-radial density maps

:   Calculate surface fluctuations

:   Compute the orientation of water molecules

:   Compute tetrahedrality parameters around a given atom

:   Compute the order parameter per atom for carbon tails

:   Calculate the electrostatic potential across the box
:::

::: {#covariance-analysis .section}
### Covariance analysis

:   Analyze the eigenvectors

:   Calculate and diagonalize the covariance matrix

:   Generate input files for essential dynamics sampling
:::

::: {#normal-modes .section}
### Normal modes

:   Analyze the normal modes

:   Diagonalize the Hessian for normal mode analysis

:   Generate a virtual oscillating trajectory from an eigenvector

:   Generate an ensemble of structures from the normal modes

:   Make a run input file

:   Find a potential energy minimum and calculate the Hessian
:::
:::

::: {#special-topics .section}
## Special topics

The information in these topics is also accessible through ` `{.samp
.docutils .literal .notranslate}[` gmx `{.samp .docutils .literal
.notranslate}]{.pre}` `{.samp .docutils .literal
.notranslate}[` help `{.samp .docutils .literal
.notranslate}]{.pre}` `{.samp .docutils .literal
.notranslate}*[` topic `{.samp .docutils .literal
.notranslate}]{.pre}*` `{.samp .docutils .literal .notranslate} on the
command line.

::: {#selection-syntax-and-usage .section}
### Selection syntax and usage

::: {.toctree-wrapper .compound}
-   -   
    -   
    -   
    -   
    -   -   
        -   
        -   
        -   
        -   
        -   
        -   
    -   
    -   
    -   
:::
:::
:::

::: {#command-changes-between-versions .section}
[ ]{#command-changes}

## Command changes between versions

Starting from GROMACS 5.0, some of the analysis commands (and a few
other commands as well) have changed significantly.

One main driver for this has been that many new tools mentioned below
now accept selections through one or more command-line options instead
of prompting for a static index group. To take full advantage of
selections, the interface to the commands has changed somewhat, and some
previous command-line options are no longer present as the same effect
can be achieved with suitable selections. Please see additional
information on how to use selections.

In the process, some old analysis commands have been removed in favor of
more powerful functionality that is available through an alternative
tool. For removed or replaced commands, this page documents how to
perform the same tasks with new tools. For new commands, a brief note on
the available features is given. See the linked help for the new
commands for a full description.

This section lists only major changes; minor changes like
additional/removed options or bug fixes are not typically included.

For more information about changed features, please check out the .

::: {#version-2020 .section}
### Version 2020

::: {#gmx-convert-trj .section}
#### gmx convert-trj

**new**

has been introduced as a selection-enabled alternative for exchanging
trajectory file format (previously done in ).
:::

::: {#gmx-extract-cluster .section}
#### gmx extract-cluster

**new**

has been introduced as a selection-enabled way to write sub-trajectories
based on the output from a cluster analysis. The corresponding option
**-sub** in has been removed.
:::
:::

::: {#version-2018 .section}
### Version 2018

::: {#gmx-trajectory .section}
#### gmx trajectory

**new**

has been introduced as a selection-enabled version of . It supports
output of coordinates, velocities, and/or forces for positions
calculated for selections.
:::
:::

::: {#version-2016 .section}
### Version 2016

::: {#analysis-on-arbitrary-subsets-of-atoms .section}
#### Analysis on arbitrary subsets of atoms

Tools implemented in the new analysis framework can now operate upon
trajectories that match only a subset of the atoms in the input
structure file.
:::

::: {#gmx-insert-molecules .section}
#### gmx insert-molecules

**improved**

has gained an option ` `{.docutils .literal
.notranslate}[` -replace `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} that makes it
possible to insert molecules into a solvated configuration, replacing
any overlapping solvent atoms. In a fully solvated box, it is also
possible to insert into a certain region of the solvent only by
selecting a subset of the solvent atoms ( ` `{.docutils .literal
.notranslate}[` -replace `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} takes a
selection that can also contain expressions like ` `{.docutils .literal
.notranslate}[` not `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` within `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate}[` 1 `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` of `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` ... `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ).
:::

::: {#gmx-rdf .section}
#### gmx rdf

**improved**

The normalization for the output RDF can now also be the radial number
density.
:::

::: {#gmx-genconf .section}
#### gmx genconf

**simplified**

Removed ` `{.docutils .literal .notranslate}[` -block `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} ,
` `{.docutils .literal .notranslate}[` -sort `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` -shuffle `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} .
:::
:::

::: {#version-5-1 .section}
### Version 5.1

::: {#general .section}
#### General

Symbolic links from 5.0 are no longer supported. The only way to invoke
a command is through ` `{.samp .docutils .literal
.notranslate}[` gmx `{.samp .docutils .literal
.notranslate}]{.pre}` `{.samp .docutils .literal
.notranslate}*[` <command> `{.samp .docutils .literal
.notranslate}]{.pre}*` `{.samp .docutils .literal .notranslate} .
:::

::: {#gmx-pairdist .section}
#### gmx pairdist

**new**

has been introduced as a selection-enabled replacement for (
` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` mindist `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} still exists
unchanged). It can calculate min/max pairwise distances between a pair
of selections, including, e.g., per-residue minimum distances or
distances from a single point to a set of residue-centers-of-mass.
:::

::: {#id1 .section}
#### gmx rdf

**rewritten**

has been rewritten for 5.1 to use selections for specifying the points
from which the RDFs are calculated. The interface is mostly the same,
except that there are new command-line options to specify the
selections. The following additional changes have been made:

-   ` `{.docutils .literal .notranslate}[` -com `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} and
    ` `{.docutils .literal .notranslate}[` -rdf `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} options
    have been removed. Equivalent functionality is available through
    selections:

    -   ` `{.docutils .literal .notranslate}[` -com `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal .notranslate} can be
        replaced with a ` `{.samp .docutils .literal
        .notranslate}[` com `{.samp .docutils .literal
        .notranslate}]{.pre}` `{.samp .docutils .literal
        .notranslate}[` of `{.samp .docutils .literal
        .notranslate}]{.pre}` `{.samp .docutils .literal
        .notranslate}*[` <selection> `{.samp .docutils .literal
        .notranslate}]{.pre}*` `{.samp .docutils .literal .notranslate}
        as the reference selection.

    -   ` `{.docutils .literal .notranslate}[` -rdf `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal .notranslate} can be
        replaced with a suitable set of selections (e.g., ` `{.samp
        .docutils .literal .notranslate}[` res_com `{.samp .docutils
        .literal .notranslate}]{.pre}` `{.samp .docutils .literal
        .notranslate}[` of `{.samp .docutils .literal
        .notranslate}]{.pre}` `{.samp .docutils .literal
        .notranslate}*[` <selection> `{.samp .docutils .literal
        .notranslate}]{.pre}*` `{.samp .docutils .literal .notranslate}
        ) and/or using ` `{.docutils .literal
        .notranslate}[` -seltype `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal .notranslate} .

-   ` `{.docutils .literal .notranslate}[` -rmax `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} option is
    added to specify a cutoff for the RDFs. If set to a value that is
    significantly smaller than half the box size, it can speed up the
    calculation significantly if a grid-based neighborhood search can be
    used.

-   ` `{.docutils .literal .notranslate}[` -hq `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} and
    ` `{.docutils .literal .notranslate}[` -fade `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} options
    have been removed, as they are simply postprocessing steps on the
    raw numbers that can be easily done after the analysis.
:::
:::

::: {#version-5-0 .section}
### Version 5.0

::: {#id2 .section}
#### General

Version 5.0 introduced the **gmx** wrapper binary. For backwards
compatibility, this version still creates symbolic links by default for
old tools: e.g., ` `{.docutils .literal
.notranslate}[` g_order `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` <options> `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} is equivalent
to ` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` order `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` <options> `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , and
` `{.docutils .literal .notranslate}[` g_order `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} is simply a
symbolic link on the file system.
:::

::: {#g-bond .section}
#### g_bond

**replaced**

This tool has been removed in 5.0. A replacement is .

You can provide your existing index file to , and it will calculate the
same distances. The differences are:

-   ` `{.docutils .literal .notranslate}[` -blen `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} and
    ` `{.docutils .literal .notranslate}[` -tol `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} options
    have different default values.

-   You can control the output histogram with ` `{.docutils .literal
    .notranslate}[` -binw `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} .

-   ` `{.docutils .literal .notranslate}[` -aver `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} and
    ` `{.docutils .literal .notranslate}[` -averdist `{.docutils
    .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}
    options are not present. Instead, you can choose between the
    different things to calculate using ` `{.docutils .literal
    .notranslate}[` -oav `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate}
    (corresponds to ` `{.docutils .literal
    .notranslate}[` -d `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} with
    ` `{.docutils .literal .notranslate}[` -averdist `{.docutils
    .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} ),
    ` `{.docutils .literal .notranslate}[` -oall `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate}
    (corresponds to ` `{.docutils .literal
    .notranslate}[` -d `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} without
    ` `{.docutils .literal .notranslate}[` -averdist `{.docutils
    .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} ),
    ` `{.docutils .literal .notranslate}[` -oh `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate}
    (corresponds to ` `{.docutils .literal
    .notranslate}[` -o `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} with
    ` `{.docutils .literal .notranslate}[` -aver `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} ), and
    ` `{.docutils .literal .notranslate}[` -oallstat `{.docutils
    .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}
    (corresponds to ` `{.docutils .literal
    .notranslate}[` -l `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} without
    ` `{.docutils .literal .notranslate}[` -aver `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} ).

You can produce any combination of output files. Compared to
` `{.docutils .literal .notranslate}[` g_bond `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , ` `{.docutils
.literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` distance `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` -oall `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} is currently
missing labels for the output columns.
:::

::: {#g-dist .section}
#### g_dist

**replaced**

This tool has been removed in 5.0. A replacement is (for most options)
or (for ` `{.docutils .literal .notranslate}[` -dist `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} or
` `{.docutils .literal .notranslate}[` -lt `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ).

If you had index groups A and B in ` `{.file .docutils .literal
.notranslate}[` index.ndx `{.file .docutils .literal
.notranslate}]{.pre}` `{.file .docutils .literal .notranslate} for
` `{.docutils .literal .notranslate}[` g_dist `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , you can use
the following command to compute the same distance with ` `{.docutils
.literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` distance `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} :

::: {.highlight-default .notranslate}
::: highlight
    gmx distance -n index.ndx -select 'com of group "A" plus com of group "B"' -oxyz -oall
:::
:::

The ` `{.docutils .literal .notranslate}[` -intra `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} switch is
replaced with ` `{.docutils .literal .notranslate}[` -nopbc `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} .

If you used ` `{.docutils .literal .notranslate}[` -dist `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` D `{.docutils .literal .notranslate}]{.pre}` `{.docutils
.literal .notranslate} , you can do the same calculation with
` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` select `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} :

::: {.highlight-default .notranslate}
::: highlight
    gmx select -n index.ndx -select 'group "B" and within D of com of group "A"' -on/-oi/-os/-olt
:::
:::

You can select the output option that best suits your post-processing
needs ( ` `{.docutils .literal .notranslate}[` -olt `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} is a
replacement for ` `{.docutils .literal
.notranslate}[` g_dist `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` -dist `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` -lt `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} )
:::

::: {#gmx-distance .section}
#### gmx distance

**new**

has been introduced as a selection-enabled replacement for various tools
that computed distances between fixed pairs of atoms (or centers-of-mass
of groups). It has a combination of the features of ` `{.docutils
.literal .notranslate}[` g_bond `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` g_dist `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , allowing
computation of one or multiple distances, either between atom-atom pairs
or centers-of-mass of groups, and providing a combination of output
options that were available in one of the tools.
:::

::: {#gmx-gangle .section}
#### gmx gangle

**new**

has been introduced as a selection-enabled replacement for ` `{.docutils
.literal .notranslate}[` g_sgangle `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . In addition
to supporting atom-atom vectors, centers-of-mass can be used as
endpoints of the vectors, and there are a few additional angle types
that can be calculated. The command also has basic support for
calculating normal angles between three atoms and/or centers-of-mass,
making it a partial replacement for as well.
:::

::: {#gmx-protonate .section}
#### gmx protonate

**replaced**

This was a very old tool originally written for united atom force
fields, where it was necessary to generate all hydrogens after running a
trajectory in order to calculate e.g. distance restraint violations. The
functionality to simply protonate a structure is available in . If there
is significant interest, we might reintroduce it after moving to new
topology formats in the future.
:::

::: {#gmx-freevolume .section}
#### gmx freevolume

**new**

This tool has been introduced in 5.0. It uses a Monte Carlo sampling
method to calculate the fraction of free volume within the box (using a
probe of a given size).
:::

::: {#g-sas .section}
#### g_sas

**rewritten**

This tool has been rewritten in 5.0, and renamed to (the underlying
surface area calculation algorithm is still the same).

The main difference in the new tool is support for selections. Instead
of prompting for an index group, a (potentially dynamic) selection for
the calculation can be given with ` `{.docutils .literal
.notranslate}[` -surface `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . Any number of
output groups can be given with ` `{.docutils .literal
.notranslate}[` -output `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , allowing
multiple parts of the surface area to be computed in a single run. The
total area of the ` `{.docutils .literal
.notranslate}[` -surface `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} group is now
always calculated.

The tool no longer automatically divides the surface into hydrophobic
and hydrophilic areas, and there is no ` `{.docutils .literal
.notranslate}[` -f_index `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} option. The
same effects can be obtained by defining suitable selections for
` `{.docutils .literal .notranslate}[` -output `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . If you want
output that contains the same numbers as with the old tool for a
calculation group ` `{.docutils .literal .notranslate}[` A `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} and
output group ` `{.docutils .literal .notranslate}[` B `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} , you
can use

::: {.highlight-default .notranslate}
::: highlight
    gmx sasa -surface 'group "A"' -output '"Hydrophobic" group "A" and charge {-0.2 to 0.2}; "Hydrophilic" group "B" and not charge {-0.2 to 0.2}; "Total" group "B"'
:::
:::

Solvation free energy estimates are now calculated only if separately
requested with ` `{.docutils .literal .notranslate}[` -odg `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} , and
are written into a separate file.

Output option ` `{.docutils .literal .notranslate}[` -i `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} for a
position restraint file is not currently implemented in the new tool,
but would not be very difficult to add if requested.
:::

::: {#g-sgangle .section}
#### g_sgangle

**replaced**

This tool has been removed in 5.0. A replacement is (for angle
calculation) and (for ` `{.docutils .literal
.notranslate}[` -od `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , ` `{.docutils
.literal .notranslate}[` -od1 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , ` `{.docutils
.literal .notranslate}[` -od2 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ).

If you had index groups A and B in index.ndx for ` `{.docutils .literal
.notranslate}[` g_sgangle `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , you can use
the following command to compute the same angle with ` `{.docutils
.literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` gangle `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} :

::: {.highlight-default .notranslate}
::: highlight
    gmx gangle -n index.ndx -g1 vector/plane -group1 'group "A"' -g2 vector/plane -group2 'group "B"' -oav
:::
:::

You need to select either ` `{.docutils .literal
.notranslate}[` vector `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} or
` `{.docutils .literal .notranslate}[` plane `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} for the
` `{.docutils .literal .notranslate}[` -g1 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` -g2 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} options
depending on which one your index groups specify.

If you only had a single index group A in index.ndx and you used
` `{.docutils .literal .notranslate}[` g_sgangle `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ` `{.docutils
.literal .notranslate}[` -z `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} or
` `{.docutils .literal .notranslate}[` -one `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , you can use:

::: {.highlight-default .notranslate}
::: highlight
    gmx gangle -n index.ndx -g1 vector/plane -group1 'group "A"' -g2 z/t0 -oav
:::
:::

For the distances, you can use to compute one or more distances as you
want. Both distances between centers of groups or individual atoms are
supported using the new selection syntax.
:::

::: {#genbox .section}
#### genbox

This tool has been split to and .
:::

::: {#tpbconv .section}
#### tpbconv

This tool has been renamed .
:::
:::
:::
:::
::: {#common-errors-when-using-gromacs .section}
# Common errors when using GROMACS

The vast majority of error messages generated by GROMACS are
descriptive, informing the user where the exact error lies. Some errors
that arise are noted below, along with more details on what the issue is
and how to solve it.

::: {#common-errors-during-usage .section}
[ ]{#common-errors}

## Common errors during usage

::: {#out-of-memory-when-allocating .section}
[ ]{#out-of-memory}

### Out of memory when allocating

The program has attempted to assign memory to be used in the
calculation, but is unable to due to insufficient memory.

Possible solutions are:

-   reduce the scope of the number of atoms selected for analysis.

-   reduce the length of trajectory file being processed.

-   in some cases confusion between Ã...ngstrÃ¶m and nm may lead to
    users generating a water box that is 10 ^3^ times larger than what
    they think it is (e.g. ).

-   use a computer with more memory.

-   install more memory in the computer.

The user should bear in mind that the cost in time and/or memory for
various activities will scale with the number of atoms/groups/residues
*N* or the simulation length *T* as order N, NlogN, or N ^2^ (or maybe
worse!) and the same for *T* , depending on the type of activity. If it
takes a long time, have a think about what you are doing, and the
underlying algorithm (see the , man page, or use the -h flag for the
utility), and see if thereâ€™s something sensible you can do that has
better scaling properties.
:::
:::

::: {#errors-in-pdb2gmx .section}
[ ]{#pdb2gmx-errors}

## Errors in

::: {#residue-xxx-not-found-in-residue-topology-database .section}
### Residue â€˜XXXâ€™ not found in residue topology database

This means that the force field you have selected while running does not
have an entry in the for XXX. The entry is necessary both for
stand-alone molecules (e.g. formaldehyde) or a peptide (standard or
non-standard). This entry defines the atom types, connectivity, bonded
and non-bonded interaction types for the residue and is necessary to use
to build a file. A entry may be missing simply because the database does
not contain the residue at all, or because the name is different.

For new users, this error appears because they are running on a file
they have, without consideration of the contents of the file. A is not
magical, it can only deal with molecules or residues (building blocks)
that are provided in the or included otherwise.

If you want to use to automatically generate your topology, you have to
ensure that the appropriate entry is present within the desired and has
the same name as the building block you are trying to use. If you call
your molecule â€œHIS,â€? then will try to build histidine, based on the
` `{.docutils .literal .notranslate}[` [ `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` HIS `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate}[` ] `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} entry
in the file, so it will look for the exact atomic entries for histidine,
no more no less.

If you want a for an arbitrary molecule, you cannot use (unless you
build the entry yourself). You will have to build that entry by hand, or
use another program (such as or one of the scripts contributed by users)
to build the file.

If there is not an entry for this residue in the database, then the
options for obtaining the force field parameters are:

-   see if there is a different name being used for the residue in the
    and rename as appropriate,

-   parameterize the residue / molecule yourself (lots of work, even for
    an expert),

-   find a for the molecule, convert it to an file and include it in
    your file,

-   use another which has parameters available for this,

-   search the primary literature for publications for parameters for
    the residue that are consistent with the force field that is being
    used.

Once you have determined the parameters and topology for your residue,
see for instructions on how to proceed.
:::

::: {#long-bonds-and-or-missing-atoms .section}
### Long bonds and/or missing atoms

There are probably atoms missing earlier in the file which makes go
crazy. Check the screen output of , as it will tell you which one is
missing. Then add the atoms in your file, energy minimization will put
them in the right place, or fix the side chain with e.g. the program.
:::

::: {#chain-identifier-x-was-used-in-two-non-sequential-blocks .section}
### Chain identifier â€˜Xâ€™ was used in two non-sequential blocks

This means that within the fed to , the X chain has been split, possibly
by the incorrect insertion of one molecule within another. The solution
is simple: move the inserted molecule to a location within the file so
that it is not splitting another molecule. This message may also mean
that the same chain identifier has been used for two separate chains. In
that case, rename the second chain to a unique identifier.
:::

::: {#warning-atom-x-is-missing-in-residue-xxx-y-in-the-pdb-file .section}
[ ]{#gmx-atom-missing}

### WARNING: atom X is missing in residue XXX Y in the pdb file

Related to the long bonds/missing atoms error above, this error is
usually quite obvious in its meaning. That is, expects certain atoms
within the given residue, based on the entries in the force field file.
There are several cases to which this error applies:

-   Missing hydrogen atoms; the error message may be suggesting that an
    entry in the file is missing. More likely, the nomenclature of your
    hydrogen atoms simply does not match what is expected by the entry.
    In this case, use ` `{.docutils .literal
    .notranslate}[` -ignh `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} to allow to
    add the correct hydrogens for you, or re-name the problematic atoms.

-   A terminal residue (usually the N-terminus) is missing H atoms; this
    usually suggests that the proper ` `{.docutils .literal
    .notranslate}[` -ter `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} option has
    not been supplied or chosen properly. In the case of the ,
    nomenclature is typically the problem. N-terminal and C-terminal
    residues must be prefixed by N and C, respectively. For example, an
    N-terminal alanine should not be listed in the file as ` `{.docutils
    .literal .notranslate}[` ALA `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} , but
    rather ` `{.docutils .literal .notranslate}[` NALA `{.docutils
    .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} ,
    as specified in the instructions.

-   Atoms are simply missing in the structure file provided to ; look
    for ` `{.docutils .literal .notranslate}[` REMARK `{.docutils
    .literal .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` 465 `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} and
    ` `{.docutils .literal .notranslate}[` REMARK `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` 470 `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} entries in
    the file. These atoms will have to be modeled in using external
    software. There is no GROMACS tool to re-construct incomplete
    models.

Contrary to what the error message says, the use of the option
` `{.docutils .literal .notranslate}[` -missing `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} is almost
always inappropriate. The ` `{.docutils .literal
.notranslate}[` -missing `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} option should
only be used to generate specialized topologies for amino acid-like
molecules to take advantage of entries. If you find yourself using
` `{.docutils .literal .notranslate}[` -missing `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} in order to
generate a topology for a protein or nucleic acid, donâ€™t; the topology
produced is likely physically unrealistic.
:::

::: {#atom-x-in-residue-yyy-not-found-in-rtp-entry .section}
### Atom X in residue YYY not found in rtp entry

If you are attempting to assemble a topology using , the atom names are
expected to match those found in the file that define the building
block(s) in your structure. In most cases, the problem arises from a
naming mismatch, so simply re-name the atoms in your appropriately. In
other cases, you may be supplying a structure that has residues that do
not conform to the expectations of the , in which case you should
investigate why such a difference is occurring and make a decision based
on what you find - use a different , manually edit the structure, etc.
:::

::: {#no-force-fields-found-files-with-name-forcefield-itp-in-subdirectories-ending-on-ff .section}
### No force fields found (files with name â€˜forcefield.itpâ€™ in subdirectories ending on â€˜.ffâ€™)

This means your environment is not configured to use GROMACS properly,
because cannot find its databases of forcefield information. This could
happen because a GROMACS installation was moved from one location to
another. Either follow the instructions about or re-install GROMACS
before doing so.
:::
:::

::: {#errors-in-grompp .section}
## Errors in

::: {#found-a-second-defaults-directive-file .section}
### Found a second defaults directive file

This is caused by the ` `{.docutils .literal
.notranslate}[` [defaults] `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} directive
appearing more than once in the or files for the system - it can only
appear once. A typical cause of this is a second defaults being set in
an included file, , that has been sourced from somewhere else. For
specifications on how the topology files work, see the , Section 5.6.:

::: {.highlight-default .notranslate}
::: highlight
    [ defaults ]
    ; nbfunc comb-rule gen-pairs fudgeLJ fudgeQQ
    1       1       no       1.0       1.0
:::
:::

One solution is to simply comment out (or delete) the lines of code out
in the file where it is included for the second time i.e.,:

::: {.highlight-default .notranslate}
::: highlight
    ;[ defaults ]
    ; nbfunc comb-rule gen-pairs fudgeLJ fudgeQQ
    ;1       1       no       1.0       1.0
:::
:::

A better approach to finding a solution is to re-think what you are
doing. The ` `{.docutils .literal .notranslate}[` [defaults] `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}
directive should only be appearing at the top of your file where you
choose the . If you are trying to mix two , then you are asking for
trouble. If a molecule file tries to choose a force field, then whoever
produced it is asking for trouble.
:::

::: {#invalid-order-for-directive-xxx .section}
### Invalid order for directive xxx

The directives in the .top and .itp files have rules about the order in
which they can appear, and this error is seen when the order is
violated. Consider the examples and discussion in chapter 5 of the ,
and/or from tutorial material. The cannot be used to ` `{.docutils
.literal .notranslate}[` #include `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} a file in just
any old location, because they contain directives and these have to be
properly placed.

In particular, ` `{.docutils .literal
.notranslate}[` Invalid `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` order `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` for `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` directive `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` defaults `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} is a result of
defaults being set in the or files in the inappropriate location; the
` `{.docutils .literal .notranslate}[` [defaults] `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} section can
only appear once and must be the first directive in the . The
` `{.docutils .literal .notranslate}[` [defaults] `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} directive is
typically present in the file (forcefield.itp), and is added to the when
you ` `{.docutils .literal .notranslate}[` #include `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} this file in
the system topology.

If the directive in question is ` `{.docutils .literal
.notranslate}[` [atomtypes] `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} (which is the
most common source of this error) or any other bonded or nonbonded
` `{.docutils .literal .notranslate}[` [*types] `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} directive,
typically the user is adding some non-standard species (ligand, solvent,
etc) that introduces new atom types or parameters into the system. As
indicated above, these new types and parameters must appear before any
` `{.docutils .literal .notranslate}[` [moleculetype] `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}
directive. The has to be fully constructed before any molecules can be
defined.
:::

::: {#atom-index-n-in-position-restraints-out-of-bounds .section}
### Atom index n in position_restraints out of bounds

A common problem is placing position restraint files for multiple
molecules out of order. Recall that a position restraint file containing
a ` `{.docutils .literal .notranslate}[` [ `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` position_restraints `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate}[` ] `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} block
can only belong to the ` `{.docutils .literal
.notranslate}[` [ `{.docutils .literal .notranslate}]{.pre}` `{.docutils
.literal .notranslate}[` moleculetype `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate}[` ] `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} block
that contains it. For example:

WRONG:

::: {.highlight-default .notranslate}
::: highlight
    #include "topol_A.itp"
    #include "topol_B.itp"
    #include "ligand.itp"

    #ifdef POSRES
    #include "posre_A.itp"
    #include "posre_B.itp"
    #include "ligand_posre.itp"
    #endif
:::
:::

RIGHT:

::: {.highlight-default .notranslate}
::: highlight
    #include "topol_A.itp"
    #ifdef POSRES
    #include "posre_A.itp"
    #endif

    #include "topol_B.itp"
    #ifdef POSRES
    #include "posre_B.itp"
    #endif

    #include "ligand.itp"
    #ifdef POSRES
    #include "ligand_posre.itp"
    #endif
:::
:::

Further, the atom index of each ` `{.docutils .literal
.notranslate}[` [position_restraint] `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} must be
relative to the ` `{.docutils .literal
.notranslate}[` [moleculetype] `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , not relative
to the system (because the parsing has not reached ` `{.docutils
.literal .notranslate}[` [molecules] `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} yet, there is
no such concept as â€œsystemâ€?). So you cannot use the output of a tool
like blindly (as ` `{.docutils .literal
.notranslate}[` genrestr `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` -h `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} warns).
:::

::: {#system-has-non-zero-total-charge .section}
### System has non-zero total charge

Notifies you that counter-ions may be required for the system to
neutralize the charge or there may be problems with the topology.

If the charge is not very close to an integer, then this indicates that
there is a problem with the . If has been used, then look at the
right-hand comment column of the atom listing, which lists the
cumulative charge. This should be an integer after every residue (and/or
charge group where applicable). This will assist in finding the residue
where things start departing from integer values. Also check the
terminal capping groups that have been used.

If the charge is already close to an integer, then the difference is
caused by and not a major problem.

Note for PME users: It is possible to use a uniform neutralizing
background charge in PME to compensate for a system with a net
background charge. This may however, especially for non-homogeneous
systems, lead to unwanted artifacts, as shown in ( ). Nevertheless, it
is a standard practice to actually add counter-ions to make the system
net neutral.
:::

::: {#incorrect-number-of-parameters .section}
### Incorrect number of parameters

Look at the file for the system. Youâ€™ve not given enough parameters
for one of the bonded definitions. Sometimes this also occurs if
youâ€™ve mangled the or the topology file format (see: Chapter 5) when
you edited the file.
:::

::: {#number-of-coordinates-in-coordinate-file-does-not-match-topology .section}
### Number of coordinates in coordinate file does not match topology

This is pointing out that, based on the information provided in the
file, , the total number of atoms or particles within the system does
not match exactly with what is provided within the , often a or a .

The most common reason for this is simply that the user has failed to
update the topology file after solvating or adding additional molecules
to the system, or made a typographical error in the number of one of the
molecules within the system. Ensure that the end of the topology file
being used contains something like the following, that matches exactly
with what is within the coordinate file being used, in terms of both
numbers and order of the molecules:

::: {.highlight-default .notranslate}
::: highlight
    [ molecules ]
    ; Compound   #mol
    Protein      1
    SOL          10189
    NA+          10
:::
:::
:::

::: {#fatal-error-no-such-moleculetype-xxx .section}
### Fatal error: No such moleculetype XXX

Each type of molecule in your ` `{.docutils .literal
.notranslate}[` [ `{.docutils .literal .notranslate}]{.pre}` `{.docutils
.literal .notranslate}[` molecules `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate}[` ] `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}
section of your file must have a corresponding ` `{.docutils .literal
.notranslate}[` [ `{.docutils .literal .notranslate}]{.pre}` `{.docutils
.literal .notranslate}[` moleculetype `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate}[` ] `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}
section defined previously, either in the file or an file. See the
section 5.6.1 for the syntax description. Your file doesnâ€™t have such
a definition for the indicated molecule. Check the contents of the
relevant files, how you have named your molecules, and how you have
tried to refer to them later. Pay attention to the status of
` `{.docutils .literal .notranslate}[` #ifdef `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and / or
` `{.docutils .literal .notranslate}[` #include `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} statements.
:::

::: {#t-coupling-group-xxx-has-fewer-than-10-of-the-atoms .section}
### T-Coupling group XXX has fewer than 10% of the atoms

It is possible to specify separate (temperature coupling groups) for
every molecule type within a simulation. This is a particularly bad
practice employed by many new users to molecular dynamics simulations.
Doing so is a bad idea, as you can introduce errors and artifacts that
are hard to predict. In some cases it is best to have all molecules
within a single group, using the default ` `{.docutils .literal
.notranslate}[` System `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} group. If
separate coupling groups are required to avoid the ` `{.docutils
.literal .notranslate}[` hot-solvent, `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` cold-solute `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} problem, then
ensure that they are of ` `{.docutils .literal
.notranslate}[` sufficient `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` size `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and combine
molecule types that appear together within the simulation. For example,
for a protein in water with counter-ions, one would likely want to use
` `{.docutils .literal .notranslate}[` Protein `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` Non-Protein `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} .
:::

::: {#the-cut-off-length-is-longer-than-half-the-shortest-box-vector-or-longer-than-the-smallest-box-diagonal-element-increase-the-box-size-or-decrease-rlist .section}
### The cut-off length is longer than half the shortest box vector or longer than the smallest box diagonal element. Increase the box size or decrease rlist

This error is generated in the cases as noted within the message. The
dimensions of the box are such that an atom will interact with itself
(when using periodic boundary conditions), thus violating the minimum
image convention. Such an event is totally unrealistic and will
introduce some serious artefacts. The solution is again what is noted
within the message, either increase the size of the simulation box so
that it is at an absolute minimum twice the cut-off length in all three
dimensions (take care here if are using pressure coupling, as the box
dimensions will change over time and if they decrease even slightly, you
will still be violating the minimum image convention) or decrease the
cut-off length (depending on the utilised, this may not be an option).
:::

::: {#atom-index-1-in-bonds-out-of-bounds .section}
### Atom index (1) in bonds out of bounds

This kind of error looks like:

::: {.highlight-default .notranslate}
::: highlight
    Fatal error:
    [ file spc.itp, line 32 ]
    Atom index (1) in bonds out of bounds (1-0).
    This probably means that you have inserted topology
    section "settles" in a part belonging to a different
    molecule than you intended to. in that case move the
    "settles" section to the right molecule.
:::
:::

This error is fairly self-explanatory. You should look at your file and
check that all of the ` `{.docutils .literal
.notranslate}[` [molecules] `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} sections
contain all of the data pertaining to that molecule, and no other data.
That is, you cannot ` `{.docutils .literal
.notranslate}[` #include `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} another
molecule type ( file) before the previous ` `{.docutils .literal
.notranslate}[` [moleculetype] `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} has ended.
Consult the examples in chapter 5 of the for information on the required
ordering of the different ` `{.docutils .literal
.notranslate}[` [sections] `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . Pay attention
to the contents of any files you have with ` `{.docutils .literal
.notranslate}[` #include `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} directives.

This error can also arise if you are using a water model that is not
enabled for use with your chosen by default. For example, if you are
attempting to use the SPC water model with an , you will see this error.
The reason is that, in ` `{.docutils .literal
.notranslate}[` spc.itp `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , there is no
` `{.docutils .literal .notranslate}[` #ifdef `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} statement
defining atom types for any of the . You can either add this section
yourself, or use a different water model.
:::

::: {#xxx-non-matching-atom-names .section}
### XXX non-matching atom names

This error usually indicates that the order of the file does not match
that of the . When running , the program reads through the , mapping the
supplied parameters to the atoms in the file. If there is a mismatch,
this error is generated. To remedy the problem, make sure that the
contents of your ` `{.docutils .literal .notranslate}[` [ `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` molecules `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate}[` ] `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}
directive matches the exact order of the atoms in the coordinate file.

In a few cases, the error is harmless. Perhaps you are using a file that
has the old (pre-4.5) ion nomenclature. In this case, allowing to
re-assign names is harmless. For just about any other situation, when
this error comes up, **it should not be ignored** . Just because the
` `{.docutils .literal .notranslate}[` -maxwarn `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} option is
available does not mean you should use it in the blind hope of your
simulation working. It will undoubtedly .
:::

::: {#the-sum-of-the-two-largest-charge-group-radii-x-is-larger-than-rlist-rvdw-rcoulomb .section}
### The sum of the two largest charge group radii (X) is larger than rlist - rvdw/rcoulomb

This error warns that some combination of settings will result in poor
energy conservation at the longest cutoff, which occurs when charge
groups move in or out of pair list range. The error can have two
sources:

-   Your charge groups encompass too many atoms. Most charge groups
    should be less than 4 atoms or less.

-   Your settings are incompatible with the chosen algorithms. For
    switch or shift functions, rlist must be larger than the longest
    cutoff ( ` `{.docutils .literal .notranslate}[` rvdw `{.docutils
    .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} or
    ` `{.docutils .literal .notranslate}[` rcoulomb `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} ) to
    provide buffer space for charge groups that move beyond the neighbor
    searching radius. If set incorrectly, you may miss interactions,
    contributing to poor energy conservation.

A similar error (â€œThe sum of the two largest charge group radii (X) is
larger than rlistâ€?) can arise under two following circumstances:

-   The charge groups are inappropriately large or rlist is set too low.

-   Molecules are broken across periodic boundaries, which is not a
    problem in a periodic system. In this case, the sum of the two
    largest charge groups will correspond to a value of twice the box
    vector along which the molecule is broken.
:::

::: {#invalid-line-in-coordinate-file-for-atom-x .section}
### Invalid line in coordinate file for atom X

This error arises if the format of the file is broken in some way. The
most common explanation is that the second line in the file specifies an
incorrect number of atoms, causing to continue searching for atoms but
finding box vectors.
:::
:::

::: {#errors-in-mdrun .section}
## Errors in

::: {#stepsize-too-small-or-no-change-in-energy-converged-to-machine-precision-but-not-to-the-requested-fmax .section}
### Stepsize too small, or no change in energy. Converged to machine precision, but not to the requested F ~max~

This may not be an error as such. It is simply informing you that during
the energy minimization process mdrun reached the limit possible to
minimize the structure with your current parameters. It does not mean
that the system has not been minimized fully, but in some situations
that may be the case. If the system has a significant amount of water
present, then an E ~pot~ of the order of -10 ^5^ to -10 ^6^ (in
conjunction with an F ~max~ between 10 and 1000 kJ mol ^-1^ nm ^-1^ ) is
typically a reasonable value for starting most MD simulations from the
resulting structure. The most important result is likely the value of F
~max~ , as it describes the slope of the potential energy surface, i.e.
how far from an energy minimum your structure lies. Only for special
purposes, such as normal mode analysis type of calculations, it may be
necessary to minimize further. Further minimization may be achieved by
using a different energy minimization method or by making use of double
precision-enabled GROMACS.
:::

::: {#energy-minimization-has-stopped-because-the-force-on-at-least-one-atom-is-not-finite .section}
### Energy minimization has stopped because the force on at least one atom is not finite

This likely indicates that (at least) two atoms are too close in the
input coordinates, and the forces exerted on each other are greater in
magnitude than can be expressed to the extent of the precision of
GROMACS, and therefore minimization cannot proceed. It is sometimes
possible to minimize systems that have infinite forces with the use of
soft-core potentials, which scale down the magnitude of Lennard-Jones
interactions with the use of the GROMACS free energy code. This approach
is an accepted workflow for equilibration of some coarse-grained systems
such as Martini.
:::

::: {#lincs-settle-shake-warnings .section}
### LINCS/SETTLE/SHAKE warnings

Sometimes, when running dynamics, may suddenly stop (perhaps after
writing several files) after a series of warnings about the constraint
algorithms (e.g. LINCS, SETTLE or SHAKE) are written to the file. These
algorithms often used to constrain bond lengths and/or angles. When a
system is (i.e. exploding due to diverging forces), the constraints are
usually the first thing to fail. This doesnâ€™t necessarily mean you
need to troubleshoot the constraint algorithm. Usually it is a sign of
something more fundamentally wrong (physically unrealistic) with your
system. See also the advice here about .
:::

::: {#interaction-not-within-cut-off .section}
### 1-4 interaction not within cut-off

Some of your atoms have moved so two atoms separated by three bonds are
separated by more than the cut-off distance. **This is BAD** . Most
importantly, **do not increase your cut-off** ! This error actually
indicates that the atoms have very large velocities, which usually means
that (part of) your molecule(s) is (are) . If you are using LINCS for
constraints, you probably also already got a number of LINCS warnings.
When using SHAKE this will give rise to a SHAKE error, which halts your
simulation before the ` `{.docutils .literal
.notranslate}[` 1-4 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` not `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` within `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` cutoff `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} error can
appear.

There can be a number of reasons for the large velocities in your
system. If it happens at the beginning of the simulation, your system
might be not equilibrated well enough (e.g. it contains some bad
contacts). Try a(nother) round of energy minimization to fix this.
Otherwise you might have a very high temperature, and/or a timestep that
is too large. Experiment with these parameters until the error stops
occurring. If this doesnâ€™t help, check the validity of the parameters
in your !
:::

::: {#simulation-running-but-no-output .section}
### Simulation running but no output

Not an error as such, but mdrun appears to be chewing up CPU time but
nothing is being written to the output files. There are a number of
reasons why this may occur:

-   Your simulation might simply be (very) , and since output is
    buffered, it can take quite some time for output to appear in the
    respective files. If you are trying to fix some problems and you
    want to get output as fast as possible, you can set the environment
    variable ` `{.docutils .literal
    .notranslate}[` GMX_LOG_BUFFER `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} to 0.

-   Something might be going wrong in your simulation, causing e.g.
    not-a-numbers (NAN) to be generated (these are the result of e.g.
    division by zero). Subsequent calculations with NANâ€™s will
    generate floating point exceptions which slow everything down by
    orders of magnitude.

-   You might have all ` `{.docutils .literal
    .notranslate}[` nst* `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} parameters
    (see your file) set to 0, this will suppress most output.

-   Your disk might be full. Eventually this will lead to crashing, but
    since output is buffered, it might take a while for mdrun to realize
    it canâ€™t write.
:::

::: {#can-not-do-conjugate-gradients-with-constraints .section}
### Can not do Conjugate Gradients with constraints

This means you canâ€™t do energy minimization with the conjugate
gradient algorithm if your topology has constraints defined. Please
check the .
:::

::: {#pressure-scaling-more-than-1 .section}
### Pressure scaling more than 1%

This error tends to be generated when the simulation box begins to
oscillate (due to large pressures and / or small coupling constants),
the system starts to resonate and . This can mean that the system
isnâ€™t equilibrated sufficiently before using pressure coupling.
Therefore, better / more equilibration may fix the issue.

It is recommended to observe the system trajectory prior and during the
crash. This may indicate if a particular part of the system / structure
is the problem.

In some cases, if the system has been equilibrated sufficiently, this
error can mean that the pressure coupling constant, , is too small
(particularly when using the Berendsen weak coupling method). Increasing
that value will slow down the response to pressure changes and may stop
the resonance from occurring. You are also more likely to see this error
if you use Parrinello-Rahman pressure coupling on a system that is not
yet equilibrated - start with the much more forgiving Berendsen method
first, then switch to other algorithms.

This error can also appear when using a timestep that is too large, e.g.
5 fs, in the absence of constraints and / or virtual sites.
:::

::: {#range-checking-error .section}
### Range Checking error

This usually means your simulation is . Probably you need to do better
energy minimization and/or equilibration and/or topology design.
:::

::: {#x-particles-communicated-to-pme-node-y-are-more-than-a-cell-length-out-of-the-domain-decomposition-cell-of-their-charge-group .section}
### X particles communicated to PME node Y are more than a cell length out of the domain decomposition cell of their charge group

This is another way that tells you your system is . If you have
particles that are flying across the system, you will get this fatal
error. The message indicates that some piece of your system is tearing
apart (hence out of the â€œcell of their charge groupâ€?). Refer to the
page for advice on how to fix this issue.
:::

::: {#a-charge-group-moved-too-far-between-two-domain-decomposition-steps .section}
### A charge group moved too far between two domain decomposition steps.

See information above.
:::

::: {#software-inconsistency-error-some-interactions-seem-to-be-assigned-multiple-times .section}
### Software inconsistency error: Some interactions seem to be assigned multiple times

See information above
:::

::: {#there-is-no-domain-decomposition-for-n-ranks-that-is-compatible-with-the-given-box-and-a-minimum-cell-size-of-x-nm .section}
### There is no domain decomposition for n ranks that is compatible with the given box and a minimum cell size of x nm

This means you tried to run a parallel calculation, and when tried to
partition your simulation cell into chunks, it couldnâ€™t. The minimum
cell size is controlled by the size of the largest charge group or
bonded interaction and the largest of ` `{.docutils .literal
.notranslate}[` rvdw `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , ` `{.docutils
.literal .notranslate}[` rlist `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` rcoulomb `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , some other
effects of bond constraints, and a safety margin. Thus it is not
possible to run a small simulation with large numbers of processors. So,
if warned you about a large charge group, pay attention and reconsider
its size. prints a breakdown of how it computed this minimum size in the
file, so you can perhaps find a cause there.

If you didnâ€™t think you were running a parallel calculation, be aware
that from 4.5, GROMACS uses thread-based parallelism by default. To
prevent this, give the ` `{.docutils .literal
.notranslate}[` -ntmpi `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate}[` 1 `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}
command line option. Otherwise, you might be using an MPI-enabled
GROMACS and not be aware of the fact.
:::
:::
:::
::: {#environment-variables .section}
# Environment Variables

GROMACS programs may be influenced by the use of environment variables.
First of all, the variables set in the ` `{.docutils .literal
.notranslate}[` GMXRC `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} file are
essential for running and compiling GROMACS. Some other useful
environment variables are listed in the following sections. Most
environment variables function by being set in your shell to any
non-NULL value. Specific requirements are described below if other
values need to be set. You should consult the documentation for your
shell for instructions on how to set environment variables in the
current shell, or in configuration files for future shells. Note that
requirements for exporting environment variables to jobs run under batch
control systems vary and you should consult your local documentation for
details.

::: {#output-control .section}
## Output Control

` `{.docutils .literal .notranslate}[` GMX_COMPELDUMP `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   Applies for computational electrophysiology setups only (see
    reference manual). The initial structure gets dumped to file, which
    allows to check whether multimeric channels have the correct PBC
    representation.

` `{.docutils .literal .notranslate}[` GMX_DISABLE_GPU_TIMING `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   Disables GPU timings in the log file for OpenCL.

` `{.docutils .literal .notranslate}[` GMX_ENABLE_GPU_TIMING `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   Enables GPU timings in the log file for CUDA and SYCL. Note that
    CUDA timings are incorrect with multiple streams, as happens with
    domain decomposition or with both non-bondeds and PME on the GPU
    (this is also the main reason why they are not turned on by
    default).

` `{.docutils .literal .notranslate}[` GMX_LOG_BUFFER `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   the size of the buffer for file I/O. When set to 0, all file I/O
    will be unbuffered and therefore very slow. This can be handy for
    debugging purposes, because it ensures that all files are always
    totally up-to-date.

` `{.docutils .literal .notranslate}[` GMX_MAXBACKUP `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   GROMACS automatically backs up old copies of files when trying to
    write a new file of the same name, and this variable controls the
    maximum number of backups that will be made, default 99. If set to 0
    it fails to run if any output file already exists. And if set to -1
    it overwrites any output file without making a backup.

` `{.docutils .literal .notranslate}[` GMX_NO_QUOTES `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   if this is explicitly set, no cool quotes will be printed at the end
    of a program.

` `{.docutils .literal .notranslate}[` GMX_PRINT_LONGFORMAT `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   use long float format when printing decimal values.

` `{.docutils .literal .notranslate}[` GMX_SUPPRESS_DUMP `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   prevent dumping of step files during (for example) blowing up during
    failure of constraint algorithms.

` `{.docutils .literal .notranslate}[` GMX_TPI_DUMP `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   dump all configurations to a file that have an interaction energy
    less than the value set in this environment variable.

` `{.docutils .literal .notranslate}[` GMX_TRAJECTORY_IO_VERBOSITY `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   Defaults to 1, which prints frame count e.g. when reading trajectory
    files. Set to 0 for quiet operation.

` `{.docutils .literal .notranslate}[` GMX_VIEW_XVG `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   ` `{.docutils .literal .notranslate}[` GMX_VIEW_EPS `{.docutils
    .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}
    and ` `{.docutils .literal .notranslate}[` GMX_VIEW_PDB `{.docutils
    .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} ,
    commands used to automatically view , and file types, respectively;
    they default to ` `{.docutils .literal
    .notranslate}[` xmgrace `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} ,
    ` `{.docutils .literal .notranslate}[` ghostview `{.docutils
    .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}
    and ` `{.docutils .literal .notranslate}[` rasmol `{.docutils
    .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} .
    Set to empty to disable automatic viewing of a particular file type.
    The command will be forked off and run in the background at the same
    priority as the GROMACS tool (which might not be what you want). Be
    careful not to use a command which blocks the terminal (e.g.
    ` `{.docutils .literal .notranslate}[` vi `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} ), since
    multiple instances might be run.
:::

::: {#debugging .section}
## Debugging

` `{.docutils .literal .notranslate}[` GMX_DD_NPULSE `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   over-ride the number of DD pulses used (default 0, meaning no
    over-ride). Normally 1 or 2.

` `{.docutils .literal .notranslate}[` GMX_DD_DEBUG `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   general debugging trigger for every domain decomposition (default 0,
    meaning off). Currently only checks global-local atom index mapping
    for consistency.

` `{.docutils .literal .notranslate}[` GMX_DD_NST_DUMP `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   number of steps that elapse between dumping the current DD to a PDB
    file (default 0). This only takes effect during domain
    decomposition, so it should typically be 0 (never), 1 (every DD
    phase) or a multiple of .

` `{.docutils .literal .notranslate}[` GMX_DD_NST_DUMP_GRID `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   number of steps that elapse between dumping the current DD grid to a
    PDB file (default 0). This only takes effect during domain
    decomposition, so it should typically be 0 (never), 1 (every DD
    phase) or a multiple of .

` `{.docutils .literal .notranslate}[` GMX_DISABLE_ALTERNATING_GPU_WAIT `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   disables the specialized polling wait path used to wait for the PME
    and nonbonded GPU tasks completion to overlap to do the reduction of
    the resulting forces that arrive first. Setting this variable
    switches to the generic path with fixed waiting order.

` `{.docutils .literal .notranslate}[` GMX_TEST_REQUIRED_NUMBER_OF_DEVICES `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   sets the number of GPUs required by the test suite. By default, the
    test suite would fall-back to using CPU if GPUs could not be
    detected. Set it to a positive integer value to ensure that at least
    this at least this number of usable GPUs are detected. Default: 0
    (not testing GPU availability).

There are a number of extra environment variables like these that are
used in debugging - check the code!
:::

::: {#performance-and-run-control .section}
## Performance and Run Control

` `{.docutils .literal .notranslate}[` GMX_AWH_NO_POINT_LIMIT `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   Removes the upper limit on the number of points in an AWH bias grid.
    By default, an error is raised if the grid is unreasonably large and
    can cause sampling problems. Setting this variable will only remove
    this safety check. It is recommended instead to reduce the grid
    size, e.g., by using lower force constants.

` `{.docutils .literal .notranslate}[` GMX_BONDED_NTHREAD_UNIFORM `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   Value of the number of threads per rank from which to switch from
    uniform to localized bonded interaction distribution; optimal value
    dependent on system and hardware, default value is 4.

` `{.docutils .literal .notranslate}[` GMX_CUDA_GRAPH `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   Use CUDA Graphs to schedule a graph on each step rather than
    multiple activities scheduled to multiple CUDA streams, if the run
    conditions allow. Experimental.

` `{.docutils .literal .notranslate}[` GMX_CYCLE_ALL `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   times all code during runs. Incompatible with threads.

` `{.docutils .literal .notranslate}[` GMX_CYCLE_BARRIER `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   calls MPI_Barrier before each cycle start/stop call.

` `{.docutils .literal .notranslate}[` GMX_DD_ORDER_ZYX `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   build domain decomposition cells in the order (z, y, x) rather than
    the default (x, y, z).

` `{.docutils .literal .notranslate}[` GMX_DD_RECORD_LOAD `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   record DD load statistics for reporting at end of the run (default
    1, meaning on)

` `{.docutils .literal .notranslate}[` GMX_DD_SINGLE_RANK `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   Controls the use of the domain decomposition machinery when using a
    single MPI rank. Value 0 turns DD off, 1 turns DD on. Default is
    automated choice based on heuristics.

` `{.docutils .literal .notranslate}[` GMX_DD_USE_SENDRECV2 `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   during constraint and vsite communication, use a pair of
    ` `{.docutils .literal .notranslate}[` MPI_Sendrecv `{.docutils
    .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}
    calls instead of two simultaneous non-blocking calls (default 0,
    meaning off). Might be faster on some MPI implementations.

` `{.docutils .literal .notranslate}[` GMX_DETAILED_PERF_STATS `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   when set, print slightly more detailed performance information to
    the file. The resulting output is the way performance summary is
    reported in versions 4.5.x and thus may be useful for anyone using
    scripts to parse files or standard output.

` `{.docutils .literal .notranslate}[` GMX_DISABLE_CUDA_TIMING `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   Deprecated. Use ` `{.docutils .literal
    .notranslate}[` GMX_DISABLE_GPU_TIMING `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} instead.

` `{.docutils .literal .notranslate}[` GMX_DISABLE_DYNAMICPRUNING `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   disables dynamic pair-list pruning. Note that will still tune
    nstlist to the optimal value picked assuming dynamic pruning. Thus
    for good performance the -nstlist option should be used.

` `{.docutils .literal .notranslate}[` GMX_DISABLE_GPU_DETECTION `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   when set, disables GPU detection even if was compiled with GPU
    support.

` `{.docutils .literal .notranslate}[` GMX_DISABLE_GPU_TIMING `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   timing of asynchronously executed GPU operations can have a
    non-negligible overhead with short step times. Disabling timing can
    improve performance in these cases. Timings are disabled by default
    with CUDA and SYCL.

` `{.docutils .literal .notranslate}[` GMX_DISABLE_SIMD_KERNELS `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   disables architecture-specific SIMD-optimized (SSE2, SSE4.1, AVX,
    etc.) non-bonded kernels thus forcing the use of plain C kernels.

` `{.docutils .literal .notranslate}[` GMX_DISABLE_STAGED_GPU_TO_CPU_PMEPP_COMM `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   Use direct rather than staged GPU communications for PME force
    transfers from the PME GPU to the CPU memory of a PP rank. This may
    have advantages in PCIe-only servers, or for runs with low atom
    counts (which are more sensitive to latency than bandwidth).

` `{.docutils .literal .notranslate}[` GMX_DISRE_ENSEMBLE_SIZE `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   the number of systems for distance restraint ensemble averaging.
    Takes an integer value.

` `{.docutils .literal .notranslate}[` GMX_DLB_BASED_ON_FLOPS `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   do domain-decomposition dynamic load balancing based on flop count
    rather than measured time elapsed (default 0, meaning off). This
    makes the load balancing reproducible, which can be useful for
    debugging purposes. A value of 1 uses the flops; a value \> 1 adds
    (value - 1)\*5% of noise to the flops to increase the imbalance and
    the scaling.

` `{.docutils .literal .notranslate}[` GMX_DLB_MAX_BOX_SCALING `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   maximum percentage box scaling permitted per domain-decomposition
    load-balancing step (default 10)

` `{.docutils .literal .notranslate}[` GMX_DO_GALACTIC_DYNAMICS `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   planetary simulations are made possible (just for fun) by setting
    this environment variable, which allows setting to -1 in the file.
    Normally, must be greater than zero to prevent a fatal error. See
    for example input files for a planetary simulation.

` `{.docutils .literal .notranslate}[` GMX_EMULATE_GPU `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   emulate GPU runs by using algorithmically equivalent CPU reference
    code instead of GPU-accelerated functions. As the CPU code is slow,
    it is intended to be used only for debugging purposes.

` `{.docutils .literal .notranslate}[` GMX_ENABLE_DIRECT_GPU_COMM `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   Enable direct GPU communication in multi-rank parallel runs. Note
    that domain decomposition with GPU-aware MPI does not support
    multiple pulses along the second and third decomposition dimension,
    so for very small systems the feature will be disabled internally.

` `{.docutils .literal .notranslate}[` GMX_ENABLE_STAGED_GPU_TO_CPU_PMEPP_COMM `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   Use a staged implementation of GPU communications for PME force
    transfers from the PME GPU to the CPU memory of a PP rank for
    thread-MPI. The staging is done via a GPU buffer on the PP GPU. This
    is expected to be beneficial for servers with direct communication
    links between GPUs.

` `{.docutils .literal .notranslate}[` GMX_ENX_NO_FATAL `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   disable exiting upon encountering a corrupted frame in an file,
    allowing the use of all frames up until the corruption.

` `{.docutils .literal .notranslate}[` GMX_FORCE_UPDATE `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   update forces when invoking ` `{.docutils .literal
    .notranslate}[` mdrun `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` -rerun `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} .

` `{.docutils .literal .notranslate}[` GMX_FORCE_GPU_AWARE_MPI `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   Override the result of build- and runtime GPU-aware MPI detection
    and force the use of direct GPU MPI communication. Aimed at cases
    where the user knows that the MPI library is GPU-aware, but GROMACS
    is not able to detect this. Note that only CUDA and SYCL builds
    support such functionality.

` `{.docutils .literal .notranslate}[` GMX_FORCE_UPDATE_DEFAULT_CPU `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   Force update to run on the CPU by default, makes the ` `{.docutils
    .literal .notranslate}[` mdrun `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` -update `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` auto `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} behave as
    ` `{.docutils .literal .notranslate}[` -update `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` cpu `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} .

` `{.docutils .literal .notranslate}[` GMX_GPU_DD_COMMS `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   Removed, use GMX_ENABLE_DIRECT_GPU_COMM instead.

` `{.docutils .literal .notranslate}[` GMX_GPU_DISABLE_COMPATIBILITY_CHECK `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   Disables the hardware compatibility check in OpenCL and SYCL. Useful
    for developers and allows testing the OpenCL/SYCL kernels on
    non-supported platforms without source code modification.

` `{.docutils .literal .notranslate}[` GMX_GPU_ID `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   set in the same way as ` `{.docutils .literal
    .notranslate}[` mdrun `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` -gpu_id `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} ,
    ` `{.docutils .literal .notranslate}[` GMX_GPU_ID `{.docutils
    .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}
    allows the user to specify different GPU IDs for different ranks,
    which can be useful for selecting different devices on different
    compute nodes in a cluster. Cannot be used in conjunction with
    ` `{.docutils .literal .notranslate}[` mdrun `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` -gpu_id `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} .

` `{.docutils .literal .notranslate}[` GMX_GPU_NB_EWALD_TWINCUT `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   force the use of twin-range cutoff kernel even if equals after
    PP-PME load balancing. The switch to twin-range kernels is
    automated, so this variable should be used only for benchmarking.

` `{.docutils .literal .notranslate}[` GMX_GPU_NB_ANA_EWALD `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   force the use of analytical Ewald kernels. Should be used only for
    benchmarking.

` `{.docutils .literal .notranslate}[` GMX_GPU_NB_TAB_EWALD `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   force the use of tabulated Ewald kernels. Should be used only for
    benchmarking.

` `{.docutils .literal .notranslate}[` GMX_GPU_PME_DECOMPOSITION `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   Enable the support for PME decomposition on GPU. This feature is
    supported with CUDA and SYCL backends, and allows using multiple PME
    ranks with GPU offload, which is expected to improve performance
    when scaling over many GPUs. Note: this feature still lacks
    substantial testing.

` `{.docutils .literal .notranslate}[` GMX_GPU_PME_PP_COMMS `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   Removed, use GMX_ENABLE_DIRECT_GPU_COMM instead.

` `{.docutils .literal .notranslate}[` GMX_GPUTASKS `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   set in the same way as ` `{.docutils .literal
    .notranslate}[` mdrun `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` -gputasks `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} ,
    ` `{.docutils .literal .notranslate}[` GMX_GPUTASKS `{.docutils
    .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}
    allows the mapping of GPU tasks to GPU device IDs to be different on
    different ranks, if e.g. the MPI runtime permits this variable to be
    different for different ranks. Cannot be used in conjunction with
    ` `{.docutils .literal .notranslate}[` mdrun `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` -gputasks `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} . Has all
    the same requirements as ` `{.docutils .literal
    .notranslate}[` mdrun `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` -gputasks `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} .

```{=html}
<!-- -->
```

` `{.docutils .literal .notranslate}[` GMX_HEFFTE_RESHAPE_ALGORITHM `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   Sets ` `{.docutils .literal
    .notranslate}[` heffte::plan_options::reshape_algorithm `{.docutils
    .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} to
    ` `{.docutils .literal .notranslate}[` p2p `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} (the
    default) or ` `{.docutils .literal
    .notranslate}[` p2p_plined `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} ,
    ` `{.docutils .literal .notranslate}[` alltoallv `{.docutils
    .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} ,
    or ` `{.docutils .literal .notranslate}[` alltoall `{.docutils
    .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} .
    See the for details.

` `{.docutils .literal .notranslate}[` GMX_HEFFTE_USE_GPU_AWARE `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   Sets ` `{.docutils .literal
    .notranslate}[` heffte::plan_options::use_gpu_aware `{.docutils
    .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} to
    ` `{.docutils .literal .notranslate}[` true `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} (the
    default) or ` `{.docutils .literal .notranslate}[` false `{.docutils
    .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} .
    See the for details.

` `{.docutils .literal .notranslate}[` GMX_HEFFTE_USE_PENCILS `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   Sets ` `{.docutils .literal
    .notranslate}[` heffte::plan_options::use_pencils `{.docutils
    .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} to
    ` `{.docutils .literal .notranslate}[` true `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} or
    ` `{.docutils .literal .notranslate}[` false `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} (the
    default). See the for details.

` `{.docutils .literal .notranslate}[` GMX_HEFFTE_USE_REORDER `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   Sets ` `{.docutils .literal
    .notranslate}[` heffte::plan_options::use_reorder `{.docutils
    .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} to
    ` `{.docutils .literal .notranslate}[` true `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} (the
    default) or ` `{.docutils .literal .notranslate}[` false `{.docutils
    .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} .
    See the for details.

` `{.docutils .literal .notranslate}[` GMX_IGNORE_FSYNC_FAILURE_ENV `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   allow to continue even if a file is missing.

` `{.docutils .literal .notranslate}[` GMX_LJCOMB_TOL `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   when set to a floating-point value, overrides the default tolerance
    of 1e-5 for force-field floating-point parameters.

` `{.docutils .literal .notranslate}[` GMX_MAXCONSTRWARN `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   if set to -1, will not exit if it produces too many LINCS warnings.

` `{.docutils .literal .notranslate}[` GMX_NB_MIN_CI `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   neighbor list balancing parameter used when running on GPU. Sets the
    target minimum number pair-lists in order to improve multi-processor
    load-balance for better performance with small simulation systems.
    Must be set to a non-negative integer, the 0 value disables list
    splitting. The default value is optimized for supported GPUs
    therefore changing it is not necessary for normal usage, but it can
    be useful on future architectures.

` `{.docutils .literal .notranslate}[` GMX_NBNXN_CYCLE `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   when set, print detailed neighbor search cycle counting.

` `{.docutils .literal .notranslate}[` GMX_NBNXN_EWALD_ANALYTICAL `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   force the use of analytical Ewald non-bonded kernels, mutually
    exclusive of ` `{.docutils .literal
    .notranslate}[` GMX_NBNXN_EWALD_TABLE `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} .

` `{.docutils .literal .notranslate}[` GMX_NBNXN_EWALD_TABLE `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   force the use of tabulated Ewald non-bonded kernels, mutually
    exclusive of ` `{.docutils .literal
    .notranslate}[` GMX_NBNXN_EWALD_ANALYTICAL `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} .

` `{.docutils .literal .notranslate}[` GMX_NBNXN_SIMD_2XNN `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   force the use of 2x(N+N) SIMD CPU non-bonded kernels, mutually
    exclusive of ` `{.docutils .literal
    .notranslate}[` GMX_NBNXN_SIMD_4XN `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} .

` `{.docutils .literal .notranslate}[` GMX_NBNXN_SIMD_4XN `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   force the use of 4xN SIMD CPU non-bonded kernels, mutually exclusive
    of ` `{.docutils .literal
    .notranslate}[` GMX_NBNXN_SIMD_2XNN `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} .

` `{.docutils .literal .notranslate}[` GMX_NO_CART_REORDER `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   used in initializing domain decomposition communicators. Rank
    reordering is default, but can be switched off with this environment
    variable.

` `{.docutils .literal .notranslate}[` GMX_NO_INT `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} , ` `{.docutils .literal .notranslate}[` GMX_NO_TERM `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} , ` `{.docutils .literal .notranslate}[` GMX_NO_USR1 `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   disable signal handlers for SIGINT, SIGTERM, and SIGUSR1,
    respectively.

` `{.docutils .literal .notranslate}[` GMX_NO_LJ_COMB_RULE `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   force the use of LJ parameter lookup instead of using combination
    rules in the non-bonded kernels.

` `{.docutils .literal .notranslate}[` GMX_NO_NODECOMM `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   do not use separate inter- and intra-node communicators.

` `{.docutils .literal .notranslate}[` GMX_NO_NONBONDED `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   skip non-bonded calculations; can be used to estimate the possible
    performance gain from adding a GPU accelerator to the current
    hardware setup â€" assuming that this is fast enough to complete the
    non-bonded calculations while the CPU does bonded force and PME
    computation. Freezing the particles will be required to stop the
    system blowing up.

` `{.docutils .literal .notranslate}[` GMX_NO_UPDATEGROUPS `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   turns off update groups. May allow for a decomposition of more
    domains for small systems at the cost of communication during
    update.

` `{.docutils .literal .notranslate}[` GMX_NOOPTIMIZEDKERNELS `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   deprecated, use ` `{.docutils .literal
    .notranslate}[` GMX_DISABLE_SIMD_KERNELS `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} instead.

` `{.docutils .literal .notranslate}[` GMX_NOPREDICT `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   shell positions are not predicted.

` `{.docutils .literal .notranslate}[` GMX_NSTLIST_DYNAMICPRUNING `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   overrides the dynamic pair-list pruning interval chosen
    heuristically by mdrun. Values should be between the pruning
    frequency value (1 for CPU and 2 for GPU) and ` `{.docutils .literal
    .notranslate}[` - `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` 1 `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} .

` `{.docutils .literal .notranslate}[` GMX_PME_NUM_THREADS `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   set the number of OpenMP or PME threads; overrides the default set
    by ; can be used instead of the ` `{.docutils .literal
    .notranslate}[` -npme `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} command
    line option, also useful to set heterogeneous per-process/-node
    thread count.

` `{.docutils .literal .notranslate}[` GMX_PME_P3M `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   use P3M-optimized influence function instead of smooth PME B-spline
    interpolation.

` `{.docutils .literal .notranslate}[` GMX_PME_THREAD_DIVISION `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   PME thread division in the format â€œx y zâ€? for all three
    dimensions. The sum of the threads in each dimension must equal the
    total number of PME threads (set in [ ]{#index-0 .target} ` `{.xref
    .std .std-envvar .docutils .literal
    .notranslate}[` GMX_PME_NTHREADS `{.xref .std .std-envvar .docutils
    .literal .notranslate}]{.pre}` `{.xref .std .std-envvar .docutils
    .literal .notranslate} ).

` `{.docutils .literal .notranslate}[` GMX_PMEONEDD `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   if the number of domain decomposition cells is set to 1 for both x
    and y, decompose PME in one dimension.

` `{.docutils .literal .notranslate}[` GMX_PULL_PARTICIPATE_ALL `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   disable the default heuristic for when to use a separate pull MPI
    communicator (at \>=32 ranks).

` `{.docutils .literal .notranslate}[` GMX_REQUIRE_SHELL_INIT `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   require that shell positions are initiated.

` `{.docutils .literal .notranslate}[` GMX_TPIC_MASSES `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   should contain multiple masses used for test particle insertion into
    a cavity. The center of mass of the last atoms is used for insertion
    into the cavity.

` `{.docutils .literal .notranslate}[` GMX_VERLET_BUFFER_PRESSURE_TOLERANCE `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   sets the maximum tolerated error in the pressure in bar for the
    automated tuning of the Verlet pair-list buffering. Can only be used
    with system where this tolerance has not been set using the mdp
    parameter.

` `{.docutils .literal .notranslate}[` GMX_VERLET_BUFFER_RES `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   resolution of buffer size in Verlet cutoff scheme. The default value
    is 0.001, but can be overridden with this environment variable.

` `{.docutils .literal .notranslate}[` HWLOC_XMLFILE `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   Not strictly a GROMACS environment variable, but on large machines
    the hwloc detection can take a few seconds if you have lots of MPI
    processes. If you run the hwloc command **lstopo out.xml** and set
    this environment variable to point to the location of this file, the
    hwloc library will use the cached information instead, which can be
    faster.

` `{.docutils .literal .notranslate}[` MDRUN `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   the command used by .

` `{.docutils .literal .notranslate}[` MPIRUN `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   the ` `{.docutils .literal .notranslate}[` mpirun `{.docutils
    .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}
    command used by .
:::

::: {#opencl-management .section}
[ ]{#id1}

## OpenCL management

Currently, several environment variables exist that help customize some
aspects of the version of GROMACS. They are mostly related to the
runtime compilation of OpenCL kernels, but they are also used in device
selection.

` `{.docutils .literal .notranslate}[` GMX_OCL_DEBUG `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   Use in conjunction with ` `{.docutils .literal
    .notranslate}[` OCL_FORCE_CPU `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} or with an
    AMD device. It adds the debug flag to the compiler options (-g).

` `{.docutils .literal .notranslate}[` GMX_OCL_DISABLE_FASTMATH `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   Prevents the use of ` `{.docutils .literal
    .notranslate}[` -cl-fast-relaxed-math `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} compiler
    option. Note: fast math is always disabled on Intel devices due to
    instability.

` `{.docutils .literal .notranslate}[` GMX_OCL_DISABLE_I_PREFETCH `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   Disables i-atom data (type or LJ parameter) prefetch allowing
    testing.

` `{.docutils .literal .notranslate}[` GMX_OCL_ENABLE_I_PREFETCH `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   Enables i-atom data (type or LJ parameter) prefetch allowing testing
    on platforms where this behavior is not default.

` `{.docutils .literal
.notranslate}[` GMX_OCL_DUMP_INTERM_FILES `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate}

> <div>
>
> If defined, intermediate language code corresponding to the OpenCL
> build process is saved to file. Caching has to be turned off in order
> for this option to take effect.
>
> > <div>
> >
> > -   NVIDIA GPUs: PTX code is saved in the current directory with the
> >     name ` `{.docutils .literal
> >     .notranslate}[` device_name.ptx `{.docutils .literal
> >     .notranslate}]{.pre}` `{.docutils .literal .notranslate}
> >
> > -   AMD GPUs: ` `{.docutils .literal
> >     .notranslate}[` .IL/.ISA `{.docutils .literal
> >     .notranslate}]{.pre}` `{.docutils .literal .notranslate} files
> >     will be created for each OpenCL kernel built. For details about
> >     where these files are created check AMD documentation for
> >     ` `{.docutils .literal .notranslate}[` -save-temps `{.docutils
> >     .literal .notranslate}]{.pre}` `{.docutils .literal
> >     .notranslate} compiler option.
> >
> > </div>
>
> </div>

` `{.docutils .literal .notranslate}[` GMX_OCL_DUMP_LOG `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   If defined, the OpenCL build log is always written to the mdrun log
    file. Otherwise, the build log is written to the log file only when
    an error occurs.

` `{.docutils .literal .notranslate}[` GMX_OCL_FILE_PATH `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   Use this parameter to force GROMACS to load the OpenCL kernels from
    a custom location. Use it only if you want to override GROMACS
    default behavior, or if you want to test your own kernels.

` `{.docutils .literal .notranslate}[` GMX_OCL_FORCE_AMD_WAVEFRONT64 `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   Force the use of Wave64 mode on AMD devices. This allows using
    OpenCL on RDNA-family devices, but is not recommended. For
    development use only.

` `{.docutils .literal .notranslate}[` GMX_OCL_FORCE_CPU `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   Force the selection of a CPU device instead of a GPU. This exists
    only for debugging purposes. Do not expect GROMACS to function
    properly with this option on, it is solely for the simplicity of
    stepping in a kernel and see what is happening.

` `{.docutils .literal .notranslate}[` GMX_OCL_GENCACHE `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   Enable OpenCL binary caching. Only intended to be used for
    development and (expert) testing as neither concurrency nor cache
    invalidation is implemented safely!

` `{.docutils .literal .notranslate}[` GMX_OCL_NOFASTGEN `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   If set, generate and compile all algorithm flavors, otherwise only
    the flavor required for the simulation is generated and compiled.

` `{.docutils .literal .notranslate}[` GMX_OCL_NOOPT `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   Disable optimisations. Adds the option ` `{.docutils .literal
    .notranslate}[` cl-opt-disable `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} to the
    compiler options.

` `{.docutils .literal .notranslate}[` GMX_OCL_SHOW_DIAGNOSTICS `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   Use Intel OpenCL extension to show additional runtime performance
    diagnostics.

` `{.docutils .literal .notranslate}[` GMX_OCL_VERBOSE `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   If defined, it enables verbose mode for OpenCL kernel build.
    Currently available only for NVIDIA GPUs. See ` `{.docutils .literal
    .notranslate}[` GMX_OCL_DUMP_LOG `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} for details
    about how to obtain the OpenCL build log.
:::

::: {#analysis-and-core-functions .section}
## Analysis and Core Functions

` `{.docutils .literal .notranslate}[` GMX_DIPOLE_SPACING `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   spacing used by .

` `{.docutils .literal .notranslate}[` GMX_ENER_VERBOSE `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   make and loud and noisy.

` `{.docutils .literal .notranslate}[` GMX_MAXRESRENUM `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   sets the maximum number of residues to be renumbered by . A value of
    -1 indicates all residues should be renumbered.

` `{.docutils .literal .notranslate}[` GMX_NO_FFRTP_TER_RENAME `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   Some force fields (like AMBER) use specific names for N- and C-
    terminal residues (NXXX and CXXX) as entries that are normally
    renamed. Setting this environment variable disables this renaming.

` `{.docutils .literal .notranslate}[` GMX_USE_XMGR `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   sets viewer to ` `{.docutils .literal
    .notranslate}[` xmgr `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate}
    (deprecated) instead of ` `{.docutils .literal
    .notranslate}[` xmgrace `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} .

` `{.docutils .literal .notranslate}[` GMXTIMEUNIT `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   the time unit used in output files, can be anything in fs, ps, ns,
    us, ms, s, m or h.

` `{.docutils .literal .notranslate}[` VMD_PLUGIN_PATH `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   where to find VMD plug-ins. Needed to be able to read file formats
    recognized only by a VMD plug-in.

` `{.docutils .literal .notranslate}[` VMDDIR `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   base path of VMD installation.
:::
:::
::: {#floating-point-arithmetic .section}
[ ]{#gmx-floating-point}

# Floating point arithmetic

GROMACS spends its life doing arithmetic on real numbers, often summing
many millions of them. These real numbers are encoded on computers in
so-called binary floating-point representation. This representation is
somewhat like scientific exponential notation (but uses binary rather
than decimal), and is necessary for the fastest possible speed for
calculations. Unfortunately the laws of algebra only approximately apply
to binary floating-point. In part, this is because some real numbers
that are represented simply and exactly in decimal (like 1/5=0.2) have
no exact representation in binary floating-point, just as 1/3 cannot be
represented in decimal. There are many sources you can find with a
search engine that discuss this issue more exhaustively, such as and
David Goldbergâ€™s 1991 paper *What every computer scientist should know
about floating-point arithmetic* ( , ). Bruce Dawson also has a written
a number of very valuable blog posts on modern floating-point
programming at his that are worth reading.

So, the sum of a large number of binary representations of exact decimal
numbers need not equal the expected algebraic or decimal result. Users
observe this phenomenon in sums of partial charges expressed to two
decimal places that sometimes only approximate the integer total charge
to which they contribute (however a deviation in the first decimal place
would always be indicative of a badly-formed topology). When GROMACS has
to represent such floating-point numbers in output, it sometimes uses a
computer form of scientific notation known as E notation. In such
notation, a number like -9.999971e-01 is actually -0.9999971, which is
close enough to -1 for purposes of assessing the total charge of a
system.

It is also not appropriate for GROMACS to guess to round things, because
such rounding relies on assumptions about the inputs that need not be
true. Instead the user needs to understand how their tools work.
:::
::: {#flow-chart .section}
# Flow Chart

This is a flow chart of a typical GROMACS MD run of a protein in a box
of water. A more detailed example is available in . Several steps of
energy minimization may be necessary, these consist of cycles: -\> .

::: graphviz
![digraph flowchart { node \[ shape=box, width=1.5 \] input_pdb \[
label=\"eiwit.pdb\" tooltip=\"Protein Databank file\"
URL=\"../reference-manual/file-formats.html#pdb\" shape=none, width=0,
height=0, margin=0 group=input \] pdb2gmx \[ label=\"Generate a GROMACS
topology\\ngmx pdb2gmx\" tooltip=\"Convert PDB file to GROMACS
coordinate file and topology\" URL=\"../onlinehelp/gmx-pdb2gmx.html\"
width=3 group=main \] input_pdb -\> pdb2gmx \[ headport=e \] editconf \[
label=\"Enlarge the box\\ngmx editconf\" tooltip=\"Adjust box size and
placement of molecule\" URL=\"../onlinehelp/gmx-editconf.html\" \]
pdb2gmx -\> editconf \[ label=\"conf.gro\" labeltooltip=\"GROMACS
coordinate file containing molecules from PDB file\"
URL=\"../reference-manual/file-formats.html#gro\" \] solvate \[
label=\"Solvate protein\\ngmx solvate\" tooltip=\"Fill box with water
(solvate molecule)\" URL=\"../onlinehelp/gmx-solvate.html\" width=3
group=main \] pdb2gmx -\> solvate \[ label=\"topol.top\"
labeltooltip=\"GROMACS ascii topology file\"
URL=\"../reference-manual/file-formats.html#top\" \] editconf -\>
solvate \[ label=\"conf.gro\" labeltooltip=\"GROMACS coordinate file
with adjusted box etc.\"
URL=\"../reference-manual/file-formats.html#gro\" \] input_mdp \[
label=\"grompp.mdp\" tooltip=\"Parameter file from grompp (controls all
MD parameters)\" URL=\"../reference-manual/file-formats.html#mdp\"
shape=none, width=0, height=0, margin=0 group=input \] grompp \[
label=\"Generate mdrun input file\\ngmx grompp\" tooltip=\"Process
parameters, coordinates and topology and write binary topology\"
URL=\"../onlinehelp/gmx-grompp.html\" width=3 group=main \] input_pdb
-\> input_mdp \[ style=invis, minlen=3 \] input_mdp -\> grompp \[
headport=e, weight=0 \] solvate -\> grompp \[ label=\"conf.gro\"
labeltooltip=\"GROMACS coordinate file with water molecules added\"
URL=\"../reference-manual/file-formats.html#gro\" \] solvate -\> grompp
\[ label=\"topol.top\" labeltooltip=\"GROMACS ascii topology file with
water molecules added\"
URL=\"../reference-manual/file-formats.html#top\" \] mdrun \[
label=\"Run the simulation (EM or MD)\\ngmx mdrun\" tooltip=\"The moment
you have all been waiting for! START YOUR MD RUN\"
URL=\"../onlinehelp/gmx-mdrun.html\" width=3 group=main \] grompp -\>
mdrun \[ label=\"topol.tpr\" labeltooltip=\"Portable GROMACS binary run
input file (contains all information to start MD run)\"
URL=\"../reference-manual/file-formats.html#tpr\" \] mdrun -\> mdrun \[
label=\"Continuation\\nstate.cpt\" labeltooltip=\"Checkpoint file\"
URL=\"../reference-manual/file-formats.html#cpt\" \] analysis \[
label=\"Analysis\\ngmx \...\" tooltip=\"Your favourite GROMACS analysis
tool\" URL=\"cmdline.html#commands-by-topic\" \] mdrun -\> analysis \[
label=\"traj.xtc / traj.trr\" labeltooltip=\"Portable compressed
trajectory / full precision portable trajectory\"
URL=\"../reference-manual/file-formats.html#xtc\" \] energy \[
label=\"Analysis\\ngmx energy\" tooltip=\"Energy plots, averages and
fluctuations\" URL=\"../onlinehelp/gmx-energy.html\" \] mdrun -\> energy
\[ label=\"ener.edr\" labeltooltip=\"Portable energy file\"
URL=\"../reference-manual/file-formats.html#edr\" \]
}](../_images/graphviz-546f8676b043be7a824d2ab2320a5e60473f82fc.png){.graphviz
usemap="#flowchart"}
:::
:::
::: {#force-fields-in-gromacs .section}
[ ]{#gmx-ff-included}

# Force fields in GROMACS

::: {#amber .section}
[ ]{#gmx-amber-ff}

## AMBER

(Assisted Model Building and Energy Refinement) refers both to a set of
molecular mechanical for the simulation of biomolecules and a package of
molecular simulation programs.

GROMACS supports the following AMBER force fields natively:

-   AMBER94

-   AMBER96

-   AMBER99

-   AMBER99SB

-   AMBER99SB-ILDN

-   AMBER03

-   AMBERGS

Information concerning the force field can be found using the following
information:

-   \- background about the AMBER force fields

-   \- information about the AMBER suite of programs for molecular
    simulation

-   \- Generalized Amber Force Field (GAFF) which is supposed to provide
    parameters suitable for small molecules that are compatible with the
    AMBER protein/nucleic acid force fields. It is available either
    together with AMBER, or through the antechamber package, which is
    also distributed separately. There are scripts available for
    converting AMBER systems (set up, for example, with GAFF) to GROMACS
    ( , or ), but they do require installation to work.
:::

::: {#charmm .section}
[ ]{#gmx-charmm-ff}

## CHARMM

(Chemistry at HARvard Macromolecular Mechanics) is a both a set of force
fields and a software package for simulations and analysis. Includes
united atom (CHARMM19) and all atom (CHARMM22, CHARMM27, CHARMM36) . The
CHARMM27 force field has been ported to GROMACS and is officially
supported. CHARMM36 force field files can be obtained from the , which
regularly produces up-to-date CHARMM force field files in GROMACS
format.

For using CHARMM36 in GROMACS, please use the following settings in the
file:

::: {.highlight-default .notranslate}
::: highlight
    constraints = h-bonds
    cutoff-scheme = Verlet
    vdwtype = cutoff
    vdw-modifier = force-switch
    rlist = 1.2
    rvdw = 1.2
    rvdw-switch = 1.0
    coulombtype = PME
    rcoulomb = 1.2
    DispCorr = no
:::
:::

Note that dispersion correction should be applied in the case of lipid
monolayers, but not bilayers.

Please also note that the switching distance is a matter of some debate
in lipid bilayer simulations, and it is dependent to some extent on the
nature of the lipid. Some studies have found that an 0.8-1.0 nm switch
is appropriate, others argue 0.8-1.2 nm is best, and yet others stand by
1.0-1.2 nm. The user is cautioned to thoroughly investigate the force
field literature for their chosen lipid(s) before beginning a
simulation!
:::

::: {#gromos .section}
[ ]{#gmx-gromos-ff}

## GROMOS

::: {.admonition .warning}
Warning

The GROMOS force fields have been parametrized with a physically
incorrect multiple-time-stepping scheme for a twin-range cut-off. When
used with a single-range cut-off (or a correct Trotter
multiple-time-stepping scheme), physical properties, such as the
density, might differ from the intended values. Since there are
researchers actively working on validating GROMOS with modern
integrators we have not yet removed the GROMOS force fields, but you
should be aware of these issues and check if molecules in your system
are affected before proceeding. Further information is available in ,
and a longer explanation of our decision to remove physically incorrect
algorithms can be found at .
:::

is is a general-purpose molecular dynamics computer simulation package
for the study of biomolecular systems. It also incorporates its own
force field covering proteins, nucleotides, sugars etc. and can be
applied to chemical and physical systems ranging from glasses and liquid
crystals, to polymers and crystals and solutions of biomolecules.

GROMACS supports the GROMOS force fields, with all parameters provided
in the distribution for 43a1, 43a2, 45a3, 53a5, 53a6 and 54a7. The
GROMOS force fields are , i.e. without explicit aliphatic (non-polar)
hydrogens.

-   GROMOS 53a6 - in GROMACS format (J. Comput. Chem. 2004 vol. 25 (13):
    1656-1676).

-   GROMOS 53a5 - in GROMACS format (J. Comput. Chem. 2004 vol. 25 (13):
    1656-1676).

-   GROMOS 43a1p - 43a1 modified to contain SEP (phosphoserine), TPO
    (phosphothreonine), and PTR (phosphotyrosine) (all PO42- forms), and
    SEPH, TPOH, PTRH (PO4H- forms).
:::

::: {#opls .section}
[ ]{#gmx-opls}

## OPLS

OPLS (Optimized Potential for Liquid Simulations) is a set of force
fields developed by Prof. William L. Jorgensen for condensed phase
simulations, with the latest version being .

The standard implementations for those force fields are the *BOSS* and
*MCPRO* programs developed by the

As there is no central web-page to point to, the user is advised to
consult the original literature for the and force fields, as well as the
Jorgensen group
:::
:::
::: {#getting-good-performance-from-mdrun .section}
[ ]{#gmx-performance}

# Getting good performance from

Here we give an overview on the parallelization and acceleration schemes
employed by GROMACS. The aim is to provide an understanding of the
underlying mechanisms that make GROMACS one of the fastest molecular
dynamics packages. The information presented should help choosing
appropriate parallelization options, run configuration, as well as
acceleration options to achieve optimal simulation performance.

The GROMACS build system and the tool have a lot of built-in and
configurable intelligence to detect your hardware and make pretty
effective use of it. For a lot of casual and serious use of , the
automatic machinery works well enough. But to get the most from your
hardware to maximize your scientific quality, read on!

::: {#hardware-background-information .section}
## Hardware background information

Modern computer hardware is complex and heterogeneous, so we need to
discuss a little bit of background information and set up some
definitions. Experienced HPC users can skip this section.

core

:   A hardware compute unit that actually executes instructions. There
    is normally more than one core in a processor, often many more.

cache

:   A special kind of memory local to core(s) that is much faster to
    access than main memory, kind of like the top of a humanâ€™s desk,
    compared to their filing cabinet. There are often several layers of
    caches associated with a core.

socket

:   A group of cores that share some kind of locality, such as a shared
    cache. This makes it more efficient to spread computational work
    over cores within a socket than over cores in different sockets.
    Modern processors often have more than one socket.

node

:   A group of sockets that share coarser-level locality, such as shared
    access to the same memory without requiring any network hardware. A
    normal laptop or desktop computer is a node. A node is often the
    smallest amount of a large compute cluster that a user can request
    to use.

thread

:   A stream of instructions for a core to execute. There are many
    different programming abstractions that create and manage spreading
    computation over multiple threads, such as OpenMP, pthreads,
    winthreads, CUDA, OpenCL, and OpenACC. Some kinds of hardware can
    map more than one software thread to a core; on Intel x86 processors
    this is called â€œhyper-threadingâ€?, while the more general concept
    is often called SMT for â€œsimultaneous multi-threadingâ€?. IBM
    Power8 can for instance use up to 8 hardware threads per core. This
    feature can usually be enabled or disabled either in the hardware
    BIOS or through a setting in the Linux operating system. GROMACS can
    typically make use of this, for a moderate free performance boost.
    In most cases it will be enabled by default e.g. on new x86
    processors, but in some cases the system administrators might have
    disabled it. If that is the case, ask if they can re-enable it for
    you. If you are not sure if it is enabled, check the output of the
    CPU information in the log file and compare with CPU specifications
    you find online.

thread affinity (pinning)

:   By default, most operating systems allow software threads to migrate
    between cores (or hardware threads) to help automatically balance
    workload. However, the performance of can deteriorate if this is
    permitted and will degrade dramatically especially when relying on
    multi-threading within a rank. To avoid this, will by default set
    the affinity of its threads to individual cores/hardware threads,
    unless the user or software environment has already done so (or not
    the entire node is used for the run, i.e. there is potential for
    node sharing). Setting thread affinity is sometimes called thread
    â€œpinningâ€?.

MPI (Message Passing Interface)

:   The dominant multi-node parallelization-scheme, which provides a
    standardized language in which programs can be written that work
    across more than one node.

rank

:   In MPI, a rank is the smallest grouping of hardware used in the
    multi-node parallelization scheme. That grouping can be controlled
    by the user, and might correspond to a core, a socket, a node, or a
    group of nodes. The best choice varies with the hardware, software
    and compute task. Sometimes an MPI rank is called an MPI process.

GPU

:   A graphics processing unit, which is often faster and more efficient
    than conventional processors for particular kinds of compute
    workloads. A GPU is always associated with a particular node, and
    often a particular socket within that node.

OpenMP

:   A standardized technique supported by many compilers to share a
    compute workload over multiple cores. Often combined with MPI to
    achieve hybrid MPI/OpenMP parallelism.

CUDA

:   A proprietary parallel computing framework and API developed by
    NVIDIA that allows targeting their accelerator hardware. GROMACS
    uses CUDA for GPU acceleration support with NVIDIA hardware.

OpenCL

:   An open standard-based parallel computing framework that consists of
    a C99-based compiler and a programming API for targeting
    heterogeneous and accelerator hardware. GROMACS uses OpenCL for GPU
    acceleration on AMD devices (both GPUs and APUs), Intel integrated
    GPUs, and Apple Silicon integrated GPUs; some NVIDIA hardware is
    also supported. In GROMACS, OpenCL has been deprecated in favor of
    SYCL.

SYCL

:   An open standard based on C++17 for targeting heterogeneous systems.
    SYCL has several implementations, of which GROMACS supports two: and
    . GROMACS uses SYCL for GPU acceleration on AMD and Intel GPUs.
    There is experimental support for NVIDIA GPUs too.

SIMD

:   A type of CPU instruction by which modern CPU cores can execute
    multiple floating-point instructions in a single cycle.
:::

::: {#work-distribution-by-parallelization-in-gromacs .section}
## Work distribution by parallelization in GROMACS

The algorithms in and their implementations are most relevant when
choosing how to make good use of the hardware. For details, see the .
The most important of these are

Domain Decomposition

:   The domain decomposition (DD) algorithm decomposes the
    (short-ranged) component of the non-bonded interactions into domains
    that share spatial locality, which permits the use of efficient
    algorithms. Each domain handles all of the particle-particle (PP)
    interactions for its members, and is mapped to a single MPI rank.
    Within a PP rank, OpenMP threads can share the workload, and some
    work can be offloaded to a GPU. The PP rank also handles any bonded
    interactions for the members of its domain. A GPU may perform work
    for more than one PP rank, but it is normally most efficient to use
    a single PP rank per GPU and for that rank to have thousands of
    particles. When the work of a PP rank is done on the CPU, will make
    extensive use of the SIMD capabilities of the core. There are
    various to control the behaviour of the DD algorithm.

Particle-mesh Ewald

:   The particle-mesh Ewald (PME) algorithm treats the long-ranged
    component of the non-bonded interactions (Coulomb and possibly also
    Lennard-Jones). Either all, or just a subset of ranks may
    participate in the work for computing the long-ranged component
    (often inaccurately called simply the â€œPMEâ€? component). Because
    the algorithm uses a 3D FFT that requires global communication, its
    parallel efficiency gets worse as more ranks participate, which can
    mean it is fastest to use just a subset of ranks (e.g. one-quarter
    to one-half of the ranks). If there are separate PME ranks, then the
    remaining ranks handle the PP work. Otherwise, all ranks do both PP
    and PME work.
:::

::: {#parallelization-schemes .section}
## Parallelization schemes

GROMACS, being performance-oriented, has a strong focus on efficient
parallelization. There are multiple parallelization schemes available,
therefore a simulation can be run on a given hardware with different
choices of run configuration.

::: {#intra-core-parallelization-via-simd-sse-avx-etc .section}
[ ]{#intra-core-parallelization}

### Intra-core parallelization via SIMD: SSE, AVX, etc.

One level of performance improvement available in GROMACS is through the
use of ` `{.docutils .literal .notranslate}[` Single `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` Instruction `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` Multiple `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` Data `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` (SIMD) `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} instructions.
In detail information for those can be found under in the installation
guide.

In GROMACS, SIMD instructions are used to parallelize the parts of the
code with the highest impact on performance (nonbonded and bonded force
calculation, PME and neighbour searching), through the use of hardware
specific SIMD kernels. Those form one of the three levels of non-bonded
kernels that are available: reference or generic kernels (slow but
useful for producing reference values for testing), optimized plain-C
kernels (can be used cross-platform but still slow) and SIMD intrinsics
accelerated kernels.

The SIMD intrinsic code is compiled by the compiler. Technically, it is
possible to compile different levels of acceleration into one binary,
but this is difficult to manage with acceleration in many parts of the
code. Thus, you need to configure and compile GROMACS for the SIMD
capabilities of the target CPU. By default, the build system will detect
the highest supported acceleration of the host where the compilation is
carried out. For cross-compiling for a machine with a different highest
SIMD instructions set, in order to set the target acceleration, the
` `{.docutils .literal .notranslate}[` -DGMX_SIMD `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} CMake option
can be used. To use a single installation on multiple different
machines, it is convenient to compile the analysis tools with the lowest
common SIMD instruction set (as these rely little on SIMD acceleration),
but for best performance should be compiled be compiled separately with
the highest (latest) ` `{.docutils .literal
.notranslate}[` native `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} SIMD
instruction set of the target architecture (supported by GROMACS).

Recent Intel CPU architectures bring tradeoffs between the maximum clock
frequency of the CPU (ie. its speed), and the width of the SIMD
instructions it executes (ie its throughput at a given speed). In
particular, the Intel ` `{.docutils .literal
.notranslate}[` Skylake `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` Cascade `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` Lake `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} processors
(e.g. Xeon SP Gold/Platinum), can offer better throughput when using
narrower SIMD because of the better clock frequency available. Consider
building configured with ` `{.docutils .literal
.notranslate}[` GMX_SIMD=AVX2_256 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} instead of
` `{.docutils .literal .notranslate}[` GMX_SIMD=AVX512 `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} for
better performance in GPU accelerated or highly parallel MPI runs.

Some of the latest ARM based CPU, such as the Fujitsu A64fx, support the
Scalable Vector Extensions (SVE). Though SVE can be used to generate
fairly efficient Vector Length Agnostic (VLA) code, this is not a good
fit for GROMACS (as the SIMD vector length assumed to be known at CMake
time). Consequently, the SVE vector length must be fixed at CMake time.
The default is to automatically detect the default vector length at
CMake time (via the ` `{.docutils .literal
.notranslate}[` /proc/sys/abi/sve_default_vector_length `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}
pseudo-file, and this can be changed by configuring with ` `{.docutils
.literal .notranslate}[` GMX_SIMD_ARM_SVE_LENGTH=<len> `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} . The
supported vector lengths are 128, 256, 512 and 1024. Since the SIMD
short-range non-bonded kernels only support up to 16 floating point
numbers per SIMD vector, 1024 bits vector length is only valid in double
precision (e.g. ` `{.docutils .literal
.notranslate}[` -DGMX_DOUBLE=on `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ). Note that
even if does check the SIMD vector length at runtime, running with a
different vector length than the one used at CMake time is undefined
behavior, and might crash before reaching the check (that would abort
with a user-friendly error message).
:::

::: {#process-or-level-parallelization-via-openmp .section}
### Process(-or) level parallelization via OpenMP

GROMACS supports OpenMP multithreading for all parts of the code. OpenMP
is enabled by default and can be turned on/off at configure time with
the ` `{.docutils .literal .notranslate}[` GMX_OPENMP `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} CMake
variable and at run-time with the ` `{.docutils .literal
.notranslate}[` -ntomp `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} option (or the
` `{.docutils .literal .notranslate}[` OMP_NUM_THREADS `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}
environment variable). The OpenMP implementation is quite efficient and
scales well for up to 12-24 threads on Intel and 6-8 threads on AMD
CPUs.
:::

::: {#node-level-parallelization-via-gpu-offloading-and-thread-mpi .section}
### Node level parallelization via GPU offloading and thread-MPI

::: {#multithreading-with-thread-mpi .section}
#### Multithreading with thread-MPI

The thread-MPI library implements a subset of the MPI 1.1 specification,
based on the system threading support. Both POSIX pthreads and Windows
threads are supported, thus providing great portability to most
UNIX/Linux and Windows operating systems. Acting as a drop-in
replacement for MPI, thread-MPI enables compiling and running on a
single machine (i.e. not across a network) without MPI. Additionally, it
not only provides a convenient way to use computers with multicore
CPU(s), but thread-MPI does in some cases make run slightly faster than
with MPI.

Thread-MPI is included in the GROMACS source and it is the default
parallelization mode, practically rendering the serial deprecated.
Compilation with thread-MPI is controlled by the ` `{.docutils .literal
.notranslate}[` GMX_THREAD_MPI `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} CMake variable.

Thread-MPI is compatible with most features and parallelization schemes,
including OpenMP, GPUs; it is not compatible with MPI and
multi-simulation runs.

By default, the thread-MPI will use all available cores in the machine
by starting an appropriate number of ranks or OpenMP threads to occupy
all of them. The number of ranks can be controlled using the
` `{.docutils .literal .notranslate}[` -nt `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` -ntmpi `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} options.
` `{.docutils .literal .notranslate}[` -nt `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} represents the
total number of threads to be used (which can be a mix of thread-MPI and
OpenMP threads).
:::

::: {#hybrid-heterogeneous-acceleration .section}
#### Hybrid/heterogeneous acceleration

Hybrid acceleration means distributing compute work between available
CPUs and GPUs to improve simulation performance. New non-bonded
algorithms have been developed with the aim of efficient acceleration
both on CPUs and GPUs.

The most compute-intensive parts of simulations, non-bonded force
calculation, as well as possibly the PME, bonded force calculation and
update and constraints can be offloaded to GPUs and carried out
simultaneously with remaining CPU work. Native GPU acceleration is
supported for the most commonly used algorithms in GROMACS. For more
information about the GPU kernels, please see the .

The native GPU acceleration can be turned on or off, either at run-time
using the ` `{.docutils .literal .notranslate}[` -nb `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}
option, or at configuration time using the ` `{.docutils .literal
.notranslate}[` GMX_GPU `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} CMake variable.

To efficiently use all compute resource available, CPU and GPU
computation is done simultaneously. Overlapping with the OpenMP
multithreaded bonded force and PME long-range electrostatic calculations
on the CPU, non-bonded forces are calculated on the GPU. Multiple GPUs,
both in a single node as well as across multiple nodes, are supported
using domain-decomposition. A single GPU is assigned to the non-bonded
workload of a domain, therefore, the number GPUs used has to match the
number of of MPI processes (or thread-MPI threads) the simulation is
started with. The available CPU cores are partitioned among the
processes (or thread-MPI threads) and a set of cores with a GPU do the
calculations on the respective domain.

With PME electrostatics, supports automated CPU-GPU load-balancing by
shifting workload from the PME mesh calculations, done on the CPU, to
the particle-particle non-bonded calculations, done on the GPU. At
startup a few iterations of tuning are executed during the first 100 to
1000 MD steps. These iterations involve scaling the electrostatics
cut-off and PME grid spacing to determine the value that gives optimal
CPU-GPU load balance. The cut-off value provided using the ` `{.docutils
.literal .notranslate}[` =rvdw `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} option
represents the minimum electrostatics cut-off the tuning starts with and
therefore should be chosen as small as possible (but still reasonable
for the physics simulated). The Lennard-Jones cut-off ` `{.docutils
.literal .notranslate}[` rvdw `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} is kept fixed.
We donâ€™t allow scaling to shorter cut-off as we donâ€™t want to change
` `{.docutils .literal .notranslate}[` rvdw `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and there would
be no performance gain.

While the automated CPU-GPU load balancing always attempts to find the
optimal cut-off setting, it might not always be possible to balance CPU
and GPU workload. This happens when the CPU threads finish calculating
the bonded forces and PME faster than the GPU the non-bonded force
calculation, even with the shortest possible cut-off. In such cases the
CPU will wait for the GPU and this time will show up as ` `{.docutils
.literal .notranslate}[` Wait `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` GPU `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` NB `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` local `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} in the cycle
and timing summary table at the end of the log file.
:::
:::

::: {#parallelization-over-multiple-nodes-via-mpi .section}
### Parallelization over multiple nodes via MPI

At the heart of the MPI parallelization in GROMACS is the
neutral-territory with dynamic load balancing. To parallelize
simulations across multiple machines (e.g. nodes of a cluster) needs to
be compiled with MPI which can be enabled using the ` `{.docutils
.literal .notranslate}[` GMX_MPI `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} CMake variable.

::: {#controlling-the-domain-decomposition-algorithm .section}
[ ]{#id1}

#### Controlling the domain decomposition algorithm

This section lists options that affect how the domain decomposition
algorithm decomposes the workload to the available parallel hardware.

` `{.docutils .literal .notranslate}[` -rdd `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   Can be used to set the required maximum distance for inter
    charge-group bonded interactions. Communication for two-body bonded
    interactions below the non-bonded cut-off distance always comes for
    free with the non-bonded communication. Particles beyond the
    non-bonded cut-off are only communicated when they have missing
    bonded interactions; this means that the extra cost is minor and
    nearly independent of the value of ` `{.docutils .literal
    .notranslate}[` -rdd `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} . With
    dynamic load balancing, option ` `{.docutils .literal
    .notranslate}[` -rdd `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} also sets
    the lower limit for the domain decomposition cell sizes. By default
    ` `{.docutils .literal .notranslate}[` -rdd `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} is
    determined by based on the initial coordinates. The chosen value
    will be a balance between interaction range and communication cost.

` `{.docutils .literal .notranslate}[` -ddcheck `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   On by default. When inter charge-group bonded interactions are
    beyond the bonded cut-off distance, terminates with an error
    message. For pair interactions and tabulated bonds that do not
    generate exclusions, this check can be turned off with the option
    ` `{.docutils .literal .notranslate}[` -noddcheck `{.docutils
    .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} .

` `{.docutils .literal .notranslate}[` -rcon `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   When constraints are present, option ` `{.docutils .literal
    .notranslate}[` -rcon `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} influences
    the cell size limit as well. Particles connected by NC constraints,
    where NC is the LINCS order plus 1, should not be beyond the
    smallest cell size. A error message is generated when this happens,
    and the user should change the decomposition or decrease the LINCS
    order and increase the number of LINCS iterations. By default
    estimates the minimum cell size required for P-LINCS in a
    conservative fashion. For high parallelization, it can be useful to
    set the distance required for P-LINCS with ` `{.docutils .literal
    .notranslate}[` -rcon `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} .

` `{.docutils .literal .notranslate}[` -dds `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   Sets the minimum allowed x, y and/or z scaling of the cells with
    dynamic load balancing. will ensure that the cells can scale down by
    at least this factor. This option is used for the automated spatial
    decomposition (when not using ` `{.docutils .literal
    .notranslate}[` -dd `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} ) as well
    as for determining the number of grid pulses, which in turn sets the
    minimum allowed cell size. Under certain circumstances the value of
    ` `{.docutils .literal .notranslate}[` -dds `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} might need
    to be adjusted to account for high or low spatial inhomogeneity of
    the system.
:::

::: {#multi-level-parallelization-mpi-and-openmp .section}
#### Multi-level parallelization: MPI and OpenMP

The multi-core trend in CPU development substantiates the need for
multi-level parallelization. Current multiprocessor machines can have
2-4 CPUs with a core count as high as 64. As the memory and cache
subsystem is lagging more and more behind the multicore evolution, this
emphasizes non-uniform memory access (NUMA) effects, which can become a
performance bottleneck. At the same time, all cores share a network
interface. In a purely MPI-parallel scheme, all MPI processes use the
same network interface, and although MPI intra-node communication is
generally efficient, communication between nodes can become a limiting
factor to parallelization. This is especially pronounced in the case of
highly parallel simulations with PME (which is very communication
intensive) and with ` `{.docutils .literal
.notranslate}[` ''fat'' `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} nodes connected
by a slow network. Multi-level parallelism aims to address the NUMA and
communication related issues by employing efficient intra-node
parallelism, typically multithreading.

Combining OpenMP with MPI creates an additional overhead especially when
running separate multi-threaded PME ranks. Depending on the
architecture, input system size, as well as other factors, MPI+OpenMP
runs can be as fast and faster already at small number of processes
(e.g. multi-processor Intel Westmere or Sandy Bridge), but can also be
considerably slower (e.g. multi-processor AMD Interlagos machines).
However, there is a more pronounced benefit of multi-level
parallelization in highly parallel runs.
:::
:::

::: {#separate-pme-ranks .section}
### Separate PME ranks

On CPU ranks, particle-particle (PP) and PME calculations are done in
the same process one after another. As PME requires all-to-all global
communication, this is most of the time the limiting factor to scaling
on a large number of cores. By designating a subset of ranks for PME
calculations only, performance of parallel runs can be greatly improved.

OpenMP multithreading in PME ranks is also possible. Using
multi-threading in PME can can improve performance at high
parallelization. The reason for this is that with N\>1 threads the
number of processes communicating, and therefore the number of messages,
is reduced by a factor of N. But note that modern communication networks
can process several messages simultaneously, such that it could be
advantageous to have more processes communicating.

Separate PME ranks are not used at low parallelization, the switch at
higher parallelization happens automatically (at \> 16 processes). The
number of PME ranks is estimated by mdrun. If the PME load is higher
than the PP load, mdrun will automatically balance the load, but this
leads to additional (non-bonded) calculations. This avoids the idling of
a large fraction of the ranks; usually 3/4 of the ranks are PP ranks.
But to ensure the best absolute performance of highly parallel runs, it
is advisable to tweak this number which is automated by the tool.

The number of PME ranks can be set manually on the command line using
the ` `{.docutils .literal .notranslate}[` -npme `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} option, the
number of PME threads can be specified on the command line with
` `{.docutils .literal .notranslate}[` -ntomp_pme `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} or
alternatively using the ` `{.docutils .literal
.notranslate}[` GMX_PME_NUM_THREADS `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} environment
variable. The latter is especially useful when running on compute nodes
with different number of cores as it enables setting different number of
PME threads on different nodes.
:::
:::

::: {#running-mdrun-within-a-single-node .section}
## Running within a single node

can be configured and compiled in several different ways that are
efficient to use within a single . The default configuration using a
suitable compiler will deploy a multi-level hybrid parallelism that uses
CUDA, OpenMP and the threading platform native to the hardware. For
programming convenience, in GROMACS, those native threads are used to
implement on a single node the same MPI scheme as would be used between
nodes, but much more efficient; this is called thread-MPI. From a
userâ€™s perspective, real MPI and thread-MPI look almost the same, and
GROMACS refers to MPI ranks to mean either kind, except where noted. A
real external MPI can be used for within a single node, but runs more
slowly than the thread-MPI version.

By default, will inspect the hardware available at run time and do its
best to make fairly efficient use of the whole node. The log file,
stdout and stderr are used to print diagnostics that inform the user
about the choices made and possible consequences.

A number of command-line parameters are available to modify the default
behavior.

` `{.docutils .literal .notranslate}[` -nt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   The total number of threads to use. The default, 0, will start as
    many threads as available cores. Whether the threads are thread-MPI
    ranks, and/or OpenMP threads within such ranks depends on other
    settings.

` `{.docutils .literal .notranslate}[` -ntmpi `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   The total number of thread-MPI ranks to use. The default, 0, will
    start one rank per GPU (if present), and otherwise one rank per
    core.

` `{.docutils .literal .notranslate}[` -ntomp `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   The total number of OpenMP threads per rank to start. The default,
    0, will start one thread on each available core. Alternatively, will
    honor the appropriate system environment variable (e.g.
    ` `{.docutils .literal .notranslate}[` OMP_NUM_THREADS `{.docutils
    .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} )
    if set. Note that the maximum number of OpenMP threads (per rank)
    is, for efficiency reasons, limited to 64. While it is rarely
    beneficial to use a number of threads higher than this, the
    GMX_OPENMP_MAX_THREADS CMake variable can be used to increase the
    limit.

` `{.docutils .literal .notranslate}[` -npme `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   The total number of ranks to dedicate to the long-ranged component
    of PME, if used. The default, -1, will dedicate ranks only if the
    total number of threads is at least 12, and will use around a
    quarter of the ranks for the long-ranged component.

` `{.docutils .literal .notranslate}[` -ntomp_pme `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   When using PME with separate PME ranks, the total number of OpenMP
    threads per separate PME rank. The default, 0, copies the value from
    ` `{.docutils .literal .notranslate}[` -ntomp `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} .

` `{.docutils .literal .notranslate}[` -pin `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   Can be set to â€œauto,â€? â€œonâ€? or â€œoffâ€? to control whether
    will attempt to set the affinity of threads to cores. Defaults to
    â€œauto,â€? which means that if detects that all the cores on the
    node are being used for , then it should behave like â€œon,â€? and
    attempt to set the affinities (unless they are already set by
    something else).

` `{.docutils .literal .notranslate}[` -pinoffset `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   If ` `{.docutils .literal .notranslate}[` -pin `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` on `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} , specifies
    the logical core number to which should pin the first thread. When
    running more than one instance of on a node, use this option to to
    avoid pinning threads from different instances to the same core.

` `{.docutils .literal .notranslate}[` -pinstride `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   If ` `{.docutils .literal .notranslate}[` -pin `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` on `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} , specifies
    the stride in logical core numbers for the cores to which should pin
    its threads. When running more than one instance of on a node, use
    this option to avoid pinning threads from different instances to the
    same core. Use the default, 0, to minimize the number of threads per
    physical core - this lets manage the hardware-, OS- and
    configuration-specific details of how to map logical cores to
    physical cores.

` `{.docutils .literal .notranslate}[` -ddorder `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   Can be set to â€œinterleave,â€? â€œpp_pmeâ€? or â€œcartesian.â€?
    Defaults to â€œinterleave,â€? which means that any separate PME
    ranks will be mapped to MPI ranks in an order like PP, PP, PME, PP,
    PP, PME, etc. This generally makes the best use of the available
    hardware. â€œpp_pmeâ€? maps all PP ranks first, then all PME ranks.
    â€œcartesianâ€? is a special-purpose mapping generally useful only
    on special torus networks with accelerated global communication for
    Cartesian communicators. Has no effect if there are no separate PME
    ranks.

` `{.docutils .literal .notranslate}[` -nb `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   Used to set where to execute the short-range non-bonded
    interactions. Can be set to â€œautoâ€?, â€œcpuâ€?, â€œgpu.â€?
    Defaults to â€œauto,â€? which uses a compatible GPU if available.
    Setting â€œcpuâ€? requires that no GPU is used. Setting â€œgpuâ€?
    requires that a compatible GPU is available and will be used.

` `{.docutils .literal .notranslate}[` -pme `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   Used to set where to execute the long-range non-bonded interactions.
    Can be set to â€œautoâ€?, â€œcpuâ€?, â€œgpu.â€? Defaults to
    â€œauto,â€? which uses a compatible GPU if available. Setting
    â€œgpuâ€? requires that a compatible GPU is available. Multiple PME
    ranks are not supported with PME on GPU, so if a GPU is used for the
    PME calculation -npme must be set to 1.

` `{.docutils .literal .notranslate}[` -bonded `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   Used to set where to execute the bonded interactions that are part
    of the PP workload for a domain. Can be set to â€œautoâ€?,
    â€œcpuâ€?, â€œgpu.â€? Defaults to â€œauto,â€? which uses a
    compatible CUDA GPU only when one is available, a GPU is handling
    short-ranged interactions, and the CPU is handling long-ranged
    interaction work (electrostatic or LJ). The work for the bonded
    interactions takes place on the same GPU as the short-ranged
    interactions, and cannot be independently assigned. Setting
    â€œgpuâ€? requires that a compatible GPU is available and will be
    used.

` `{.docutils .literal .notranslate}[` -update `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   Used to set where to execute update and constraints, when present.
    Can be set to â€œautoâ€?, â€œcpuâ€?, â€œgpu.â€? Defaults to
    â€œauto,â€? which currently always uses the CPU. Setting â€œgpuâ€?
    requires that a compatible CUDA GPU is available, the simulation
    uses a single rank. Update and constraints on a GPU is currently not
    supported with mass and constraints free-energy perturbation, domain
    decomposition, virtual sites, Ewald surface correction, replica
    exchange, constraint pulling, orientation restraints and
    computational electrophysiology.

` `{.docutils .literal .notranslate}[` -gpu_id `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   A string that specifies the ID numbers of the GPUs that are
    available to be used by ranks on each node. For example, â€œ12â€?
    specifies that the GPUs with IDs 1 and 2 (as reported by the GPU
    runtime) can be used by . This is useful when sharing a node with
    other computations, or if a GPU that is dedicated to a display
    should not be used by GROMACS. Without specifying this parameter,
    will utilize all GPUs. When many GPUs are present, a comma may be
    used to separate the IDs, so â€œ12,13â€? would make GPUs 12 and 13
    available to . It could be necessary to use different GPUs on
    different nodes of a simulation, in which case the environment
    variable ` `{.docutils .literal
    .notranslate}[` GMX_GPU_ID `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} can be set
    differently for the ranks on different nodes to achieve that result.
    In GROMACS versions preceding 2018 this parameter used to specify
    both GPU availability and GPU task assignment. The latter is now
    done with the ` `{.docutils .literal
    .notranslate}[` -gputasks `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} parameter.

` `{.docutils .literal .notranslate}[` -gputasks `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   A string that specifies the ID numbers of the GPUs to be used by
    corresponding GPU tasks on this node. For example, â€œ0011â€?
    specifies that the first two GPU tasks will use GPU 0, and the other
    two use GPU 1. When using this option, the number of ranks must be
    known to , as well as where tasks of different types should be run,
    such as by using ` `{.docutils .literal
    .notranslate}[` -nb `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` gpu `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} - only the
    tasks which are set to run on GPUs count for parsing the mapping.
    See for more details. Note that ` `{.docutils .literal
    .notranslate}[` -gpu_id `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} and
    ` `{.docutils .literal .notranslate}[` -gputasks `{.docutils
    .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}
    can not be used at the same time! In GROMACS versions preceding 2018
    only a single type of GPU task (â€œPPâ€?) could be run on any rank.
    Now that there is some support for running PME on GPUs, the number
    of GPU tasks (and the number of GPU IDs expected in the
    ` `{.docutils .literal .notranslate}[` -gputasks `{.docutils
    .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}
    string) can actually be 3 for a single-rank simulation. The IDs
    still have to be the same in this case, as using multiple GPUs per
    single rank is not yet implemented. The order of GPU tasks per rank
    in the string is PP first, PME second. The order of ranks with
    different kinds of GPU tasks is the same by default, but can be
    influenced with the ` `{.docutils .literal
    .notranslate}[` -ddorder `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} option and
    gets quite complex when using multiple nodes. Note that the bonded
    interactions for a PP task may run on the same GPU as the
    short-ranged work, or on the CPU, which can be controlled with the
    ` `{.docutils .literal .notranslate}[` -bonded `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} flag. The
    GPU task assignment (whether manually set, or automated), will be
    reported in the output on the first physical node of the simulation.
    For example:

    ::: {.highlight-default .notranslate}
    ::: highlight
        gmx mdrun -gputasks 0001 -nb gpu -pme gpu -npme 1 -ntmpi 4
    :::
    :::

    will produce the following output in the log file/terminal:

    ::: {.highlight-default .notranslate}
    ::: highlight
        On host tcbl14 2 GPUs selected for this run.
        Mapping of GPU IDs to the 4 GPU tasks in the 4 ranks on this node:
        PP:0,PP:0,PP:0,PME:1
    :::
    :::

    In this case, 3 ranks are set by user to compute PP work on GPU 0,
    and 1 rank to compute PME on GPU 1. The detailed indexing of the
    GPUs is also reported in the log file.

    For more information about GPU tasks, please refer to .

` `{.docutils .literal .notranslate}[` -pmefft `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   Allows choosing whether to execute the 3D FFT computation on a CPU
    or GPU. Can be set to â€œautoâ€?, â€œcpuâ€?, â€œgpu.â€?. When PME is
    offloaded to a GPU ` `{.docutils .literal
    .notranslate}[` -pmefft `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` gpu `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} is the
    default, and the entire PME calculation is executed on the GPU.
    However, in some cases, e.g. with a relatively slow or older
    generation GPU combined with fast CPU cores in a run, moving some
    work off of the GPU back to the CPU by computing FFTs on the CPU can
    improve performance.

::: {#examples-for-mdrun-on-one-node .section}
[ ]{#gmx-mdrun-single-node}

### Examples for on one node

::: {.highlight-default .notranslate}
::: highlight
    gmx mdrun
:::
:::

Starts using all the available resources. will automatically choose a
fairly efficient division into thread-MPI ranks, OpenMP threads and
assign work to compatible GPUs. Details will vary with hardware and the
kind of simulation being run.

::: {.highlight-default .notranslate}
::: highlight
    gmx mdrun -nt 8
:::
:::

Starts using 8 threads, which might be thread-MPI or OpenMP threads
depending on hardware and the kind of simulation being run.

::: {.highlight-default .notranslate}
::: highlight
    gmx mdrun -ntmpi 2 -ntomp 4
:::
:::

Starts using eight total threads, with two thread-MPI ranks and four
OpenMP threads per rank. You should only use these options when seeking
optimal performance, and must take care that the ranks you create can
have all of their OpenMP threads run on the same socket. The number of
ranks should be a multiple of the number of sockets, and the number of
cores per node should be a multiple of the number of threads per rank.

::: {.highlight-default .notranslate}
::: highlight
    gmx mdrun -ntmpi 4 -nb gpu -pme cpu
:::
:::

Starts using four thread-MPI ranks. The CPU cores available will be
split evenly between the ranks using OpenMP threads. The long-range
component of the forces are calculated on CPUs. This may be optimal on
hardware where the CPUs are relatively powerful compared to the GPUs.
The bonded part of force calculation will automatically be assigned to
the GPU, since the long-range component of the forces are calculated on
CPU(s).

::: {.highlight-default .notranslate}
::: highlight
    gmx mdrun -ntmpi 1 -nb gpu -pme gpu -bonded gpu -update gpu
:::
:::

Starts using a single thread-MPI rank that will use all available CPU
cores. All interaction types that can run on a GPU will do so. This may
be optimal on hardware where the CPUs are extremely weak compared to the
GPUs.

::: {.highlight-default .notranslate}
::: highlight
    gmx mdrun -ntmpi 4 -nb gpu -pme cpu -gputasks 0011
:::
:::

Starts using four thread-MPI ranks, and maps them to GPUs with IDs 0
and 1. The CPU cores available will be split evenly between the ranks
using OpenMP threads, with the first two ranks offloading short-range
nonbonded force calculations to GPU 0, and the last two ranks offloading
to GPU 1. The long-range component of the forces are calculated on CPUs.
This may be optimal on hardware where the CPUs are relatively powerful
compared to the GPUs.

::: {.highlight-default .notranslate}
::: highlight
    gmx mdrun -ntmpi 4 -nb gpu -pme gpu -npme 1 -gputasks 0001
:::
:::

Starts using four thread-MPI ranks, one of which is dedicated to the
long-range PME calculation. The first 3 threads offload their
short-range non-bonded calculations to the GPU with ID 0, the 4th (PME)
thread offloads its calculations to the GPU with ID 1.

::: {.highlight-default .notranslate}
::: highlight
    gmx mdrun -ntmpi 4 -nb gpu -pme gpu -npme 1 -gputasks 0011
:::
:::

Similar to the above example, with 3 ranks assigned to calculating
short-range non-bonded forces, and one rank assigned to calculate the
long-range forces. In this case, 2 of the 3 short-range ranks offload
their nonbonded force calculations to GPU 0. The GPU with ID 1
calculates the short-ranged forces of the 3rd short-range rank, as well
as the long-range forces of the PME-dedicated rank. Whether this or the
above example is optimal will depend on the capabilities of the
individual GPUs and the system composition.

::: {.highlight-default .notranslate}
::: highlight
    gmx mdrun -gpu_id 12
:::
:::

Starts using GPUs with IDs 1 and 2 (e.g. because GPU 0 is dedicated to
running a display). This requires two thread-MPI ranks, and will split
the available CPU cores between them using OpenMP threads.

::: {.highlight-default .notranslate}
::: highlight
    gmx mdrun -nt 6 -pin on -pinoffset 0 -pinstride 1
    gmx mdrun -nt 6 -pin on -pinoffset 6 -pinstride 1
:::
:::

Starts two processes, each with six total threads arranged so that the
processes affect each other as little as possible by being assigned to
disjoint sets of physical cores. Threads will have their affinities set
to particular logical cores, beginning from the first and 7th logical
cores, respectively. The above would work well on an Intel CPU with six
physical cores and hyper-threading enabled. Use this kind of setup only
if restricting to a subset of cores to share a node with other
processes. A word of caution: The mapping of logical CPUs/cores to
physical cores may differ between operating systems. On Linux,
` `{.docutils .literal .notranslate}[` cat `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` /proc/cpuinfo `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} can be examined
to determine this mapping.

::: {.highlight-default .notranslate}
::: highlight
    mpirun -np 2 gmx_mpi mdrun
:::
:::

When using an compiled with external MPI, this will start two ranks and
as many OpenMP threads as the hardware and MPI setup will permit. If the
MPI setup is restricted to one node, then the resulting will be local to
that node.
:::
:::

::: {#running-mdrun-on-more-than-one-node .section}
[ ]{#gmx-mdrun-multiple-nodes}

## Running on more than one node

This requires configuring GROMACS to build with an external MPI library.
By default, this executable is run with ` `{.docutils .literal
.notranslate}[` gmx_mpi `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` mdrun `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . All of the
considerations for running single-node still apply, except that
` `{.docutils .literal .notranslate}[` -ntmpi `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` -nt `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} cause a fatal
error, and instead the number of ranks is controlled by the MPI
environment. Settings such as ` `{.docutils .literal
.notranslate}[` -npme `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} are much more
important when using multiple nodes. Configuring the MPI environment to
produce one rank per core is generally good until one approaches the
strong-scaling limit. At that point, using OpenMP to spread the work of
an MPI rank over more than one core is needed to continue to improve
absolute performance. The location of the scaling limit depends on the
processor, presence of GPUs, network, and simulation algorithm, but it
is worth measuring at around \~200 particles/core if you need maximum
throughput.

There are further command-line parameters that are relevant in these
cases.

` `{.docutils .literal .notranslate}[` -tunepme `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   Defaults to â€œon.â€? If â€œon,â€? a simulation will optimize
    various aspects of the PME and DD algorithms, shifting load between
    ranks and/or GPUs to maximize throughput. Some features are not
    compatible with this, and these ignore this option.

` `{.docutils .literal .notranslate}[` -dlb `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

:   Can be set to â€œauto,â€? â€œno,â€? or â€œyes.â€? Defaults to
    â€œauto.â€? Doing Dynamic Load Balancing between MPI ranks is needed
    to maximize performance. This is particularly important for
    molecular systems with heterogeneous particle or interaction
    density. When a certain threshold for performance loss is exceeded,
    DLB activates and shifts particles between ranks to improve
    performance. If available, using ` `{.docutils .literal
    .notranslate}[` -bonded `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` gpu `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} is expected
    to improve the ability of DLB to maximize performance. DLB is not
    compatible with GPU-resident parallelization (with ` `{.docutils
    .literal .notranslate}[` -update `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` gpu `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} ) and
    therefore it remains switched off in such simulations.

During the simulation must communicate between all PP ranks to compute
quantities such as kinetic energy for log file reporting, or perhaps
temperature coupling. By default, this happens whenever necessary to
honor several , so that the period between communication phases is the
least common denominator of , , and .

Note that ` `{.docutils .literal .notranslate}[` -tunepme `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} has
more effect when there is more than one , because the cost of
communication for the PP and PME ranks differs. It still shifts load
between PP and PME ranks, but does not change the number of separate PME
ranks in use.

Note also that ` `{.docutils .literal .notranslate}[` -dlb `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` -tunepme `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} can interfere
with each other, so if you experience performance variation that could
result from this, you may wish to tune PME separately, and run the
result with ` `{.docutils .literal .notranslate}[` mdrun `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` -notunepme `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` -dlb `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` yes `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} .

The utility is available to search a wider range of parameter space,
including making safe modifications to the file, and varying
` `{.docutils .literal .notranslate}[` -npme `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . It is only
aware of the number of ranks created by the MPI environment, and does
not explicitly manage any aspect of OpenMP during the optimization.

::: {#examples-for-mdrun-on-more-than-one-node .section}
### Examples for on more than one node

The examples and explanations for for single-node are still relevant,
but ` `{.docutils .literal .notranslate}[` -ntmpi `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} is no longer
the way to choose the number of MPI ranks.

::: {.highlight-default .notranslate}
::: highlight
    mpirun -np 16 gmx_mpi mdrun
:::
:::

Starts with 16 ranks, which are mapped to the hardware by the MPI
library, e.g. as specified in an MPI hostfile. The available cores will
be automatically split among ranks using OpenMP threads, depending on
the hardware and any environment settings such as ` `{.docutils .literal
.notranslate}[` OMP_NUM_THREADS `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} .

::: {.highlight-default .notranslate}
::: highlight
    mpirun -np 16 gmx_mpi mdrun -npme 5
:::
:::

Starts with 16 ranks, as above, and require that 5 of them are dedicated
to the PME component.

::: {.highlight-default .notranslate}
::: highlight
    mpirun -np 11 gmx_mpi mdrun -ntomp 2 -npme 6 -ntomp_pme 1
:::
:::

Starts with 11 ranks, as above, and require that six of them are
dedicated to the PME component with one OpenMP thread each. The
remaining five do the PP component, with two OpenMP threads each.

::: {.highlight-default .notranslate}
::: highlight
    mpirun -np 4 gmx_mpi mdrun -ntomp 6 -nb gpu -gputasks 00
:::
:::

Starts on a machine with two nodes, using four total ranks, each rank
with six OpenMP threads, and both ranks on a node sharing GPU with ID 0.

::: {.highlight-default .notranslate}
::: highlight
    mpirun -np 8 gmx_mpi mdrun -ntomp 3 -gputasks 0000
:::
:::

Using a same/similar hardware as above, starts on a machine with two
nodes, using eight total ranks, each rank with three OpenMP threads, and
all four ranks on a node sharing GPU with ID 0. This may or may not be
faster than the previous setup on the same hardware.

::: {.highlight-default .notranslate}
::: highlight
    mpirun -np 20 gmx_mpi mdrun -ntomp 4 -gputasks 00
:::
:::

Starts with 20 ranks, and assigns the CPU cores evenly across ranks each
to one OpenMP thread. This setup is likely to be suitable when there are
ten nodes, each with one GPU, and each node has two sockets each of four
cores.

::: {.highlight-default .notranslate}
::: highlight
    mpirun -np 10 gmx_mpi mdrun -gpu_id 1
:::
:::

Starts with 20 ranks, and assigns the CPU cores evenly across ranks each
to one OpenMP thread. This setup is likely to be suitable when there are
ten nodes, each with two GPUs, but another job on each node is using GPU
0. The job scheduler should set the affinity of threads of both jobs to
their allocated cores, or the performance of will suffer greatly.

::: {.highlight-default .notranslate}
::: highlight
    mpirun -np 20 gmx_mpi mdrun -gpu_id 01
:::
:::

Starts with 20 ranks. This setup is likely to be suitable when there are
ten nodes, each with two GPUs, but there is no need to specify
` `{.docutils .literal .notranslate}[` -gpu_id `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} for the normal
case where all the GPUs on the node are available for use.
:::
:::

::: {#avoiding-communication-for-constraints .section}
## Avoiding communication for constraints

Because of the very short time it takes to perform an MD step, in
particular close to the scaling limit, any communication will have a
negative effect on performance due to latency overhead and
synchronization. Most of the communication can not be avoided, but
sometimes one can completely avoid communication of coordinates for
constraints. The points listed below will improve performance in general
and can have a particularly strong effect at the scaling limit which is
around \~100 atoms/core or \~10000 atoms/GPU. Simulations that need to
be done as fast as possible, or strong-scaling benchmarks should be
constructed with these points in mind.

When possible, one should avoid the use of ` `{.docutils .literal
.notranslate}[` constraints `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate}[` = `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` all-bonds `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} with P-LINCS.
This not only requires a lot of communication, it also sets an
artificial minimum on the size of domains. If you are using an atomistic
force field and integrating with a time step of 2 fs, you can usually
change to constraints ` `{.docutils .literal
.notranslate}[` constraints `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate}[` = `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` h-bonds `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} without
changing other settings. These are actually the settings most force
fields were parameterized with, so this is also scientifically better.

To completely avoid communication for constraints and/or to have the
update run on a GPU, the system needs to support so-called â€œupdate
groupsâ€? (or no constraints at all). Update groups are supported when
all atoms involved in coupled constraints are coupled directly to one
central atom and consecutively ordered, not interdispersed with
non-constrained atoms. An example is a compactly described methyl group.
For atomistic force fields with ` `{.docutils .literal
.notranslate}[` constraints `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate}[` = `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` h-bonds `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} this means in
practice that in the topology hydrogens come adjacent to their connected
heavy atom. In addition, when virtual sites are present, the
constructing atoms should all be constrained together and the virtual
site and constructing atoms should be consecutive, but the order does
not matter. The TIP4P water model is an example of this. Whether or not
update groups are used is noted in the log file. When they cannot be
used, the reason for disabling them is also noted.
:::

::: {#finding-out-how-to-run-mdrun-better .section}
## Finding out how to run better

The Wallcycle module is used for runtime performance measurement of . At
the end of the log file of each run, the â€œReal cycle and time
accountingâ€? section provides a table with runtime statistics for
different parts of the code in rows of the table. The table contains
columns indicating the number of ranks and threads that executed the
respective part of the run, wall-time and cycle count aggregates (across
all threads and ranks) averaged over the entire run. The last column
also shows what percentage of the total runtime each row represents.
Note that the timer resetting functionalities ( ` `{.docutils .literal
.notranslate}[` -resethway `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` -resetstep `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ) reset the
performance counters and therefore are useful to avoid startup overhead
and performance instability (e.g. due to load balancing) at the
beginning of the run.

The performance counters are:

-   Particle-particle during Particle mesh Ewald

-   Domain decomposition

-   Domain decomposition communication load

-   Domain decomposition communication bounds

-   Virtual site constraints

-   Send X to Particle mesh Ewald

-   Neighbor search

-   Launch GPU operations

-   Communication of coordinates

-   Force

-   Waiting + Communication of force

-   Particle mesh Ewald

-   PME redist. X/F

-   PME spread

-   PME gather

-   PME 3D-FFT

-   PME 3D-FFT Communication

-   PME solve Lennard-Jones

-   PME solve LJ

-   PME solve Elec

-   PME wait for particle-particle

-   Wait + Receive PME force

-   Wait GPU nonlocal

-   Wait GPU local

-   Wait PME GPU spread

-   Wait PME GPU gather

-   Reduce PME GPU Force

-   Non-bonded position/force buffer operations

-   Virtual site spread

-   COM pull force

-   AWH (accelerated weight histogram method)

-   Write trajectory

-   Update

-   Constraints

-   Communication of energies

-   Enforced rotation

-   Add rotational forces

-   Position swapping

-   Interactive MD

-   MD Graph

As performance data is collected for every run, they are essential to
assessing and tuning the performance of performance. Therefore, they
benefit both code developers as well as users of the program. The
counters are an average of the time/cycles different parts of the
simulation take, hence can not directly reveal fluctuations during a
single run (although comparisons across multiple runs are still very
useful).

Counters will appear in an MD log file only if the related parts of the
code were executed during the run. There is also a special counter
called â€œRestâ€? which indicates the amount of time not accounted for
by any of the counters above. Therefore, a significant amount â€œRestâ€?
time (more than a few percent) will often be an indication of
parallelization inefficiency (e.g. serial code) and it is recommended to
be reported to the developers.

An additional set of subcounters can offer more fine-grained inspection
of performance. They are:

-   Domain decomposition redistribution

-   DD neighbor search grid + sort

-   DD setup communication

-   DD make topology

-   DD make constraints

-   DD topology other

-   Neighbor search grid local

-   NS grid non-local

-   NS search local

-   NS search non-local

-   Bonded force

-   Bonded-FEP force

-   Restraints force

-   Listed buffer operations

-   Nonbonded pruning

-   Nonbonded force

-   Launch non-bonded GPU tasks

-   Launch PME GPU tasks

-   Ewald force correction

-   Non-bonded position buffer operations

-   Non-bonded force buffer operations

Subcounters are geared toward developers and have to be enabled during
compilation. See for more information.
:::

::: {#running-mdrun-with-gpus .section}
[ ]{#gmx-mdrun-on-gpu}

## Running with GPUs

::: {#types-of-gpu-tasks .section}
[ ]{#gmx-gpu-tasks}

### Types of GPU tasks

To better understand the later sections on different GPU use cases for
calculation of , , and we first introduce the concept of different GPU
tasks. When thinking about running a simulation, several different kinds
of interactions between the atoms have to be calculated (for more
information please refer to the reference manual). The calculation can
thus be split into several distinct parts that are largely independent
of each other (hence can be calculated in any order, e.g. sequentially
or concurrently), with the information from each of them combined at the
end of time step to obtain the final forces on each atom and to
propagate the system to the next time point. For a better understanding
also please see the section on .

Of all calculations required for an MD step, GROMACS aims to optimize
performance bottom-up for each step from the lowest level (SIMD unit,
cores, sockets, accelerators, etc.). Therefore many of the individual
computation units are highly tuned for the lowest level of hardware
parallelism: the SIMD units. Additionally, with GPU accelerators used as
*co-processors* , some of the work can be *offloaded* , that is
calculated simultaneously/concurrently with the CPU on the accelerator
device, with the result being communicated to the CPU. Right now,
GROMACS supports GPU accelerator offload of two tasks: the short-range ,
and .

GROMACS supports two major offload modes: force-offload and
GPU-resident. The former involves offloading some of or all interaction
calculations with integration on the CPU (hence requiring per-step data
movement). In the GPU-resident mode by offloading integration and
constraints (when used) less data movement is necessary.

The force-offload mode is the more broadly supported GPU-acceleration
mode with short-range nonbonded offload supported on a wide range of GPU
accelerators (NVIDIA, AMD, and Intel). This is compatible with the grand
majority of the features and parallelization modes and can be used to
scale to large machines. Simultaneously offloading both short-range
nonbonded and long-range PME work to GPU accelerators has some
restrictions in terms of feature and parallelization compatibility
(please see the ). Offloading (most types of) bonded interactions is
supported in CUDA and SYCL. The GPU-resident mode is supported with CUDA
and SYCL, but it has additional limitations as described in .

::: {#gpu-computation-of-short-range-nonbonded-interactions .section}
[ ]{#gmx-gpu-pp}

#### GPU computation of short range nonbonded interactions

Using the GPU for the short-ranged nonbonded interactions provides the
majority of the available speed-up compared to run using only the CPU.
Here, the GPU acts as an accelerator that can effectively parallelize
this problem and thus reduce the calculation time.
:::

::: {#gpu-accelerated-calculation-of-pme .section}
[ ]{#gmx-gpu-pme}

#### GPU accelerated calculation of PME

GROMACS allows offloading of the PME calculation to the GPU, to further
reduce the load on the CPU and improve usage overlap between CPU and
GPU. Here, the solving of PME will be performed in addition to the
calculation of the short range interactions on the same GPU as the short
range interactions.
:::

::: {#known-limitations .section}
[ ]{#gmx-pme-gpu-limitations}

#### Known limitations

**Please note again the limitations outlined below!**

-   Only a PME order of 4 is supported on GPUs.

-   Multiple ranks (hence multiple GPUs) computing PME have limited
    support: experimental PME decomposition in hybrid mode (
    ` `{.docutils .literal .notranslate}[` -pmefft `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` cpu `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} ) with CUDA
    from the 2022 release and full GPU PME decomposition since the 2023
    release with CUDA or SYCL (when GROMACS is built with or ).

-   Only dynamical integrators are supported (ie. leap-frog, Velocity
    Verlet, stochastic dynamics)

-   LJ PME is not supported on GPUs.

-   When GROMACS is built with SYCL using oneAPI for AMD/NVIDIA GPUs,
    only hybrid mode ( ` `{.docutils .literal
    .notranslate}[` -pmefft `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` cpu `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} ) is
    supported. Fully-offloaded PME is supported when using oneAPI for
    Intel GPUs and hipSYCL for AMD/NVIDIA GPUs.
:::

::: {#gpu-accelerated-calculation-of-bonded-interactions-cuda-and-sycl .section}
[ ]{#gmx-gpu-bonded}

#### GPU accelerated calculation of bonded interactions (CUDA and SYCL)

GROMACS allows the offloading of the bonded part of the PP workload to a
compatible GPU. This is treated as part of the PP work, and requires
that the short-ranged non-bonded task also runs on a GPU. Typically,
there is a performance advantage to offloading bonded interactions in
particular when the amount of CPU resources per GPU is relatively little
(either because the CPU is weak or there are few CPU cores assigned to a
GPU in a run) or when there are other computations on the CPU. A typical
case for the latter is free-energy calculations.
:::

::: {#gpu-accelerated-calculation-of-constraints-and-coordinate-update-cuda-and-sycl-only .section}
[ ]{#gmx-gpu-update}

#### GPU accelerated calculation of constraints and coordinate update (CUDA and SYCL only)

GROMACS makes it possible to also perform the coordinate update and (if
requested) constraint calculation on a GPU. This parallelization mode is
referred to as â€œGPU-residentâ€? as all force and coordinate data can
remain resident on the GPU for a number of steps (typically between
temperature/pressure coupling or neighbor searching steps). The
GPU-resident mode allows executing all (supported) computation of a
simulation step on the GPU. This has the benefit that there is less
coupling between CPU host and GPU and on typical MD steps data does not
need to be transferred between CPU and GPU in contrast to the
force-offload scheme requires coordinates and forces to be transferred
every step between the CPU and GPU. The GPU-resident scheme however is
still able to carry out part of the computation on the CPU concurrently
with GPU calculation. This helps supporting the broad range of GROMACS
features not all of which are ported to GPUs. At the same time, it also
allows improving performance by making use of the otherwise mostly idle
CPU. It can often be advantageous to move the bonded or PME calculation
back to the CPU, but the details of this will depending on the relative
performance if the CPU cores paired in a simulation with a GPU.

GPU-resident mode is enabled by default (when supported) with an
automatic fallback to CPU update when the build configuration or
simulation settings are incompatible with it. It is possible to change
the default behaviour by setting the ` `{.docutils .literal
.notranslate}[` GMX_FORCE_UPDATE_DEFAULT_CPU `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} environment
variable. In this case simulations following the default behavior (ie.
` `{.docutils .literal .notranslate}[` -update `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` auto `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ) will run the
update on the CPU.

Using this parallelization mode is typically advantageous in cases where
a fast GPU is used with a slower CPU, in particular if there is only
single simulation assigned to a GPU. However, in typical throughput
cases where multiple runs are assigned to each GPU, offloading
everything, especially without moving back some of the work to the CPU
can perform worse than the parallelization mode where only force
computation is offloaded.
:::

::: {#assigning-tasks-to-gpus .section}
#### Assigning tasks to GPUs

Depending on which tasks should be performed on which hardware,
different kinds of calculations can be combined on the same or different
GPUs, according to the information provided for running .

It is possible to assign the calculation of the different computational
tasks to the same GPU, meaning that they will share the computational
resources on the same device, or to different processing units that will
each perform one task each.

One overview over the possible task assignments is given below:

GROMACS version 2018:

> <div>
>
> Two different types of assignable GPU accelerated tasks are available,
> (short-range) nonbonded and PME. Each PP rank has a nonbnonded task
> that can be offloaded to a GPU. If there is only one rank with a PME
> task (including if that rank is a PME-only rank), then that task can
> be offloaded to a GPU. Such a PME task can run wholly on the GPU, or
> have its latter stages run only on the CPU.
>
> Limitations are that PME on GPU does not support PME domain
> decomposition, so that only one PME task can be offloaded to a single
> GPU assigned to a separate PME rank, while the nonbonded can be
> decomposed and offloaded to multiple GPUs.
>
> </div>

GROMACS version 2019:

> <div>
>
> No new assignable GPU tasks are available, but any bonded interactions
> may run on the same GPU as the short-ranged interactions for a PP
> task. This can be influenced with the ` `{.docutils .literal
> .notranslate}[` -bonded `{.docutils .literal
> .notranslate}]{.pre}` `{.docutils .literal .notranslate} flag.
>
> </div>

GROMACS version 2020:

> <div>
>
> Update and constraints can run on the same GPU as the short-ranged
> nonbonded and bonded interactions for a PP task. This can be
> influenced with the ` `{.docutils .literal
> .notranslate}[` -update `{.docutils .literal
> .notranslate}]{.pre}` `{.docutils .literal .notranslate} flag.
>
> </div>

GROMACS version 2021/2022:

> <div>
>
> Communication and auxiliary tasks can also be offloaded in CUDA
> builds. In domain-decomposition halo exchange and PP-PME
> communication, instead of staging transfers between GPUs though the
> CPU, direct GPUâ€"GPU communication is possible. As an auxiliary tasks
> for halo exchange data packing and unpacking is performed which is
> also offloaded to the GPU. In the 2021 release this is supported with
> thread-MPI and from the 2022 release it is also supported using
> GPU-aware MPI. Direct GPU communication is not enabled by default and
> can be triggered using the ` `{.docutils .literal
> .notranslate}[` GMX_ENABLE_DIRECT_GPU_COMM `{.docutils .literal
> .notranslate}]{.pre}` `{.docutils .literal .notranslate} environment
> variable (will only have an effect on supported systems).
>
> </div>

GROMACS version 2023:

> <div>
>
> Update now runs by default on the GPU with supported simulation
> settings; note that this is only available with CUDA and SYCL not with
> OpenCL.
>
> PME decomposition support adds additional parallelization-related
> auxiliary GPU tasks including grid packing and reduction operations as
> well as distributed GPU FFT computation.
>
> Experimental support for CUDA-graphs scheduling has been added, which
> supports most GPU-resident runs that donâ€™t require CPU force
> computation.
>
> </div>
:::

::: {#performance-considerations-for-gpu-tasks .section}
#### Performance considerations for GPU tasks

1.  The performance balance depends on the speed and number of CPU cores
    you have vs the speed and number of GPUs you have.

2.  The GPU-resident parallelization mode (with update/constraints
    offloaded) is less sensitive to the appropriate CPU-GPU balance than
    the force-offload mode.

3.  With slow/old GPUs and/or fast/modern CPUs with many cores, it might
    make more sense to let the CPU do PME calculation, with the GPUs
    focused on the nonbonded calculation.

4.  With fast/modern GPUs and/or slow/old CPUs with few cores, it
    generally helps to have the GPU do PME.

5.  Offloading bonded work to a GPU will often not improve simulation
    performance as efficient CPU-based kernels can complete the bonded
    computation before the GPU is done with other offloaded work.
    Therefore, will default to no bonded offload when PME is offloaded.
    Typical cases where performance can improve with bonded offload are:
    with significant bonded work (e.g. pure lipid or mostly polymer
    systems with little solvent), with very few and/or slow CPU cores
    per GPU, or when the CPU does other computation (e.g. PME, free
    energy).

6.  On most modern hardware GPU-resident mode (default) is faster than
    force-offload mode, although it may leave the CPU idle. Moving back
    the bonded work to the CPU ( ` `{.docutils .literal
    .notranslate}[` -bonded `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` cpu `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} ) is a
    better way to make use of a fast CPU than leaving integration and
    constraints on the CPU. The only exception may be multi-simulations
    with a significant number of simulations assigned to each GPU.

7.  Direct GPU communication will in most cases outperform staged
    communication (both with thread-MPI and MPI). Ideally it should be
    combined with GPU-resident mode to maximize the benefit.

8.  The only way to know for sure which alternative is best for your
    machine is to test and check performance.
:::
:::

::: {#reducing-overheads-in-gpu-accelerated-runs .section}
### Reducing overheads in GPU accelerated runs

In order for CPU cores and GPU(s) to execute concurrently, tasks are
launched and executed asynchronously on the GPU(s) while the CPU cores
execute non-offloaded force computation (like computing bonded forces or
free energy computation). Asynchronous task launches are handled by the
GPU device driver and require CPU involvement. Therefore, scheduling GPU
tasks requires CPU resources that can compete with other CPU tasks and
cause interference that could lead to slowdown.

Delays in CPU execution are caused by the latency of launching GPU
tasks, an overhead that can become significant as simulation ns/day
increases (i.e. with shorter wall-time per step). The cost of launching
GPU work is measured by and reported in the performance summary section
of the log file (â€œLaunch PP GPU ops.â€?/â€?Launch PME GPU ops.â€?
rows). A few percent of runtime spent in launching work is normal, but
in fast-iterating and multi-GPU parallel runs, costs of 10% or larger
can be observed. Whether this has a significant performance impact
depends on how much work within the main MD step is assigned to the CPU.
With most or all force computation offloaded, and when the CPU is not
involved in communication (e.g. with thread-MPI and direct GPU
communication enabled) it may be that large launch costs do not lead to
large performance losses. However, when the CPU is assigned computation
(e.g. in free energy or pull/AWH simulations) or MPI communication is
launched from the CPU (even with GPU-aware MPI), the GPU launch cost
will compete with other CPU work and therefore represent overheads. In
general, a user can do little to avoid such overheads, but there are a
few cases where tweaks can give performance benefits. In OpenCL runs,
timing of GPU tasks is by default enabled and, while in most cases its
impact is small, in fast runs performance can be affected. In these
cases, when more than a few percent of â€œLaunch GPU opsâ€? time is
observed, it is recommended to turn off timing by setting the
` `{.docutils .literal
.notranslate}[` GMX_DISABLE_GPU_TIMING `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} environment
variable. In parallel runs with many ranks sharing a GPU, launch
overheads can also be reduced by starting fewer thread-MPI or MPI ranks
per GPU; e.g. most often one rank per thread or core is not optimal. The
CUDA graphs functionality (added in GROMACS 2023) targets reducing such
overheads and improving GPU work scheduling efficiency and therefore it
can provide significant improvements especially for small simulation
systems running on fast GPUs. Since it is a new feature, in the 2023
release CUDA-graph support needs to be triggered using the ` `{.docutils
.literal .notranslate}[` GMX_CUDA_GRAPH `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} environment
variable.

The second type of overhead, interference of the GPU runtime or driver
with CPU computation, is caused by the scheduling and coordination of
GPU tasks. A separate GPU runtime/driver thread requires CPU resources
which may compete with the concurrently running non-offloaded tasks (if
present), potentially degrading the performance of this CPU work. To
minimize the overhead it can be useful to leave at least one CPU
hardware thread unused when launching , especially on CPUs with high
core counts and/or simultaneous multithreading enabled. E.g. on a
machine with a 16-core CPU and 32 threads, try ` `{.docutils .literal
.notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` mdrun `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` -ntomp `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` 31 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` -pin `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` on `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . This will
leave some CPU resources for the GPU task scheduling potentially
reducing interference with CPU computation. Note that assigning fewer
resources to CPU computation involves a tradeoff which, with many CPU
cores per GPU, may not be significant, but in some cases (e.g. with
multi-rank MPI runs) it may lead to complex resource assignment and may
outweigh the benefits of reduced GPU scheduling overheads, so we
recommend to test the alternatives before adopting such techniques.
:::
:::

::: {#running-the-opencl-version-of-mdrun .section}
## Running the OpenCL version of mdrun

Currently supported hardware architectures are:

-   GCN-based and CDNA-based AMD GPUs;

-   NVIDIA GPUs prior to Volta;

-   Intel iGPUs.

Make sure that you have the latest drivers installed. For AMD GPUs, the
compute-oriented stack is recommended; alternatively, the AMDGPU-PRO
stack is also compatible; using the outdated and unsupported
` `{.docutils .literal .notranslate}[` fglrx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} proprietary
driver and runtime is not recommended (but for certain older hardware
that may be the only way to obtain support). In addition Mesa version
17.0 or newer with LLVM 4.0 or newer is also supported. For NVIDIA GPUs,
using the proprietary driver is required as the open source nouveau
driver (available in Mesa) does not provide the OpenCL support. For
Intel integrated GPUs, the is recommended.

The minimum OpenCL version required is unknown. See also the .

Devices from the AMD GCN architectures (all series) are compatible and
regularly tested; NVIDIA Kepler and later (compute capability 3.0) are
known to work, but before doing production runs always make sure that
the GROMACS tests pass successfully on the hardware.

The OpenCL GPU kernels are compiled at run time. Hence, building the
OpenCL program can take a few seconds, introducing a slight delay in the
startup. This is not normally a problem for long production MD, but you
might prefer to do some kinds of work, e.g. that runs very few steps, on
just the CPU (e.g. see ` `{.docutils .literal
.notranslate}[` -nb `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} above).

The same ` `{.docutils .literal .notranslate}[` -gpu_id `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} option
(or ` `{.docutils .literal .notranslate}[` GMX_GPU_ID `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}
environment variable) used to select CUDA devices, or to define a
mapping of GPUs to PP ranks, is used for OpenCL devices.

Some other environment variables may be of interest to developers.

::: {#known-limitations-of-the-opencl-support .section}
[ ]{#opencl-known-limitations}

### Known limitations of the OpenCL support

Limitations in the current OpenCL support of interest to GROMACS users:

-   Intel integrated GPUs are supported. Intel CPUs and Xeon Phi are not
    supported. Set ` `{.docutils .literal
    .notranslate}[` -DGMX_GPU_NB_CLUSTER_SIZE=4 `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} when
    compiling GROMACS to run on consumer Intel GPUs (as opposed to Ponte
    Vecchio / Data Center Max GPUs).

-   Due to blocking behavior of some asynchronous task enqueuing
    functions in the NVIDIA OpenCL runtime, with the affected driver
    versions there is almost no performance gain when using NVIDIA GPUs.
    The issue affects NVIDIA driver versions up to 349 series, but it
    known to be fixed 352 and later driver releases.

-   On NVIDIA GPUs the OpenCL kernels achieve much lower performance
    than the equivalent CUDA kernels due to limitations of the NVIDIA
    OpenCL compiler.

-   On the NVIDIA Volta and Turing architectures the OpenCL code is
    known to produce incorrect results with driver version up to 440.x
    (most likely due to compiler issues). Runs typically fail on these
    architectures.
:::
:::

::: {#running-sycl-version-of-mdrun .section}
## Running SYCL version of mdrun

Make sure that you have the latest drivers installed and check the for
the list of compatible hardware and software and the recommended
compile-time options.

Please keep in mind the following environment variables that might be
useful:

-   When using oneAPI runtime:

    -   ` `{.docutils .literal
        .notranslate}[` SYCL_CACHE_PERSISTENT=1 `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal .notranslate} :
        enables caching of GPU kernels, reducing startup time.

In addition to ` `{.docutils .literal
.notranslate}[` -gpu_id `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} option,
backend-specific environment variables, like ` `{.docutils .literal
.notranslate}[` SYCL_DEVICE_FILTER `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} or
` `{.docutils .literal .notranslate}[` ROCR_VISIBLE_DEVICES `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} ,
could be used to select GPUs.
:::

::: {#performance-checklist .section}
## Performance checklist

There are many different aspects that affect the performance of
simulations in GROMACS. Most simulations require a lot of computational
resources, therefore it can be worthwhile to optimize the use of those
resources. Several issues mentioned in the list below could lead to a
performance difference of a factor of 2. So it can be useful go through
the checklist.

::: {#gromacs-configuration .section}
### GROMACS configuration

-   Donâ€™t use double precision unless youâ€™re absolute sure you need
    it.

-   Compile the FFTW library (yourself) with the correct flags on x86
    (in most cases, the correct flags are automatically configured).

-   On x86, use gcc as the compiler (not icc, pgi or the Cray compiler).

-   On POWER, use gcc instead of IBMâ€™s xlc.

-   Use a new compiler version, especially for gcc (e.g. from version 5
    to 6 the performance of the compiled code improved a lot).

-   MPI library: OpenMPI usually has good performance and causes little
    trouble.

-   Make sure your compiler supports OpenMP (some versions of Clang
    donâ€™t).

-   If you have GPUs that support either CUDA, OpenCL, or SYCL, use
    them.

    -   Configure with ` `{.docutils .literal
        .notranslate}[` -DGMX_GPU=CUDA `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal .notranslate} ,
        ` `{.docutils .literal
        .notranslate}[` -DGMX_GPU=OpenCL `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal .notranslate} , or
        ` `{.docutils .literal
        .notranslate}[` -DGMX_GPU=SYCL `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal .notranslate} .

    -   For CUDA, use the newest CUDA available for your GPU to take
        advantage of the latest performance enhancements.

    -   Use a recent GPU driver.

    -   Make sure you use an with ` `{.docutils .literal
        .notranslate}[` GMX_SIMD `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal .notranslate}
        appropriate for the CPU architecture; the log file will contain
        a warning note if suboptimal setting is used. However, prefer
        ` `{.docutils .literal .notranslate}[` AVX2 `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal .notranslate} over
        ` `{.docutils .literal .notranslate}[` AVX512 `{.docutils
        .literal .notranslate}]{.pre}` `{.docutils .literal
        .notranslate} in GPU or highly parallel MPI runs (for more
        information see the ).

    -   If compiling on a cluster head node, make sure that
        ` `{.docutils .literal .notranslate}[` GMX_SIMD `{.docutils
        .literal .notranslate}]{.pre}` `{.docutils .literal
        .notranslate} is appropriate for the compute nodes.
:::

::: {#run-setup .section}
### Run setup

-   For an approximately spherical solute, use a rhombic dodecahedron
    unit cell.

-   When using a time-step of \<=2.5 fs, use (and not ), since:

    -   this is faster, especially with GPUs;

    -   it is necessary to be able to use GPU-resident mode;

    -   and most force fields have been parametrized with only bonds
        involving hydrogens constrained.

-   You can often increase the time-step to 4 fs by repartitioning
    hydrogen masses using the ` `{.docutils .literal
    .notranslate}[` mass-repartition-factor `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} mdp option.
    This does not affect equilibrium distributions, but makes dynamics
    slightly slower.

-   You can increase the time-step to 4 or 5 fs when using virtual
    interaction sites ( ` `{.docutils .literal
    .notranslate}[` gmx `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` pdb2gmx `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` -vsite `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` h `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} ).

-   For massively parallel runs with PME, you might need to try
    different numbers of PME ranks ( ` `{.docutils .literal
    .notranslate}[` gmx `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` mdrun `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` -npme `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` ??? `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} ) to
    achieve best performance; can help automate this search.

-   For massively parallel runs (also ` `{.docutils .literal
    .notranslate}[` gmx `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` mdrun `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` -multidir `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} ), or with
    a slow network, global communication can become a bottleneck and you
    can reduce it by choosing larger periods for algorithms such as
    temperature and pressure coupling).
:::

::: {#checking-and-improving-performance .section}
### Checking and improving performance

-   Look at the end of the ` `{.docutils .literal
    .notranslate}[` md.log `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} file to see
    the performance and the cycle counters and wall-clock time for
    different parts of the MD calculation. The PP/PME load ratio is also
    printed, with a warning when a lot of performance is lost due to
    imbalance.

-   Adjust the number of PME ranks and/or the cut-off and PME
    grid-spacing when there is a large PP/PME imbalance. Note that even
    with a small reported imbalance, the automated PME-tuning might have
    reduced the initial imbalance. You could still gain performance by
    changing the mdp parameters or increasing the number of PME ranks.

-   (Especially) In GPU-resident runs ( ` `{.docutils .literal
    .notranslate}[` -update `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` gpu `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} ):

    -   Frequent virial or energy computation can have a large overhead
        (and this will not show up in the cycle counters). To reduce
        this overhead, increase ` `{.docutils .literal
        .notranslate}[` nstcalcenergy `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal .notranslate} ;

    -   Frequent temperature or pressure coupling can have significant
        overhead; to reduce this, make sure to have as infrequent
        coupling as your algorithms allow (typically \>=50-100 steps).

-   If the neighbor searching and/or domain decomposition takes a lot of
    time, increase ` `{.docutils .literal
    .notranslate}[` nstlist `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} . If a
    Verlet buffer tolerance is used, this is done automatically by and
    the pair-list buffer is increased to keep the energy drift constant.

    > <div>
    >
    > -   especially with multi-GPU runs, the automatic increasing of
    >     ` `{.docutils .literal .notranslate}[` nstlist `{.docutils
    >     .literal .notranslate}]{.pre}` `{.docutils .literal
    >     .notranslate} at ` `{.docutils .literal
    >     .notranslate}[` mdrun `{.docutils .literal
    >     .notranslate}]{.pre}` `{.docutils .literal .notranslate}
    >     startup can be conservative and larger value is often be
    >     optimal (e.g. ` `{.docutils .literal
    >     .notranslate}[` nstlist=200-300 `{.docutils .literal
    >     .notranslate}]{.pre}` `{.docutils .literal .notranslate} with
    >     PME and default Verlet buffer tolerance).
    >
    > -   odd values of nstlist should be avoided when using CUDA Graphs
    >     to minimize the overhead associated with graph instantiation.
    >
    > </div>

-   If ` `{.docutils .literal .notranslate}[` Comm. `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` energies `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} takes a lot
    of time (a note will be printed in the log file), increase
    ` `{.docutils .literal .notranslate}[` nstcalcenergy `{.docutils
    .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} .

-   If all communication takes a lot of time, you might be running on
    too many cores, or you could try running combined MPI/OpenMP
    parallelization with 2 or 4 OpenMP threads per MPI process.

-   In multi-GPU runs avoid using as many ranks as cores (or hardware
    threads) since this introduces a major inefficiency due to overheads
    associated to GPUs sharing by several MPI ranks. Use at most a few
    ranks per GPU, 1-3 ranks is generally optimal; with GPU-resident
    mode and direct GPU communication typically 1 rank/GPU is best.
:::
:::
:::
::: {#getting-started .section}
[ ]{#gmx-getting-started}

# Getting started

::: {.toctree-wrapper .compound}
:::

In this chapter we assume the reader is familiar with Molecular Dynamics
and familiar with Unix, including the use of a text editor such as
` `{.docutils .literal .notranslate}[` jot `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , ` `{.docutils
.literal .notranslate}[` emacs `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} or
` `{.docutils .literal .notranslate}[` vi `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . We
furthermore assume the GROMACS software is installed properly on your
system. When you see a line like

::: {.highlight-default .notranslate}
::: highlight
    ls -l
:::
:::

you are supposed to type the contents of that line on your computer
terminal.

::: {#setting-up-your-environment .section}
## Setting up your environment

In order to check whether you have access to GROMACS, please start by
entering the command:

::: {.highlight-default .notranslate}
::: highlight
    gmx -version
:::
:::

This command should print out information about the version of GROMACS
installed. If this, in contrast, returns the phrase

::: {.highlight-default .notranslate}
::: highlight
    gmx: command not found.
:::
:::

then you have to find where your version of GROMACS is installed. In the
default case, the binaries are located in ` `{.docutils .literal
.notranslate}[` /usr/local/gromacs/bin `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , however, you
can ask your local system administrator for more information, and then
follow the advice for .
:::

::: {#flowchart-of-typical-simulation .section}
## Flowchart of typical simulation

A typical simulation workflow with GROMACS is .
:::

::: {#important-files .section}
## Important files

Here is an overview of the most important GROMACS file types that you
will encounter.

::: {#molecular-topology-file-top .section}
### Molecular Topology file ( ` `{.docutils .literal .notranslate}[` .top `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} )

The molecular topology file is generated by the program . translates a
structure file of any peptide or protein to a molecular topology file.
This topology file contains a complete description of all the
interactions in your peptide or protein.
:::

::: {#topology-include-file-mechanism .section}
[ ]{#gmx-topo-include}

### Topology #include file mechanism

When constructing a system topology in a file for presentation to
grompp, GROMACS uses a built-in version of the so-called C preprocessor,
cpp (in GROMACS 3, it really was cpp). cpp interprets lines like:

::: {.highlight-default .notranslate}
::: highlight
    #include "ions.itp"
:::
:::

by looking for the indicated file in the current directory, the GROMACS
share/top directory as indicated by the GMXLIB environment variable, and
any directory indicated by a ` `{.docutils .literal
.notranslate}[` -I `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} flag in the
value of the include in the file. It either finds this file or reports a
warning. (Note that when you supply a directory name, you should use
Unix-style forward slashes â€˜/â€™, not Windows-style backslashes â€˜\'
for separators.) When found, it then uses the contents exactly as if you
had cut and pasted the included file into the main file yourself. Note
that you shouldnâ€™t go and do this copy-and-paste yourself, since the
main purposes of the include file mechanism are to re-use previous work,
make future changes easier, and prevent typos.

Further, ` `{.docutils .literal .notranslate}[` cpp `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} interprets code
such as:

::: {.highlight-default .notranslate}
::: highlight
    #ifdef POSRES_WATER
    ; Position restraint for each water oxygen
    [ position_restraints ]
    ;  i funct       fcx        fcy        fcz
        1    1       1000       1000       1000
    #endif
:::
:::

by testing whether the preprocessor variable ` `{.docutils .literal
.notranslate}[` POSRES_WATER `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} was defined
somewhere (i.e. â€œif definedâ€?). This could be done with ` `{.docutils
.literal .notranslate}[` #define `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` POSRES_WATER `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} earlier in the
file (or its ` `{.docutils .literal .notranslate}[` #include `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}
files), with a ` `{.docutils .literal .notranslate}[` -D `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} flag
in the ` `{.docutils .literal .notranslate}[` include `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} run
parameter as above, or on the command line to ` `{.docutils .literal
.notranslate}[` cpp `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . The function
of the ` `{.docutils .literal .notranslate}[` -D `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} flag is
borrowed from the similar usage in ` `{.docutils .literal
.notranslate}[` cpp `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . The string
that follows ` `{.docutils .literal .notranslate}[` -D `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} must
match exactly; using ` `{.docutils .literal
.notranslate}[` -DPOSRES `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} will not
trigger ` `{.docutils .literal .notranslate}[` #ifdef `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` POSRE `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} or
` `{.docutils .literal .notranslate}[` #ifdef `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` DPOSRES `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . This
mechanism allows you to change your file to choose whether or not you
want position restraints on your solvent, rather than your file. Note
that preprocessor variables are not the same as shell environment
variables.
:::

::: {#molecular-structure-file-gro-pdb .section}
[ ]{#gmx-need-for-gro}

### Molecular Structure file ( ` `{.docutils .literal .notranslate}[` .gro `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} , ` `{.docutils .literal .notranslate}[` .pdb `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} )

When is executed to generate a molecular topology, it also translates
the structure file ( file) to a GROMOS structure file ( file). The main
difference between a file and a gromos file is their format and that a
file can also hold velocities. However, if you do not need the
velocities, you can also use a file in all programs. To generate a box
of solvent molecules around the peptide, the program is used. First the
program should be used to define a box of appropriate size around the
molecule. solvates a solute molecule (the peptide) into any solvent (in
this case, water). The output of is a gromos structure file of the
peptide solvated in water. also changes the molecular topology file
(generated by ) to add solvent to the topology.
:::

::: {#molecular-dynamics-parameter-file-mdp .section}
### Molecular Dynamics parameter file ( ` `{.docutils .literal .notranslate}[` .mdp `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} )

The Molecular Dynamics Parameter ( ) file contains all information about
the Molecular Dynamics simulation itself e.g. time-step, number of
steps, temperature, pressure etc. The easiest way of handling such a
file is by adapting a sample file. A is available.
:::

::: {#index-file-ndx .section}
### Index file ( ` `{.docutils .literal .notranslate}[` .ndx `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} )

Sometimes you may need an index file to specify actions on groups of
atoms (e.g. temperature coupling, accelerations, freezing). Usually the
default index groups will be sufficient, so for this demo we will not
consider the use of index files.
:::

::: {#run-input-file-tpr .section}
### Run input file ( ` `{.docutils .literal .notranslate}[` .tpr `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} )

The next step is to combine the molecular structure ( file), topology (
file) MD-parameters ( file) and (optionally) the index file ( ) to
generate a run input file ( extension). This file contains all
information needed to start a simulation with GROMACS. The program
processes all input files and generates the run input file.
:::

::: {#trajectory-file-trr-tng-or-xtc .section}
### Trajectory file ( ` `{.docutils .literal .notranslate}[` .trr `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} , ` `{.docutils .literal .notranslate}[` .tng `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} , or ` `{.docutils .literal .notranslate}[` .xtc `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} )

Once the run input file is available, we can start the simulation. The
program which starts the simulation is called . The only input file of
that you usually need in order to start a run is the run input file (
file). The typical output files of are the trajectory file ( file), a
logfile ( file), and perhaps a checkpoint file ( file).
:::
:::

::: {#tutorial-material .section}
## Tutorial material

There are several third-party available that cover aspects of using
GROMACS. Further information can also be found in the section.
:::

::: {#background-reading .section}
## Background reading

-   Berendsen, H.J.C., Postma, J.P.M., van Gunsteren, W.F.,
    Hermans, J. (1981) Intermolecular Forces, chapter Interaction models
    for water in relation to protein hydration, pp 331-342.
    Dordrecht: D. Reidel Publishing Company Dordrecht

-   Kabsch, W., Sander, C. (1983). Dictionary of protein secondary
    structure: Pattern recognition of hydrogen-bonded and geometrical
    features. Biopolymers **22** , 2577â€"2637.

-   Mierke, D.F., Kessler, H. (1991). Molecular dynamics with dimethyl
    sulfoxide as a solvent. Conformation of a cyclic hexapeptide. J. Am.
    Chem. Soc. **113** , 9446.

-   Stryer, L. (1988). Biochemistry vol. 1, p. 211. New York: Freeman, 3
    edition.
:::
:::
::: {#gmx-anaeig .section}
[ ]{#id1}

# gmx anaeig

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx anaeig [-v [<.trr/.cpt/...>]] [-v2 [<.trr/.cpt/...>]]
           [-f [<.xtc/.trr/...>]] [-s [<.tpr/.gro/...>]]
           [-n [<.ndx>]] [-eig [<.xvg>]] [-eig2 [<.xvg>]]
           [-comp [<.xvg>]] [-rmsf [<.xvg>]] [-proj [<.xvg>]]
           [-2d [<.xvg>]] [-3d [<.gro/.g96/...>]]
           [-filt [<.xtc/.trr/...>]] [-extr [<.xtc/.trr/...>]]
           [-over [<.xvg>]] [-inpr [<.xpm>]] [-b <time>] [-e <time>]
           [-dt <time>] [-tu <enum>] [-[no]w] [-xvg <enum>]
           [-first <int>] [-last <int>] [-skip <int>] [-max <real>]
           [-nframes <int>] [-[no]split] [-[no]entropy]
           [-temp <real>] [-nevskip <int>]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` anaeig `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} analyzes
eigenvectors. The eigenvectors can be of a covariance matrix ( ) or of a
Normal Modes analysis ( ).

When a trajectory is projected on eigenvectors, all structures are
fitted to the structure in the eigenvector file, if present, otherwise
to the structure in the structure file. When no run input file is
supplied, periodicity will not be taken into account. Most analyses are
performed on eigenvectors ` `{.docutils .literal
.notranslate}[` -first `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} to
` `{.docutils .literal .notranslate}[` -last `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , but when
` `{.docutils .literal .notranslate}[` -first `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} is set to -1
you will be prompted for a selection.

` `{.docutils .literal .notranslate}[` -comp `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} : plot the
vector components per atom of eigenvectors ` `{.docutils .literal
.notranslate}[` -first `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} to
` `{.docutils .literal .notranslate}[` -last `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} .

` `{.docutils .literal .notranslate}[` -rmsf `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} : plot the RMS
fluctuation per atom of eigenvectors ` `{.docutils .literal
.notranslate}[` -first `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} to
` `{.docutils .literal .notranslate}[` -last `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} (requires
` `{.docutils .literal .notranslate}[` -eig `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ).

` `{.docutils .literal .notranslate}[` -proj `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} : calculate
projections of a trajectory on eigenvectors ` `{.docutils .literal
.notranslate}[` -first `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} to
` `{.docutils .literal .notranslate}[` -last `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . The
projections of a trajectory on the eigenvectors of its covariance matrix
are called principal components (pcâ€™s). It is often useful to check
the cosine content of the pcâ€™s, since the pcâ€™s of random diffusion
are cosines with the number of periods equal to half the pc index. The
cosine content of the pcâ€™s can be calculated with the program .

` `{.docutils .literal .notranslate}[` -2d `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} : calculate a
2d projection of a trajectory on eigenvectors ` `{.docutils .literal
.notranslate}[` -first `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` -last `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} .

` `{.docutils .literal .notranslate}[` -3d `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} : calculate a
3d projection of a trajectory on the first three selected eigenvectors.

` `{.docutils .literal .notranslate}[` -filt `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} : filter the
trajectory to show only the motion along eigenvectors ` `{.docutils
.literal .notranslate}[` -first `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} to
` `{.docutils .literal .notranslate}[` -last `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} .

` `{.docutils .literal .notranslate}[` -extr `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} : calculate the
two extreme projections along a trajectory on the average structure and
interpolate ` `{.docutils .literal .notranslate}[` -nframes `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} frames
between them, or set your own extremes with ` `{.docutils .literal
.notranslate}[` -max `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . The
eigenvector ` `{.docutils .literal .notranslate}[` -first `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} will
be written unless ` `{.docutils .literal
.notranslate}[` -first `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` -last `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} have been set
explicitly, in which case all eigenvectors will be written to separate
files. Chain identifiers will be added when writing a file with two or
three structures (you can use ` `{.docutils .literal
.notranslate}[` rasmol `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` -nmrpdb `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} to view such a
file).

::: {#overlap-calculations-between-covariance-analysis .section}
### Overlap calculations between covariance analysis

**Note:** the analysis should use the same fitting structure

` `{.docutils .literal .notranslate}[` -over `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} : calculate the
subspace overlap of the eigenvectors in file ` `{.docutils .literal
.notranslate}[` -v2 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} with
eigenvectors ` `{.docutils .literal .notranslate}[` -first `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} to
` `{.docutils .literal .notranslate}[` -last `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} in file
` `{.docutils .literal .notranslate}[` -v `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} .

` `{.docutils .literal .notranslate}[` -inpr `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} : calculate a
matrix of inner-products between eigenvectors in files ` `{.docutils
.literal .notranslate}[` -v `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` -v2 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . All
eigenvectors of both files will be used unless ` `{.docutils .literal
.notranslate}[` -first `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` -last `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} have been set
explicitly.

When ` `{.docutils .literal .notranslate}[` -v `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` -v2 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} are given, a
single number for the overlap between the covariance matrices is
generated. Note that the eigenvalues are by default read from the
timestamp field in the eigenvector input files, but when ` `{.docutils
.literal .notranslate}[` -eig `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , or
` `{.docutils .literal .notranslate}[` -eig2 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} are given, the
corresponding eigenvalues are used instead. The formulas are:

::: {.highlight-default .notranslate}
::: highlight
            difference = sqrt(tr((sqrt(M1) - sqrt(M2))^2))
    normalized overlap = 1 - difference/sqrt(tr(M1) + tr(M2))
         shape overlap = 1 - sqrt(tr((sqrt(M1/tr(M1)) - sqrt(M2/tr(M2)))^2))
:::
:::

where M1 and M2 are the two covariance matrices and tr is the trace of a
matrix. The numbers are proportional to the overlap of the square root
of the fluctuations. The normalized overlap is the most useful number,
it is 1 for identical matrices and 0 when the sampled subspaces are
orthogonal.

When the ` `{.docutils .literal .notranslate}[` -entropy `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} flag
is given an entropy estimate will be computed based on the Quasiharmonic
approach and based on Schlitterâ€™s formula.
:::
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -v `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.trr/.cpt/â€¦\>\] (eigenvec.trr)

:   Full precision trajectory:

` `{.docutils .literal .notranslate}[` -v2 `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.trr/.cpt/â€¦\>\] (eigenvec2.trr) (Optional)

:   Full precision trajectory:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (traj.xtc) (Optional)

:   Trajectory:

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr/.gro/â€¦\>\] (topol.tpr) (Optional)

:   Structure+mass(db): brk ent

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx) (Optional)

:   Index file

` `{.docutils .literal .notranslate}[` -eig `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (eigenval.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -eig2 `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (eigenval2.xvg) (Optional)

:   xvgr/xmgr file

Options to specify output files:

` `{.docutils .literal .notranslate}[` -comp `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (eigcomp.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -rmsf `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (eigrmsf.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -proj `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (proj.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -2d `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (2dproj.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -3d `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.gro/.g96/â€¦\>\] (3dproj.pdb) (Optional)

:   Structure file: brk ent esp

` `{.docutils .literal .notranslate}[` -filt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (filtered.xtc) (Optional)

:   Trajectory:

` `{.docutils .literal .notranslate}[` -extr `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (extreme.pdb) (Optional)

:   Trajectory:

` `{.docutils .literal .notranslate}[` -over `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (overlap.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -inpr `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xpm\>\] (inprod.xpm) (Optional)

:   X PixMap compatible matrix file

Other options:

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of first frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of last frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -dt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Only use frame when t MOD dt = first time (default unit ps)

` `{.docutils .literal .notranslate}[` -tu `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (ps)

:   Unit for time values: fs, ps, ns, us, ms, s

` `{.docutils .literal .notranslate}[` -[no]w `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   View output , , and files

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   xvg plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -first `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (1)

:   First eigenvector for analysis (-1 is select)

` `{.docutils .literal .notranslate}[` -last `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (-1)

:   Last eigenvector for analysis (-1 is till the last)

` `{.docutils .literal .notranslate}[` -skip `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (1)

:   Only analyse every nr-th frame

` `{.docutils .literal .notranslate}[` -max `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Maximum for projection of the eigenvector on the average structure,
    max=0 gives the extremes

` `{.docutils .literal .notranslate}[` -nframes `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (2)

:   Number of frames for the extremes output

` `{.docutils .literal .notranslate}[` -[no]split `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Split eigenvector projections where time is zero

` `{.docutils .literal .notranslate}[` -[no]entropy `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Compute entropy according to the Quasiharmonic formula or
    Schlitterâ€™s method.

` `{.docutils .literal .notranslate}[` -temp `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (298.15)

:   Temperature for entropy calculations

` `{.docutils .literal .notranslate}[` -nevskip `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (6)

:   Number of eigenvalues to skip when computing the entropy due to the
    quasi harmonic approximation. When you do a rotational and/or
    translational fit prior to the covariance analysis, you get 3 or 6
    eigenvalues that are very close to zero, and which should not be
    taken into account when computing the entropy.
:::
:::
::: {#gmx-analyze .section}
[ ]{#id1}

# gmx analyze

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx analyze [-f [<.xvg>]] [-ac [<.xvg>]] [-msd [<.xvg>]] [-cc [<.xvg>]]
            [-dist [<.xvg>]] [-av [<.xvg>]] [-ee [<.xvg>]]
            [-fitted [<.xvg>]] [-g [<.log>]] [-[no]w] [-xvg <enum>]
            [-[no]time] [-b <real>] [-e <real>] [-n <int>] [-[no]d]
            [-bw <real>] [-errbar <enum>] [-[no]integrate]
            [-aver_start <real>] [-[no]xydy] [-[no]regression]
            [-[no]luzar] [-temp <real>] [-fitstart <real>]
            [-fitend <real>] [-filter <real>] [-[no]power]
            [-[no]subav] [-[no]oneacf] [-acflen <int>]
            [-[no]normalize] [-P <enum>] [-fitfn <enum>]
            [-beginfit <real>] [-endfit <real>]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` analyze `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} reads an ASCII
file and analyzes data sets. A line in the input file may start with a
time (see option ` `{.docutils .literal
.notranslate}[` -time `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ) and any
number of *y* -values may follow. Multiple sets can also be read when
they are separated by & (option ` `{.docutils .literal
.notranslate}[` -n `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ); in this case
only one *y* -value is read from each line. All lines starting with \#
and @ are skipped. All analyses can also be done for the derivative of a
set (option ` `{.docutils .literal .notranslate}[` -d `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} ).

All options, except for ` `{.docutils .literal
.notranslate}[` -av `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` -power `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , assume that
the points are equidistant in time.

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` analyze `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} always shows
the average and standard deviation of each set, as well as the relative
deviation of the third and fourth cumulant from those of a Gaussian
distribution with the same standard deviation.

Option ` `{.docutils .literal .notranslate}[` -ac `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} produces the
autocorrelation function(s). Be sure that the time interval between data
points is much shorter than the time scale of the autocorrelation.

Option ` `{.docutils .literal .notranslate}[` -cc `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} plots the
resemblance of set i with a cosine of i/2 periods. The formula is:

::: {.highlight-default .notranslate}
::: highlight
    2 (integral from 0 to T of y(t) cos(i pi t) dt)^2
    / integral from 0 to T of y^2(t) dt
:::
:::

This is useful for principal components obtained from covariance
analysis, since the principal components of random diffusion are pure
cosines.

Option ` `{.docutils .literal .notranslate}[` -msd `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} produces the
mean square displacement(s).

Option ` `{.docutils .literal .notranslate}[` -dist `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} produces
distribution plot(s).

Option ` `{.docutils .literal .notranslate}[` -av `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} produces the
average over the sets. Error bars can be added with the option
` `{.docutils .literal .notranslate}[` -errbar `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . The errorbars
can represent the standard deviation, the error (assuming the points are
independent) or the interval containing 90% of the points, by discarding
5% of the points at the top and the bottom.

Option ` `{.docutils .literal .notranslate}[` -ee `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} produces error
estimates using block averaging. A set is divided in a number of blocks
and averages are calculated for each block. The error for the total
average is calculated from the variance between averages of the m blocks
B_i as follows: error\^2 = sum (B_i - \<B\>)\^2 / (m\*(m-1)). These
errors are plotted as a function of the block size. Also an analytical
block average curve is plotted, assuming that the autocorrelation is a
sum of two exponentials. The analytical curve for the block average is:

::: {.highlight-default .notranslate}
::: highlight
    f(t) = sigma``*``sqrt(2/T (  alpha
    (tau_1 ((exp(-t/tau_1) - 1)
    tau_1/t + 1)) +
    (1-alpha) (tau_2
    ((exp(-t/tau_2) - 1) tau_2/t +
    1)))),
:::
:::

where T is the total time. alpha, tau_1 and tau_2 are obtained by
fitting f\^2(t) to error\^2. When the actual block average is very close
to the analytical curve, the error is sigma\`\`\*\`\`sqrt(2/T (a tau_1 +
(1-a) tau_2)). The complete derivation is given in B. Hess, J. Chem.
Phys. 116:209-217, 2002.

Option ` `{.docutils .literal .notranslate}[` -filter `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} prints
the RMS high-frequency fluctuation of each set and over all sets with
respect to a filtered average. The filter is proportional to cos(pi
t/len) where t goes from -len/2 to len/2. len is supplied with the
option ` `{.docutils .literal .notranslate}[` -filter `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} . This
filter reduces oscillations with period len/2 and len by a factor of
0.79 and 0.33 respectively.

Option ` `{.docutils .literal .notranslate}[` -g `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} fits the data
to the function given with option ` `{.docutils .literal
.notranslate}[` -fitfn `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} .

Option ` `{.docutils .literal .notranslate}[` -power `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} fits
the data to b t\^a, which is accomplished by fitting to a t + b on
log-log scale. All points after the first zero or with a negative value
are ignored.

Option ` `{.docutils .literal .notranslate}[` -luzar `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}
performs a Luzar & Chandler kinetics analysis on output from . The input
file can be taken directly from ` `{.docutils .literal
.notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` hbond `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` -ac `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , and then the
same result should be produced.

Option ` `{.docutils .literal .notranslate}[` -fitfn `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}
performs curve fitting to a number of different curves that make sense
in the context of molecular dynamics, mainly exponential curves. More
information is in the manual. To check the output of the fitting
procedure the option ` `{.docutils .literal
.notranslate}[` -fitted `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} will print both
the original data and the fitted function to a new data file. The
fitting parameters are stored as comment in the output file.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (graph.xvg)

:   xvgr/xmgr file

Options to specify output files:

` `{.docutils .literal .notranslate}[` -ac `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (autocorr.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -msd `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (msd.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -cc `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (coscont.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -dist `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (distr.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -av `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (average.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -ee `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (errest.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -fitted `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (fitted.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -g `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.log\>\] (fitlog.log) (Optional)

:   Log file

Other options:

` `{.docutils .literal .notranslate}[` -[no]w `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   View output , , and files

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   xvg plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -[no]time `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Expect a time in the input

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (-1)

:   First time to read from set

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (-1)

:   Last time to read from set

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (1)

:   Read this number of sets separated by &

` `{.docutils .literal .notranslate}[` -[no]d `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Use the derivative

` `{.docutils .literal .notranslate}[` -bw `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0.1)

:   Binwidth for the distribution

` `{.docutils .literal .notranslate}[` -errbar `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (none)

:   Error bars for ` `{.docutils .literal
    .notranslate}[` -av `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} : none,
    stddev, error, 90

` `{.docutils .literal .notranslate}[` -[no]integrate `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Integrate data function(s) numerically using trapezium rule

` `{.docutils .literal .notranslate}[` -aver_start `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Start averaging the integral from here

` `{.docutils .literal .notranslate}[` -[no]xydy `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Interpret second data set as error in the y values for integrating

` `{.docutils .literal .notranslate}[` -[no]regression `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Perform a linear regression analysis on the data. If ` `{.docutils
    .literal .notranslate}[` -xydy `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} is set a
    second set will be interpreted as the error bar in the Y value.
    Otherwise, if multiple data sets are present a multilinear
    regression will be performed yielding the constant A that minimize
    chi\^2 = (y - A_0 x_0 - A_1 x_1 - â€¦ - A_N x_N)\^2 where now Y is
    the first data set in the input file and x_i the others. Do read the
    information at the option ` `{.docutils .literal
    .notranslate}[` -time `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} .

` `{.docutils .literal .notranslate}[` -[no]luzar `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Do a Luzar and Chandler analysis on a correlation function and
    related as produced by . When in addition the ` `{.docutils .literal
    .notranslate}[` -xydy `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} flag is
    given the second and fourth column will be interpreted as errors in
    c(t) and n(t).

` `{.docutils .literal .notranslate}[` -temp `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (298.15)

:   Temperature for the Luzar hydrogen bonding kinetics analysis (K)

` `{.docutils .literal .notranslate}[` -fitstart `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (1)

:   Time (ps) from which to start fitting the correlation functions in
    order to obtain the forward and backward rate constants for HB
    breaking and formation

` `{.docutils .literal .notranslate}[` -fitend `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (60)

:   Time (ps) where to stop fitting the correlation functions in order
    to obtain the forward and backward rate constants for HB breaking
    and formation. Only with ` `{.docutils .literal
    .notranslate}[` -gem `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate}

` `{.docutils .literal .notranslate}[` -filter `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Print the high-frequency fluctuation after filtering with a cosine
    filter of this length

` `{.docutils .literal .notranslate}[` -[no]power `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Fit data to: b t\^a

` `{.docutils .literal .notranslate}[` -[no]subav `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Subtract the average before autocorrelating

` `{.docutils .literal .notranslate}[` -[no]oneacf `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Calculate one ACF over all sets

` `{.docutils .literal .notranslate}[` -acflen `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (-1)

:   Length of the ACF, default is half the number of frames

` `{.docutils .literal .notranslate}[` -[no]normalize `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Normalize ACF

` `{.docutils .literal .notranslate}[` -P `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (0)

:   Order of Legendre polynomial for ACF (0 indicates none): 0, 1, 2, 3

` `{.docutils .literal .notranslate}[` -fitfn `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (none)

:   Fit function: none, exp, aexp, exp_exp, exp5, exp7, exp9

` `{.docutils .literal .notranslate}[` -beginfit `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Time where to begin the exponential fit of the correlation function

` `{.docutils .literal .notranslate}[` -endfit `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (-1)

:   Time where to end the exponential fit of the correlation function,
    -1 is until the end
:::
:::
::: {#gmx-angle .section}
[ ]{#id1}

# gmx angle

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx angle [-f [<.xtc/.trr/...>]] [-n [<.ndx>]] [-od [<.xvg>]]
          [-ov [<.xvg>]] [-of [<.xvg>]] [-ot [<.xvg>]] [-oh [<.xvg>]]
          [-oc [<.xvg>]] [-or [<.trr>]] [-b <time>] [-e <time>]
          [-dt <time>] [-[no]w] [-xvg <enum>] [-type <enum>]
          [-[no]all] [-binwidth <real>] [-[no]periodic]
          [-[no]chandler] [-[no]avercorr] [-acflen <int>]
          [-[no]normalize] [-P <enum>] [-fitfn <enum>]
          [-beginfit <real>] [-endfit <real>]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` angle `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} computes the
angle distribution for a number of angles or dihedrals.

With option ` `{.docutils .literal .notranslate}[` -ov `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} , you
can plot the average angle of a group of angles as a function of time.
With the ` `{.docutils .literal .notranslate}[` -all `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}
option, the first graph is the average and the rest are the individual
angles.

With the ` `{.docutils .literal .notranslate}[` -of `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} option,
` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` angle `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} also calculates
the fraction of trans dihedrals (only for dihedrals) as function of
time, but this is probably only fun for a select few.

With option ` `{.docutils .literal .notranslate}[` -oc `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} , a
dihedral correlation function is calculated.

It should be noted that the index file must contain atom triplets for
angles or atom quadruplets for dihedrals. If this is not the case, the
program will crash.

With option ` `{.docutils .literal .notranslate}[` -or `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} , a
trajectory file is dumped containing cos and sin of selected dihedral
angles, which subsequently can be used as input for a principal
components analysis using .

Option ` `{.docutils .literal .notranslate}[` -ot `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} plots when
transitions occur between dihedral rotamers of multiplicity 3 and
` `{.docutils .literal .notranslate}[` -oh `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} records a
histogram of the times between such transitions, assuming the input
trajectory frames are equally spaced in time.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (traj.xtc)

:   Trajectory:

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (angle.ndx)

:   Index file

Options to specify output files:

` `{.docutils .literal .notranslate}[` -od `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (angdist.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -ov `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (angaver.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -of `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (dihfrac.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -ot `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (dihtrans.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -oh `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (trhisto.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -oc `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (dihcorr.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -or `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.trr\>\] (traj.trr) (Optional)

:   Trajectory in portable xdr format

Other options:

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of first frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of last frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -dt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Only use frame when t MOD dt = first time (default unit ps)

` `{.docutils .literal .notranslate}[` -[no]w `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   View output , , and files

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   xvg plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -type `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (angle)

:   Type of angle to analyse: angle, dihedral, improper,
    ryckaert-bellemans

` `{.docutils .literal .notranslate}[` -[no]all `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Plot all angles separately in the averages file, in the order of
    appearance in the index file.

` `{.docutils .literal .notranslate}[` -binwidth `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (1)

:   binwidth (degrees) for calculating the distribution

` `{.docutils .literal .notranslate}[` -[no]periodic `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Print dihedral angles modulo 360 degrees

` `{.docutils .literal .notranslate}[` -[no]chandler `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Use Chandler correlation function (N\[trans\] = 1, N\[gauche\] = 0)
    rather than cosine correlation function. Trans is defined as phi \<
    -60 or phi \> 60.

` `{.docutils .literal .notranslate}[` -[no]avercorr `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Average the correlation functions for the individual
    angles/dihedrals

` `{.docutils .literal .notranslate}[` -acflen `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (-1)

:   Length of the ACF, default is half the number of frames

` `{.docutils .literal .notranslate}[` -[no]normalize `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Normalize ACF

` `{.docutils .literal .notranslate}[` -P `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (0)

:   Order of Legendre polynomial for ACF (0 indicates none): 0, 1, 2, 3

` `{.docutils .literal .notranslate}[` -fitfn `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (none)

:   Fit function: none, exp, aexp, exp_exp, exp5, exp7, exp9

` `{.docutils .literal .notranslate}[` -beginfit `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Time where to begin the exponential fit of the correlation function

` `{.docutils .literal .notranslate}[` -endfit `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (-1)

:   Time where to end the exponential fit of the correlation function,
    -1 is until the end
:::

::: {#known-issues .section}
## Known Issues

-   Counting transitions only works for dihedrals with multiplicity 3
:::
:::
::: {#gmx-awh .section}
[ ]{#id1}

# gmx awh

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx awh [-f [<.edr>]] [-s [<.tpr>]] [-o [<.xvg>]] [-fric [<.xvg>]]
        [-b <time>] [-e <time>] [-[no]w] [-xvg <enum>] [-skip <int>]
        [-[no]more] [-[no]kt]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` awh `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} extracts AWH
data from an energy file. One or two files are written per AWH bias per
time frame. The bias index, if more than one, is appended to the file,
as well as the time of the frame. By default only the PMF is printed.
With ` `{.docutils .literal .notranslate}[` -more `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} the bias,
target and coordinate distributions are also printed. With ` `{.docutils
.literal .notranslate}[` -more `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} the bias,
target and coordinate distributions are also printed, as well as the
metric sqrt(det(friction_tensor)) normalized such that the average is 1.
Option ` `{.docutils .literal .notranslate}[` -fric `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} prints all
components of the friction tensor to an additional set of files.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.edr\>\] (ener.edr)

:   Energy file

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr\>\] (topol.tpr)

:   Portable xdr run input file

Options to specify output files:

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (awh.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -fric `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (friction.xvg) (Optional)

:   xvgr/xmgr file

Other options:

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of first frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of last frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -[no]w `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   View output , , and files

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   xvg plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -skip `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (0)

:   Skip number of frames between data points

` `{.docutils .literal .notranslate}[` -[no]more `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Print more output

` `{.docutils .literal .notranslate}[` -[no]kt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Print free energy output in units of kT instead of kJ/mol
:::
:::
::: {#gmx-bar .section}
[ ]{#id1}

# gmx bar

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx bar [-f [<.xvg> [...]]] [-g [<.edr> [...]]] [-o [<.xvg>]]
        [-oi [<.xvg>]] [-oh [<.xvg>]] [-[no]w] [-xvg <enum>]
        [-b <real>] [-e <real>] [-temp <real>] [-prec <int>]
        [-nbmin <int>] [-nbmax <int>] [-nbin <int>] [-[no]extp]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` bar `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} calculates free
energy difference estimates through Bennettâ€™s acceptance ratio method
(BAR). It also automatically adds series of individual free energies
obtained with BAR into a combined free energy estimate.

Every individual BAR free energy difference relies on two simulations at
different states: say state A and state B, as controlled by a parameter,
lambda (see the parameter ` `{.docutils .literal
.notranslate}[` init_lambda `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ). The BAR
method calculates a ratio of weighted average of the Hamiltonian
difference of state B given state A and vice versa. The energy
differences to the other state must be calculated explicitly during the
simulation. This can be done with the option ` `{.docutils .literal
.notranslate}[` foreign_lambda `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} .

Input option ` `{.docutils .literal .notranslate}[` -f `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}
expects multiple ` `{.docutils .literal
.notranslate}[` dhdl.xvg `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} files. Two
types of input files are supported:

> <div>
>
> -   Files with more than one *y* -value. The files should have columns
>     with dH/dlambda and Deltalambda. The lambda values are inferred
>     from the legends: lambda of the simulation from the legend of
>     dH/dlambda and the foreign lambda values from the legends of Delta
>     H
>
> -   Files with only one *y* -value. Using the ` `{.docutils .literal
>     .notranslate}[` -extp `{.docutils .literal
>     .notranslate}]{.pre}` `{.docutils .literal .notranslate} option
>     for these files, it is assumed that the *y* -value is dH/dlambda
>     and that the Hamiltonian depends linearly on lambda. The lambda
>     value of the simulation is inferred from the subtitle (if
>     present), otherwise from a number in the subdirectory in the file
>     name.
>
> </div>

The lambda of the simulation is parsed from ` `{.docutils .literal
.notranslate}[` dhdl.xvg `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} fileâ€™s legend
containing the string â€˜dHâ€™, the foreign lambda values from the
legend containing the capitalized letters â€˜Dâ€™ and â€˜Hâ€™. The
temperature is parsed from the legend line containing â€˜T =â€™.

The input option ` `{.docutils .literal .notranslate}[` -g `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}
expects multiple files. These can contain either lists of energy
differences (see the option ` `{.docutils .literal
.notranslate}[` separate_dhdl_file `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ), or a series
of histograms (see the options ` `{.docutils .literal
.notranslate}[` dh_hist_size `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` dh_hist_spacing `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} ). The
temperature and lambda values are automatically deduced from the
` `{.docutils .literal .notranslate}[` ener.edr `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} file.

In addition to the option ` `{.docutils .literal
.notranslate}[` foreign_lambda `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , the energy
difference can also be extrapolated from the dH/dlambda values. This is
done with the\`\`-extp\`\` option, which assumes that the systemâ€™s
Hamiltonian depends linearly on lambda, which is not normally the case.

The free energy estimates are determined using BAR with bisection, with
the precision of the output set with ` `{.docutils .literal
.notranslate}[` -prec `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . An error
estimate taking into account time correlations is made by splitting the
data into blocks and determining the free energy differences over those
blocks and assuming the blocks are independent. The final error estimate
is determined from the average variance over 5 blocks. A range of block
numbers for error estimation can be provided with the options
` `{.docutils .literal .notranslate}[` -nbmin `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` -nbmax `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} .

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` bar `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} tries to
aggregate samples with the same â€˜nativeâ€™ and â€˜foreignâ€™ lambda
values, but always assumes independent samples. **Note** that when
aggregating energy differences/derivatives with different sampling
intervals, this is almost certainly not correct. Usually subsequent
energies are correlated and different time intervals mean different
degrees of correlation between samples.

The results are split in two parts: the last part contains the final
results in kJ/mol, together with the error estimate for each part and
the total. The first part contains detailed free energy difference
estimates and phase space overlap measures in units of kT (together with
their computed error estimate). The printed values are:

> <div>
>
> -   lam_A: the lambda values for point A.
>
> -   lam_B: the lambda values for point B.
>
> -   DG: the free energy estimate.
>
> -   s_A: an estimate of the relative entropy of B in A.
>
> -   s_B: an estimate of the relative entropy of A in B.
>
> -   stdev: an estimate expected per-sample standard deviation.
>
> </div>

The relative entropy of both states in each otherâ€™s ensemble can be
interpreted as a measure of phase space overlap: the relative entropy
s_A of the work samples of lambda_B in the ensemble of lambda_A (and
vice versa for s_B), is a measure of the â€˜distanceâ€™ between
Boltzmann distributions of the two states, that goes to zero for
identical distributions. See Wu & Kofke, J. Chem. Phys. 123 084109
(2005) for more information.

The estimate of the expected per-sample standard deviation, as given in
Bennettâ€™s original BAR paper: Bennett, J. Comp. Phys. 22, p 245
(1976). Eq. 10 therein gives an estimate of the quality of sampling (not
directly of the actual statistical error, because it assumes independent
samples).

To get a visual estimate of the phase space overlap, use the
` `{.docutils .literal .notranslate}[` -oh `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} option to write
series of histograms, together with the ` `{.docutils .literal
.notranslate}[` -nbin `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} option.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\> \[â€¦\]\] (dhdl.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -g `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.edr\> \[â€¦\]\] (ener.edr) (Optional)

:   Energy file

Options to specify output files:

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (bar.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -oi `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (barint.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -oh `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (histogram.xvg) (Optional)

:   xvgr/xmgr file

Other options:

` `{.docutils .literal .notranslate}[` -[no]w `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   View output , , and files

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   xvg plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Begin time for BAR

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (-1)

:   End time for BAR

` `{.docutils .literal .notranslate}[` -temp `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (-1)

:   Temperature (K)

` `{.docutils .literal .notranslate}[` -prec `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (2)

:   The number of digits after the decimal point

` `{.docutils .literal .notranslate}[` -nbmin `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (5)

:   Minimum number of blocks for error estimation

` `{.docutils .literal .notranslate}[` -nbmax `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (5)

:   Maximum number of blocks for error estimation

` `{.docutils .literal .notranslate}[` -nbin `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (100)

:   Number of bins for histogram output

` `{.docutils .literal .notranslate}[` -[no]extp `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Whether to linearly extrapolate dH/dl values to use as energies
:::
:::
::: {#gmx-bundle .section}
[ ]{#id1}

# gmx bundle

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx bundle [-f [<.xtc/.trr/...>]] [-s [<.tpr/.gro/...>]] [-n [<.ndx>]]
           [-ol [<.xvg>]] [-od [<.xvg>]] [-oz [<.xvg>]]
           [-ot [<.xvg>]] [-otr [<.xvg>]] [-otl [<.xvg>]]
           [-ok [<.xvg>]] [-okr [<.xvg>]] [-okl [<.xvg>]]
           [-oa [<.pdb>]] [-b <time>] [-e <time>] [-dt <time>]
           [-tu <enum>] [-xvg <enum>] [-na <int>] [-[no]z]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` bundle `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} analyzes
bundles of axes. The axes can be for instance helix axes. The program
reads two index groups and divides both of them in ` `{.docutils
.literal .notranslate}[` -na `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} parts. The
centers of mass of these parts define the tops and bottoms of the axes.
Several quantities are written to file: the axis length, the distance
and the z-shift of the axis mid-points with respect to the average
center of all axes, the total tilt, the radial tilt and the lateral tilt
with respect to the average axis.

With options ` `{.docutils .literal .notranslate}[` -ok `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} ,
` `{.docutils .literal .notranslate}[` -okr `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` -okl `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} the total,
radial and lateral kinks of the axes are plotted. An extra index group
of kink atoms is required, which is also divided into ` `{.docutils
.literal .notranslate}[` -na `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} parts. The kink
angle is defined as the angle between the kink-top and the bottom-kink
vectors.

With option ` `{.docutils .literal .notranslate}[` -oa `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} the
top, mid (or kink when ` `{.docutils .literal
.notranslate}[` -ok `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} is set) and
bottom points of each axis are written to a file each frame. The residue
numbers correspond to the axis numbers. When viewing this file with
Rasmol, use the command line option ` `{.docutils .literal
.notranslate}[` -nmrpdb `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , and type
` `{.docutils .literal .notranslate}[` set `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` axis `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` true `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} to display the
reference axis.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (traj.xtc)

:   Trajectory:

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr/.gro/â€¦\>\] (topol.tpr)

:   Structure+mass(db): brk ent

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx) (Optional)

:   Index file

Options to specify output files:

` `{.docutils .literal .notranslate}[` -ol `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (bun_len.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -od `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (bun_dist.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -oz `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (bun_z.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -ot `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (bun_tilt.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -otr `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (bun_tiltr.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -otl `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (bun_tiltl.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -ok `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (bun_kink.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -okr `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (bun_kinkr.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -okl `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (bun_kinkl.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -oa `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.pdb\>\] (axes.pdb) (Optional)

:   Protein data bank file

Other options:

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of first frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of last frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -dt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Only use frame when t MOD dt = first time (default unit ps)

` `{.docutils .literal .notranslate}[` -tu `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (ps)

:   Unit for time values: fs, ps, ns, us, ms, s

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   xvg plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -na `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (0)

:   Number of axes

` `{.docutils .literal .notranslate}[` -[no]z `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Use the *z* -axis as reference instead of the average axis
:::
:::
::: {#gmx-check .section}
[ ]{#id1}

# gmx check

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx check [-f [<.xtc/.trr/...>]] [-f2 [<.xtc/.trr/...>]] [-s1 [<.tpr>]]
          [-s2 [<.tpr>]] [-c [<.tpr/.gro/...>]] [-e [<.edr>]]
          [-e2 [<.edr>]] [-n [<.ndx>]] [-m [<.tex>]] [-vdwfac <real>]
          [-bonlo <real>] [-bonhi <real>] [-[no]rmsd] [-tol <real>]
          [-abstol <real>] [-[no]ab] [-lastener <string>]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` check `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} reads a
trajectory ( , or ), an energy file ( ) or an index file ( ) and prints
out useful information about them.

Option ` `{.docutils .literal .notranslate}[` -c `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} checks for
presence of coordinates, velocities and box in the file, for close
contacts (smaller than ` `{.docutils .literal
.notranslate}[` -vdwfac `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and not bonded,
i.e. not between ` `{.docutils .literal
.notranslate}[` -bonlo `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` -bonhi `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , all relative
to the sum of both Van der Waals radii) and atoms outside the box (these
may occur often and are no problem). If velocities are present, an
estimated temperature will be calculated from them.

If an index file, is given its contents will be summarized.

If both a trajectory and a file are given (with ` `{.docutils .literal
.notranslate}[` -s1 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ) the program
will check whether the bond lengths defined in the tpr file are indeed
correct in the trajectory. If not you may have non-matching files due to
e.g. deshuffling or due to problems with virtual sites. With these
flags, ` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` check `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} provides a
quick check for such problems.

The program can compare two run input ( ) files when both ` `{.docutils
.literal .notranslate}[` -s1 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` -s2 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} are supplied.
When comparing run input files this way, the default relative tolerance
is reduced to 0.000001 and the absolute tolerance set to zero to find
any differences not due to minor compiler optimization differences,
although you can of course still set any other tolerances through the
options. Similarly a pair of trajectory files can be compared (using the
` `{.docutils .literal .notranslate}[` -f2 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} option), or a
pair of energy files (using the ` `{.docutils .literal
.notranslate}[` -e2 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} option).

For free energy simulations the A and B state topology from one run
input file can be compared with options ` `{.docutils .literal
.notranslate}[` -s1 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` -ab `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} .
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (traj.xtc) (Optional)

:   Trajectory:

` `{.docutils .literal .notranslate}[` -f2 `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (traj.xtc) (Optional)

:   Trajectory:

` `{.docutils .literal .notranslate}[` -s1 `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr\>\] (top1.tpr) (Optional)

:   Portable xdr run input file

` `{.docutils .literal .notranslate}[` -s2 `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr\>\] (top2.tpr) (Optional)

:   Portable xdr run input file

` `{.docutils .literal .notranslate}[` -c `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr/.gro/â€¦\>\] (topol.tpr) (Optional)

:   Structure+mass(db): brk ent

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.edr\>\] (ener.edr) (Optional)

:   Energy file

` `{.docutils .literal .notranslate}[` -e2 `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.edr\>\] (ener2.edr) (Optional)

:   Energy file

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx) (Optional)

:   Index file

Options to specify output files:

` `{.docutils .literal .notranslate}[` -m `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tex\>\] (doc.tex) (Optional)

:   LaTeX file

Other options:

` `{.docutils .literal .notranslate}[` -vdwfac `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0.8)

:   Fraction of sum of VdW radii used as warning cutoff

` `{.docutils .literal .notranslate}[` -bonlo `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0.4)

:   Min. fract. of sum of VdW radii for bonded atoms

` `{.docutils .literal .notranslate}[` -bonhi `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0.7)

:   Max. fract. of sum of VdW radii for bonded atoms

` `{.docutils .literal .notranslate}[` -[no]rmsd `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Print RMSD for x, v and f

` `{.docutils .literal .notranslate}[` -tol `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0.001)

:   Relative tolerance for comparing real values defined as
    2\*(a-b)/(\|a\|+\|b\|)

` `{.docutils .literal .notranslate}[` -abstol `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0.001)

:   Absolute tolerance, useful when sums are close to zero.

` `{.docutils .literal .notranslate}[` -[no]ab `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Compare the A and B topology from one file

` `{.docutils .literal .notranslate}[` -lastener `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<string\>

:   Last energy term to compare (if not given all are tested). It makes
    sense to go up until the Pressure.
:::
:::
::: {#gmx-chi .section}
[ ]{#id1}

# gmx chi

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx chi [-s [<.gro/.g96/...>]] [-f [<.xtc/.trr/...>]] [-ss [<.dat>]]
        [-o [<.xvg>]] [-p [<.pdb>]] [-jc [<.xvg>]] [-corr [<.xvg>]]
        [-g [<.log>]] [-ot [<.xvg>]] [-oh [<.xvg>]] [-rt [<.xvg>]]
        [-cp [<.xvg>]] [-b <time>] [-e <time>] [-dt <time>] [-[no]w]
        [-xvg <enum>] [-r0 <int>] [-rN <int>] [-[no]phi] [-[no]psi]
        [-[no]omega] [-[no]rama] [-[no]viol] [-[no]periodic]
        [-[no]all] [-[no]rad] [-[no]shift] [-binwidth <int>]
        [-core_rotamer <real>] [-maxchi <enum>] [-[no]normhisto]
        [-[no]ramomega] [-bfact <real>] [-[no]chi_prod] [-[no]HChi]
        [-bmax <real>] [-acflen <int>] [-[no]normalize] [-P <enum>]
        [-fitfn <enum>] [-beginfit <real>] [-endfit <real>]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` chi `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} computes phi,
psi, omega, and chi dihedrals for all your amino acid backbone and
sidechains. It can compute dihedral angle as a function of time, and as
histogram distributions. The distributions ` `{.docutils .literal
.notranslate}[` (histo-(dihedral)(RESIDUE).xvg `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ) are
cumulative over all residues of each type.

If option ` `{.docutils .literal .notranslate}[` -corr `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} is
given, the program will calculate dihedral autocorrelation functions.
The function used is C(t) = \<cos(chi(tau)) cos(chi(tau+t))\>. The use
of cosines rather than angles themselves, resolves the problem of
periodicity. (Van der Spoel & Berendsen (1997), Biophys. J. 72,
2032-2041). Separate files for each dihedral of each residue
` `{.docutils .literal
.notranslate}[` (corr(dihedral)(RESIDUE)(nresnr).xvg `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} ) are
output, as well as a file containing the information for all residues
(argument of ` `{.docutils .literal .notranslate}[` -corr `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} ).

With option ` `{.docutils .literal .notranslate}[` -all `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} , the
angles themselves as a function of time for each residue are printed to
separate files ` `{.docutils .literal
.notranslate}[` (dihedral)(RESIDUE)(nresnr).xvg `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . These can be
in radians or degrees.

A log file (argument ` `{.docutils .literal
.notranslate}[` -g `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ) is also
written. This contains

> <div>
>
> -   information about the number of residues of each type.
>
> -   The NMR \^3J coupling constants from the Karplus equation.
>
> -   a table for each residue of the number of transitions between
>     rotamers per nanosecond, and the order parameter S\^2 of each
>     dihedral.
>
> -   a table for each residue of the rotamer occupancy.
>
> </div>

All rotamers are taken as 3-fold, except for omega and chi dihedrals to
planar groups (i.e. chi_2 of aromatics, Asp and Asn; chi_3 of Glu and
Gln; and chi_4 of Arg), which are 2-fold. â€œrotamer 0â€? means that the
dihedral was not in the core region of each rotamer. The width of the
core region can be set with ` `{.docutils .literal
.notranslate}[` -core_rotamer `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate}

The S\^2 order parameters are also output to an file (argument
` `{.docutils .literal .notranslate}[` -o `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ) and
optionally as a file with the S\^2 values as B-factor (argument
` `{.docutils .literal .notranslate}[` -p `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ). The total
number of rotamer transitions per timestep (argument ` `{.docutils
.literal .notranslate}[` -ot `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ), the number
of transitions per rotamer (argument ` `{.docutils .literal
.notranslate}[` -rt `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ), and the \^3J
couplings (argument ` `{.docutils .literal
.notranslate}[` -jc `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ), can also be
written to files. Note that the analysis of rotamer transitions assumes
that the supplied trajectory frames are equally spaced in time.

If ` `{.docutils .literal .notranslate}[` -chi_prod `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} is set (and
` `{.docutils .literal .notranslate}[` -maxchi `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} \> 0),
cumulative rotamers, e.g. 1+9(chi_1-1)+3(chi_2-1)+ (chi_3-1) (if the
residue has three 3-fold dihedrals and ` `{.docutils .literal
.notranslate}[` -maxchi `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} \>= 3) are
calculated. As before, if any dihedral is not in the core region, the
rotamer is taken to be 0. The occupancies of these cumulative rotamers
(starting with rotamer 0) are written to the file that is the argument
of ` `{.docutils .literal .notranslate}[` -cp `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , and if the
` `{.docutils .literal .notranslate}[` -all `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} flag is given,
the rotamers as functions of time are written to ` `{.docutils .literal
.notranslate}[` chiproduct(RESIDUE)(nresnr).xvg `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and their
occupancies to ` `{.docutils .literal
.notranslate}[` histo-chiproduct(RESIDUE)(nresnr).xvg `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} .

The option ` `{.docutils .literal .notranslate}[` -r `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}
generates a contour plot of the average omega angle as a function of the
phi and psi angles, that is, in a Ramachandran plot the average omega
angle is plotted using color coding.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.gro/.g96/â€¦\>\] (conf.gro)

:   Structure file: brk ent esp

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (traj.xtc)

:   Trajectory:

` `{.docutils .literal .notranslate}[` -ss `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.dat\>\] (ssdump.dat) (Optional)

:   Generic data file

Options to specify output files:

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (order.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -p `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.pdb\>\] (order.pdb) (Optional)

:   Protein data bank file

` `{.docutils .literal .notranslate}[` -jc `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (Jcoupling.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -corr `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (dihcorr.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -g `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.log\>\] (chi.log)

:   Log file

` `{.docutils .literal .notranslate}[` -ot `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (dihtrans.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -oh `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (trhisto.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -rt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (restrans.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -cp `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (chiprodhisto.xvg) (Optional)

:   xvgr/xmgr file

Other options:

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of first frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of last frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -dt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Only use frame when t MOD dt = first time (default unit ps)

` `{.docutils .literal .notranslate}[` -[no]w `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   View output , , and files

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   xvg plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -r0 `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (1)

:   starting residue

` `{.docutils .literal .notranslate}[` -rN `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (-1)

:   last residue

` `{.docutils .literal .notranslate}[` -[no]phi `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Output for phi dihedral angles

` `{.docutils .literal .notranslate}[` -[no]psi `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Output for psi dihedral angles

` `{.docutils .literal .notranslate}[` -[no]omega `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Output for omega dihedrals (peptide bonds)

` `{.docutils .literal .notranslate}[` -[no]rama `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Generate phi/psi and chi_1/chi_2 Ramachandran plots

` `{.docutils .literal .notranslate}[` -[no]viol `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Write a file that gives 0 or 1 for violated Ramachandran angles

` `{.docutils .literal .notranslate}[` -[no]periodic `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Print dihedral angles modulo 360 degrees

` `{.docutils .literal .notranslate}[` -[no]all `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Output separate files for every dihedral.

` `{.docutils .literal .notranslate}[` -[no]rad `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   in angle vs time files, use radians rather than degrees.

` `{.docutils .literal .notranslate}[` -[no]shift `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Compute chemical shifts from phi/psi angles

` `{.docutils .literal .notranslate}[` -binwidth `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (1)

:   bin width for histograms (degrees)

` `{.docutils .literal .notranslate}[` -core_rotamer `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0.5)

:   only the central ` `{.docutils .literal
    .notranslate}[` -core_rotamer `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate}
    \*(360/multiplicity) belongs to each rotamer (the rest is assigned
    to rotamer 0)

` `{.docutils .literal .notranslate}[` -maxchi `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (0)

:   calculate first ndih chi dihedrals: 0, 1, 2, 3, 4, 5, 6

` `{.docutils .literal .notranslate}[` -[no]normhisto `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Normalize histograms

` `{.docutils .literal .notranslate}[` -[no]ramomega `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   compute average omega as a function of phi/psi and plot it in an
    plot

` `{.docutils .literal .notranslate}[` -bfact `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (-1)

:   B-factor value for file for atoms with no calculated dihedral order
    parameter

` `{.docutils .literal .notranslate}[` -[no]chi_prod `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   compute a single cumulative rotamer for each residue

` `{.docutils .literal .notranslate}[` -[no]HChi `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Include dihedrals to sidechain hydrogens

` `{.docutils .literal .notranslate}[` -bmax `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Maximum B-factor on any of the atoms that make up a dihedral, for
    the dihedral angle to be considered in the statistics. Applies to
    database work where a number of X-Ray structures is analyzed.
    ` `{.docutils .literal .notranslate}[` -bmax `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<= 0 means
    no limit.

` `{.docutils .literal .notranslate}[` -acflen `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (-1)

:   Length of the ACF, default is half the number of frames

` `{.docutils .literal .notranslate}[` -[no]normalize `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Normalize ACF

` `{.docutils .literal .notranslate}[` -P `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (0)

:   Order of Legendre polynomial for ACF (0 indicates none): 0, 1, 2, 3

` `{.docutils .literal .notranslate}[` -fitfn `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (none)

:   Fit function: none, exp, aexp, exp_exp, exp5, exp7, exp9

` `{.docutils .literal .notranslate}[` -beginfit `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Time where to begin the exponential fit of the correlation function

` `{.docutils .literal .notranslate}[` -endfit `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (-1)

:   Time where to end the exponential fit of the correlation function,
    -1 is until the end
:::

::: {#known-issues .section}
## Known Issues

-   N-terminal phi and C-terminal psi dihedrals are calculated in a
    non-standard way, using H-N-CA-C for phi instead of C(-)-N-CA-C, and
    N-CA-C-O for psi instead of N-CA-C-N(+). This causes (usually small)
    discrepancies with the output of other tools like .

-   Rotamers with multiplicity 2 are printed in ` `{.docutils .literal
    .notranslate}[` chi.log `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} as if they
    had

-   multiplicity 3, with the 3rd (g(+)) always having probability 0
:::
:::
::: {#gmx-cluster .section}
[ ]{#id1}

# gmx cluster

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx cluster [-f [<.xtc/.trr/...>]] [-s [<.tpr/.gro/...>]] [-n [<.ndx>]]
            [-dm [<.xpm>]] [-om [<.xpm>]] [-o [<.xpm>]] [-g [<.log>]]
            [-dist [<.xvg>]] [-ev [<.xvg>]] [-conv [<.xvg>]]
            [-sz [<.xvg>]] [-tr [<.xpm>]] [-ntr [<.xvg>]]
            [-clid [<.xvg>]] [-cl [<.xtc/.trr/...>]]
            [-clndx [<.ndx>]] [-b <time>] [-e <time>] [-dt <time>]
            [-tu <enum>] [-[no]w] [-xvg <enum>] [-[no]dista]
            [-nlevels <int>] [-cutoff <real>] [-[no]fit]
            [-max <real>] [-skip <int>] [-[no]av] [-wcl <int>]
            [-nst <int>] [-rmsmin <real>] [-method <enum>]
            [-minstruct <int>] [-[no]binary] [-M <int>] [-P <int>]
            [-seed <int>] [-niter <int>] [-nrandom <int>]
            [-kT <real>] [-[no]pbc]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` cluster `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} can cluster
structures using several different methods. Distances between structures
can be determined from a trajectory or read from an matrix file with the
` `{.docutils .literal .notranslate}[` -dm `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} option. RMS
deviation after fitting or RMS deviation of atom-pair distances can be
used to define the distance between structures.

single linkage: add a structure to a cluster when its distance to any
element of the cluster is less than ` `{.docutils .literal
.notranslate}[` cutoff `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} .

Jarvis Patrick: add a structure to a cluster when this structure and a
structure in the cluster have each other as neighbors and they have a
least ` `{.docutils .literal .notranslate}[` P `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} neighbors in
common. The neighbors of a structure are the M closest structures or all
structures within ` `{.docutils .literal
.notranslate}[` cutoff `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} .

Monte Carlo: reorder the RMSD matrix using Monte Carlo such that the
order of the frames is using the smallest possible increments. With this
it is possible to make a smooth animation going from one structure to
another with the largest possible (e.g.) RMSD between them, however the
intermediate steps should be as small as possible. Applications could be
to visualize a potential of mean force ensemble of simulations or a
pulling simulation. Obviously the user has to prepare the trajectory
well (e.g. by not superimposing frames). The final result can be inspect
visually by looking at the matrix file, which should vary smoothly from
bottom to top.

diagonalization: diagonalize the RMSD matrix.

gromos: use algorithm as described in Daura *et al.* ( *Angew. Chem.
Int. Ed.* **1999** , *38* , pp 236-240). Count number of neighbors using
cut-off, take structure with largest number of neighbors with all its
neighbors as cluster and eliminate it from the pool of clusters. Repeat
for remaining structures in pool.

When the clustering algorithm assigns each structure to exactly one
cluster (single linkage, Jarvis Patrick and gromos) and a trajectory
file is supplied, the structure with the smallest average distance to
the others or the average structure or all structures for each cluster
will be written to a trajectory file. When writing all structures,
separate numbered files are made for each cluster.

Two output files are always written:

> <div>
>
> -   ` `{.docutils .literal .notranslate}[` -o `{.docutils .literal
>     .notranslate}]{.pre}` `{.docutils .literal .notranslate} writes
>     the RMSD values in the upper left half of the matrix and a
>     graphical depiction of the clusters in the lower right half When
>     ` `{.docutils .literal .notranslate}[` -minstruct `{.docutils
>     .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}
>     = 1 the graphical depiction is black when two structures are in
>     the same cluster. When ` `{.docutils .literal
>     .notranslate}[` -minstruct `{.docutils .literal
>     .notranslate}]{.pre}` `{.docutils .literal .notranslate} \> 1
>     different colors will be used for each cluster.
>
> -   ` `{.docutils .literal .notranslate}[` -g `{.docutils .literal
>     .notranslate}]{.pre}` `{.docutils .literal .notranslate} writes
>     information on the options used and a detailed list of all
>     clusters and their members.
>
> </div>

Additionally, a number of optional output files can be written:

> <div>
>
> -   ` `{.docutils .literal .notranslate}[` -dist `{.docutils .literal
>     .notranslate}]{.pre}` `{.docutils .literal .notranslate} writes
>     the RMSD distribution.
>
> -   ` `{.docutils .literal .notranslate}[` -ev `{.docutils .literal
>     .notranslate}]{.pre}` `{.docutils .literal .notranslate} writes
>     the eigenvectors of the RMSD matrix diagonalization.
>
> -   ` `{.docutils .literal .notranslate}[` -sz `{.docutils .literal
>     .notranslate}]{.pre}` `{.docutils .literal .notranslate} writes
>     the cluster sizes.
>
> -   ` `{.docutils .literal .notranslate}[` -tr `{.docutils .literal
>     .notranslate}]{.pre}` `{.docutils .literal .notranslate} writes a
>     matrix of the number transitions between cluster pairs.
>
> -   ` `{.docutils .literal .notranslate}[` -ntr `{.docutils .literal
>     .notranslate}]{.pre}` `{.docutils .literal .notranslate} writes
>     the total number of transitions to or from each cluster.
>
> -   ` `{.docutils .literal .notranslate}[` -clid `{.docutils .literal
>     .notranslate}]{.pre}` `{.docutils .literal .notranslate} writes
>     the cluster number as a function of time.
>
> -   ` `{.docutils .literal .notranslate}[` -clndx `{.docutils .literal
>     .notranslate}]{.pre}` `{.docutils .literal .notranslate} writes
>     the frame numbers corresponding to the clusters to the specified
>     index file to be read into trjconv.
>
> -   ` `{.docutils .literal .notranslate}[` -cl `{.docutils .literal
>     .notranslate}]{.pre}` `{.docutils .literal .notranslate} writes
>     average (with option ` `{.docutils .literal
>     .notranslate}[` -av `{.docutils .literal
>     .notranslate}]{.pre}` `{.docutils .literal .notranslate} ) or
>     central structure of each cluster or writes numbered files with
>     cluster members for a selected set of clusters (with option
>     ` `{.docutils .literal .notranslate}[` -wcl `{.docutils .literal
>     .notranslate}]{.pre}` `{.docutils .literal .notranslate} , depends
>     on ` `{.docutils .literal .notranslate}[` -nst `{.docutils
>     .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}
>     and ` `{.docutils .literal .notranslate}[` -rmsmin `{.docutils
>     .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}
>     ). The center of a cluster is the structure with the smallest
>     average RMSD from all other structures of the cluster.
>
> </div>
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (traj.xtc) (Optional)

:   Trajectory:

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr/.gro/â€¦\>\] (topol.tpr)

:   Structure+mass(db): brk ent

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx) (Optional)

:   Index file

` `{.docutils .literal .notranslate}[` -dm `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xpm\>\] (rmsd.xpm) (Optional)

:   X PixMap compatible matrix file

Options to specify output files:

` `{.docutils .literal .notranslate}[` -om `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xpm\>\] (rmsd-raw.xpm)

:   X PixMap compatible matrix file

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xpm\>\] (rmsd-clust.xpm)

:   X PixMap compatible matrix file

` `{.docutils .literal .notranslate}[` -g `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.log\>\] (cluster.log)

:   Log file

` `{.docutils .literal .notranslate}[` -dist `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (rmsd-dist.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -ev `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (rmsd-eig.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -conv `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (mc-conv.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -sz `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (clust-size.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -tr `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xpm\>\] (clust-trans.xpm) (Optional)

:   X PixMap compatible matrix file

` `{.docutils .literal .notranslate}[` -ntr `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (clust-trans.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -clid `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (clust-id.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -cl `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (clusters.pdb) (Optional)

:   Trajectory:

` `{.docutils .literal .notranslate}[` -clndx `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (clusters.ndx) (Optional)

:   Index file

Other options:

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of first frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of last frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -dt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Only use frame when t MOD dt = first time (default unit ps)

` `{.docutils .literal .notranslate}[` -tu `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (ps)

:   Unit for time values: fs, ps, ns, us, ms, s

` `{.docutils .literal .notranslate}[` -[no]w `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   View output , , and files

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   xvg plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -[no]dista `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Use RMSD of distances instead of RMS deviation

` `{.docutils .literal .notranslate}[` -nlevels `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (40)

:   Discretize RMSD matrix in this number of levels

` `{.docutils .literal .notranslate}[` -cutoff `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0.1)

:   RMSD cut-off (nm) for two structures to be neighbor

` `{.docutils .literal .notranslate}[` -[no]fit `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Use least squares fitting before RMSD calculation

` `{.docutils .literal .notranslate}[` -max `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (-1)

:   Maximum level in RMSD matrix

` `{.docutils .literal .notranslate}[` -skip `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (1)

:   Only analyze every nr-th frame

` `{.docutils .literal .notranslate}[` -[no]av `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Write average instead of middle structure for each cluster

` `{.docutils .literal .notranslate}[` -wcl `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (0)

:   Write the structures for this number of clusters to numbered files

` `{.docutils .literal .notranslate}[` -nst `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (1)

:   Only write all structures if more than this number of structures per
    cluster

` `{.docutils .literal .notranslate}[` -rmsmin `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   minimum rms difference with rest of cluster for writing structures

` `{.docutils .literal .notranslate}[` -method `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (linkage)

:   Method for cluster determination: linkage, jarvis-patrick,
    monte-carlo, diagonalization, gromos

` `{.docutils .literal .notranslate}[` -minstruct `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (1)

:   Minimum number of structures in cluster for coloring in the file

` `{.docutils .literal .notranslate}[` -[no]binary `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Treat the RMSD matrix as consisting of 0 and 1, where the cut-off is
    given by ` `{.docutils .literal .notranslate}[` -cutoff `{.docutils
    .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}

` `{.docutils .literal .notranslate}[` -M `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (10)

:   Number of nearest neighbors considered for Jarvis-Patrick algorithm,
    0 is use cutoff

` `{.docutils .literal .notranslate}[` -P `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (3)

:   Number of identical nearest neighbors required to form a cluster

` `{.docutils .literal .notranslate}[` -seed `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (0)

:   Random number seed for Monte Carlo clustering algorithm (0 means
    generate)

` `{.docutils .literal .notranslate}[` -niter `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (10000)

:   Number of iterations for MC

` `{.docutils .literal .notranslate}[` -nrandom `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (0)

:   The first iterations for MC may be done complete random, to shuffle
    the frames

` `{.docutils .literal .notranslate}[` -kT `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0.001)

:   Boltzmann weighting factor for Monte Carlo optimization (zero turns
    off uphill steps)

` `{.docutils .literal .notranslate}[` -[no]pbc `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   PBC check
:::
:::
::: {#gmx-clustsize .section}
[ ]{#id1}

# gmx clustsize

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx clustsize [-f [<.xtc/.trr/...>]] [-s [<.tpr>]] [-n [<.ndx>]]
             [-o [<.xpm>]] [-ow [<.xpm>]] [-nc [<.xvg>]]
             [-mc [<.xvg>]] [-ac [<.xvg>]] [-hc [<.xvg>]]
             [-temp [<.xvg>]] [-mcn [<.ndx>]] [-b <time>] [-e <time>]
             [-dt <time>] [-tu <enum>] [-[no]w] [-xvg <enum>]
             [-cut <real>] [-[no]mol] [-[no]pbc] [-nskip <int>]
             [-nlevels <int>] [-ndf <int>] [-rgblo <vector>]
             [-rgbhi <vector>]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` clustsize `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} computes the
size distributions of molecular/atomic clusters in the gas phase. The
output is given in the form of an file. The total number of clusters is
written to an file.

When the ` `{.docutils .literal .notranslate}[` -mol `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} option
is given clusters will be made out of molecules rather than atoms, which
allows clustering of large molecules. In this case an index file would
still contain atom numbers or your calculation will die with a SEGV.

When velocities are present in your trajectory, the temperature of the
largest cluster will be printed in a separate file assuming that the
particles are free to move. If you are using constraints, please correct
the temperature. For instance water simulated with SHAKE or SETTLE will
yield a temperature that is 1.5 times too low. You can compensate for
this with the ` `{.docutils .literal .notranslate}[` -ndf `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}
option. Remember to take the removal of center of mass motion into
account.

The ` `{.docutils .literal .notranslate}[` -mc `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} option will
produce an index file containing the atom numbers of the largest
cluster.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (traj.xtc)

:   Trajectory:

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr\>\] (topol.tpr) (Optional)

:   Portable xdr run input file

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx) (Optional)

:   Index file

Options to specify output files:

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xpm\>\] (csize.xpm)

:   X PixMap compatible matrix file

` `{.docutils .literal .notranslate}[` -ow `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xpm\>\] (csizew.xpm)

:   X PixMap compatible matrix file

` `{.docutils .literal .notranslate}[` -nc `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (nclust.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -mc `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (maxclust.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -ac `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (avclust.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -hc `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (histo-clust.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -temp `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (temp.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -mcn `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (maxclust.ndx) (Optional)

:   Index file

Other options:

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of first frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of last frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -dt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Only use frame when t MOD dt = first time (default unit ps)

` `{.docutils .literal .notranslate}[` -tu `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (ps)

:   Unit for time values: fs, ps, ns, us, ms, s

` `{.docutils .literal .notranslate}[` -[no]w `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   View output , , and files

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   xvg plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -cut `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0.35)

:   Largest distance (nm) to be considered in a cluster

` `{.docutils .literal .notranslate}[` -[no]mol `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Cluster molecules rather than atoms (needs file)

` `{.docutils .literal .notranslate}[` -[no]pbc `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Use periodic boundary conditions

` `{.docutils .literal .notranslate}[` -nskip `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (0)

:   Number of frames to skip between writing

` `{.docutils .literal .notranslate}[` -nlevels `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (20)

:   Number of levels of grey in output

` `{.docutils .literal .notranslate}[` -ndf `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (-1)

:   Number of degrees of freedom of the entire system for temperature
    calculation. If not set, the number of atoms times three is used.

` `{.docutils .literal .notranslate}[` -rgblo `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<vector\> (1 1 0)

:   RGB values for the color of the lowest occupied cluster size

` `{.docutils .literal .notranslate}[` -rgbhi `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<vector\> (0 0 1)

:   RGB values for the color of the highest occupied cluster size
:::
:::
::: {#gmx-confrms .section}
[ ]{#id1}

# gmx confrms

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx confrms [-f1 [<.tpr/.gro/...>]] [-f2 [<.gro/.g96/...>]]
            [-n1 [<.ndx>]] [-n2 [<.ndx>]] [-o [<.gro/.g96/...>]]
            [-no [<.ndx>]] [-[no]w] [-[no]one] [-[no]mw] [-[no]pbc]
            [-[no]fit] [-[no]name] [-[no]label] [-[no]bfac]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` confrms `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} computes the
root mean square deviation (RMSD) of two structures after least-squares
fitting the second structure on the first one. The two structures do NOT
need to have the same number of atoms, only the two index groups used
for the fit need to be identical. With ` `{.docutils .literal
.notranslate}[` -name `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} only matching
atom names from the selected groups will be used for the fit and RMSD
calculation. This can be useful when comparing mutants of a protein.

The superimposed structures are written to file. In a file the two
structures will be written as separate models (use ` `{.docutils
.literal .notranslate}[` rasmol `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` -nmrpdb `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ). Also in a
file, B-factors calculated from the atomic MSD values can be written
with ` `{.docutils .literal .notranslate}[` -bfac `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} .
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f1 `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr/.gro/â€¦\>\] (conf1.gro)

:   Structure+mass(db): brk ent

` `{.docutils .literal .notranslate}[` -f2 `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.gro/.g96/â€¦\>\] (conf2.gro)

:   Structure file: brk ent esp

` `{.docutils .literal .notranslate}[` -n1 `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (fit1.ndx) (Optional)

:   Index file

` `{.docutils .literal .notranslate}[` -n2 `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (fit2.ndx) (Optional)

:   Index file

Options to specify output files:

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.gro/.g96/â€¦\>\] (fit.pdb)

:   Structure file: brk ent esp

` `{.docutils .literal .notranslate}[` -no `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (match.ndx) (Optional)

:   Index file

Other options:

` `{.docutils .literal .notranslate}[` -[no]w `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   View output , , and files

` `{.docutils .literal .notranslate}[` -[no]one `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Only write the fitted structure to file

` `{.docutils .literal .notranslate}[` -[no]mw `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Mass-weighted fitting and RMSD

` `{.docutils .literal .notranslate}[` -[no]pbc `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Try to make molecules whole again

` `{.docutils .literal .notranslate}[` -[no]fit `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Do least squares superposition of the target structure to the
    reference

` `{.docutils .literal .notranslate}[` -[no]name `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Only compare matching atom names

` `{.docutils .literal .notranslate}[` -[no]label `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Added chain labels A for first and B for second structure

` `{.docutils .literal .notranslate}[` -[no]bfac `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Output B-factors from atomic MSD values
:::
:::
::: {#gmx-convert-tpr .section}
[ ]{#id1}

# gmx convert-tpr

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx convert-tpr [-s [<.tpr/.gro/...>]] [-n [<.ndx>]]
             [-o [<.tpr/.gro/...>]] [-extend <time>] [-until <time>]
             [-nsteps <int>] [-[no]generate_velocities]
             [-velocity_temp <real>] [-velocity_seed <int>]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` convert-tpr `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} can edit run
input files in three ways.

**1.** by modifying the number of steps in a run input file with options
` `{.docutils .literal .notranslate}[` -extend `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , ` `{.docutils
.literal .notranslate}[` -until `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} or
` `{.docutils .literal .notranslate}[` -nsteps `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} (nsteps=-1
means unlimited number of steps)

**2.** by creating a .tpx file for a subset of your original tpx file,
which is useful when you want to remove the solvent from your .tpx file,
or when you want to make e.g. a pure Calpha .tpx file. Note that you may
need to use ` `{.docutils .literal .notranslate}[` -nsteps `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` -1 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} (or similar) to
get this to work. **WARNING: this .tpx file is not fully functional** .

**3.** by setting the charges of a specified group to zero. This is
useful when doing free energy estimates using the LIE (Linear
Interaction Energy) method.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr/.gro/â€¦\>\] (topol.tpr)

:   Run input file to modify: brk ent

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx) (Optional)

:   File containing additional index groups

Options to specify output files:

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr/.gro/â€¦\>\] (tprout.tpr) (Optional)

:   Generated modified run input file: brk ent

Other options:

` `{.docutils .literal .notranslate}[` -extend `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Extend runtime by this amount (ps)

` `{.docutils .literal .notranslate}[` -until `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Extend runtime until this ending time (ps)

` `{.docutils .literal .notranslate}[` -nsteps `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (0)

:   Change the number of steps remaining to be made

` `{.docutils .literal .notranslate}[` -[no]generate_velocities `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Reassign velocities, using a generated seed unless one is explicitly
    set

` `{.docutils .literal .notranslate}[` -velocity_temp `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (300)

:   Temperature to use when generating velocities

` `{.docutils .literal .notranslate}[` -velocity_seed `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (-1)

:   Random seed for velocities. If value is -1, a new one is generated
:::
:::
::: {#gmx-convert-trj .section}
[ ]{#id1}

# gmx convert-trj

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx convert-trj [-f [<.xtc/.trr/...>]] [-s [<.tpr/.gro/...>]]
             [-n [<.ndx>]] [-o [<.xtc/.trr/...>]] [-b <time>]
             [-e <time>] [-dt <time>] [-tu <enum>]
             [-fgroup <selection>] [-xvg <enum>] [-[no]rmpbc]
             [-[no]pbc] [-sf <file>] [-selrpos <enum>]
             [-select <selection>] [-vel <enum>] [-force <enum>]
             [-atoms <enum>] [-precision <int>] [-starttime <time>]
             [-timestep <time>] [-box <vector>]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` convert-trj `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} converts
trajectory files between different formats. The module supports writing
all GROMACS supported file formats from the supported input formats.

Included is also a selection of possible options to modify individual
trajectory frames, including options to produce slimmer output files. It
is also possible to replace the particle information stored in the input
trajectory with those from a structure file

The module can also generate subsets of trajectories based on user
supplied selections.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (traj.xtc) (Optional)

:   Input trajectory or single configuration:

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr/.gro/â€¦\>\] (topol.tpr) (Optional)

:   Input structure: brk ent

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx) (Optional)

:   Extra index groups

Options to specify output files:

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (trajout.xtc)

:   Output trajectory:

Other options:

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   First frame (ps) to read from trajectory

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Last frame (ps) to read from trajectory

` `{.docutils .literal .notranslate}[` -dt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Only use frame if t MOD dt == first time (ps)

` `{.docutils .literal .notranslate}[` -tu `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (ps)

:   Unit for time values: fs, ps, ns, us, ms, s

` `{.docutils .literal .notranslate}[` -fgroup `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<selection\>

:   Atoms stored in the trajectory file (if not set, assume first N
    atoms)

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   Plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -[no]rmpbc `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Make molecules whole for each frame

` `{.docutils .literal .notranslate}[` -[no]pbc `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Use periodic boundary conditions for distance calculation

` `{.docutils .literal .notranslate}[` -sf `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<file\>

:   Provide selections from files

` `{.docutils .literal .notranslate}[` -selrpos `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (atom)

:   Selection reference positions: atom, res_com, res_cog, mol_com,
    mol_cog, whole_res_com, whole_res_cog, whole_mol_com, whole_mol_cog,
    part_res_com, part_res_cog, part_mol_com, part_mol_cog, dyn_res_com,
    dyn_res_cog, dyn_mol_com, dyn_mol_cog

` `{.docutils .literal .notranslate}[` -select `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<selection\>

:   Selection of particles to write to the file

` `{.docutils .literal .notranslate}[` -vel `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (preserved-if-present)

:   Save velocities from frame if possible: preserved-if-present,
    always, never

` `{.docutils .literal .notranslate}[` -force `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (preserved-if-present)

:   Save forces from frame if possible: preserved-if-present, always,
    never

` `{.docutils .literal .notranslate}[` -atoms `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (preserved-if-present)

:   Decide on providing new atom information from topology or using
    current frame atom information: preserved-if-present,
    always-from-structure, never, always

` `{.docutils .literal .notranslate}[` -precision `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (3)

:   Set output precision to custom value

` `{.docutils .literal .notranslate}[` -starttime `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Change start time for first frame

` `{.docutils .literal .notranslate}[` -timestep `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Change time between different frames

` `{.docutils .literal .notranslate}[` -box `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<vector\>

:   New diagonal box vector for output frame
:::
:::
::: {#gmx-covar .section}
[ ]{#id1}

# gmx covar

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx covar [-f [<.xtc/.trr/...>]] [-s [<.tpr/.gro/...>]] [-n [<.ndx>]]
          [-o [<.xvg>]] [-v [<.trr/.cpt/...>]]
          [-av [<.gro/.g96/...>]] [-l [<.log>]] [-ascii [<.dat>]]
          [-xpm [<.xpm>]] [-xpma [<.xpm>]] [-b <time>] [-e <time>]
          [-dt <time>] [-tu <enum>] [-xvg <enum>] [-[no]fit]
          [-[no]ref] [-[no]mwa] [-last <int>] [-[no]pbc]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` covar `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} calculates and
diagonalizes the (mass-weighted) covariance matrix. All structures are
fitted to the structure in the structure file. When this is not a run
input file periodicity will not be taken into account. When the fit and
analysis groups are identical and the analysis is non mass-weighted, the
fit will also be non mass-weighted.

The eigenvectors are written to a trajectory file ( ` `{.docutils
.literal .notranslate}[` -v `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ). When the
same atoms are used for the fit and the covariance analysis, the
reference structure for the fit is written first with t=-1. The average
(or reference when ` `{.docutils .literal
.notranslate}[` -ref `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} is used)
structure is written with t=0, the eigenvectors are written as frames
with the eigenvector number and eigenvalue as step number and timestamp,
respectively.

The eigenvectors can be analyzed with .

Option ` `{.docutils .literal .notranslate}[` -ascii `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} writes
the whole covariance matrix to an ASCII file. The order of the elements
is: x1x1, x1y1, x1z1, x1x2, â€¦

Option ` `{.docutils .literal .notranslate}[` -xpm `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} writes the
whole covariance matrix to an file.

Option ` `{.docutils .literal .notranslate}[` -xpma `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} writes the
atomic covariance matrix to an file, i.e. for each atom pair the sum of
the xx, yy and zz covariances is written.

Note that the diagonalization of a matrix requires memory and time that
will increase at least as fast as than the square of the number of atoms
involved. It is easy to run out of memory, in which case this tool will
probably exit with a â€˜Segmentation faultâ€™. You should consider
carefully whether a reduced set of atoms will meet your needs for lower
costs.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (traj.xtc)

:   Trajectory:

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr/.gro/â€¦\>\] (topol.tpr)

:   Structure+mass(db): brk ent

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx) (Optional)

:   Index file

Options to specify output files:

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (eigenval.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -v `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.trr/.cpt/â€¦\>\] (eigenvec.trr)

:   Full precision trajectory:

` `{.docutils .literal .notranslate}[` -av `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.gro/.g96/â€¦\>\] (average.pdb)

:   Structure file: brk ent esp

` `{.docutils .literal .notranslate}[` -l `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.log\>\] (covar.log)

:   Log file

` `{.docutils .literal .notranslate}[` -ascii `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.dat\>\] (covar.dat) (Optional)

:   Generic data file

` `{.docutils .literal .notranslate}[` -xpm `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xpm\>\] (covar.xpm) (Optional)

:   X PixMap compatible matrix file

` `{.docutils .literal .notranslate}[` -xpma `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xpm\>\] (covara.xpm) (Optional)

:   X PixMap compatible matrix file

Other options:

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of first frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of last frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -dt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Only use frame when t MOD dt = first time (default unit ps)

` `{.docutils .literal .notranslate}[` -tu `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (ps)

:   Unit for time values: fs, ps, ns, us, ms, s

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   xvg plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -[no]fit `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Fit to a reference structure

` `{.docutils .literal .notranslate}[` -[no]ref `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Use the deviation from the conformation in the structure file
    instead of from the average

` `{.docutils .literal .notranslate}[` -[no]mwa `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Mass-weighted covariance analysis

` `{.docutils .literal .notranslate}[` -last `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (-1)

:   Last eigenvector to write away (-1 is till the last)

` `{.docutils .literal .notranslate}[` -[no]pbc `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Apply corrections for periodic boundary conditions
:::
:::
::: {#gmx-current .section}
[ ]{#id1}

# gmx current

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx current [-s [<.tpr/.gro/...>]] [-n [<.ndx>]] [-f [<.xtc/.trr/...>]]
            [-o [<.xvg>]] [-caf [<.xvg>]] [-dsp [<.xvg>]]
            [-md [<.xvg>]] [-mj [<.xvg>]] [-mc [<.xvg>]] [-b <time>]
            [-e <time>] [-dt <time>] [-[no]w] [-xvg <enum>]
            [-sh <int>] [-[no]nojump] [-eps <real>] [-bfit <real>]
            [-efit <real>] [-bvit <real>] [-evit <real>]
            [-temp <real>]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` current `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} is a tool for
calculating the current autocorrelation function, the correlation of the
rotational and translational dipole moment of the system, and the
resulting static dielectric constant. To obtain a reasonable result, the
index group has to be neutral. Furthermore, the routine is capable of
extracting the static conductivity from the current autocorrelation
function, if velocities are given. Additionally, an Einstein-Helfand fit
can be used to obtain the static conductivity.

The flag ` `{.docutils .literal .notranslate}[` -caf `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} is for
the output of the current autocorrelation function and ` `{.docutils
.literal .notranslate}[` -mc `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} writes the
correlation of the rotational and translational part of the dipole
moment in the corresponding file. However, this option is only available
for trajectories containing velocities. Options ` `{.docutils .literal
.notranslate}[` -sh `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` -tr `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} are responsible
for the averaging and integration of the autocorrelation functions.
Since averaging proceeds by shifting the starting point through the
trajectory, the shift can be modified with ` `{.docutils .literal
.notranslate}[` -sh `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} to enable the
choice of uncorrelated starting points. Towards the end, statistical
inaccuracy grows and integrating the correlation function only yields
reliable values until a certain point, depending on the number of
frames. The option ` `{.docutils .literal
.notranslate}[` -tr `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} controls the
region of the integral taken into account for calculating the static
dielectric constant.

Option ` `{.docutils .literal .notranslate}[` -temp `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} sets the
temperature required for the computation of the static dielectric
constant.

Option ` `{.docutils .literal .notranslate}[` -eps `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} controls the
dielectric constant of the surrounding medium for simulations using a
Reaction Field or dipole corrections of the Ewald summation (
` `{.docutils .literal .notranslate}[` -eps `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} =0 corresponds
to tin-foil boundary conditions).

` `{.docutils .literal .notranslate}[` -[no]nojump `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} unfolds the
coordinates to allow free diffusion. This is required to get a
continuous translational dipole moment, required for the
Einstein-Helfand fit. The results from the fit allow the determination
of the dielectric constant for system of charged molecules. However, it
is also possible to extract the dielectric constant from the
fluctuations of the total dipole moment in folded coordinates. But this
option has to be used with care, since only very short time spans
fulfill the approximation that the density of the molecules is
approximately constant and the averages are already converged. To be on
the safe side, the dielectric constant should be calculated with the
help of the Einstein-Helfand method for the translational part of the
dielectric constant.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr/.gro/â€¦\>\] (topol.tpr)

:   Structure+mass(db): brk ent

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx) (Optional)

:   Index file

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (traj.xtc)

:   Trajectory:

Options to specify output files:

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (current.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -caf `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (caf.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -dsp `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (dsp.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -md `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (md.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -mj `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (mj.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -mc `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (mc.xvg) (Optional)

:   xvgr/xmgr file

Other options:

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of first frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of last frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -dt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Only use frame when t MOD dt = first time (default unit ps)

` `{.docutils .literal .notranslate}[` -[no]w `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   View output , , and files

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   xvg plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -sh `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (1000)

:   Shift of the frames for averaging the correlation functions and the
    mean-square displacement.

` `{.docutils .literal .notranslate}[` -[no]nojump `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Removes jumps of atoms across the box.

` `{.docutils .literal .notranslate}[` -eps `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Dielectric constant of the surrounding medium. The value zero
    corresponds to infinity (tin-foil boundary conditions).

` `{.docutils .literal .notranslate}[` -bfit `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (100)

:   Begin of the fit of the straight line to the MSD of the
    translational fraction of the dipole moment.

` `{.docutils .literal .notranslate}[` -efit `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (400)

:   End of the fit of the straight line to the MSD of the translational
    fraction of the dipole moment.

` `{.docutils .literal .notranslate}[` -bvit `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0.5)

:   Begin of the fit of the current autocorrelation function to a\*t\^b.

` `{.docutils .literal .notranslate}[` -evit `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (5)

:   End of the fit of the current autocorrelation function to a\*t\^b.

` `{.docutils .literal .notranslate}[` -temp `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (300)

:   Temperature for calculating epsilon.
:::
:::
::: {#gmx-density .section}
[ ]{#id1}

# gmx density

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx density [-f [<.xtc/.trr/...>]] [-n [<.ndx>]] [-s [<.tpr>]]
            [-ei [<.dat>]] [-o [<.xvg>]] [-b <time>] [-e <time>]
            [-dt <time>] [-[no]w] [-xvg <enum>] [-d <string>]
            [-sl <int>] [-dens <enum>] [-ng <int>] [-[no]center]
            [-[no]symm]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` density `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} computes
partial densities across the box, using an index file.

For the total density of NPT simulations, use instead.

Option ` `{.docutils .literal .notranslate}[` -center `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}
performs the histogram binning relative to the center of an arbitrary
group, in absolute box coordinates. If you are calculating profiles
along the Z axis box dimension bZ, output would be from -bZ/2 to bZ/2 if
you center based on the entire system. Note that this behaviour has
changed in GROMACS 5.0; earlier versions merely performed a static
binning in (0,bZ) and shifted the output. Now we compute the center for
each frame and bin in (-bZ/2,bZ/2).

Option ` `{.docutils .literal .notranslate}[` -symm `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} symmetrizes the
output around the center. This will automatically turn on ` `{.docutils
.literal .notranslate}[` -center `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} too. The
binning is now always performed in relative coordinates to account for
changing box dimensions with pressure coupling, with the output scaled
to the average box dimension along the output axis.

Densities are in kg/m\^3, and number densities or electron densities can
also be calculated. For electron densities, a file describing the number
of electrons for each type of atom should be provided using
` `{.docutils .literal .notranslate}[` -ei `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . It should
look like:

::: {.highlight-default .notranslate}
::: highlight
    2
    atomname = nrelectrons
    atomname = nrelectrons
:::
:::

The first line contains the number of lines to read from the file. There
should be one line for each unique atom name in your system. The number
of electrons for each atom is modified by its atomic partial charge.

IMPORTANT CONSIDERATIONS FOR BILAYERS

One of the most common usage scenarios is to calculate the density of
various groups across a lipid bilayer, typically with the z axis being
the normal direction. For short simulations, small systems, and fixed
box sizes this will work fine, but for the more general case lipid
bilayers can be complicated. The first problem that while both proteins
and lipids have low volume compressibility, lipids have quite high area
compressiblity. This means the shape of the box (thickness and
area/lipid) will fluctuate substantially even for a fully relaxed
system. Since GROMACS places the box between the origin and positive
coordinates, this in turn means that a bilayer centered in the box will
move a bit up/down due to these fluctuations, and smear out your
profile. The easiest way to fix this (if you want pressure coupling) is
to use the ` `{.docutils .literal .notranslate}[` -center `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} option
that calculates the density profile with respect to the center of the
box. Note that you can still center on the bilayer part even if you have
a complex non-symmetric system with a bilayer and, say, membrane
proteins - then our output will simply have more values on one side of
the (center) origin reference.

Finally, large bilayers that are not subject to a surface tension will
exhibit undulatory fluctuations, where there are â€˜wavesâ€™ forming in
the system. This is a fundamental property of the biological system, and
if you are comparing against experiments you likely want to include the
undulation smearing effect.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (traj.xtc)

:   Trajectory:

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx) (Optional)

:   Index file

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr\>\] (topol.tpr)

:   Portable xdr run input file

` `{.docutils .literal .notranslate}[` -ei `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.dat\>\] (electrons.dat) (Optional)

:   Generic data file

Options to specify output files:

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (density.xvg)

:   xvgr/xmgr file

Other options:

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of first frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of last frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -dt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Only use frame when t MOD dt = first time (default unit ps)

` `{.docutils .literal .notranslate}[` -[no]w `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   View output , , and files

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   xvg plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -d `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<string\> (Z)

:   Take the normal on the membrane in direction X, Y or Z.

` `{.docutils .literal .notranslate}[` -sl `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (50)

:   Divide the box in this number of slices.

` `{.docutils .literal .notranslate}[` -dens `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (mass)

:   Density: mass, number, charge, electron

` `{.docutils .literal .notranslate}[` -ng `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (1)

:   Number of groups of which to compute densities.

` `{.docutils .literal .notranslate}[` -[no]center `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Perform the binning relative to the center of the (changing) box.
    Useful for bilayers.

` `{.docutils .literal .notranslate}[` -[no]symm `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Symmetrize the density along the axis, with respect to the center.
    Useful for bilayers.
:::

::: {#known-issues .section}
## Known Issues

-   When calculating electron densities, atomnames are used instead of
    types. This is bad.
:::
:::
::: {#gmx-densmap .section}
[ ]{#id1}

# gmx densmap

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx densmap [-f [<.xtc/.trr/...>]] [-s [<.tpr/.gro/...>]] [-n [<.ndx>]]
            [-od [<.dat>]] [-o [<.xpm>]] [-b <time>] [-e <time>]
            [-dt <time>] [-[no]w] [-bin <real>] [-aver <enum>]
            [-xmin <real>] [-xmax <real>] [-n1 <int>] [-n2 <int>]
            [-amax <real>] [-rmax <real>] [-[no]mirror] [-[no]sums]
            [-unit <enum>] [-dmin <real>] [-dmax <real>]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` densmap `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} computes 2D
number-density maps. It can make planar and axial-radial density maps.
The output file can be visualized with for instance xv and can be
converted to postscript with ` `{.docutils .literal
.notranslate}[` xpm2ps `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . Optionally,
output can be in text form to a file with ` `{.docutils .literal
.notranslate}[` -od `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , instead of
the usual file with ` `{.docutils .literal
.notranslate}[` -o `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} .

The default analysis is a 2-D number-density map for a selected group of
atoms in the x-y plane. The averaging direction can be changed with the
option ` `{.docutils .literal .notranslate}[` -aver `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . When
` `{.docutils .literal .notranslate}[` -xmin `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and/or
` `{.docutils .literal .notranslate}[` -xmax `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} are set only
atoms that are within the limit(s) in the averaging direction are taken
into account. The grid spacing is set with the option ` `{.docutils
.literal .notranslate}[` -bin `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . When
` `{.docutils .literal .notranslate}[` -n1 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} or
` `{.docutils .literal .notranslate}[` -n2 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} is non-zero,
the grid size is set by this option. Box size fluctuations are properly
taken into account.

When options ` `{.docutils .literal .notranslate}[` -amax `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` -rmax `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} are set, an
axial-radial number-density map is made. Three groups should be
supplied, the centers of mass of the first two groups define the axis,
the third defines the analysis group. The axial direction goes from
-amax to +amax, where the center is defined as the midpoint between the
centers of mass and the positive direction goes from the first to the
second center of mass. The radial direction goes from 0 to rmax or from
-rmax to +rmax when the ` `{.docutils .literal
.notranslate}[` -mirror `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} option has been
set.

The normalization of the output is set with the ` `{.docutils .literal
.notranslate}[` -unit `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} option. The
default produces a true number density. Unit ` `{.docutils .literal
.notranslate}[` nm-2 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} leaves out the
normalization for the averaging or the angular direction. Option
` `{.docutils .literal .notranslate}[` count `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} produces the
count for each grid cell. When you do not want the scale in the output
to go from zero to the maximum density, you can set the maximum with the
option ` `{.docutils .literal .notranslate}[` -dmax `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} .
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (traj.xtc)

:   Trajectory:

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr/.gro/â€¦\>\] (topol.tpr) (Optional)

:   Structure+mass(db): brk ent

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx) (Optional)

:   Index file

Options to specify output files:

` `{.docutils .literal .notranslate}[` -od `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.dat\>\] (densmap.dat) (Optional)

:   Generic data file

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xpm\>\] (densmap.xpm)

:   X PixMap compatible matrix file

Other options:

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of first frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of last frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -dt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Only use frame when t MOD dt = first time (default unit ps)

` `{.docutils .literal .notranslate}[` -[no]w `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   View output , , and files

` `{.docutils .literal .notranslate}[` -bin `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0.02)

:   Grid size (nm)

` `{.docutils .literal .notranslate}[` -aver `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (z)

:   The direction to average over: z, y, x

` `{.docutils .literal .notranslate}[` -xmin `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (-1)

:   Minimum coordinate for averaging

` `{.docutils .literal .notranslate}[` -xmax `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (-1)

:   Maximum coordinate for averaging

` `{.docutils .literal .notranslate}[` -n1 `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (0)

:   Number of grid cells in the first direction

` `{.docutils .literal .notranslate}[` -n2 `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (0)

:   Number of grid cells in the second direction

` `{.docutils .literal .notranslate}[` -amax `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Maximum axial distance from the center

` `{.docutils .literal .notranslate}[` -rmax `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Maximum radial distance

` `{.docutils .literal .notranslate}[` -[no]mirror `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Add the mirror image below the axial axis

` `{.docutils .literal .notranslate}[` -[no]sums `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Print density sums (1D map) to stdout

` `{.docutils .literal .notranslate}[` -unit `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (nm-3)

:   Unit for the output: nm-3, nm-2, count

` `{.docutils .literal .notranslate}[` -dmin `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Minimum density in output

` `{.docutils .literal .notranslate}[` -dmax `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Maximum density in output (0 means calculate it)
:::
:::
::: {#gmx-densorder .section}
[ ]{#id1}

# gmx densorder

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx densorder [-s [<.tpr>]] [-f [<.xtc/.trr/...>]] [-n [<.ndx>]]
             [-o [<.dat>]] [-or [<.out> [...]]] [-og [<.xpm> [...]]]
             [-Spect [<.out> [...]]] [-b <time>] [-e <time>]
             [-dt <time>] [-[no]w] [-[no]1d] [-bw <real>]
             [-bwn <real>] [-order <int>] [-axis <string>]
             [-method <enum>] [-d1 <real>] [-d2 <real>]
             [-tblock <int>] [-nlevel <int>]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` densorder `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} reduces a
two-phase density distribution along an axis, computed over a MD
trajectory, to 2D surfaces fluctuating in time, by a fit to a functional
profile for interfacial densities. A time-averaged spatial
representation of the interfaces can be output with the option
` `{.docutils .literal .notranslate}[` -tavg `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} .
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr\>\] (topol.tpr)

:   Portable xdr run input file

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (traj.xtc)

:   Trajectory:

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx)

:   Index file

Options to specify output files:

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.dat\>\] (Density4D.dat) (Optional)

:   Generic data file

` `{.docutils .literal .notranslate}[` -or `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.out\> \[â€¦\]\] (hello.out) (Optional)

:   Generic output file

` `{.docutils .literal .notranslate}[` -og `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xpm\> \[â€¦\]\] (interface.xpm) (Optional)

:   X PixMap compatible matrix file

` `{.docutils .literal .notranslate}[` -Spect `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.out\> \[â€¦\]\] (intfspect.out) (Optional)

:   Generic output file

Other options:

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of first frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of last frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -dt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Only use frame when t MOD dt = first time (default unit ps)

` `{.docutils .literal .notranslate}[` -[no]w `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   View output , , and files

` `{.docutils .literal .notranslate}[` -[no]1d `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Pseudo-1d interface geometry

` `{.docutils .literal .notranslate}[` -bw `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0.2)

:   Binwidth of density distribution tangential to interface

` `{.docutils .literal .notranslate}[` -bwn `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0.05)

:   Binwidth of density distribution normal to interface

` `{.docutils .literal .notranslate}[` -order `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (0)

:   Order of Gaussian filter, order 0 equates to NO filtering

` `{.docutils .literal .notranslate}[` -axis `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<string\> (Z)

:   Axis Direction - X, Y or Z

` `{.docutils .literal .notranslate}[` -method `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (bisect)

:   Interface location method: bisect, functional

` `{.docutils .literal .notranslate}[` -d1 `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Bulk density phase 1 (at small z)

` `{.docutils .literal .notranslate}[` -d2 `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (1000)

:   Bulk density phase 2 (at large z)

` `{.docutils .literal .notranslate}[` -tblock `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (100)

:   Number of frames in one time-block average

` `{.docutils .literal .notranslate}[` -nlevel `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (100)

:   Number of Height levels in 2D - XPixMaps
:::
:::
::: {#gmx-dielectric .section}
[ ]{#id1}

# gmx dielectric

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx dielectric [-f [<.xvg>]] [-d [<.xvg>]] [-o [<.xvg>]] [-c [<.xvg>]]
             [-b <time>] [-e <time>] [-dt <time>] [-[no]w]
             [-xvg <enum>] [-[no]x1] [-eint <real>] [-bfit <real>]
             [-efit <real>] [-tail <real>] [-A <real>] [-tau1 <real>]
             [-tau2 <real>] [-eps0 <real>] [-epsRF <real>]
             [-fix <int>] [-ffn <enum>] [-nsmooth <int>]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` dielectric `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} calculates
frequency dependent dielectric constants from the autocorrelation
function of the total dipole moment in your simulation. This ACF can be
generated by . The functional forms of the available functions are:

> <div>
>
> -   One parameter: y = exp(-a_1 x),
>
> -   Two parameters: y = a_2 exp(-a_1 x),
>
> -   Three parameters: y = a_2 exp(-a_1 x) + (1 - a_2) exp(-a_3 x).
>
> </div>

Start values for the fit procedure can be given on the command line. It
is also possible to fix parameters at their start value, use
` `{.docutils .literal .notranslate}[` -fix `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} with the number
of the parameter you want to fix.

Three output files are generated, the first contains the ACF, an
exponential fit to it with 1, 2 or 3 parameters, and the numerical
derivative of the combination data/fit. The second file contains the
real and imaginary parts of the frequency-dependent dielectric constant,
the last gives a plot known as the Cole-Cole plot, in which the
imaginary component is plotted as a function of the real component. For
a pure exponential relaxation (Debye relaxation) the latter plot should
be one half of a circle.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (dipcorr.xvg)

:   xvgr/xmgr file

Options to specify output files:

` `{.docutils .literal .notranslate}[` -d `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (deriv.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (epsw.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -c `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (cole.xvg)

:   xvgr/xmgr file

Other options:

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of first frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of last frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -dt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Only use frame when t MOD dt = first time (default unit ps)

` `{.docutils .literal .notranslate}[` -[no]w `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   View output , , and files

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   xvg plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -[no]x1 `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   use first column as *x* -axis rather than first data set

` `{.docutils .literal .notranslate}[` -eint `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (5)

:   Time to end the integration of the data and start to use the fit

` `{.docutils .literal .notranslate}[` -bfit `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (5)

:   Begin time of fit

` `{.docutils .literal .notranslate}[` -efit `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (500)

:   End time of fit

` `{.docutils .literal .notranslate}[` -tail `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (500)

:   Length of function including data and tail from fit

` `{.docutils .literal .notranslate}[` -A `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0.5)

:   Start value for fit parameter A

` `{.docutils .literal .notranslate}[` -tau1 `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (10)

:   Start value for fit parameter tau1

` `{.docutils .literal .notranslate}[` -tau2 `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (1)

:   Start value for fit parameter tau2

` `{.docutils .literal .notranslate}[` -eps0 `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (80)

:   epsilon0 of your liquid

` `{.docutils .literal .notranslate}[` -epsRF `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (78.5)

:   epsilon of the reaction field used in your simulation. A value of 0
    means infinity.

` `{.docutils .literal .notranslate}[` -fix `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (0)

:   Fix parameters at their start values, A (2), tau1 (1), or tau2 (4)

` `{.docutils .literal .notranslate}[` -ffn `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (none)

:   Fit function: none, exp, aexp, exp_exp, exp5, exp7, exp9

` `{.docutils .literal .notranslate}[` -nsmooth `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (3)

:   Number of points for smoothing
:::
:::
::: {#gmx-dipoles .section}
[ ]{#id1}

# gmx dipoles

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx dipoles [-en [<.edr>]] [-f [<.xtc/.trr/...>]] [-s [<.tpr>]]
            [-n [<.ndx>]] [-o [<.xvg>]] [-eps [<.xvg>]] [-a [<.xvg>]]
            [-d [<.xvg>]] [-c [<.xvg>]] [-g [<.xvg>]]
            [-adip [<.xvg>]] [-dip3d [<.xvg>]] [-cos [<.xvg>]]
            [-cmap [<.xpm>]] [-slab [<.xvg>]] [-b <time>] [-e <time>]
            [-dt <time>] [-[no]w] [-xvg <enum>] [-mu <real>]
            [-mumax <real>] [-epsilonRF <real>] [-skip <int>]
            [-temp <real>] [-corr <enum>] [-[no]pairs] [-[no]quad]
            [-ncos <int>] [-axis <string>] [-sl <int>]
            [-gkratom <int>] [-gkratom2 <int>] [-rcmax <real>]
            [-[no]phi] [-nlevels <int>] [-ndegrees <int>]
            [-acflen <int>] [-[no]normalize] [-P <enum>]
            [-fitfn <enum>] [-beginfit <real>] [-endfit <real>]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` dipoles `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} computes the
total dipole plus fluctuations of a simulation system. From this you can
compute e.g. the dielectric constant for low-dielectric media. For
molecules with a net charge, the net charge is subtracted at center of
mass of the molecule.

The file ` `{.docutils .literal .notranslate}[` Mtot.xvg `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}
contains the total dipole moment of a frame, the components as well as
the norm of the vector. The file ` `{.docutils .literal
.notranslate}[` aver.xvg `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} contains
\<\|mu\|\^2\> and \|\<mu\>\|\^2 during the simulation. The file
` `{.docutils .literal .notranslate}[` dipdist.xvg `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} contains the
distribution of dipole moments during the simulation The value of
` `{.docutils .literal .notranslate}[` -mumax `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} is used as the
highest value in the distribution graph.

Furthermore, the dipole autocorrelation function will be computed when
option ` `{.docutils .literal .notranslate}[` -corr `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} is used. The
output file name is given with the ` `{.docutils .literal
.notranslate}[` -c `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} option. The
correlation functions can be averaged over all molecules ( ` `{.docutils
.literal .notranslate}[` mol `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ), plotted per
molecule separately ( ` `{.docutils .literal
.notranslate}[` molsep `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ) or it can be
computed over the total dipole moment of the simulation box (
` `{.docutils .literal .notranslate}[` total `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ).

Option ` `{.docutils .literal .notranslate}[` -g `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} produces a plot
of the distance dependent Kirkwood G-factor, as well as the average
cosine of the angle between the dipoles as a function of the distance.
The plot also includes gOO and hOO according to Nymand & Linse, J. Chem.
Phys. 112 (2000) pp 6386-6395. In the same plot, we also include the
energy per scale computed by taking the inner product of the dipoles
divided by the distance to the third power.

EXAMPLES

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` dipoles `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` -corr `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` mol `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` -P `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate}[` 1 `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` -o `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` dip_sqr `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` -mu `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` 2.273 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` -mumax `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` 5.0 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate}

This will calculate the autocorrelation function of the molecular
dipoles using a first order Legendre polynomial of the angle of the
dipole vector and itself a time t later. For this calculation 1001
frames will be used. Further, the dielectric constant will be calculated
using an ` `{.docutils .literal .notranslate}[` -epsilonRF `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} of
infinity (default), temperature of 300 K (default) and an average dipole
moment of the molecule of 2.273 (SPC). For the distribution function a
maximum of 5.0 will be used.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -en `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.edr\>\] (ener.edr) (Optional)

:   Energy file

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (traj.xtc)

:   Trajectory:

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr\>\] (topol.tpr)

:   Portable xdr run input file

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx) (Optional)

:   Index file

Options to specify output files:

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (Mtot.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -eps `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (epsilon.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -a `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (aver.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -d `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (dipdist.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -c `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (dipcorr.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -g `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (gkr.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -adip `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (adip.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -dip3d `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (dip3d.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -cos `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (cosaver.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -cmap `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xpm\>\] (cmap.xpm) (Optional)

:   X PixMap compatible matrix file

` `{.docutils .literal .notranslate}[` -slab `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (slab.xvg) (Optional)

:   xvgr/xmgr file

Other options:

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of first frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of last frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -dt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Only use frame when t MOD dt = first time (default unit ps)

` `{.docutils .literal .notranslate}[` -[no]w `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   View output , , and files

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   xvg plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -mu `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (-1)

:   dipole of a single molecule (in Debye)

` `{.docutils .literal .notranslate}[` -mumax `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (5)

:   max dipole in Debye (for histogram)

` `{.docutils .literal .notranslate}[` -epsilonRF `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   epsilon of the reaction field used during the simulation, needed for
    dielectric constant calculation. WARNING: 0.0 means infinity
    (default)

` `{.docutils .literal .notranslate}[` -skip `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (0)

:   Skip steps in the output (but not in the computations)

` `{.docutils .literal .notranslate}[` -temp `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (300)

:   Average temperature of the simulation (needed for dielectric
    constant calculation)

` `{.docutils .literal .notranslate}[` -corr `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (none)

:   Correlation function to calculate: none, mol, molsep, total

` `{.docutils .literal .notranslate}[` -[no]pairs `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Calculate \|cos(theta)\| between all pairs of molecules. May be slow

` `{.docutils .literal .notranslate}[` -[no]quad `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Take quadrupole into account

` `{.docutils .literal .notranslate}[` -ncos `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (1)

:   Must be 1 or 2. Determines whether the \<cos(theta)\> is computed
    between all molecules in one group, or between molecules in two
    different groups. This turns on the ` `{.docutils .literal
    .notranslate}[` -g `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} flag.

` `{.docutils .literal .notranslate}[` -axis `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<string\> (Z)

:   Take the normal on the computational box in direction X, Y or Z.

` `{.docutils .literal .notranslate}[` -sl `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (10)

:   Divide the box into this number of slices.

` `{.docutils .literal .notranslate}[` -gkratom `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (0)

:   Use the n-th atom of a molecule (starting from 1) to calculate the
    distance between molecules rather than the center of charge (when 0)
    in the calculation of distance dependent Kirkwood factors

` `{.docutils .literal .notranslate}[` -gkratom2 `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (0)

:   Same as previous option in case ncos = 2, i.e. dipole interaction
    between two groups of molecules

` `{.docutils .literal .notranslate}[` -rcmax `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Maximum distance to use in the dipole orientation distribution (with
    ncos == 2). If zero, a criterion based on the box length will be
    used.

` `{.docutils .literal .notranslate}[` -[no]phi `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Plot the â€˜torsion angleâ€™ defined as the rotation of the two
    dipole vectors around the distance vector between the two molecules
    in the file from the ` `{.docutils .literal
    .notranslate}[` -cmap `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} option. By
    default the cosine of the angle between the dipoles is plotted.

` `{.docutils .literal .notranslate}[` -nlevels `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (20)

:   Number of colors in the cmap output

` `{.docutils .literal .notranslate}[` -ndegrees `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (90)

:   Number of divisions on the *y* -axis in the cmap output (for 180
    degrees)

` `{.docutils .literal .notranslate}[` -acflen `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (-1)

:   Length of the ACF, default is half the number of frames

` `{.docutils .literal .notranslate}[` -[no]normalize `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Normalize ACF

` `{.docutils .literal .notranslate}[` -P `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (0)

:   Order of Legendre polynomial for ACF (0 indicates none): 0, 1, 2, 3

` `{.docutils .literal .notranslate}[` -fitfn `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (none)

:   Fit function: none, exp, aexp, exp_exp, exp5, exp7, exp9

` `{.docutils .literal .notranslate}[` -beginfit `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Time where to begin the exponential fit of the correlation function

` `{.docutils .literal .notranslate}[` -endfit `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (-1)

:   Time where to end the exponential fit of the correlation function,
    -1 is until the end
:::
:::
::: {#gmx-disre .section}
[ ]{#id1}

# gmx disre

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx disre [-s [<.tpr>]] [-f [<.xtc/.trr/...>]] [-n [<.ndx>]]
          [-c [<.ndx>]] [-ds [<.xvg>]] [-da [<.xvg>]] [-dn [<.xvg>]]
          [-dm [<.xvg>]] [-dr [<.xvg>]] [-l [<.log>]] [-q [<.pdb>]]
          [-x [<.xpm>]] [-b <time>] [-e <time>] [-dt <time>] [-[no]w]
          [-xvg <enum>] [-ntop <int>] [-maxdr <real>]
          [-nlevels <int>] [-[no]third]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` disre `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} computes
violations of distance restraints. The program always computes the
instantaneous violations rather than time-averaged, because this
analysis is done from a trajectory file afterwards it does not make
sense to use time averaging. However, the time averaged values per
restraint are given in the log file.

An index file may be used to select specific restraints by index group
label for printing.

When the optional ` `{.docutils .literal .notranslate}[` -q `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} flag
is given a file coloured by the amount of average violations.

When the ` `{.docutils .literal .notranslate}[` -c `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} option is
given, an index file will be read containing the frames in your
trajectory corresponding to the clusters (defined in another manner)
that you want to analyze. For these clusters the program will compute
average violations using the third power averaging algorithm and print
them in the log file.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr\>\] (topol.tpr)

:   Portable xdr run input file

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (traj.xtc)

:   Trajectory:

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (viol.ndx) (Optional)

:   Index file

` `{.docutils .literal .notranslate}[` -c `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (clust.ndx) (Optional)

:   Index file

Options to specify output files:

` `{.docutils .literal .notranslate}[` -ds `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (drsum.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -da `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (draver.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -dn `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (drnum.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -dm `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (drmax.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -dr `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (restr.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -l `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.log\>\] (disres.log)

:   Log file

` `{.docutils .literal .notranslate}[` -q `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.pdb\>\] (viol.pdb) (Optional)

:   Protein data bank file

` `{.docutils .literal .notranslate}[` -x `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xpm\>\] (matrix.xpm) (Optional)

:   X PixMap compatible matrix file

Other options:

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of first frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of last frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -dt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Only use frame when t MOD dt = first time (default unit ps)

` `{.docutils .literal .notranslate}[` -[no]w `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   View output , , and files

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   xvg plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -ntop `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (0)

:   Number of large violations that are stored in the log file every
    step

` `{.docutils .literal .notranslate}[` -maxdr `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Maximum distance violation in matrix output. If less than or equal
    to 0 the maximum will be determined by the data.

` `{.docutils .literal .notranslate}[` -nlevels `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (20)

:   Number of levels in the matrix output

` `{.docutils .literal .notranslate}[` -[no]third `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Use inverse third power averaging or linear for matrix output
:::
:::
::: {#gmx-distance .section}
[ ]{#id1}

# gmx distance

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx distance [-f [<.xtc/.trr/...>]] [-s [<.tpr/.gro/...>]] [-n [<.ndx>]]
             [-oav [<.xvg>]] [-oall [<.xvg>]] [-oxyz [<.xvg>]]
             [-oh [<.xvg>]] [-oallstat [<.xvg>]] [-b <time>]
             [-e <time>] [-dt <time>] [-tu <enum>]
             [-fgroup <selection>] [-xvg <enum>] [-[no]rmpbc]
             [-[no]pbc] [-sf <file>] [-selrpos <enum>]
             [-seltype <enum>] [-select <selection>] [-len <real>]
             [-tol <real>] [-binw <real>]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` distance `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} calculates
distances between pairs of positions as a function of time. Each
selection specifies an independent set of distances to calculate. Each
selection should consist of pairs of positions, and the distances are
computed between positions 1-2, 3-4, etc.

` `{.docutils .literal .notranslate}[` -oav `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} writes the
average distance as a function of time for each selection. ` `{.docutils
.literal .notranslate}[` -oall `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} writes all the
individual distances. ` `{.docutils .literal
.notranslate}[` -oxyz `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} does the same,
but the x, y, and z components of the distance are written instead of
the norm. ` `{.docutils .literal .notranslate}[` -oh `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} writes
a histogram of the distances for each selection. The location of the
histogram is set with ` `{.docutils .literal
.notranslate}[` -len `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` -tol `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . Bin width is
set with ` `{.docutils .literal .notranslate}[` -binw `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} .
` `{.docutils .literal .notranslate}[` -oallstat `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} writes out the
average and standard deviation for each individual distance, calculated
over the frames.

Note that ` `{.docutils .literal .notranslate}[` gmx `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` distance `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} calculates
distances between fixed pairs (1-2, 3-4, etc.) within a single
selection. To calculate distances between two selections, including
minimum, maximum, and pairwise distances, use .
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (traj.xtc) (Optional)

:   Input trajectory or single configuration:

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr/.gro/â€¦\>\] (topol.tpr) (Optional)

:   Input structure: brk ent

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx) (Optional)

:   Extra index groups

Options to specify output files:

` `{.docutils .literal .notranslate}[` -oav `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (distave.xvg) (Optional)

:   Average distances as function of time

` `{.docutils .literal .notranslate}[` -oall `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (dist.xvg) (Optional)

:   All distances as function of time

` `{.docutils .literal .notranslate}[` -oxyz `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (distxyz.xvg) (Optional)

:   Distance components as function of time

` `{.docutils .literal .notranslate}[` -oh `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (disthist.xvg) (Optional)

:   Histogram of the distances

` `{.docutils .literal .notranslate}[` -oallstat `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (diststat.xvg) (Optional)

:   Statistics for individual distances

Other options:

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   First frame (ps) to read from trajectory

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Last frame (ps) to read from trajectory

` `{.docutils .literal .notranslate}[` -dt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Only use frame if t MOD dt == first time (ps)

` `{.docutils .literal .notranslate}[` -tu `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (ps)

:   Unit for time values: fs, ps, ns, us, ms, s

` `{.docutils .literal .notranslate}[` -fgroup `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<selection\>

:   Atoms stored in the trajectory file (if not set, assume first N
    atoms)

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   Plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -[no]rmpbc `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Make molecules whole for each frame

` `{.docutils .literal .notranslate}[` -[no]pbc `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Use periodic boundary conditions for distance calculation

` `{.docutils .literal .notranslate}[` -sf `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<file\>

:   Provide selections from files

` `{.docutils .literal .notranslate}[` -selrpos `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (atom)

:   Selection reference positions: atom, res_com, res_cog, mol_com,
    mol_cog, whole_res_com, whole_res_cog, whole_mol_com, whole_mol_cog,
    part_res_com, part_res_cog, part_mol_com, part_mol_cog, dyn_res_com,
    dyn_res_cog, dyn_mol_com, dyn_mol_cog

` `{.docutils .literal .notranslate}[` -seltype `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (atom)

:   Default selection output positions: atom, res_com, res_cog, mol_com,
    mol_cog, whole_res_com, whole_res_cog, whole_mol_com, whole_mol_cog,
    part_res_com, part_res_cog, part_mol_com, part_mol_cog, dyn_res_com,
    dyn_res_cog, dyn_mol_com, dyn_mol_cog

` `{.docutils .literal .notranslate}[` -select `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<selection\>

:   Position pairs to calculate distances for

` `{.docutils .literal .notranslate}[` -len `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0.1)

:   Mean distance for histogramming

` `{.docutils .literal .notranslate}[` -tol `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (1)

:   Width of full distribution as fraction of ` `{.docutils .literal
    .notranslate}[` -len `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate}

` `{.docutils .literal .notranslate}[` -binw `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0.001)

:   Bin width for histogramming
:::
:::
::: {#gmx-dos .section}
[ ]{#id1}

# gmx dos

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx dos [-f [<.trr/.cpt/...>]] [-s [<.tpr>]] [-n [<.ndx>]]
        [-vacf [<.xvg>]] [-mvacf [<.xvg>]] [-dos [<.xvg>]]
        [-g [<.log>]] [-b <time>] [-e <time>] [-dt <time>] [-[no]w]
        [-xvg <enum>] [-[no]v] [-[no]recip] [-[no]abs] [-[no]normdos]
        [-T <real>] [-acflen <int>] [-[no]normalize] [-P <enum>]
        [-fitfn <enum>] [-beginfit <real>] [-endfit <real>]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` dos `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} computes the
Density of States from a simulations. In order for this to be meaningful
the velocities must be saved in the trajecotry with sufficiently high
frequency such as to cover all vibrations. For flexible systems that
would be around a few fs between saving. Properties based on the DoS are
printed on the standard output. Note that the density of states is
calculated from the mass-weighted autocorrelation, and by default only
from the square of the real component rather than absolute value. This
means the shape can differ substantially from the plain vibrational
power spectrum you can calculate with gmx velacc.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.trr/.cpt/â€¦\>\] (traj.trr)

:   Full precision trajectory:

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr\>\] (topol.tpr)

:   Portable xdr run input file

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx) (Optional)

:   Index file

Options to specify output files:

` `{.docutils .literal .notranslate}[` -vacf `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (vacf.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -mvacf `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (mvacf.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -dos `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (dos.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -g `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.log\>\] (dos.log)

:   Log file

Other options:

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of first frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of last frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -dt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Only use frame when t MOD dt = first time (default unit ps)

` `{.docutils .literal .notranslate}[` -[no]w `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   View output , , and files

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   xvg plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -[no]v `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Be loud and noisy.

` `{.docutils .literal .notranslate}[` -[no]recip `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Use cm\^-1 on X-axis instead of 1/ps for DoS plots.

` `{.docutils .literal .notranslate}[` -[no]abs `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Use the absolute value of the Fourier transform of the VACF as the
    Density of States. Default is to use the real component only

` `{.docutils .literal .notranslate}[` -[no]normdos `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Normalize the DoS such that it adds up to 3N. This should usually
    not be necessary.

` `{.docutils .literal .notranslate}[` -T `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (298.15)

:   Temperature in the simulation

` `{.docutils .literal .notranslate}[` -acflen `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (-1)

:   Length of the ACF, default is half the number of frames

` `{.docutils .literal .notranslate}[` -[no]normalize `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Normalize ACF

` `{.docutils .literal .notranslate}[` -P `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (0)

:   Order of Legendre polynomial for ACF (0 indicates none): 0, 1, 2, 3

` `{.docutils .literal .notranslate}[` -fitfn `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (none)

:   Fit function: none, exp, aexp, exp_exp, exp5, exp7, exp9

` `{.docutils .literal .notranslate}[` -beginfit `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Time where to begin the exponential fit of the correlation function

` `{.docutils .literal .notranslate}[` -endfit `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (-1)

:   Time where to end the exponential fit of the correlation function,
    -1 is until the end
:::

::: {#known-issues .section}
## Known Issues

-   This program needs a lot of memory: total usage equals the number of
    atoms times 3 times number of frames times 4 (or 8 when run in
    double precision).
:::
:::
::: {#gmx-dssp .section}
[ ]{#id1}

# gmx dssp

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx dssp [-f [<.xtc/.trr/...>]] [-s [<.tpr/.gro/...>]] [-n [<.ndx>]]
         [-o [<.dat>]] [-num [<.xvg>]] [-b <time>] [-e <time>]
         [-dt <time>] [-tu <enum>] [-fgroup <selection>]
         [-xvg <enum>] [-[no]rmpbc] [-[no]pbc] [-sf <file>]
         [-selrpos <enum>] [-seltype <enum>] [-sel <selection>]
         [-hmode <enum>] [-hbond <enum>] [-[no]nb] [-cutoff <real>]
         [-[no]clear] [-[no]pihelix] [-ppstretch <enum>]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` dssp `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} allows using
the DSSP algorithm (namely, by detecting specific patterns of hydrogen
bonds between amino acid residues) to determine the secondary structure
of a protein.

One-symbol secondary structure designations that are used in the output
file:

` `{.docutils .literal .notranslate}[` H `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} â€"
alpha-helix;

` `{.docutils .literal .notranslate}[` B `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} â€" residue in
isolated beta-bridge;

` `{.docutils .literal .notranslate}[` E `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} â€" extended
strand that participates in beta-ladder;

` `{.docutils .literal .notranslate}[` G `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} â€" 3_10-helix;

` `{.docutils .literal .notranslate}[` I `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} â€" pi-helix;

` `{.docutils .literal .notranslate}[` P `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} â€" kappa-helix
(poly-proline II helix);

` `{.docutils .literal .notranslate}[` S `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} â€" bend;

` `{.docutils .literal .notranslate}[` T `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} â€"
hydrogen-bonded turn;

` `{.docutils .literal .notranslate}[` = `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} â€" break;

` `{.docutils .literal .notranslate}[` ~ `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} â€" loop (no
special secondary structure designation).

` `{.docutils .literal .notranslate}[` -num `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} allows you to
get a plot of the number of secondary structures of each type as a
function of time at the output.

` `{.docutils .literal .notranslate}[` -hmode `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} selects between
using hydrogen atoms directly from the structure (â€œgromacsâ€? option)
and using hydrogen pseudo-atoms based on C and O atom coordinates of
previous residue (â€œdsspâ€? option). You should always use the
â€œdsspâ€? option for structures with absent hydrogen atoms!

` `{.docutils .literal .notranslate}[` -hbond `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} selects between
different definitions of hydrogen bond. â€œenergyâ€? means the
calculation of a hydrogen bond using the electrostatic interaction
energy and â€œgeometryâ€? means the calculation of the hydrogen bond
using geometric criterion for the existence of a hydrogen bond.

` `{.docutils .literal .notranslate}[` -nb `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} allows using
GROMACS neighbor-search method to find residue pairs that may have a
hydrogen bond instead of simply iterating over the residues among
themselves.

` `{.docutils .literal .notranslate}[` -cutoff `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} is a real value
that defines maximum distance from residue to its neighbor residue used
in ` `{.docutils .literal .notranslate}[` -nb `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . Minimum (and
also recommended) value is 0.9.

` `{.docutils .literal .notranslate}[` -clear `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} allows you to
ignore the analysis of the secondary structure residues that are missing
one or more critical atoms (CA, C, N, O or H). Always use this option
together with ` `{.docutils .literal .notranslate}[` -hmode `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` dssp `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} for structures
that lack hydrogen atoms!

` `{.docutils .literal .notranslate}[` -pihelix `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} changes
pattern-search algorithm towards preference of pi-helices.

` `{.docutils .literal .notranslate}[` -ppstretch `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} defines stretch
value of polyproline-helices. â€œshortenedâ€? means stretch with size 2
and â€œdefaultâ€? means stretch with size 3.

Note that ` `{.docutils .literal .notranslate}[` gmx `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` dssp `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} currently is
not capable of reproducing the secondary structure of proteins whose
structure is determined by methods other than X-ray crystallography
(structures in .pdb format with incorrect values in the CRYST1 line) due
to the incorrect cell size in such structures.

Please note that the computation is always done in single precision,
regardless of the precision for which GROMACS was configured.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (traj.xtc) (Optional)

:   Input trajectory or single configuration:

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr/.gro/â€¦\>\] (topol.tpr) (Optional)

:   Input structure: brk ent

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx) (Optional)

:   Extra index groups

Options to specify output files:

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.dat\>\] (dssp.dat)

:   Filename for DSSP output

` `{.docutils .literal .notranslate}[` -num `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (num.xvg) (Optional)

:   Output file name for secondary structures statistics for the
    trajectory

Other options:

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   First frame (ps) to read from trajectory

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Last frame (ps) to read from trajectory

` `{.docutils .literal .notranslate}[` -dt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Only use frame if t MOD dt == first time (ps)

` `{.docutils .literal .notranslate}[` -tu `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (ps)

:   Unit for time values: fs, ps, ns, us, ms, s

` `{.docutils .literal .notranslate}[` -fgroup `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<selection\>

:   Atoms stored in the trajectory file (if not set, assume first N
    atoms)

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   Plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -[no]rmpbc `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Make molecules whole for each frame

` `{.docutils .literal .notranslate}[` -[no]pbc `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Use periodic boundary conditions for distance calculation

` `{.docutils .literal .notranslate}[` -sf `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<file\>

:   Provide selections from files

` `{.docutils .literal .notranslate}[` -selrpos `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (atom)

:   Selection reference positions: atom, res_com, res_cog, mol_com,
    mol_cog, whole_res_com, whole_res_cog, whole_mol_com, whole_mol_cog,
    part_res_com, part_res_cog, part_mol_com, part_mol_cog, dyn_res_com,
    dyn_res_cog, dyn_mol_com, dyn_mol_cog

` `{.docutils .literal .notranslate}[` -seltype `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (atom)

:   Default selection output positions: atom, res_com, res_cog, mol_com,
    mol_cog, whole_res_com, whole_res_cog, whole_mol_com, whole_mol_cog,
    part_res_com, part_res_cog, part_mol_com, part_mol_cog, dyn_res_com,
    dyn_res_cog, dyn_mol_com, dyn_mol_cog

` `{.docutils .literal .notranslate}[` -sel `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<selection\>

:   Group for DSSP

` `{.docutils .literal .notranslate}[` -hmode `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (gromacs)

:   Hydrogens pseudoatoms creating mode: gromacs, dssp

` `{.docutils .literal .notranslate}[` -hbond `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (energy)

:   Selects between different definitions of hydrogen bond: energy,
    geometry

` `{.docutils .literal .notranslate}[` -[no]nb `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Use GROMACS neighbor-search method

` `{.docutils .literal .notranslate}[` -cutoff `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0.9)

:   Distance from residue to its neighbor residue in neighbor search.
    Must be \>= 0.9

` `{.docutils .literal .notranslate}[` -[no]clear `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Clear defective residues from the structure

` `{.docutils .literal .notranslate}[` -[no]pihelix `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Prefer Pi Helices

` `{.docutils .literal .notranslate}[` -ppstretch `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (default)

:   Stretch value for PP-helices: shortened, default
:::
:::
::: {#gmx-dump .section}
[ ]{#id1}

# gmx dump

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx dump [-s <.tpr>] [-f <.xtc/.trr/...>] [-e <.edr>] [-cp <.cpt>]
         [-p <.top>] [-mtx <.mtx>] [-om <.mdp>] [-[no]nr]
         [-[no]param] [-[no]sys] [-[no]orgir]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` dump `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} reads a run
input file ( ), a trajectory ( / / ` `{.docutils .literal
.notranslate}[` tng `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ), an energy
file ( ), a checkpoint file ( ) or topology file ( ) and prints that to
standard output in a readable format. This program is essential for
checking your run input file in case of problems.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<.tpr\> (Optional)

:   Run input file to dump

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<.xtc/.trr/â€¦\> (Optional)

:   Trajectory file to dump:

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<.edr\> (Optional)

:   Energy file to dump

` `{.docutils .literal .notranslate}[` -cp `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<.cpt\> (Optional)

:   Checkpoint file to dump

` `{.docutils .literal .notranslate}[` -p `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<.top\> (Optional)

:   Topology file to dump

` `{.docutils .literal .notranslate}[` -mtx `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<.mtx\> (Optional)

:   Hessian matrix to dump

Options to specify output files:

` `{.docutils .literal .notranslate}[` -om `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<.mdp\> (Optional)

:   grompp input file from run input file

Other options:

` `{.docutils .literal .notranslate}[` -[no]nr `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Show index numbers in output (leaving them out makes comparison
    easier, but creates a useless topology)

` `{.docutils .literal .notranslate}[` -[no]param `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Show parameters for each bonded interaction (for comparing dumps, it
    is useful to combine this with -nonr)

` `{.docutils .literal .notranslate}[` -[no]sys `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   List the atoms and bonded interactions for the whole system instead
    of for each molecule type

` `{.docutils .literal .notranslate}[` -[no]orgir `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Show input parameters from tpr as they were written by the version
    that produced the file, instead of how the current version reads
    them
:::

::: {#known-issues .section}
## Known Issues

-   The file produced by ` `{.docutils .literal
    .notranslate}[` -om `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} can not be
    read by grompp.
:::
:::
::: {#gmx-dyecoupl .section}
[ ]{#id1}

# gmx dyecoupl

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx dyecoupl [-f [<.xtc/.trr/...>]] [-n [<.ndx>]] [-ot [<.xvg>]]
             [-oe [<.xvg>]] [-o [<.dat>]] [-rhist [<.xvg>]]
             [-khist [<.xvg>]] [-b <time>] [-e <time>] [-tu <enum>]
             [-[no]w] [-xvg <enum>] [-[no]pbcdist] [-[no]norm]
             [-bins <int>] [-R0 <real>]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` dyecoupl `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} extracts dye
dynamics from trajectory files. Currently, R and kappa\^2 between dyes
is extracted for (F)RET simulations with assumed dipolar coupling as in
the Foerster equation. It further allows the calculation of R(t) and
kappa\^2(t), R and kappa\^2 histograms and averages, as well as the
instantaneous FRET efficiency E(t) for a specified Foerster radius R_0
(switch ` `{.docutils .literal .notranslate}[` -R0 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ). The input
dyes have to be whole (see res and mol pbc options in ` `{.docutils
.literal .notranslate}[` trjconv `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ). The dye
transition dipole moment has to be defined by at least a single atom
pair, however multiple atom pairs can be provided in the index file. The
distance R is calculated on the basis of the COMs of the given atom
pairs. The ` `{.docutils .literal .notranslate}[` -pbcdist `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} option
calculates distances to the nearest periodic image instead to the
distance in the box. This works however only, for periodic boundaries in
all 3 dimensions. The ` `{.docutils .literal
.notranslate}[` -norm `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} option (area-)
normalizes the histograms.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (traj.xtc)

:   Trajectory:

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx)

:   Index file

Options to specify output files:

` `{.docutils .literal .notranslate}[` -ot `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (rkappa.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -oe `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (insteff.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.dat\>\] (rkappa.dat) (Optional)

:   Generic data file

` `{.docutils .literal .notranslate}[` -rhist `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (rhist.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -khist `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (khist.xvg) (Optional)

:   xvgr/xmgr file

Other options:

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of first frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of last frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -tu `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (ps)

:   Unit for time values: fs, ps, ns, us, ms, s

` `{.docutils .literal .notranslate}[` -[no]w `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   View output , , and files

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   xvg plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -[no]pbcdist `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Distance R based on PBC

` `{.docutils .literal .notranslate}[` -[no]norm `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Normalize histograms

` `{.docutils .literal .notranslate}[` -bins `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (50)

:   \# of histogram bins

` `{.docutils .literal .notranslate}[` -R0 `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (-1)

:   Foerster radius including kappa\^2=2/3 in nm
:::
:::
::: {#gmx-editconf .section}
[ ]{#id1}

# gmx editconf

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx editconf [-f [<.gro/.g96/...>]] [-n [<.ndx>]] [-bf [<.dat>]]
             [-o [<.gro/.g96/...>]] [-mead [<.pqr>]] [-[no]w]
             [-[no]ndef] [-bt <enum>] [-box <vector>]
             [-angles <vector>] [-d <real>] [-[no]c]
             [-center <vector>] [-aligncenter <vector>]
             [-align <vector>] [-translate <vector>]
             [-rotate <vector>] [-[no]princ] [-scale <vector>]
             [-density <real>] [-[no]pbc] [-resnr <int>] [-[no]grasp]
             [-rvdw <real>] [-[no]sig56] [-[no]vdwread] [-[no]atom]
             [-[no]legend] [-label <string>] [-[no]conect]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` editconf `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} converts
generic structure format to , ` `{.docutils .literal
.notranslate}[` .g96 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} or .

The box can be modified with options ` `{.docutils .literal
.notranslate}[` -box `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , ` `{.docutils
.literal .notranslate}[` -d `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` -angles `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . Both
` `{.docutils .literal .notranslate}[` -box `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` -d `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} will center the
system in the box, unless ` `{.docutils .literal
.notranslate}[` -noc `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} is used. The
` `{.docutils .literal .notranslate}[` -center `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} option can be
used to shift the geometric center of the system from the default of
(x/2, y/2, z/2) implied by ` `{.docutils .literal
.notranslate}[` -c `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} to some other
value.

Option ` `{.docutils .literal .notranslate}[` -bt `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} determines the
box type: ` `{.docutils .literal .notranslate}[` triclinic `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} is a
triclinic box, ` `{.docutils .literal .notranslate}[` cubic `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} is a
rectangular box with all sides equal ` `{.docutils .literal
.notranslate}[` dodecahedron `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} represents a
rhombic dodecahedron and ` `{.docutils .literal
.notranslate}[` octahedron `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} is a truncated
octahedron. The last two are special cases of a triclinic box. The
length of the three box vectors of the truncated octahedron is the
shortest distance between two opposite hexagons. Relative to a cubic box
with some periodic image distance, the volume of a dodecahedron with
this same periodic distance is 0.71 times that of the cube, and that of
a truncated octahedron is 0.77 times.

Option ` `{.docutils .literal .notranslate}[` -box `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} requires only
one value for a cubic, rhombic dodecahedral, or truncated octahedral
box.

With ` `{.docutils .literal .notranslate}[` -d `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and a
` `{.docutils .literal .notranslate}[` triclinic `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} box the size of
the system in the *x* -, *y* -, and *z* -directions is used. With
` `{.docutils .literal .notranslate}[` -d `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` cubic `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , ` `{.docutils
.literal .notranslate}[` dodecahedron `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} or
` `{.docutils .literal .notranslate}[` octahedron `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} boxes, the
dimensions are set to the diameter of the system (largest distance
between atoms) plus twice the specified distance.

Option ` `{.docutils .literal .notranslate}[` -angles `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} is
only meaningful with option ` `{.docutils .literal
.notranslate}[` -box `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and a triclinic
box and cannot be used with option ` `{.docutils .literal
.notranslate}[` -d `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} .

When ` `{.docutils .literal .notranslate}[` -n `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} or
` `{.docutils .literal .notranslate}[` -ndef `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} is set, a group
can be selected for calculating the size and the geometric center,
otherwise the whole system is used.

` `{.docutils .literal .notranslate}[` -rotate `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} rotates the
coordinates and velocities.

` `{.docutils .literal .notranslate}[` -princ `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} aligns the
principal axes of the system along the coordinate axes, with the longest
axis aligned with the *x* -axis. This may allow you to decrease the box
volume, but beware that molecules can rotate significantly in a
nanosecond.

Scaling is applied before any of the other operations are performed.
Boxes and coordinates can be scaled to give a certain density (option
` `{.docutils .literal .notranslate}[` -density `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ). Note that
this may be inaccurate in case a file is given as input. A special
feature of the scaling option is that when the factor -1 is given in one
dimension, one obtains a mirror image, mirrored in one of the planes.
When one uses -1 in three dimensions, a point-mirror image is obtained.

Groups are selected after all operations have been applied.

Periodicity can be removed in a crude manner. It is important that the
box vectors at the bottom of your input file are correct when the
periodicity is to be removed.

When writing files, B-factors can be added with the ` `{.docutils
.literal .notranslate}[` -bf `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} option.
B-factors are read from a file with with following format: first line
states number of entries in the file, next lines state an index followed
by a B-factor. The B-factors will be attached per residue unless the
number of B-factors is larger than the number of the residues or unless
the ` `{.docutils .literal .notranslate}[` -atom `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} option is set.
Obviously, any type of numeric data can be added instead of B-factors.
` `{.docutils .literal .notranslate}[` -legend `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} will produce a
row of CA atoms with B-factors ranging from the minimum to the maximum
value found, effectively making a legend for viewing.

With the option ` `{.docutils .literal .notranslate}[` -mead `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} a
special (.pqr) file for the MEAD electrostatics program
(Poisson-Boltzmann solver) can be made. A further prerequisite is that
the input file is a run input file. The B-factor field is then filled
with the Van der Waals radius of the atoms while the occupancy field
will hold the charge.

The option ` `{.docutils .literal .notranslate}[` -grasp `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} is
similar, but it puts the charges in the B-factor and the radius in the
occupancy.

Option ` `{.docutils .literal .notranslate}[` -align `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} allows
alignment of the principal axis of a specified group against the given
vector, with an optional center of rotation specified by ` `{.docutils
.literal .notranslate}[` -aligncenter `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} .

Finally, with option ` `{.docutils .literal
.notranslate}[` -label `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , ` `{.docutils
.literal .notranslate}[` editconf `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} can add a chain
identifier to a file, which can be useful for analysis with e.g. Rasmol.

To convert a truncated octrahedron file produced by a package which uses
a cubic box with the corners cut off (such as GROMOS), use:

::: {.highlight-default .notranslate}
::: highlight
    gmx editconf -f in -rotate 0 45 35.264 -bt o -box veclen -o out
:::
:::

where ` `{.docutils .literal .notranslate}[` veclen `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} is the size of
the cubic box times sqrt(3)/2.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.gro/.g96/â€¦\>\] (conf.gro)

:   Structure file: brk ent esp

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx) (Optional)

:   Index file

` `{.docutils .literal .notranslate}[` -bf `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.dat\>\] (bfact.dat) (Optional)

:   Generic data file

Options to specify output files:

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.gro/.g96/â€¦\>\] (out.gro) (Optional)

:   Structure file: brk ent esp

` `{.docutils .literal .notranslate}[` -mead `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.pqr\>\] (mead.pqr) (Optional)

:   Coordinate file for MEAD

Other options:

` `{.docutils .literal .notranslate}[` -[no]w `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   View output , , and files

` `{.docutils .literal .notranslate}[` -[no]ndef `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Choose output from default index groups

` `{.docutils .literal .notranslate}[` -bt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (triclinic)

:   Box type for ` `{.docutils .literal .notranslate}[` -box `{.docutils
    .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}
    and ` `{.docutils .literal .notranslate}[` -d `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} :
    triclinic, cubic, dodecahedron, octahedron

` `{.docutils .literal .notranslate}[` -box `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<vector\> (0 0 0)

:   Box vector lengths (a,b,c)

` `{.docutils .literal .notranslate}[` -angles `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<vector\> (90 90 90)

:   Angles between the box vectors (bc,ac,ab)

` `{.docutils .literal .notranslate}[` -d `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Distance between the solute and the box

` `{.docutils .literal .notranslate}[` -[no]c `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Center molecule in box (implied by ` `{.docutils .literal
    .notranslate}[` -box `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} and
    ` `{.docutils .literal .notranslate}[` -d `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} )

` `{.docutils .literal .notranslate}[` -center `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<vector\> (0 0 0)

:   Shift the geometrical center to (x,y,z)

` `{.docutils .literal .notranslate}[` -aligncenter `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<vector\> (0 0 0)

:   Center of rotation for alignment

` `{.docutils .literal .notranslate}[` -align `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<vector\> (0 0 0)

:   Align to target vector

` `{.docutils .literal .notranslate}[` -translate `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<vector\> (0 0 0)

:   Translation

` `{.docutils .literal .notranslate}[` -rotate `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<vector\> (0 0 0)

:   Rotation around the X, Y and Z axes in degrees

` `{.docutils .literal .notranslate}[` -[no]princ `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Orient molecule(s) along their principal axes

` `{.docutils .literal .notranslate}[` -scale `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<vector\> (1 1 1)

:   Scaling factor

` `{.docutils .literal .notranslate}[` -density `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (1000)

:   Density (g/L) of the output box achieved by scaling

` `{.docutils .literal .notranslate}[` -[no]pbc `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Remove the periodicity (make molecule whole again)

` `{.docutils .literal .notranslate}[` -resnr `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (-1)

:   Renumber residues starting from resnr

` `{.docutils .literal .notranslate}[` -[no]grasp `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Store the charge of the atom in the B-factor field and the radius of
    the atom in the occupancy field

` `{.docutils .literal .notranslate}[` -rvdw `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0.12)

:   Default Van der Waals radius (in nm) if one can not be found in the
    database or if no parameters are present in the topology file

` `{.docutils .literal .notranslate}[` -[no]sig56 `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Use rmin/2 (minimum in the Van der Waals potential) rather than
    sigma/2

` `{.docutils .literal .notranslate}[` -[no]vdwread `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Read the Van der Waals radii from the file ` `{.docutils .literal
    .notranslate}[` vdwradii.dat `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} rather than
    computing the radii based on the force field

` `{.docutils .literal .notranslate}[` -[no]atom `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Force B-factor attachment per atom

` `{.docutils .literal .notranslate}[` -[no]legend `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Make B-factor legend

` `{.docutils .literal .notranslate}[` -label `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<string\> (A)

:   Add chain label for all residues

` `{.docutils .literal .notranslate}[` -[no]conect `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Add CONECT records to a file when written. Can only be done when a
    topology is present
:::

::: {#known-issues .section}
## Known Issues

-   For complex molecules, the periodicity removal routine may break
    down,

-   in that case you can use .
:::
:::
::: {#gmx-eneconv .section}
[ ]{#id1}

# gmx eneconv

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx eneconv [-f [<.edr> [...]]] [-o [<.edr>]] [-b <real>] [-e <real>]
            [-dt <real>] [-offset <real>] [-[no]settime] [-[no]sort]
            [-[no]rmdh] [-scalefac <real>] [-[no]error]
```
:::

::: {#description .section}
## Description

With *multiple files* specified for the ` `{.docutils .literal
.notranslate}[` -f `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} option:

Concatenates several energy files in sorted order. In the case of double
time frames, the one in the later file is used. By specifying
` `{.docutils .literal .notranslate}[` -settime `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} you will be
asked for the start time of each file. The input files are taken from
the command line, such that the command ` `{.docutils .literal
.notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` eneconv `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` -f `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` *.edr `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` -o `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` fixed.edr `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} should do the
trick.

With *one file* specified for ` `{.docutils .literal
.notranslate}[` -f `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} :

Reads one energy file and writes another, applying the ` `{.docutils
.literal .notranslate}[` -dt `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , ` `{.docutils
.literal .notranslate}[` -offset `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , ` `{.docutils
.literal .notranslate}[` -t0 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` -settime `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} options and
converting to a different format if necessary (indicated by file
extensions).

` `{.docutils .literal .notranslate}[` -settime `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} is applied
first, then ` `{.docutils .literal .notranslate}[` -dt `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} /
` `{.docutils .literal .notranslate}[` -offset `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} followed by
` `{.docutils .literal .notranslate}[` -b `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` -e `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} to select which
frames to write.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.edr\> \[â€¦\]\] (ener.edr)

:   Energy file

Options to specify output files:

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.edr\>\] (fixed.edr)

:   Energy file

Other options:

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (-1)

:   First time to use

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (-1)

:   Last time to use

` `{.docutils .literal .notranslate}[` -dt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Only write out frame when t MOD dt = offset

` `{.docutils .literal .notranslate}[` -offset `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Time offset for ` `{.docutils .literal
    .notranslate}[` -dt `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} option

` `{.docutils .literal .notranslate}[` -[no]settime `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Change starting time interactively

` `{.docutils .literal .notranslate}[` -[no]sort `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Sort energy files (not frames)

` `{.docutils .literal .notranslate}[` -[no]rmdh `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Remove free energy block data

` `{.docutils .literal .notranslate}[` -scalefac `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (1)

:   Multiply energy component by this factor

` `{.docutils .literal .notranslate}[` -[no]error `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Stop on errors in the file
:::

::: {#known-issues .section}
## Known Issues

-   When combining trajectories the sigma and E\^2 (necessary for
    statistics) are not updated correctly. Only the actual energy is
    correct. One thus has to compute statistics in another way.
:::
:::
::: {#gmx-enemat .section}
[ ]{#id1}

# gmx enemat

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx enemat [-f [<.edr>]] [-groups [<.dat>]] [-eref [<.dat>]]
           [-emat [<.xpm>]] [-etot [<.xvg>]] [-b <time>] [-e <time>]
           [-dt <time>] [-[no]w] [-xvg <enum>] [-[no]sum]
           [-skip <int>] [-[no]mean] [-nlevels <int>] [-max <real>]
           [-min <real>] [-[no]coulsr] [-[no]coul14] [-[no]ljsr]
           [-[no]lj14] [-[no]bhamsr] [-[no]free] [-temp <real>]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` enemat `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} extracts an
energy matrix from the energy file ( ` `{.docutils .literal
.notranslate}[` -f `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ). With
` `{.docutils .literal .notranslate}[` -groups `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} a file must be
supplied with on each line a group of atoms to be used. For these groups
matrix of interaction energies will be extracted from the energy file by
looking for energy groups with names corresponding to pairs of groups of
atoms, e.g. if your ` `{.docutils .literal
.notranslate}[` -groups `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} file contains:

::: {.highlight-default .notranslate}
::: highlight
    2
    Protein
    SOL
:::
:::

then energy groups with names like â€˜Coul-SR:Protein-SOLâ€™ and
â€˜LJ:Protein-SOLâ€™ are expected in the energy file (although
` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` enemat `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} is most useful
if many groups are analyzed simultaneously). Matrices for different
energy types are written out separately, as controlled by the
` `{.docutils .literal .notranslate}[` -[no]coul `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , ` `{.docutils
.literal .notranslate}[` -[no]coulr `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , ` `{.docutils
.literal .notranslate}[` -[no]coul14 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , ` `{.docutils
.literal .notranslate}[` -[no]lj `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , ` `{.docutils
.literal .notranslate}[` -[no]lj14 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , ` `{.docutils
.literal .notranslate}[` -[no]bham `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` -[no]free `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} options.
Finally, the total interaction energy energy per group can be calculated
( ` `{.docutils .literal .notranslate}[` -etot `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ).

An approximation of the free energy can be calculated using: E_free =
E_0 + kT log(\<exp((E-E_0)/kT)\>), where â€˜\<\>â€™ stands for
time-average. A file with reference free energies can be supplied to
calculate the free energy difference with some reference state. Group
names (e.g. residue names) in the reference file should correspond to
the group names as used in the ` `{.docutils .literal
.notranslate}[` -groups `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} file, but a
appended number (e.g. residue number) in the ` `{.docutils .literal
.notranslate}[` -groups `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} will be ignored
in the comparison.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.edr\>\] (ener.edr) (Optional)

:   Energy file

` `{.docutils .literal .notranslate}[` -groups `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.dat\>\] (groups.dat)

:   Generic data file

` `{.docutils .literal .notranslate}[` -eref `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.dat\>\] (eref.dat) (Optional)

:   Generic data file

Options to specify output files:

` `{.docutils .literal .notranslate}[` -emat `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xpm\>\] (emat.xpm)

:   X PixMap compatible matrix file

` `{.docutils .literal .notranslate}[` -etot `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (energy.xvg)

:   xvgr/xmgr file

Other options:

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of first frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of last frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -dt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Only use frame when t MOD dt = first time (default unit ps)

` `{.docutils .literal .notranslate}[` -[no]w `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   View output , , and files

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   xvg plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -[no]sum `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Sum the energy terms selected rather than display them all

` `{.docutils .literal .notranslate}[` -skip `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (0)

:   Skip number of frames between data points

` `{.docutils .literal .notranslate}[` -[no]mean `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   with ` `{.docutils .literal .notranslate}[` -groups `{.docutils
    .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}
    extracts matrix of mean energies instead of matrix for each timestep

` `{.docutils .literal .notranslate}[` -nlevels `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (20)

:   number of levels for matrix colors

` `{.docutils .literal .notranslate}[` -max `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (1e+20)

:   max value for energies

` `{.docutils .literal .notranslate}[` -min `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (-1e+20)

:   min value for energies

` `{.docutils .literal .notranslate}[` -[no]coulsr `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   extract Coulomb SR energies

` `{.docutils .literal .notranslate}[` -[no]coul14 `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   extract Coulomb 1-4 energies

` `{.docutils .literal .notranslate}[` -[no]ljsr `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   extract Lennard-Jones SR energies

` `{.docutils .literal .notranslate}[` -[no]lj14 `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   extract Lennard-Jones 1-4 energies

` `{.docutils .literal .notranslate}[` -[no]bhamsr `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   extract Buckingham SR energies

` `{.docutils .literal .notranslate}[` -[no]free `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   calculate free energy

` `{.docutils .literal .notranslate}[` -temp `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (300)

:   reference temperature for free energy calculation
:::
:::
::: {#gmx-energy .section}
[ ]{#id1}

# gmx energy

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx energy [-f [<.edr>]] [-f2 [<.edr>]] [-s [<.tpr>]] [-o [<.xvg>]]
           [-viol [<.xvg>]] [-pairs [<.xvg>]] [-corr [<.xvg>]]
           [-vis [<.xvg>]] [-evisco [<.xvg>]] [-eviscoi [<.xvg>]]
           [-ravg [<.xvg>]] [-odh [<.xvg>]] [-b <time>] [-e <time>]
           [-[no]w] [-xvg <enum>] [-[no]fee] [-fetemp <real>]
           [-zero <real>] [-[no]sum] [-[no]dp] [-nbmin <int>]
           [-nbmax <int>] [-[no]mutot] [-[no]aver] [-nmol <int>]
           [-[no]fluct_props] [-[no]driftcorr] [-[no]fluc]
           [-[no]orinst] [-[no]ovec] [-einstein_restarts <int>]
           [-acflen <int>] [-[no]normalize] [-P <enum>]
           [-fitfn <enum>] [-beginfit <real>] [-endfit <real>]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` energy `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} extracts energy
components from an energy file. The user is prompted to interactively
select the desired energy terms.

Average, RMSD, and drift are calculated with full precision from the
simulation (see printed manual). Drift is calculated by performing a
least-squares fit of the data to a straight line. The reported total
drift is the difference of the fit at the first and last point. An error
estimate of the average is given based on a block averages over 5 blocks
using the full-precision averages. The error estimate can be performed
over multiple block lengths with the options ` `{.docutils .literal
.notranslate}[` -nbmin `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` -nbmax `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . **Note** that
in most cases the energy files contains averages over all MD steps, or
over many more points than the number of frames in energy file. This
makes the ` `{.docutils .literal .notranslate}[` gmx `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` energy `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} statistics
output more accurate than the output. When exact averages are not
present in the energy file, the statistics mentioned above are simply
over the single, per-frame energy values.

The term fluctuation gives the RMSD around the least-squares fit.

Some fluctuation-dependent properties can be calculated provided the
correct energy terms are selected, and that the command line option
` `{.docutils .literal .notranslate}[` -fluct_props `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} is given. The
following properties will be computed:

::: {.table-wrapper .docutils .container}
  Property                          Energy terms needed
  --------------------------------- ---------------------
  Heat capacity C_p (NPT sims):     Enthalpy, Temp
  Heat capacity C_v (NVT sims):     Etot, Temp
  Thermal expansion coeff. (NPT):   Enthalpy, Vol, Temp
  Isothermal compressibility:       Vol, Temp
  Adiabatic bulk modulus:           Vol, Temp
:::

You always need to set the number of molecules ` `{.docutils .literal
.notranslate}[` -nmol `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . The C_p/C_v
computations do **not** include any corrections for quantum effects. Use
the program if you need that (and you do).

Option ` `{.docutils .literal .notranslate}[` -odh `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} extracts and
plots the free energy data (Hamiltoian differences and/or the
Hamiltonian derivative dhdl) from the ` `{.docutils .literal
.notranslate}[` ener.edr `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} file.

With ` `{.docutils .literal .notranslate}[` -fee `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} an estimate is
calculated for the free-energy difference with an ideal gas state:

::: {.highlight-default .notranslate}
::: highlight
    Delta A = A(N,V,T) - A_idealgas(N,V,T) = kT
    ln(<exp(U_pot/kT)>)
    Delta G = G(N,p,T) - G_idealgas(N,p,T) = kT
    ln(<exp(U_pot/kT)>)
:::
:::

where k is Boltzmannâ€™s constant, T is set by ` `{.docutils .literal
.notranslate}[` -fetemp `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and the average
is over the ensemble (or time in a trajectory). Note that this is in
principle only correct when averaging over the whole (Boltzmann)
ensemble and using the potential energy. This also allows for an entropy
estimate using:

::: {.highlight-default .notranslate}
::: highlight
    Delta S(N,V,T) = S(N,V,T) - S_idealgas(N,V,T) =
    (<U_pot> - Delta A)/T
    Delta S(N,p,T) = S(N,p,T) - S_idealgas(N,p,T) =
    (<U_pot> + pV - Delta G)/T
:::
:::

When a second energy file is specified ( ` `{.docutils .literal
.notranslate}[` -f2 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ), a free
energy difference is calculated:

::: {.highlight-default .notranslate}
::: highlight
    dF = -kT
    ln(<exp(-(E_B-E_A) /
    kT)>_A),
:::
:::

where E_A and E_B are the energies from the first and second energy
files, and the average is over the ensemble A. The running average of
the free energy difference is printed to a file specified by
` `{.docutils .literal .notranslate}[` -ravg `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . **Note** that
the energies must both be calculated from the same trajectory.

For liquids, viscosities can be calculated by integrating the
auto-correlation function of, or by using the Einstein formula for, the
off-diagonal pressure elements. The option ` `{.docutils .literal
.notranslate}[` -vis `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} turns
calculation of the shear and bulk viscosity through integration of the
auto-correlation function. For accurate results, this requires extremely
frequent computation and output of the pressure tensor. The Einstein
formula does not require frequent output and is therefore more
convenient. Note that frequent pressure calculation (nstcalcenergy mdp
parameter) is still needed. Option ` `{.docutils .literal
.notranslate}[` -evicso `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} gives this
shear viscosity estimate and option ` `{.docutils .literal
.notranslate}[` -eviscoi `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} the integral.
Using one of these two options also triggers the other. The viscosity is
computed from integrals averaged over ` `{.docutils .literal
.notranslate}[` -einstein_restarts `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} starting points
uniformly distributed over the first quarter of the trajectory.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.edr\>\] (ener.edr)

:   Energy file

` `{.docutils .literal .notranslate}[` -f2 `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.edr\>\] (ener.edr) (Optional)

:   Energy file

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr\>\] (topol.tpr) (Optional)

:   Portable xdr run input file

Options to specify output files:

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (energy.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -viol `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (violaver.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -pairs `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (pairs.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -corr `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (enecorr.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -vis `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (visco.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -evisco `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (evisco.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -eviscoi `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (eviscoi.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -ravg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (runavgdf.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -odh `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (dhdl.xvg) (Optional)

:   xvgr/xmgr file

Other options:

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of first frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of last frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -[no]w `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   View output , , and files

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   xvg plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -[no]fee `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Do a free energy estimate

` `{.docutils .literal .notranslate}[` -fetemp `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (300)

:   Reference temperature for free energy calculation

` `{.docutils .literal .notranslate}[` -zero `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Subtract a zero-point energy

` `{.docutils .literal .notranslate}[` -[no]sum `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Sum the energy terms selected rather than display them all

` `{.docutils .literal .notranslate}[` -[no]dp `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Print energies in high precision

` `{.docutils .literal .notranslate}[` -nbmin `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (5)

:   Minimum number of blocks for error estimate

` `{.docutils .literal .notranslate}[` -nbmax `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (5)

:   Maximum number of blocks for error estimate

` `{.docutils .literal .notranslate}[` -[no]mutot `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Compute the total dipole moment from the components

` `{.docutils .literal .notranslate}[` -[no]aver `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Also print the exact average and rmsd stored in the energy frames
    (only when 1 term is requested)

` `{.docutils .literal .notranslate}[` -nmol `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (1)

:   Number of molecules in your sample: the energies are divided by this
    number

` `{.docutils .literal .notranslate}[` -[no]fluct_props `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Compute properties based on energy fluctuations, like heat capacity

` `{.docutils .literal .notranslate}[` -[no]driftcorr `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Useful only for calculations of fluctuation properties. The drift in
    the observables will be subtracted before computing the fluctuation
    properties.

` `{.docutils .literal .notranslate}[` -[no]fluc `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Calculate autocorrelation of energy fluctuations rather than energy
    itself

` `{.docutils .literal .notranslate}[` -[no]orinst `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Analyse instantaneous orientation data

` `{.docutils .literal .notranslate}[` -[no]ovec `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Also plot the eigenvectors with ` `{.docutils .literal
    .notranslate}[` -oten `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate}

` `{.docutils .literal .notranslate}[` -einstein_restarts `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (100)

:   Number of restarts for computing the viscosity using the Einstein
    relation

` `{.docutils .literal .notranslate}[` -acflen `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (-1)

:   Length of the ACF, default is half the number of frames

` `{.docutils .literal .notranslate}[` -[no]normalize `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Normalize ACF

` `{.docutils .literal .notranslate}[` -P `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (0)

:   Order of Legendre polynomial for ACF (0 indicates none): 0, 1, 2, 3

` `{.docutils .literal .notranslate}[` -fitfn `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (none)

:   Fit function: none, exp, aexp, exp_exp, exp5, exp7, exp9

` `{.docutils .literal .notranslate}[` -beginfit `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Time where to begin the exponential fit of the correlation function

` `{.docutils .literal .notranslate}[` -endfit `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (-1)

:   Time where to end the exponential fit of the correlation function,
    -1 is until the end
:::
:::
::: {#gmx-extract-cluster .section}
[ ]{#id1}

# gmx extract-cluster

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx extract-cluster [-f [<.xtc/.trr/...>]] [-s [<.tpr/.gro/...>]]
             [-n [<.ndx>]] [-clusters [<.ndx>]]
             [-o [<.xtc/.trr/...>]] [-b <time>] [-e <time>]
             [-dt <time>] [-tu <enum>] [-fgroup <selection>]
             [-xvg <enum>] [-[no]rmpbc] [-[no]pbc] [-sf <file>]
             [-selrpos <enum>] [-select <selection>] [-vel <enum>]
             [-force <enum>] [-atoms <enum>] [-precision <int>]
             [-starttime <time>] [-timestep <time>] [-box <vector>]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` extract-cluster `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} can be used to
extract trajectory frames that correspond to clusters obtained from
running gmx cluster with the -clndx option. The module supports writing
all GROMACS supported trajectory file formats.

Included is also a selection of possible options to change additional
information.

It is possible to write only a selection of atoms to the output
trajectory files for each cluster.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (traj.xtc) (Optional)

:   Input trajectory or single configuration:

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr/.gro/â€¦\>\] (topol.tpr) (Optional)

:   Input structure: brk ent

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx) (Optional)

:   Extra index groups

` `{.docutils .literal .notranslate}[` -clusters `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (cluster.ndx)

:   Name of index file containing frame indices for each cluster,
    obtained from gmx cluster -clndx.

Options to specify output files:

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (trajout.xtc)

:   Prefix for the name of the trajectory file written for each
    cluster.:

Other options:

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   First frame (ps) to read from trajectory

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Last frame (ps) to read from trajectory

` `{.docutils .literal .notranslate}[` -dt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Only use frame if t MOD dt == first time (ps)

` `{.docutils .literal .notranslate}[` -tu `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (ps)

:   Unit for time values: fs, ps, ns, us, ms, s

` `{.docutils .literal .notranslate}[` -fgroup `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<selection\>

:   Atoms stored in the trajectory file (if not set, assume first N
    atoms)

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   Plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -[no]rmpbc `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Make molecules whole for each frame

` `{.docutils .literal .notranslate}[` -[no]pbc `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Use periodic boundary conditions for distance calculation

` `{.docutils .literal .notranslate}[` -sf `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<file\>

:   Provide selections from files

` `{.docutils .literal .notranslate}[` -selrpos `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (atom)

:   Selection reference positions: atom, res_com, res_cog, mol_com,
    mol_cog, whole_res_com, whole_res_cog, whole_mol_com, whole_mol_cog,
    part_res_com, part_res_cog, part_mol_com, part_mol_cog, dyn_res_com,
    dyn_res_cog, dyn_mol_com, dyn_mol_cog

` `{.docutils .literal .notranslate}[` -select `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<selection\>

:   Selection of atoms to write to the file

` `{.docutils .literal .notranslate}[` -vel `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (preserved-if-present)

:   Save velocities from frame if possible: preserved-if-present,
    always, never

` `{.docutils .literal .notranslate}[` -force `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (preserved-if-present)

:   Save forces from frame if possible: preserved-if-present, always,
    never

` `{.docutils .literal .notranslate}[` -atoms `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (preserved-if-present)

:   Decide on providing new atom information from topology or using
    current frame atom information: preserved-if-present,
    always-from-structure, never, always

` `{.docutils .literal .notranslate}[` -precision `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (3)

:   Set output precision to custom value

` `{.docutils .literal .notranslate}[` -starttime `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Change start time for first frame

` `{.docutils .literal .notranslate}[` -timestep `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Change time between different frames

` `{.docutils .literal .notranslate}[` -box `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<vector\>

:   New diagonal box vector for output frame
:::
:::
::: {#gmx-filter .section}
[ ]{#id1}

# gmx filter

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx filter [-f [<.xtc/.trr/...>]] [-s [<.tpr/.gro/...>]] [-n [<.ndx>]]
           [-ol [<.xtc/.trr/...>]] [-oh [<.xtc/.trr/...>]]
           [-b <time>] [-e <time>] [-dt <time>] [-[no]w] [-nf <int>]
           [-[no]all] [-[no]nojump] [-[no]fit]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` filter `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} performs
frequency filtering on a trajectory. The filter shape is cos(pi t/A) + 1
from -A to +A, where A is given by the option ` `{.docutils .literal
.notranslate}[` -nf `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} times the time
step in the input trajectory. This filter reduces fluctuations with
period A by 85%, with period 2\*A by 50% and with period 3\*A by 17% for
low-pass filtering. Both a low-pass and high-pass filtered trajectory
can be written.

Option ` `{.docutils .literal .notranslate}[` -ol `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} writes a
low-pass filtered trajectory. A frame is written every ` `{.docutils
.literal .notranslate}[` -nf `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} input frames.
This ratio of filter length and output interval ensures a good
suppression of aliasing of high-frequency motion, which is useful for
making smooth movies. Also averages of properties which are linear in
the coordinates are preserved, since all input frames are weighted
equally in the output. When all frames are needed, use the ` `{.docutils
.literal .notranslate}[` -all `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} option.

Option ` `{.docutils .literal .notranslate}[` -oh `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} writes a
high-pass filtered trajectory. The high-pass filtered coordinates are
added to the coordinates from the structure file. When using high-pass
filtering use ` `{.docutils .literal .notranslate}[` -fit `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} or
make sure you use a trajectory that has been fitted on the coordinates
in the structure file.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (traj.xtc)

:   Trajectory:

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr/.gro/â€¦\>\] (topol.tpr) (Optional)

:   Structure+mass(db): brk ent

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx) (Optional)

:   Index file

Options to specify output files:

` `{.docutils .literal .notranslate}[` -ol `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (lowpass.xtc) (Optional)

:   Trajectory:

` `{.docutils .literal .notranslate}[` -oh `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (highpass.xtc) (Optional)

:   Trajectory:

Other options:

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of first frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of last frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -dt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Only use frame when t MOD dt = first time (default unit ps)

` `{.docutils .literal .notranslate}[` -[no]w `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   View output , , and files

` `{.docutils .literal .notranslate}[` -nf `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (10)

:   Sets the filter length as well as the output interval for low-pass
    filtering

` `{.docutils .literal .notranslate}[` -[no]all `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Write all low-pass filtered frames

` `{.docutils .literal .notranslate}[` -[no]nojump `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Remove jumps of atoms across the box

` `{.docutils .literal .notranslate}[` -[no]fit `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Fit all frames to a reference structure
:::
:::
::: {#gmx-freevolume .section}
[ ]{#id1}

# gmx freevolume

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx freevolume [-f [<.xtc/.trr/...>]] [-s [<.tpr/.gro/...>]]
             [-n [<.ndx>]] [-o [<.xvg>]] [-b <time>] [-e <time>]
             [-dt <time>] [-tu <enum>] [-fgroup <selection>]
             [-xvg <enum>] [-[no]rmpbc] [-sf <file>]
             [-selrpos <enum>] [-select <selection>] [-radius <real>]
             [-seed <int>] [-ninsert <int>]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` freevolume `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} calculates the
free volume in a box as a function of time. The free volume is plotted
as a fraction of the total volume. The program tries to insert a probe
with a given radius, into the simulations box and if the distance
between the probe and any atom is less than the sums of the van der
Waals radii of both atoms, the position is considered to be occupied,
i.e. non-free. By using a probe radius of 0, the true free volume is
computed. By using a larger radius, e.g. 0.14 nm, roughly corresponding
to a water molecule, the free volume for a hypothetical particle with
that size will be produced. Note however, that since atoms are treated
as hard-spheres these number are very approximate, and typically only
relative changes are meaningful, for instance by doing a series of
simulations at different temperature.

The group specified by the selection is considered to delineate non-free
volume. The number of insertions per unit of volume is important to get
a converged result. About 1000/nm\^3 yields an overall standard
deviation that is determined by the fluctuations in the trajectory
rather than by the fluctuations due to the random numbers.

The results are critically dependent on the van der Waals radii; we
recommend to use the values due to Bondi (1964).

The Fractional Free Volume (FFV) that some authors like to use is given
by 1 - 1.3\*(1-Free Volume). This value is printed on the terminal.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (traj.xtc) (Optional)

:   Input trajectory or single configuration:

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr/.gro/â€¦\>\] (topol.tpr) (Optional)

:   Input structure: brk ent

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx) (Optional)

:   Extra index groups

Options to specify output files:

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (freevolume.xvg) (Optional)

:   Computed free volume

Other options:

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   First frame (ps) to read from trajectory

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Last frame (ps) to read from trajectory

` `{.docutils .literal .notranslate}[` -dt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Only use frame if t MOD dt == first time (ps)

` `{.docutils .literal .notranslate}[` -tu `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (ps)

:   Unit for time values: fs, ps, ns, us, ms, s

` `{.docutils .literal .notranslate}[` -fgroup `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<selection\>

:   Atoms stored in the trajectory file (if not set, assume first N
    atoms)

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   Plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -[no]rmpbc `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Make molecules whole for each frame

` `{.docutils .literal .notranslate}[` -sf `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<file\>

:   Provide selections from files

` `{.docutils .literal .notranslate}[` -selrpos `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (atom)

:   Selection reference positions: atom, res_com, res_cog, mol_com,
    mol_cog, whole_res_com, whole_res_cog, whole_mol_com, whole_mol_cog,
    part_res_com, part_res_cog, part_mol_com, part_mol_cog, dyn_res_com,
    dyn_res_cog, dyn_mol_com, dyn_mol_cog

` `{.docutils .literal .notranslate}[` -select `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<selection\>

:   Atoms that are considered as part of the excluded volume

` `{.docutils .literal .notranslate}[` -radius `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Radius of the probe to be inserted (nm, 0 yields the true free
    volume)

` `{.docutils .literal .notranslate}[` -seed `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (0)

:   Seed for random number generator (0 means generate).

` `{.docutils .literal .notranslate}[` -ninsert `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (1000)

:   Number of probe insertions per cubic nm to try for each frame in the
    trajectory.
:::
:::
::: {#gmx-gangle .section}
[ ]{#id1}

# gmx gangle

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx gangle [-f [<.xtc/.trr/...>]] [-s [<.tpr/.gro/...>]] [-n [<.ndx>]]
           [-oav [<.xvg>]] [-oall [<.xvg>]] [-oh [<.xvg>]]
           [-b <time>] [-e <time>] [-dt <time>] [-tu <enum>]
           [-fgroup <selection>] [-xvg <enum>] [-[no]rmpbc]
           [-[no]pbc] [-sf <file>] [-selrpos <enum>]
           [-seltype <enum>] [-g1 <enum>] [-g2 <enum>] [-binw <real>]
           [-group1 <selection>] [-group2 <selection>]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` gangle `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} computes
different types of angles between vectors. It supports both vectors
defined by two positions and normals of planes defined by three
positions. The z axis or the local normal of a sphere can also be used
as one of the vectors. There are also convenience options â€˜angleâ€™
and â€˜dihedralâ€™ for calculating bond angles and dihedrals defined by
three/four positions.

The type of the angle is specified with ` `{.docutils .literal
.notranslate}[` -g1 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` -g2 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . If
` `{.docutils .literal .notranslate}[` -g1 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} is
` `{.docutils .literal .notranslate}[` angle `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} or
` `{.docutils .literal .notranslate}[` dihedral `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , ` `{.docutils
.literal .notranslate}[` -g2 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} should not be
specified. In this case, ` `{.docutils .literal
.notranslate}[` -group1 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} should specify
one or more selections, and each should contain triplets or quartets of
positions that define the angles to be calculated.

If ` `{.docutils .literal .notranslate}[` -g1 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} is
` `{.docutils .literal .notranslate}[` vector `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} or
` `{.docutils .literal .notranslate}[` plane `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , ` `{.docutils
.literal .notranslate}[` -group1 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} should specify
selections that contain either pairs ( ` `{.docutils .literal
.notranslate}[` vector `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ) or triplets (
` `{.docutils .literal .notranslate}[` plane `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ) of positions.
For vectors, the positions set the endpoints of the vector, and for
planes, the three positions are used to calculate the normal of the
plane. In both cases, ` `{.docutils .literal
.notranslate}[` -g2 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} specifies the
other vector to use (see below).

With ` `{.docutils .literal .notranslate}[` -g2 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` vector `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} or
` `{.docutils .literal .notranslate}[` -g2 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` plane `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , ` `{.docutils
.literal .notranslate}[` -group2 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} should specify
another set of vectors. ` `{.docutils .literal
.notranslate}[` -group1 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` -group2 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} should specify
the same number of selections. It is also allowed to only have a single
selection for one of the options, in which case the same selection is
used with each selection in the other group. Similarly, for each
selection in ` `{.docutils .literal .notranslate}[` -group1 `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} , the
corresponding selection in ` `{.docutils .literal
.notranslate}[` -group2 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} should specify
the same number of vectors or a single vector. In the latter case, the
angle is calculated between that single vector and each vector from the
other selection.

With ` `{.docutils .literal .notranslate}[` -g2 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` sphnorm `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , each
selection in ` `{.docutils .literal .notranslate}[` -group2 `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} should
specify a single position that is the center of the sphere. The second
vector is calculated as the vector from the center to the midpoint of
the positions specified by ` `{.docutils .literal
.notranslate}[` -group1 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} .

With ` `{.docutils .literal .notranslate}[` -g2 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate}[` z `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} ,
` `{.docutils .literal .notranslate}[` -group2 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} is not
necessary, and angles between the first vectors and the positive Z axis
are calculated.

With ` `{.docutils .literal .notranslate}[` -g2 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` t0 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , ` `{.docutils
.literal .notranslate}[` -group2 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} is not
necessary, and angles are calculated from the vectors as they are in the
first frame.

There are three options for output: ` `{.docutils .literal
.notranslate}[` -oav `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} writes an xvg
file with the time and the average angle for each frame. ` `{.docutils
.literal .notranslate}[` -oall `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} writes all the
individual angles. ` `{.docutils .literal
.notranslate}[` -oh `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} writes a
histogram of the angles. The bin width can be set with ` `{.docutils
.literal .notranslate}[` -binw `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . For
` `{.docutils .literal .notranslate}[` -oav `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` -oh `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , separate
average/histogram is computed for each selection in ` `{.docutils
.literal .notranslate}[` -group1 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} .
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (traj.xtc) (Optional)

:   Input trajectory or single configuration:

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr/.gro/â€¦\>\] (topol.tpr) (Optional)

:   Input structure: brk ent

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx) (Optional)

:   Extra index groups

Options to specify output files:

` `{.docutils .literal .notranslate}[` -oav `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (angaver.xvg) (Optional)

:   Average angles as a function of time

` `{.docutils .literal .notranslate}[` -oall `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (angles.xvg) (Optional)

:   All angles as a function of time

` `{.docutils .literal .notranslate}[` -oh `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (anghist.xvg) (Optional)

:   Histogram of the angles

Other options:

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   First frame (ps) to read from trajectory

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Last frame (ps) to read from trajectory

` `{.docutils .literal .notranslate}[` -dt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Only use frame if t MOD dt == first time (ps)

` `{.docutils .literal .notranslate}[` -tu `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (ps)

:   Unit for time values: fs, ps, ns, us, ms, s

` `{.docutils .literal .notranslate}[` -fgroup `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<selection\>

:   Atoms stored in the trajectory file (if not set, assume first N
    atoms)

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   Plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -[no]rmpbc `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Make molecules whole for each frame

` `{.docutils .literal .notranslate}[` -[no]pbc `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Use periodic boundary conditions for distance calculation

` `{.docutils .literal .notranslate}[` -sf `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<file\>

:   Provide selections from files

` `{.docutils .literal .notranslate}[` -selrpos `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (atom)

:   Selection reference positions: atom, res_com, res_cog, mol_com,
    mol_cog, whole_res_com, whole_res_cog, whole_mol_com, whole_mol_cog,
    part_res_com, part_res_cog, part_mol_com, part_mol_cog, dyn_res_com,
    dyn_res_cog, dyn_mol_com, dyn_mol_cog

` `{.docutils .literal .notranslate}[` -seltype `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (atom)

:   Default selection output positions: atom, res_com, res_cog, mol_com,
    mol_cog, whole_res_com, whole_res_cog, whole_mol_com, whole_mol_cog,
    part_res_com, part_res_cog, part_mol_com, part_mol_cog, dyn_res_com,
    dyn_res_cog, dyn_mol_com, dyn_mol_cog

` `{.docutils .literal .notranslate}[` -g1 `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (angle)

:   Type of analysis/first vector group: angle, dihedral, vector, plane

` `{.docutils .literal .notranslate}[` -g2 `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (none)

:   Type of second vector group: none, vector, plane, t0, z, sphnorm

` `{.docutils .literal .notranslate}[` -binw `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (1)

:   Binwidth for -oh in degrees

` `{.docutils .literal .notranslate}[` -group1 `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<selection\>

:   First analysis/vector selection

` `{.docutils .literal .notranslate}[` -group2 `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<selection\>

:   Second analysis/vector selection
:::
:::
::: {#gmx-genconf .section}
[ ]{#id1}

# gmx genconf

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx genconf [-f [<.gro/.g96/...>]] [-trj [<.xtc/.trr/...>]]
            [-o [<.gro/.g96/...>]] [-nbox <vector>] [-dist <vector>]
            [-seed <int>] [-[no]rot] [-maxrot <vector>]
            [-[no]renumber]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` genconf `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} multiplies a
given coordinate file by simply stacking them on top of each other, like
a small child playing with wooden blocks. The program makes a grid of
*user-defined* proportions ( ` `{.docutils .literal
.notranslate}[` -nbox `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ), and
interspaces the grid point with an extra space ` `{.docutils .literal
.notranslate}[` -dist `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} .

When option ` `{.docutils .literal .notranslate}[` -rot `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} is
used the program does not check for overlap between molecules on grid
points. It is recommended to make the box in the input file at least as
big as the coordinates + van der Waals radius.

If the optional trajectory file is given, conformations are not
generated, but read from this file and translated appropriately to build
the grid.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.gro/.g96/â€¦\>\] (conf.gro)

:   Structure file: brk ent esp

` `{.docutils .literal .notranslate}[` -trj `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (traj.xtc) (Optional)

:   Trajectory:

Options to specify output files:

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.gro/.g96/â€¦\>\] (out.gro)

:   Structure file: brk ent esp

Other options:

` `{.docutils .literal .notranslate}[` -nbox `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<vector\> (1 1 1)

:   Number of boxes

` `{.docutils .literal .notranslate}[` -dist `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<vector\> (0 0 0)

:   Distance between boxes

` `{.docutils .literal .notranslate}[` -seed `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (0)

:   Random generator seed (0 means generate)

` `{.docutils .literal .notranslate}[` -[no]rot `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Randomly rotate conformations

` `{.docutils .literal .notranslate}[` -maxrot `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<vector\> (180 180 180)

:   Maximum random rotation

` `{.docutils .literal .notranslate}[` -[no]renumber `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Renumber residues
:::

::: {#known-issues .section}
## Known Issues

-   The program should allow for random displacement of lattice points.
:::
:::
::: {#gmx-genion .section}
[ ]{#id1}

# gmx genion

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx genion [-s [<.tpr>]] [-n [<.ndx>]] [-p [<.top>]]
           [-o [<.gro/.g96/...>]] [-np <int>] [-pname <string>]
           [-pq <int>] [-nn <int>] [-nname <string>] [-nq <int>]
           [-rmin <real>] [-seed <int>] [-conc <real>] [-[no]neutral]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` genion `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} randomly
replaces solvent molecules with monoatomic ions. The group of solvent
molecules should be continuous and all molecules should have the same
number of atoms. The user should add the ion molecules to the topology
file or use the ` `{.docutils .literal .notranslate}[` -p `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} option
to automatically modify the topology.

The ion molecule type, residue and atom names in all force fields are
the capitalized element names without sign. This molecule name should be
given with ` `{.docutils .literal .notranslate}[` -pname `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} or
` `{.docutils .literal .notranslate}[` -nname `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , and the
` `{.docutils .literal .notranslate}[` [molecules] `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} section of your
topology updated accordingly, either by hand or with ` `{.docutils
.literal .notranslate}[` -p `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . Do not use an
atom name instead!

Ions which can have multiple charge states get the multiplicity added,
without sign, for the uncommon states only.

For larger ions, e.g. sulfate we recommended using .
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr\>\] (topol.tpr)

:   Portable xdr run input file

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx) (Optional)

:   Index file

Options to specify input/output files:

` `{.docutils .literal .notranslate}[` -p `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.top\>\] (topol.top) (Optional)

:   Topology file

Options to specify output files:

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.gro/.g96/â€¦\>\] (out.gro)

:   Structure file: brk ent esp

Other options:

` `{.docutils .literal .notranslate}[` -np `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (0)

:   Number of positive ions

` `{.docutils .literal .notranslate}[` -pname `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<string\> (NA)

:   Name of the positive ion

` `{.docutils .literal .notranslate}[` -pq `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (1)

:   Charge of the positive ion

` `{.docutils .literal .notranslate}[` -nn `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (0)

:   Number of negative ions

` `{.docutils .literal .notranslate}[` -nname `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<string\> (CL)

:   Name of the negative ion

` `{.docutils .literal .notranslate}[` -nq `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (-1)

:   Charge of the negative ion

` `{.docutils .literal .notranslate}[` -rmin `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0.6)

:   Minimum distance between ions and non-solvent

` `{.docutils .literal .notranslate}[` -seed `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (0)

:   Seed for random number generator (0 means generate)

` `{.docutils .literal .notranslate}[` -conc `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Specify salt concentration (mol/liter). This will add sufficient
    ions to reach up to the specified concentration as computed from the
    volume of the cell in the input file. Overrides the ` `{.docutils
    .literal .notranslate}[` -np `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} and
    ` `{.docutils .literal .notranslate}[` -nn `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} options.

` `{.docutils .literal .notranslate}[` -[no]neutral `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   This option will add enough ions to neutralize the system. These
    ions are added on top of those specified with ` `{.docutils .literal
    .notranslate}[` -np `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} /
    ` `{.docutils .literal .notranslate}[` -nn `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} or
    ` `{.docutils .literal .notranslate}[` -conc `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} .
:::

::: {#known-issues .section}
## Known Issues

-   If you specify a salt concentration existing ions are not taken into
    account. In effect you therefore specify the amount of salt to be
    added.
:::
:::
::: {#gmx-genrestr .section}
[ ]{#id1}

# gmx genrestr

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx genrestr [-f [<.gro/.g96/...>]] [-n [<.ndx>]] [-o [<.itp>]]
             [-of [<.ndx>]] [-fc <vector>] [-freeze <real>]
             [-[no]disre] [-disre_dist <real>] [-disre_frac <real>]
             [-disre_up2 <real>] [-cutoff <real>] [-[no]constr]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` genrestr `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} produces an
#include file for a topology containing a list of atom numbers and three
force constants for the *x* -, *y* -, and *z* -direction based on the
contents of the ` `{.docutils .literal .notranslate}[` -f `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} file.
A single isotropic force constant may be given on the command line
instead of three components.

WARNING: Position restraints are interactions within molecules,
therefore they must be included within the correct ` `{.docutils
.literal .notranslate}[` [ `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` moleculetype `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate}[` ] `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} block
in the topology. The atom indices within the ` `{.docutils .literal
.notranslate}[` [ `{.docutils .literal .notranslate}]{.pre}` `{.docutils
.literal .notranslate}[` position_restraints `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate}[` ] `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} block
must be within the range of the atom indices for that molecule type.
Since the atom numbers in every moleculetype in the topology start at 1
and the numbers in the input file for ` `{.docutils .literal
.notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` genrestr `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} number
consecutively from 1, ` `{.docutils .literal
.notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` genrestr `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} will only
produce a useful file for the first molecule. You may wish to edit the
resulting index file to remove the lines for later atoms, or construct a
suitable index group to provide as input to ` `{.docutils .literal
.notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` genrestr `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} .

The ` `{.docutils .literal .notranslate}[` -of `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} option produces
an index file that can be used for freezing atoms. In this case, the
input file must be a file.

With the ` `{.docutils .literal .notranslate}[` -disre `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}
option, half a matrix of distance restraints is generated instead of
position restraints. With this matrix, that one typically would apply to
Calpha atoms in a protein, one can maintain the overall conformation of
a protein without tieing it to a specific position (as with position
restraints).
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.gro/.g96/â€¦\>\] (conf.gro)

:   Structure file: brk ent esp

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx) (Optional)

:   Index file

Options to specify output files:

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.itp\>\] (posre.itp)

:   Include file for topology

` `{.docutils .literal .notranslate}[` -of `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (freeze.ndx) (Optional)

:   Index file

Other options:

` `{.docutils .literal .notranslate}[` -fc `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<vector\> (1000 1000 1000)

:   Force constants (kJ/mol nm\^2)

` `{.docutils .literal .notranslate}[` -freeze `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   If the ` `{.docutils .literal .notranslate}[` -of `{.docutils
    .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}
    option or this one is given an index file will be written containing
    atom numbers of all atoms that have a B-factor less than the level
    given here

` `{.docutils .literal .notranslate}[` -[no]disre `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Generate a distance restraint matrix for all the atoms in index

` `{.docutils .literal .notranslate}[` -disre_dist `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0.1)

:   Distance range around the actual distance for generating distance
    restraints

` `{.docutils .literal .notranslate}[` -disre_frac `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Fraction of distance to be used as interval rather than a fixed
    distance. If the fraction of the distance that you specify here is
    less than the distance given in the previous option, that one is
    used instead.

` `{.docutils .literal .notranslate}[` -disre_up2 `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (1)

:   Distance between upper bound for distance restraints, and the
    distance at which the force becomes constant (see manual)

` `{.docutils .literal .notranslate}[` -cutoff `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (-1)

:   Only generate distance restraints for atoms pairs within cutoff (nm)

` `{.docutils .literal .notranslate}[` -[no]constr `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Generate a constraint matrix rather than distance restraints.
    Constraints of type 2 will be generated that do generate exclusions.
:::
:::
::: {#gmx-grompp .section}
[ ]{#id1}

# gmx grompp

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx grompp [-f [<.mdp>]] [-c [<.gro/.g96/...>]] [-r [<.gro/.g96/...>]]
           [-rb [<.gro/.g96/...>]] [-n [<.ndx>]] [-p [<.top>]]
           [-t [<.trr/.cpt/...>]] [-e [<.edr>]] [-qmi [<.inp>]]
           [-ref [<.trr/.cpt/...>]] [-po [<.mdp>]] [-pp [<.top>]]
           [-o [<.tpr>]] [-imd [<.gro>]] [-[no]v] [-time <real>]
           [-[no]rmvsbds] [-maxwarn <int>] [-[no]zero] [-[no]renum]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` grompp `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} (the gromacs
preprocessor) reads a molecular topology file, checks the validity of
the file, expands the topology from a molecular description to an atomic
description. The topology file contains information about molecule types
and the number of molecules, the preprocessor copies each molecule as
needed. There is no limitation on the number of molecule types. Bonds
and bond-angles can be converted into constraints, separately for
hydrogens and heavy atoms. Then a coordinate file is read and velocities
can be generated from a Maxwellian distribution if requested.
` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` grompp `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} also reads
parameters for (eg. number of MD steps, time step, cut-off). Eventually
a binary file is produced that can serve as the sole input file for the
MD program.

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` grompp `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} uses the atom
names from the topology file. The atom names in the coordinate file
(option ` `{.docutils .literal .notranslate}[` -c `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ) are only read
to generate warnings when they do not match the atom names in the
topology. Note that the atom names are irrelevant for the simulation as
only the atom types are used for generating interaction parameters.

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` grompp `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} uses a built-in
preprocessor to resolve includes, macros, etc. The preprocessor supports
the following keywords:

::: {.highlight-default .notranslate}
::: highlight
    #ifdef VARIABLE
    #ifndef VARIABLE
    #else
    #endif
    #define VARIABLE
    #undef VARIABLE
    #include "filename"
    #include <filename>
:::
:::

The functioning of these statements in your topology may be modulated by
using the following two flags in your file:

::: {.highlight-default .notranslate}
::: highlight
    define = -DVARIABLE1 -DVARIABLE2
    include = -I/home/john/doe
:::
:::

For further information a C-programming textbook may help you out.
Specifying the ` `{.docutils .literal .notranslate}[` -pp `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} flag
will get the pre-processed topology file written out so that you can
verify its contents.

When using position restraints, a file with restraint coordinates must
be supplied with ` `{.docutils .literal .notranslate}[` -r `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (can
be the same file as supplied for ` `{.docutils .literal
.notranslate}[` -c `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ). For free
energy calculations, separate reference coordinates for the B topology
can be supplied with ` `{.docutils .literal
.notranslate}[` -rb `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , otherwise
they will be equal to those of the A topology.

Starting coordinates can be read from trajectory with ` `{.docutils
.literal .notranslate}[` -t `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . The last
frame with coordinates and velocities will be read, unless the
` `{.docutils .literal .notranslate}[` -time `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} option is used.
Only if this information is absent will the coordinates in the
` `{.docutils .literal .notranslate}[` -c `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} file be used.
Note that these velocities will not be used when ` `{.docutils .literal
.notranslate}[` gen_vel `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate}[` = `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` yes `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} in your file.
An energy file can be supplied with ` `{.docutils .literal
.notranslate}[` -e `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} to read
Nose-Hoover and/or Parrinello-Rahman coupling variables.

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` grompp `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} can be used to
restart simulations (preserving continuity) by supplying just a
checkpoint file with ` `{.docutils .literal
.notranslate}[` -t `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . However, for
simply changing the number of run steps to extend a run, using is more
convenient than ` `{.docutils .literal .notranslate}[` gmx `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` grompp `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . You then
supply the old checkpoint file directly to with ` `{.docutils .literal
.notranslate}[` -cpi `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . If you wish
to change the ensemble or things like output frequency, then supplying
the checkpoint file to ` `{.docutils .literal
.notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` grompp `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} with
` `{.docutils .literal .notranslate}[` -t `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} along with a
new file with ` `{.docutils .literal .notranslate}[` -f `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} is the
recommended procedure. Actually preserving the ensemble (if possible)
still requires passing the checkpoint file to ` `{.docutils .literal
.notranslate}[` -cpi `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} .

By default, all bonded interactions which have constant energy due to
virtual site constructions will be removed. If this constant energy is
not zero, this will result in a shift in the total energy. All bonded
interactions can be kept by turning off ` `{.docutils .literal
.notranslate}[` -rmvsbds `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . Additionally,
all constraints for distances which will be constant anyway because of
virtual site constructions will be removed. If any constraints remain
which involve virtual sites, a fatal error will result.

To verify your run input file, please take note of all warnings on the
screen, and correct where necessary. Do also look at the contents of the
` `{.docutils .literal .notranslate}[` mdout.mdp `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} file; this
contains comment lines, as well as the input that ` `{.docutils .literal
.notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` grompp `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} has read. If in
doubt, you can start ` `{.docutils .literal
.notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` grompp `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} with the
` `{.docutils .literal .notranslate}[` -debug `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} option which
will give you more information in a file called ` `{.docutils .literal
.notranslate}[` grompp.log `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} (along with
real debug info). You can see the contents of the run input file with
the program. can be used to compare the contents of two run input files.

The ` `{.docutils .literal .notranslate}[` -maxwarn `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} option can be
used to override warnings printed by ` `{.docutils .literal
.notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` grompp `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} that otherwise
halt output. In some cases, warnings are harmless, but usually they are
not. The user is advised to carefully interpret the output messages
before attempting to bypass them with this option.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.mdp\>\] (grompp.mdp)

:   grompp input file with MD parameters

` `{.docutils .literal .notranslate}[` -c `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.gro/.g96/â€¦\>\] (conf.gro)

:   Structure file: brk ent esp

` `{.docutils .literal .notranslate}[` -r `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.gro/.g96/â€¦\>\] (restraint.gro) (Optional)

:   Structure file: brk ent esp

` `{.docutils .literal .notranslate}[` -rb `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.gro/.g96/â€¦\>\] (restraint.gro) (Optional)

:   Structure file: brk ent esp

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx) (Optional)

:   Index file

` `{.docutils .literal .notranslate}[` -p `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.top\>\] (topol.top)

:   Topology file

` `{.docutils .literal .notranslate}[` -t `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.trr/.cpt/â€¦\>\] (traj.trr) (Optional)

:   Full precision trajectory:

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.edr\>\] (ener.edr) (Optional)

:   Energy file

` `{.docutils .literal .notranslate}[` -qmi `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.inp\>\] (topol-qmmm.inp) (Optional)

:   Input file for QM program

Options to specify input/output files:

` `{.docutils .literal .notranslate}[` -ref `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.trr/.cpt/â€¦\>\] (rotref.trr) (Optional)

:   Full precision trajectory:

Options to specify output files:

` `{.docutils .literal .notranslate}[` -po `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.mdp\>\] (mdout.mdp)

:   grompp input file with MD parameters

` `{.docutils .literal .notranslate}[` -pp `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.top\>\] (processed.top) (Optional)

:   Topology file

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr\>\] (topol.tpr)

:   Portable xdr run input file

` `{.docutils .literal .notranslate}[` -imd `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.gro\>\] (imdgroup.gro) (Optional)

:   Coordinate file in Gromos-87 format

Other options:

` `{.docutils .literal .notranslate}[` -[no]v `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Be loud and noisy

` `{.docutils .literal .notranslate}[` -time `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (-1)

:   Take frame at or first after this time.

` `{.docutils .literal .notranslate}[` -[no]rmvsbds `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Remove constant bonded interactions with virtual sites

` `{.docutils .literal .notranslate}[` -maxwarn `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (0)

:   Number of allowed warnings during input processing. Not for normal
    use and may generate unstable systems

` `{.docutils .literal .notranslate}[` -[no]zero `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Set parameters for bonded interactions without defaults to zero
    instead of generating an error

` `{.docutils .literal .notranslate}[` -[no]renum `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Renumber atomtypes and minimize number of atomtypes
:::
:::
::: {#gmx-gyrate .section}
[ ]{#id1}

# gmx gyrate

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx gyrate [-f [<.xtc/.trr/...>]] [-s [<.tpr/.gro/...>]] [-n [<.ndx>]]
           [-o [<.xvg>]] [-b <time>] [-e <time>] [-dt <time>]
           [-tu <enum>] [-fgroup <selection>] [-xvg <enum>]
           [-[no]rmpbc] [-sf <file>] [-selrpos <enum>]
           [-seltype <enum>] [-sel <selection>] [-mode <enum>]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` gyrate `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} computes the
radius of gyration of a molecule and the radii of gyration about the *x*
-, *y* - and *z* -axes, as a function of time. The atoms are explicitly
mass weighted.

The axis components corresponds to the mass-weighted root-mean-square of
the radii components orthogonal to each axis, for example:

Rg(x) = sqrt((sum_i w_i (R_i(y)\^2 + R_i(z)\^2))/(sum_i w_i)).

where w_i is the weight value in the given situation (mass, charge,
unit)

Note that this is a new implementation of the gyrate utility added in
GROMACS 2024. If you need the old one, use ` `{.docutils .literal
.notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` gyrate-legacy `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} .
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (traj.xtc) (Optional)

:   Input trajectory or single configuration:

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr/.gro/â€¦\>\] (topol.tpr) (Optional)

:   Input structure: brk ent

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx) (Optional)

:   Extra index groups

Options to specify output files:

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (gyrate-taf.xvg)

:   Filename for gyrate plot output

Other options:

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   First frame (ps) to read from trajectory

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Last frame (ps) to read from trajectory

` `{.docutils .literal .notranslate}[` -dt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Only use frame if t MOD dt == first time (ps)

` `{.docutils .literal .notranslate}[` -tu `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (ps)

:   Unit for time values: fs, ps, ns, us, ms, s

` `{.docutils .literal .notranslate}[` -fgroup `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<selection\>

:   Atoms stored in the trajectory file (if not set, assume first N
    atoms)

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   Plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -[no]rmpbc `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Make molecules whole for each frame

` `{.docutils .literal .notranslate}[` -sf `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<file\>

:   Provide selections from files

` `{.docutils .literal .notranslate}[` -selrpos `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (atom)

:   Selection reference positions: atom, res_com, res_cog, mol_com,
    mol_cog, whole_res_com, whole_res_cog, whole_mol_com, whole_mol_cog,
    part_res_com, part_res_cog, part_mol_com, part_mol_cog, dyn_res_com,
    dyn_res_cog, dyn_mol_com, dyn_mol_cog

` `{.docutils .literal .notranslate}[` -seltype `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (atom)

:   Default selection output positions: atom, res_com, res_cog, mol_com,
    mol_cog, whole_res_com, whole_res_cog, whole_mol_com, whole_mol_cog,
    part_res_com, part_res_cog, part_mol_com, part_mol_cog, dyn_res_com,
    dyn_res_cog, dyn_mol_com, dyn_mol_cog

` `{.docutils .literal .notranslate}[` -sel `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<selection\>

:   Select group to compute gyrate radius

` `{.docutils .literal .notranslate}[` -mode `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (mass)

:   Atom weighting mode: mass, charge, geometry
:::
:::
::: {#gmx-gyrate-legacy .section}
[ ]{#id1}

# gmx gyrate-legacy

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx gyrate-legacy [-f [<.xtc/.trr/...>]] [-s [<.tpr/.gro/...>]]
             [-n [<.ndx>]] [-o [<.xvg>]] [-acf [<.xvg>]] [-b <time>]
             [-e <time>] [-dt <time>] [-[no]w] [-xvg <enum>]
             [-nmol <int>] [-[no]q] [-[no]p] [-[no]moi] [-nz <int>]
             [-acflen <int>] [-[no]normalize] [-P <enum>]
             [-fitfn <enum>] [-beginfit <real>] [-endfit <real>]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` gyrate-legacy `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} computes the
radius of gyration of a molecule and the radii of gyration about the *x*
-, *y* - and *z* -axes, as a function of time. The atoms are explicitly
mass weighted.

The axis components corresponds to the mass-weighted root-mean-square of
the radii components orthogonal to each axis, for example:

Rg(x) = sqrt((sum_i m_i (R_i(y)\^2 + R_i(z)\^2))/(sum_i m_i)).

With the ` `{.docutils .literal .notranslate}[` -nmol `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} option
the radius of gyration will be calculated for multiple molecules by
splitting the analysis group in equally sized parts.

With the option ` `{.docutils .literal .notranslate}[` -nz `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} 2D
radii of gyration in the *x-y* plane of slices along the *z* -axis are
calculated.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (traj.xtc)

:   Trajectory:

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr/.gro/â€¦\>\] (topol.tpr)

:   Structure+mass(db): brk ent

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx) (Optional)

:   Index file

Options to specify output files:

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (gyrate.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -acf `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (moi-acf.xvg) (Optional)

:   xvgr/xmgr file

Other options:

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of first frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of last frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -dt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Only use frame when t MOD dt = first time (default unit ps)

` `{.docutils .literal .notranslate}[` -[no]w `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   View output , , and files

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   xvg plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -nmol `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (1)

:   The number of molecules to analyze

` `{.docutils .literal .notranslate}[` -[no]q `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Use absolute value of the charge of an atom as weighting factor
    instead of mass

` `{.docutils .literal .notranslate}[` -[no]p `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Calculate the radii of gyration about the principal axes.

` `{.docutils .literal .notranslate}[` -[no]moi `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Calculate the moments of inertia (defined by the principal axes).

` `{.docutils .literal .notranslate}[` -nz `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (0)

:   Calculate the 2D radii of gyration of this number of slices along
    the z-axis

` `{.docutils .literal .notranslate}[` -acflen `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (-1)

:   Length of the ACF, default is half the number of frames

` `{.docutils .literal .notranslate}[` -[no]normalize `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Normalize ACF

` `{.docutils .literal .notranslate}[` -P `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (0)

:   Order of Legendre polynomial for ACF (0 indicates none): 0, 1, 2, 3

` `{.docutils .literal .notranslate}[` -fitfn `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (none)

:   Fit function: none, exp, aexp, exp_exp, exp5, exp7, exp9

` `{.docutils .literal .notranslate}[` -beginfit `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Time where to begin the exponential fit of the correlation function

` `{.docutils .literal .notranslate}[` -endfit `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (-1)

:   Time where to end the exponential fit of the correlation function,
    -1 is until the end
:::
:::
::: {#gmx-h2order .section}
[ ]{#id1}

# gmx h2order

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx h2order [-f [<.xtc/.trr/...>]] [-n [<.ndx>]] [-nm [<.ndx>]]
            [-s [<.tpr>]] [-o [<.xvg>]] [-b <time>] [-e <time>]
            [-dt <time>] [-[no]w] [-xvg <enum>] [-d <enum>]
            [-sl <int>]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` h2order `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} computes the
orientation of water molecules with respect to the normal of the box.
The program determines the average cosine of the angle between the
dipole moment of water and an axis of the box. The box is divided in
slices and the average orientation per slice is printed. Each water
molecule is assigned to a slice, per time frame, based on the position
of the oxygen. When ` `{.docutils .literal
.notranslate}[` -nm `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} is used, the
angle between the water dipole and the axis from the center of mass to
the oxygen is calculated instead of the angle between the dipole and a
box axis.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (traj.xtc)

:   Trajectory:

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx)

:   Index file

` `{.docutils .literal .notranslate}[` -nm `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx) (Optional)

:   Index file

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr\>\] (topol.tpr)

:   Portable xdr run input file

Options to specify output files:

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (order.xvg)

:   xvgr/xmgr file

Other options:

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of first frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of last frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -dt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Only use frame when t MOD dt = first time (default unit ps)

` `{.docutils .literal .notranslate}[` -[no]w `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   View output , , and files

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   xvg plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -d `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (Z)

:   Take the normal on the membrane in direction X, Y or Z.: Z, Y, X

` `{.docutils .literal .notranslate}[` -sl `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (0)

:   Calculate order parameter as function of boxlength, dividing the box
    in this number of slices.
:::

::: {#known-issues .section}
## Known Issues

-   The program assigns whole water molecules to a slice, based on the
    first atom of three in the index file group. It assumes an order
    O,H,H. Name is not important, but the order is. If this demand is
    not met, assigning molecules to slices is different.
:::
:::
::: {#gmx-hbond .section}
[ ]{#id1}

# gmx hbond

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx hbond [-f [<.xtc/.trr/...>]] [-s [<.tpr/.gro/...>]] [-n [<.ndx>]]
          [-o [<.ndx>]] [-num [<.xvg>]] [-dist [<.xvg>]]
          [-ang [<.xvg>]] [-dan [<.xvg>]] [-b <time>] [-e <time>]
          [-dt <time>] [-tu <enum>] [-fgroup <selection>]
          [-xvg <enum>] [-[no]rmpbc] [-[no]pbc] [-sf <file>]
          [-selrpos <enum>] [-seltype <enum>] [-r <selection>]
          [-t <selection>] [-[no]m] [-[no]pf] [-[no]an]
          [-cutoff <real>]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` hbond `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} allows using
geometric definition of hydrogen bonds to define them throughout the
structure.

` `{.docutils .literal .notranslate}[` -r `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} specifies
reference selection, relative to which the search for hydrogen bonds in
target selection will develop. Note that all atoms in reference and
target selections should be either absolutely identical or
non-overlapping at all.

` `{.docutils .literal .notranslate}[` -t `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} specifies
target selection, relative to which the search for hydrogen bonds in
reference selection will develop. Note that all atoms in reference and
target selections should be either absolutely identical or
non-overlapping at all.

` `{.docutils .literal .notranslate}[` -m `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} forces to merge
together information in output index file about hydrogen bonds if they
differ only in hydrogen indices. This also means that information about
hydrogen atoms in the hydrogen bonds would not be written in output
index file at all.

` `{.docutils .literal .notranslate}[` -pf `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} forces to write
hydrogen bonds for each frame separately instead of writing hydrogen
bonds for the whole system. Each information about hydrogen bonds in new
frame will be stored in its own section of the output index file.

` `{.docutils .literal .notranslate}[` -an `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} forces to
accept nitrogen atoms as acceptors of hydrogen bond. If this option is
set to â€˜falseâ€™ state, only oxygen atoms will be considered as
acceptors.

` `{.docutils .literal .notranslate}[` -cutoff `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} is a real value
that defines distance from donor to acceptor (and vise versa) that used
in neighbor search. Minimum (and also recommended) value is 0.35.

` `{.docutils .literal .notranslate}[` -num `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} allows you to
get a plot of the number of hydrogen bonds as a function of time at the
output.

` `{.docutils .literal .notranslate}[` -dist `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} allows you to
get a plot of the distance distribution of all hydrogen bonds at the
output.

` `{.docutils .literal .notranslate}[` -ang `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} allows you to
get a plot of the angular distribution of all hydrogen bonds at the
output.

` `{.docutils .literal .notranslate}[` -dan `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} allows you to
get a plot of the number of analyzed donors and acceptors for each frame
at the output.

Note that this is a new implementation of the hbond utility added in
GROMACS 2024. If you need the old one, use ` `{.docutils .literal
.notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` hbond-legacy `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} .
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (traj.xtc) (Optional)

:   Input trajectory or single configuration:

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr/.gro/â€¦\>\] (topol.tpr) (Optional)

:   Input structure: brk ent

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx) (Optional)

:   Extra index groups

Options to specify output files:

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (hbond.ndx)

:   Index file that contains selected groupsâ€™, acceptorsâ€™, donorsâ€™
    and hydrogensâ€™ indices and hydrogen bond pairs between or within
    selected groups.

` `{.docutils .literal .notranslate}[` -num `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (hbnum.xvg) (Optional)

:   Number of hydrogen bonds as a function of time.

` `{.docutils .literal .notranslate}[` -dist `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (hbdist.xvg) (Optional)

:   Distance distribution of all hydrogen bonds.

` `{.docutils .literal .notranslate}[` -ang `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (hbang.xvg) (Optional)

:   Angle distribution of all hydrogen bonds.

` `{.docutils .literal .notranslate}[` -dan `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (hbdan.xvg) (Optional)

:   Number of donors and acceptors analyzed for each frame.

Other options:

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   First frame (ps) to read from trajectory

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Last frame (ps) to read from trajectory

` `{.docutils .literal .notranslate}[` -dt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Only use frame if t MOD dt == first time (ps)

` `{.docutils .literal .notranslate}[` -tu `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (ps)

:   Unit for time values: fs, ps, ns, us, ms, s

` `{.docutils .literal .notranslate}[` -fgroup `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<selection\>

:   Atoms stored in the trajectory file (if not set, assume first N
    atoms)

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   Plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -[no]rmpbc `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Make molecules whole for each frame

` `{.docutils .literal .notranslate}[` -[no]pbc `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Use periodic boundary conditions for distance calculation

` `{.docutils .literal .notranslate}[` -sf `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<file\>

:   Provide selections from files

` `{.docutils .literal .notranslate}[` -selrpos `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (atom)

:   Selection reference positions: atom, res_com, res_cog, mol_com,
    mol_cog, whole_res_com, whole_res_cog, whole_mol_com, whole_mol_cog,
    part_res_com, part_res_cog, part_mol_com, part_mol_cog, dyn_res_com,
    dyn_res_cog, dyn_mol_com, dyn_mol_cog

` `{.docutils .literal .notranslate}[` -seltype `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (atom)

:   Default selection output positions: atom, res_com, res_cog, mol_com,
    mol_cog, whole_res_com, whole_res_cog, whole_mol_com, whole_mol_cog,
    part_res_com, part_res_cog, part_mol_com, part_mol_cog, dyn_res_com,
    dyn_res_cog, dyn_mol_com, dyn_mol_cog

` `{.docutils .literal .notranslate}[` -r `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<selection\>

:   Reference selection, relative to which the search for hydrogen bonds
    in target selection will develop.

` `{.docutils .literal .notranslate}[` -t `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<selection\>

:   Target selection, relative to which the search for hydrogen bonds in
    reference selection will develop.

` `{.docutils .literal .notranslate}[` -[no]m `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Merge together information about hydrogen bonds if they differ only
    in hydrogen indices.

` `{.docutils .literal .notranslate}[` -[no]pf `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Write hydrogen bonds for each frame separately instead of writing
    hydrogen bonds for the whole system.

` `{.docutils .literal .notranslate}[` -[no]an `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Accept nitrogen atoms as acceptors of hydrogen bond.

` `{.docutils .literal .notranslate}[` -cutoff `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0.35)

:   Distance from donor to acceptor (and vise versa) that used in
    neighbor search. Must be \>= 0.35.
:::
:::
::: {#gmx-hbond-legacy .section}
[ ]{#id1}

# gmx hbond-legacy

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx hbond-legacy [-f [<.xtc/.trr/...>]] [-s [<.tpr>]] [-n [<.ndx>]]
             [-num [<.xvg>]] [-g [<.log>]] [-ac [<.xvg>]]
             [-dist [<.xvg>]] [-ang [<.xvg>]] [-hx [<.xvg>]]
             [-hbn [<.ndx>]] [-hbm [<.xpm>]] [-don [<.xvg>]]
             [-dan [<.xvg>]] [-life [<.xvg>]] [-nhbdist [<.xvg>]]
             [-b <time>] [-e <time>] [-dt <time>] [-tu <enum>]
             [-xvg <enum>] [-a <real>] [-r <real>] [-[no]da]
             [-r2 <real>] [-abin <real>] [-rbin <real>] [-[no]nitacc]
             [-[no]contact] [-shell <real>] [-fitstart <real>]
             [-fitend <real>] [-temp <real>] [-dump <int>]
             [-max_hb <real>] [-[no]merge] [-nthreads <int>]
             [-acflen <int>] [-[no]normalize] [-P <enum>]
             [-fitfn <enum>] [-beginfit <real>] [-endfit <real>]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` hbond-legacy `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} computes and
analyzes hydrogen bonds. Hydrogen bonds are determined based on cutoffs
for the angle Hydrogen - Donor - Acceptor (zero is extended) and the
distance Donor - Acceptor (or Hydrogen - Acceptor using ` `{.docutils
.literal .notranslate}[` -noda `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ). OH and NH
groups are regarded as donors, O is an acceptor always, N is an acceptor
by default, but this can be switched using ` `{.docutils .literal
.notranslate}[` -nitacc `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . Dummy
hydrogen atoms are assumed to be connected to the first preceding
non-hydrogen atom.

You need to specify two groups for analysis, which must be either
identical or non-overlapping. All hydrogen bonds between the two groups
are analyzed.

If you set ` `{.docutils .literal .notranslate}[` -shell `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} , you
will be asked for an additional index group which should contain exactly
one atom. In this case, only hydrogen bonds between atoms within the
shell distance from the one atom are considered.

With option -ac, rate constants for hydrogen bonding can be derived with
the model of Luzar and Chandler (Nature 379:55, 1996; J. Chem. Phys.
113:23, 2000). If contact kinetics are analyzed by using the -contact
option, then n(t) can be defined as either all pairs that are not within
contact distance r at time t (corresponding to leaving the -r2 option at
the default value 0) or all pairs that are within distance r2
(corresponding to setting a second cut-off value with option -r2). See
mentioned literature for more details and definitions.

**Output:**

> <div>
>
> -   ` `{.docutils .literal .notranslate}[` -num `{.docutils .literal
>     .notranslate}]{.pre}` `{.docutils .literal .notranslate} : number
>     of hydrogen bonds as a function of time.
>
> -   ` `{.docutils .literal .notranslate}[` -ac `{.docutils .literal
>     .notranslate}]{.pre}` `{.docutils .literal .notranslate} : average
>     over all autocorrelations of the existence functions (either 0
>     or 1) of all hydrogen bonds.
>
> -   ` `{.docutils .literal .notranslate}[` -dist `{.docutils .literal
>     .notranslate}]{.pre}` `{.docutils .literal .notranslate} :
>     distance distribution of all hydrogen bonds.
>
> -   ` `{.docutils .literal .notranslate}[` -ang `{.docutils .literal
>     .notranslate}]{.pre}` `{.docutils .literal .notranslate} : angle
>     distribution of all hydrogen bonds.
>
> -   ` `{.docutils .literal .notranslate}[` -hx `{.docutils .literal
>     .notranslate}]{.pre}` `{.docutils .literal .notranslate} : the
>     number of n-n+i hydrogen bonds as a function of time where n and
>     n+i stand for residue numbers and i ranges from 0 to 6. This
>     includes the n-n+3, n-n+4 and n-n+5 hydrogen bonds associated with
>     helices in proteins.
>
> -   ` `{.docutils .literal .notranslate}[` -hbn `{.docutils .literal
>     .notranslate}]{.pre}` `{.docutils .literal .notranslate} : all
>     selected groups, donors, hydrogens and acceptors for selected
>     groups, all hydrogen bonded atoms from all groups and all solvent
>     atoms involved in insertion. Output is limited unless
>     ` `{.docutils .literal .notranslate}[` -nomerge `{.docutils
>     .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}
>     is set.
>
> -   ` `{.docutils .literal .notranslate}[` -hbm `{.docutils .literal
>     .notranslate}]{.pre}` `{.docutils .literal .notranslate} :
>     existence matrix for all hydrogen bonds over all frames, this also
>     contains information on solvent insertion into hydrogen bonds.
>     Ordering is identical to that in ` `{.docutils .literal
>     .notranslate}[` -hbn `{.docutils .literal
>     .notranslate}]{.pre}` `{.docutils .literal .notranslate} index
>     file.
>
> -   ` `{.docutils .literal .notranslate}[` -dan `{.docutils .literal
>     .notranslate}]{.pre}` `{.docutils .literal .notranslate} : write
>     out the number of donors and acceptors analyzed for each
>     timeframe. This is especially useful when using ` `{.docutils
>     .literal .notranslate}[` -shell `{.docutils .literal
>     .notranslate}]{.pre}` `{.docutils .literal .notranslate} .
>
> -   ` `{.docutils .literal .notranslate}[` -nhbdist `{.docutils
>     .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}
>     : compute the number of HBonds per hydrogen in order to compare
>     results to Raman Spectroscopy.
>
> </div>

Note: options ` `{.docutils .literal .notranslate}[` -ac `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} ,
` `{.docutils .literal .notranslate}[` -life `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , ` `{.docutils
.literal .notranslate}[` -hbn `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` -hbm `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} require an
amount of memory proportional to the total numbers of donors times the
total number of acceptors in the selected group(s).
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (traj.xtc)

:   Trajectory:

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr\>\] (topol.tpr)

:   Portable xdr run input file

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx) (Optional)

:   Index file

Options to specify output files:

` `{.docutils .literal .notranslate}[` -num `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (hbnum.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -g `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.log\>\] (hbond.log) (Optional)

:   Log file

` `{.docutils .literal .notranslate}[` -ac `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (hbac.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -dist `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (hbdist.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -ang `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (hbang.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -hx `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (hbhelix.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -hbn `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (hbond.ndx) (Optional)

:   Index file

` `{.docutils .literal .notranslate}[` -hbm `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xpm\>\] (hbmap.xpm) (Optional)

:   X PixMap compatible matrix file

` `{.docutils .literal .notranslate}[` -don `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (donor.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -dan `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (danum.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -life `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (hblife.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -nhbdist `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (nhbdist.xvg) (Optional)

:   xvgr/xmgr file

Other options:

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of first frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of last frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -dt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Only use frame when t MOD dt = first time (default unit ps)

` `{.docutils .literal .notranslate}[` -tu `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (ps)

:   Unit for time values: fs, ps, ns, us, ms, s

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   xvg plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -a `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (30)

:   Cutoff angle (degrees, Hydrogen - Donor - Acceptor)

` `{.docutils .literal .notranslate}[` -r `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0.35)

:   Cutoff radius (nm, X - Acceptor, see next option)

` `{.docutils .literal .notranslate}[` -[no]da `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Use distance Donor-Acceptor (if TRUE) or Hydrogen-Acceptor (FALSE)

` `{.docutils .literal .notranslate}[` -r2 `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Second cutoff radius. Mainly useful with ` `{.docutils .literal
    .notranslate}[` -contact `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} and
    ` `{.docutils .literal .notranslate}[` -ac `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate}

` `{.docutils .literal .notranslate}[` -abin `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (1)

:   Binwidth angle distribution (degrees)

` `{.docutils .literal .notranslate}[` -rbin `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0.005)

:   Binwidth distance distribution (nm)

` `{.docutils .literal .notranslate}[` -[no]nitacc `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Regard nitrogen atoms as acceptors

` `{.docutils .literal .notranslate}[` -[no]contact `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Do not look for hydrogen bonds, but merely for contacts within the
    cut-off distance

` `{.docutils .literal .notranslate}[` -shell `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (-1)

:   when \> 0, only calculate hydrogen bonds within \# nm shell around
    one particle

` `{.docutils .literal .notranslate}[` -fitstart `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (1)

:   Time (ps) from which to start fitting the correlation functions in
    order to obtain the forward and backward rate constants for HB
    breaking and formation. With ` `{.docutils .literal
    .notranslate}[` -gemfit `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} we suggest
    ` `{.docutils .literal .notranslate}[` -fitstart `{.docutils
    .literal .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` 0 `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate}

` `{.docutils .literal .notranslate}[` -fitend `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (60)

:   Time (ps) to which to stop fitting the correlation functions in
    order to obtain the forward and backward rate constants for HB
    breaking and formation (only with ` `{.docutils .literal
    .notranslate}[` -gemfit `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} )

` `{.docutils .literal .notranslate}[` -temp `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (298.15)

:   Temperature (K) for computing the Gibbs energy corresponding to HB
    breaking and reforming

` `{.docutils .literal .notranslate}[` -dump `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (0)

:   Dump the first N hydrogen bond ACFs in a single file for debugging

` `{.docutils .literal .notranslate}[` -max_hb `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Theoretical maximum number of hydrogen bonds used for normalizing HB
    autocorrelation function. Can be useful in case the program
    estimates it wrongly

` `{.docutils .literal .notranslate}[` -[no]merge `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   H-bonds between the same donor and acceptor, but with different
    hydrogen are treated as a single H-bond. Mainly important for the
    ACF. Not compatible with options that depend on knowing a specific
    hydrogen: ` `{.docutils .literal .notranslate}[` -noad `{.docutils
    .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} ,
    ` `{.docutils .literal .notranslate}[` -ang `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} .

` `{.docutils .literal .notranslate}[` -nthreads `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (0)

:   Number of threads used for the parallel loop over autocorrelations.
    nThreads \<= 0 means maximum number of threads. Requires linking
    with OpenMP. The number of threads is limited by the number of cores
    (before OpenMP v.3 ) or environment variable OMP_THREAD_LIMIT
    (OpenMP v.3)

` `{.docutils .literal .notranslate}[` -acflen `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (-1)

:   Length of the ACF, default is half the number of frames

` `{.docutils .literal .notranslate}[` -[no]normalize `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Normalize ACF

` `{.docutils .literal .notranslate}[` -P `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (0)

:   Order of Legendre polynomial for ACF (0 indicates none): 0, 1, 2, 3

` `{.docutils .literal .notranslate}[` -fitfn `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (none)

:   Fit function: none, exp, aexp, exp_exp, exp5, exp7, exp9

` `{.docutils .literal .notranslate}[` -beginfit `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Time where to begin the exponential fit of the correlation function

` `{.docutils .literal .notranslate}[` -endfit `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (-1)

:   Time where to end the exponential fit of the correlation function,
    -1 is until the end
:::
:::
::: {#gmx-helix .section}
[ ]{#id1}

# gmx helix

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx helix [-s [<.tpr>]] [-n [<.ndx>]] [-f [<.xtc/.trr/...>]]
          [-cz [<.gro/.g96/...>]] [-b <time>] [-e <time>]
          [-dt <time>] [-[no]w] [-r0 <int>] [-[no]q] [-[no]F]
          [-[no]db] [-[no]ev] [-ahxstart <int>] [-ahxend <int>]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` helix `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} computes all
kinds of helix properties. First, the peptide is checked to find the
longest helical part, as determined by hydrogen bonds and phi/psi
angles. That bit is fitted to an ideal helix around the *z* -axis and
centered around the origin. Then the following properties are computed:

> <div>
>
> -   Helix radius (file ` `{.docutils .literal
>     .notranslate}[` radius.xvg `{.docutils .literal
>     .notranslate}]{.pre}` `{.docutils .literal .notranslate} ). This
>     is merely the RMS deviation in two dimensions for all Calpha
>     atoms. it is calculated as sqrt((sum_i (x\^2(i)+y\^2(i)))/N) where
>     N is the number of backbone atoms. For an ideal helix the radius
>     is 0.23 nm.
>
> -   Twist (file ` `{.docutils .literal
>     .notranslate}[` twist.xvg `{.docutils .literal
>     .notranslate}]{.pre}` `{.docutils .literal .notranslate} ). The
>     average helical angle per residue is calculated. For an
>     alpha-helix it is 100 degrees, for 3-10 helices it will be
>     smaller, and for 5-helices it will be larger.
>
> -   Rise per residue (file ` `{.docutils .literal
>     .notranslate}[` rise.xvg `{.docutils .literal
>     .notranslate}]{.pre}` `{.docutils .literal .notranslate} ). The
>     helical rise per residue is plotted as the difference in *z*
>     -coordinate between Calpha atoms. For an ideal helix, this is 0.15
>     nm.
>
> -   Total helix length (file ` `{.docutils .literal
>     .notranslate}[` len-ahx.xvg `{.docutils .literal
>     .notranslate}]{.pre}` `{.docutils .literal .notranslate} ). The
>     total length of the helix in nm. This is simply the average rise
>     (see above) times the number of helical residues (see below).
>
> -   Helix dipole, backbone only (file ` `{.docutils .literal
>     .notranslate}[` dip-ahx.xvg `{.docutils .literal
>     .notranslate}]{.pre}` `{.docutils .literal .notranslate} ).
>
> -   RMS deviation from ideal helix, calculated for the Calpha atoms
>     only (file ` `{.docutils .literal
>     .notranslate}[` rms-ahx.xvg `{.docutils .literal
>     .notranslate}]{.pre}` `{.docutils .literal .notranslate} ).
>
> -   Average Calpha - Calpha dihedral angle (file ` `{.docutils
>     .literal .notranslate}[` phi-ahx.xvg `{.docutils .literal
>     .notranslate}]{.pre}` `{.docutils .literal .notranslate} ).
>
> -   Average phi and psi angles (file ` `{.docutils .literal
>     .notranslate}[` phipsi.xvg `{.docutils .literal
>     .notranslate}]{.pre}` `{.docutils .literal .notranslate} ).
>
> -   Ellipticity at 222 nm according to Hirst and Brooks.
>
> </div>
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr\>\] (topol.tpr)

:   Portable xdr run input file

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx)

:   Index file

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (traj.xtc)

:   Trajectory:

Options to specify output files:

` `{.docutils .literal .notranslate}[` -cz `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.gro/.g96/â€¦\>\] (zconf.gro)

:   Structure file: brk ent esp

Other options:

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of first frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of last frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -dt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Only use frame when t MOD dt = first time (default unit ps)

` `{.docutils .literal .notranslate}[` -[no]w `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   View output , , and files

` `{.docutils .literal .notranslate}[` -r0 `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (1)

:   The first residue number in the sequence

` `{.docutils .literal .notranslate}[` -[no]q `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Check at every step which part of the sequence is helical

` `{.docutils .literal .notranslate}[` -[no]F `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Toggle fit to a perfect helix

` `{.docutils .literal .notranslate}[` -[no]db `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Print debug info

` `{.docutils .literal .notranslate}[` -[no]ev `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Write a new â€˜trajectoryâ€™ file for ED

` `{.docutils .literal .notranslate}[` -ahxstart `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (0)

:   First residue in helix

` `{.docutils .literal .notranslate}[` -ahxend `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (0)

:   Last residue in helix
:::
:::
::: {#gmx-helixorient .section}
[ ]{#id1}

# gmx helixorient

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx helixorient [-s [<.tpr>]] [-f [<.xtc/.trr/...>]] [-n [<.ndx>]]
             [-oaxis [<.dat>]] [-ocenter [<.dat>]] [-orise [<.xvg>]]
             [-oradius [<.xvg>]] [-otwist [<.xvg>]]
             [-obending [<.xvg>]] [-otilt [<.xvg>]] [-orot [<.xvg>]]
             [-b <time>] [-e <time>] [-dt <time>] [-xvg <enum>]
             [-[no]sidechain] [-[no]incremental]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` helixorient `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} calculates the
coordinates and direction of the average axis inside an alpha helix, and
the direction/vectors of both the Calpha and (optionally) a sidechain
atom relative to the axis.

As input, you need to specify an index group with Calpha atoms
corresponding to an alpha-helix of continuous residues. Sidechain
directions require a second index group of the same size, containing the
heavy atom in each residue that should represent the sidechain.

**Note** that this program does not do any fitting of structures.

We need four Calpha coordinates to define the local direction of the
helix axis.

The tilt/rotation is calculated from Euler rotations, where we define
the helix axis as the local *x* -axis, the residues/Calpha vector as *y*
, and the *z* -axis from their cross product. We use the Euler Y-Z-X
rotation, meaning we first tilt the helix axis (1) around and (2)
orthogonal to the residues vector, and finally apply the (3) rotation
around it. For debugging or other purposes, we also write out the actual
Euler rotation angles as ` `{.docutils .literal
.notranslate}[` theta[1-3].xvg `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate}
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr\>\] (topol.tpr)

:   Portable xdr run input file

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (traj.xtc)

:   Trajectory:

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx) (Optional)

:   Index file

Options to specify output files:

` `{.docutils .literal .notranslate}[` -oaxis `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.dat\>\] (helixaxis.dat)

:   Generic data file

` `{.docutils .literal .notranslate}[` -ocenter `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.dat\>\] (center.dat)

:   Generic data file

` `{.docutils .literal .notranslate}[` -orise `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (rise.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -oradius `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (radius.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -otwist `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (twist.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -obending `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (bending.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -otilt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (tilt.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -orot `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (rotation.xvg)

:   xvgr/xmgr file

Other options:

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of first frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of last frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -dt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Only use frame when t MOD dt = first time (default unit ps)

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   xvg plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -[no]sidechain `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Calculate sidechain directions relative to helix axis too.

` `{.docutils .literal .notranslate}[` -[no]incremental `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Calculate incremental rather than total rotation/tilt.
:::
:::
::: {#gmx-help .section}
[ ]{#id1}

# gmx help
:::
::: {#gmx-hydorder .section}
[ ]{#id1}

# gmx hydorder

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx hydorder [-f [<.xtc/.trr/...>]] [-n [<.ndx>]] [-s [<.tpr>]]
             [-o [<.xpm> [...]]] [-or [<.out> [...]]]
             [-Spect [<.out> [...]]] [-b <time>] [-e <time>]
             [-dt <time>] [-[no]w] [-d <enum>] [-bw <real>]
             [-sgang1 <real>] [-sgang2 <real>] [-tblock <int>]
             [-nlevel <int>]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` hydorder `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} computes the
tetrahedrality order parameters around a given atom. Both angle an
distance order parameters are calculated. See P.-L. Chau and A.J.
Hardwick, Mol. Phys., 93, (1998), 511-518. for more details.

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` hydorder `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} calculates the
order parameter in a 3d-mesh in the box, and with 2 phases in the box
gives the user the option to define a 2D interface in time separating
the faces by specifying parameters ` `{.docutils .literal
.notranslate}[` -sgang1 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` -sgang2 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} (it is
important to select these judiciously).
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (traj.xtc)

:   Trajectory:

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx)

:   Index file

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr\>\] (topol.tpr)

:   Portable xdr run input file

Options to specify output files:

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xpm\> \[â€¦\]\] (intf.xpm)

:   X PixMap compatible matrix file

` `{.docutils .literal .notranslate}[` -or `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.out\> \[â€¦\]\] (raw.out) (Optional)

:   Generic output file

` `{.docutils .literal .notranslate}[` -Spect `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.out\> \[â€¦\]\] (intfspect.out) (Optional)

:   Generic output file

Other options:

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of first frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of last frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -dt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Only use frame when t MOD dt = first time (default unit ps)

` `{.docutils .literal .notranslate}[` -[no]w `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   View output , , and files

` `{.docutils .literal .notranslate}[` -d `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (z)

:   Direction of the normal on the membrane: z, x, y

` `{.docutils .literal .notranslate}[` -bw `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (1)

:   Binwidth of box mesh

` `{.docutils .literal .notranslate}[` -sgang1 `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (1)

:   tetrahedral angle parameter in Phase 1 (bulk)

` `{.docutils .literal .notranslate}[` -sgang2 `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (1)

:   tetrahedral angle parameter in Phase 2 (bulk)

` `{.docutils .literal .notranslate}[` -tblock `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (1)

:   Number of frames in one time-block average

` `{.docutils .literal .notranslate}[` -nlevel `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (100)

:   Number of Height levels in 2D - XPixMaps
:::
:::
::: {#gmx-insert-molecules .section}
[ ]{#id1}

# gmx insert-molecules

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx insert-molecules [-f [<.gro/.g96/...>]] [-ci [<.gro/.g96/...>]]
             [-ip [<.dat>]] [-n [<.ndx>]] [-o [<.gro/.g96/...>]]
             [-replace <selection>] [-sf <file>] [-selrpos <enum>]
             [-box <vector>] [-nmol <int>] [-try <int>] [-seed <int>]
             [-radius <real>] [-scale <real>] [-dr <vector>]
             [-rot <enum>]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` insert-molecules `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} inserts
` `{.docutils .literal .notranslate}[` -nmol `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} copies of the
system specified in the ` `{.docutils .literal
.notranslate}[` -ci `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} input file. The
insertions take place either into vacant space in the solute
conformation given with ` `{.docutils .literal
.notranslate}[` -f `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , or into an
empty box given by ` `{.docutils .literal
.notranslate}[` -box `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . Specifying
both ` `{.docutils .literal .notranslate}[` -f `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` -box `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} behaves like
` `{.docutils .literal .notranslate}[` -f `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , but places a
new box around the solute before insertions. Any velocities present are
discarded.

It is possible to also insert into a solvated configuration and replace
solvent atoms with the inserted atoms. To do this, use ` `{.docutils
.literal .notranslate}[` -replace `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} to specify a
selection that identifies the atoms that can be replaced. The tool
assumes that all molecules in this selection consist of single residues:
each residue from this selection that overlaps with the inserted
molecules will be removed instead of preventing insertion.

By default, the insertion positions are random (with initial seed
specified by ` `{.docutils .literal .notranslate}[` -seed `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} ). The
program iterates until ` `{.docutils .literal
.notranslate}[` -nmol `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} molecules have
been inserted in the box. Molecules are not inserted where the distance
between any existing atom and any atom of the inserted molecule is less
than the sum based on the van der Waals radii of both atoms. A database
( ` `{.docutils .literal .notranslate}[` vdwradii.dat `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} ) of
van der Waals radii is read by the program, and the resulting radii
scaled by ` `{.docutils .literal .notranslate}[` -scale `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} . If
radii are not found in the database, those atoms are assigned the
(pre-scaled) distance ` `{.docutils .literal
.notranslate}[` -radius `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . Note that the
usefulness of those radii depends on the atom names, and thus varies
widely with force field.

A total of ` `{.docutils .literal .notranslate}[` -nmol `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \*
` `{.docutils .literal .notranslate}[` -try `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} insertion
attempts are made before giving up. Increase ` `{.docutils .literal
.notranslate}[` -try `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} if you have
several small holes to fill. Option ` `{.docutils .literal
.notranslate}[` -rot `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} specifies
whether the insertion molecules are randomly oriented before insertion
attempts.

Alternatively, the molecules can be inserted only at positions defined
in positions.dat ( ` `{.docutils .literal
.notranslate}[` -ip `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ). That file
should have 3 columns (x,y,z), that give the displacements compared to
the input molecule position ( ` `{.docutils .literal
.notranslate}[` -ci `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ). Hence, if
that file should contain the absolute positions, the molecule must be
centered on (0,0,0) before using ` `{.docutils .literal
.notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` insert-molecules `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} (e.g. from
` `{.docutils .literal .notranslate}[` -center `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ). Comments in
that file starting with \# are ignored. Option ` `{.docutils .literal
.notranslate}[` -dr `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} defines the
maximally allowed displacements during insertial trials. ` `{.docutils
.literal .notranslate}[` -try `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` -rot `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} work as in the
default mode (see above).
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.gro/.g96/â€¦\>\] (protein.gro) (Optional)

:   Existing configuration to insert into: brk ent esp

` `{.docutils .literal .notranslate}[` -ci `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.gro/.g96/â€¦\>\] (insert.gro)

:   Configuration to insert: brk ent esp

` `{.docutils .literal .notranslate}[` -ip `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.dat\>\] (positions.dat) (Optional)

:   Predefined insertion trial positions

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx) (Optional)

:   Extra index groups

Options to specify output files:

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.gro/.g96/â€¦\>\] (out.gro)

:   Output configuration after insertion: brk ent esp

Other options:

` `{.docutils .literal .notranslate}[` -replace `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<selection\>

:   Atoms that can be removed if overlapping

` `{.docutils .literal .notranslate}[` -sf `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<file\>

:   Provide selections from files

` `{.docutils .literal .notranslate}[` -selrpos `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (atom)

:   Selection reference positions: atom, res_com, res_cog, mol_com,
    mol_cog, whole_res_com, whole_res_cog, whole_mol_com, whole_mol_cog,
    part_res_com, part_res_cog, part_mol_com, part_mol_cog, dyn_res_com,
    dyn_res_cog, dyn_mol_com, dyn_mol_cog

` `{.docutils .literal .notranslate}[` -box `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<vector\> (0 0 0)

:   Box size (in nm)

` `{.docutils .literal .notranslate}[` -nmol `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (0)

:   Number of extra molecules to insert

` `{.docutils .literal .notranslate}[` -try `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (10)

:   Try inserting ` `{.docutils .literal
    .notranslate}[` -nmol `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} times
    ` `{.docutils .literal .notranslate}[` -try `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} times

` `{.docutils .literal .notranslate}[` -seed `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (0)

:   Random generator seed (0 means generate)

` `{.docutils .literal .notranslate}[` -radius `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0.105)

:   Default van der Waals distance

` `{.docutils .literal .notranslate}[` -scale `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0.57)

:   Scale factor to multiply Van der Waals radii from the database in
    share/gromacs/top/vdwradii.dat. The default value of 0.57 yields
    density close to 1000 g/l for proteins in water.

` `{.docutils .literal .notranslate}[` -dr `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<vector\> (0 0 0)

:   Allowed displacement in x/y/z from positions in ` `{.docutils
    .literal .notranslate}[` -ip `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} file

` `{.docutils .literal .notranslate}[` -rot `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xyz)

:   Rotate inserted molecules randomly: xyz, z, none
:::
:::
::: {#gmx-lie .section}
[ ]{#id1}

# gmx lie

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx lie [-f [<.edr>]] [-o [<.xvg>]] [-b <time>] [-e <time>] [-dt <time>]
        [-[no]w] [-xvg <enum>] [-Elj <real>] [-Eqq <real>]
        [-Clj <real>] [-Cqq <real>] [-ligand <string>]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` lie `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} computes a free
energy estimate based on an energy analysis from nonbonded energies. One
needs an energy file with the following components: Coul-(A-B) LJ-SR
(A-B) etc.

To utilize ` `{.docutils .literal .notranslate}[` g_lie `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}
correctly, two simulations are required: one with the molecule of
interest bound to its receptor and one with the molecule in water. Both
need to utilize ` `{.docutils .literal
.notranslate}[` energygrps `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} such that
Coul-SR(A-B), LJ-SR(A-B), etc. terms are written to the file. Values
from the molecule-in-water simulation are necessary for supplying
suitable values for -Elj and -Eqq.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.edr\>\] (ener.edr)

:   Energy file

Options to specify output files:

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (lie.xvg)

:   xvgr/xmgr file

Other options:

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of first frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of last frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -dt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Only use frame when t MOD dt = first time (default unit ps)

` `{.docutils .literal .notranslate}[` -[no]w `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   View output , , and files

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   xvg plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -Elj `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Lennard-Jones interaction between ligand and solvent

` `{.docutils .literal .notranslate}[` -Eqq `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Coulomb interaction between ligand and solvent

` `{.docutils .literal .notranslate}[` -Clj `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0.181)

:   Factor in the LIE equation for Lennard-Jones component of energy

` `{.docutils .literal .notranslate}[` -Cqq `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0.5)

:   Factor in the LIE equation for Coulomb component of energy

` `{.docutils .literal .notranslate}[` -ligand `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<string\> (none)

:   Name of the ligand in the energy file
:::
:::
::: {#gmx-make-edi .section}
[ ]{#id1}

# gmx make_edi

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx make_edi [-f [<.trr/.cpt/...>]] [-eig [<.xvg>]]
             [-s [<.tpr/.gro/...>]] [-n [<.ndx>]]
             [-tar [<.gro/.g96/...>]] [-ori [<.gro/.g96/...>]]
             [-o [<.edi>]] [-xvg <enum>] [-mon <string>]
             [-linfix <string>] [-linacc <string>] [-radfix <string>]
             [-radacc <string>] [-radcon <string>] [-flood <string>]
             [-outfrq <int>] [-slope <real>] [-linstep <string>]
             [-accdir <string>] [-radstep <real>] [-maxedsteps <int>]
             [-eqsteps <int>] [-deltaF0 <real>] [-deltaF <real>]
             [-tau <real>] [-Eflnull <real>] [-T <real>]
             [-alpha <real>] [-[no]restrain] [-[no]hessian]
             [-[no]harmonic] [-constF <string>]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` make_edi `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} generates an
essential dynamics (ED) sampling input file to be used with
` `{.docutils .literal .notranslate}[` mdrun `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} based on
eigenvectors of a covariance matrix ( ) or from a normal modes analysis
( ). ED sampling can be used to manipulate the position along collective
coordinates (eigenvectors) of (biological) macromolecules during a
simulation. Particularly, it may be used to enhance the sampling
efficiency of MD simulations by stimulating the system to explore new
regions along these collective coordinates. A number of different
algorithms are implemented to drive the system along the eigenvectors (
` `{.docutils .literal .notranslate}[` -linfix `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , ` `{.docutils
.literal .notranslate}[` -linacc `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , ` `{.docutils
.literal .notranslate}[` -radfix `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , ` `{.docutils
.literal .notranslate}[` -radacc `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , ` `{.docutils
.literal .notranslate}[` -radcon `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ), to keep the
position along a certain (set of) coordinate(s) fixed ( ` `{.docutils
.literal .notranslate}[` -linfix `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ), or to only
monitor the projections of the positions onto these coordinates (
` `{.docutils .literal .notranslate}[` -mon `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ).

References:

A. Amadei, A.B.M. Linssen, B.L. de Groot, D.M.F. van Aalten and H.J.C.
Berendsen; An efficient method for sampling the essential subspace of
proteins., J. Biomol. Struct. Dyn. 13:615-626 (1996)

B.L. de Groot, A. Amadei, D.M.F. van Aalten and H.J.C. Berendsen;
Towards an exhaustive sampling of the configurational spaces of the two
forms of the peptide hormone guanylin, J. Biomol. Struct. Dyn. 13 :
741-751 (1996)

B.L. de Groot, A.Amadei, R.M. Scheek, N.A.J. van Nuland and H.J.C.
Berendsen; An extended sampling of the configurational space of HPr from
E. coli Proteins: Struct. Funct. Gen. 26: 314-322 (1996)

You will be prompted for one or more index groups that correspond to the
eigenvectors, reference structure, target positions, etc.

` `{.docutils .literal .notranslate}[` -mon `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} : monitor
projections of the coordinates onto selected eigenvectors.

` `{.docutils .literal .notranslate}[` -linfix `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} : perform
fixed-step linear expansion along selected eigenvectors.

` `{.docutils .literal .notranslate}[` -linacc `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} : perform
acceptance linear expansion along selected eigenvectors. (steps in the
desired directions will be accepted, others will be rejected).

` `{.docutils .literal .notranslate}[` -radfix `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} : perform
fixed-step radius expansion along selected eigenvectors.

` `{.docutils .literal .notranslate}[` -radacc `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} : perform
acceptance radius expansion along selected eigenvectors. (steps in the
desired direction will be accepted, others will be rejected). **Note:**
by default the starting MD structure will be taken as origin of the
first expansion cycle for radius expansion. If ` `{.docutils .literal
.notranslate}[` -ori `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} is specified,
you will be able to read in a structure file that defines an external
origin.

` `{.docutils .literal .notranslate}[` -radcon `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} : perform
acceptance radius contraction along selected eigenvectors towards a
target structure specified with ` `{.docutils .literal
.notranslate}[` -tar `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} .

NOTE: each eigenvector can be selected only once.

` `{.docutils .literal .notranslate}[` -outfrq `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} : frequency (in
steps) of writing out projections etc. to file

` `{.docutils .literal .notranslate}[` -slope `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} : minimal slope
in acceptance radius expansion. A new expansion cycle will be started if
the spontaneous increase of the radius (in nm/step) is less than the
value specified.

` `{.docutils .literal .notranslate}[` -maxedsteps `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} : maximum
number of steps per cycle in radius expansion before a new cycle is
started.

Note on the parallel implementation: since ED sampling is a â€˜globalâ€™
thing (collective coordinates etc.), at least on the â€˜proteinâ€™ side,
ED sampling is not very parallel-friendly from an implementation point
of view. Because parallel ED requires some extra communication, expect
the performance to be lower as in a free MD simulation, especially on a
large number of ranks and/or when the ED group contains a lot of atoms.

Please also note that if your ED group contains more than a single
protein, then the file must contain the correct PBC representation of
the ED group. Take a look on the initial RMSD from the reference
structure, which is printed out at the start of the simulation; if this
is much higher than expected, one of the ED molecules might be shifted
by a box vector.

All ED-related output of ` `{.docutils .literal
.notranslate}[` mdrun `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} (specify with
` `{.docutils .literal .notranslate}[` -eo `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ) is written to
a file as a function of time in intervals of OUTFRQ steps.

**Note** that you can impose multiple ED constraints and flooding
potentials in a single simulation (on different molecules) if several
files were concatenated first. The constraints are applied in the order
they appear in the file. Depending on what was specified in the input
file, the output file contains for each ED dataset

> <div>
>
> -   the RMSD of the fitted molecule to the reference structure (for
>     atoms involved in fitting prior to calculating the ED constraints)
>
> -   projections of the positions onto selected eigenvectors
>
> </div>

FLOODING:

with ` `{.docutils .literal .notranslate}[` -flood `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , you can
specify which eigenvectors are used to compute a flooding potential,
which will lead to extra forces expelling the structure out of the
region described by the covariance matrix. If you switch -restrain the
potential is inverted and the structure is kept in that region.

The origin is normally the average structure stored in the ` `{.docutils
.literal .notranslate}[` eigvec.trr `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} file. It can be
changed with ` `{.docutils .literal .notranslate}[` -ori `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} to an
arbitrary position in configuration space. With ` `{.docutils .literal
.notranslate}[` -tau `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , ` `{.docutils
.literal .notranslate}[` -deltaF0 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , and
` `{.docutils .literal .notranslate}[` -Eflnull `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} you control the
flooding behaviour. Efl is the flooding strength, it is updated
according to the rule of adaptive flooding. Tau is the time constant of
adaptive flooding, high tau means slow adaption (i.e. growth). DeltaF0
is the flooding strength you want to reach after tau ps of simulation.
To use constant Efl set ` `{.docutils .literal
.notranslate}[` -tau `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} to zero.

` `{.docutils .literal .notranslate}[` -alpha `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} is a fudge
parameter to control the width of the flooding potential. A value of 2
has been found to give good results for most standard cases in flooding
of proteins. alpha basically accounts for incomplete sampling, if you
sampled further the width of the ensemble would increase, this is
mimicked by alpha \> 1. For restraining, alpha \< 1 can give you smaller
width in the restraining potential.

RESTART and FLOODING: If you want to restart a crashed flooding
simulation please find the values deltaF and Efl in the output file and
manually put them into the file under DELTA_F0 and EFL_NULL.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.trr/.cpt/â€¦\>\] (eigenvec.trr)

:   Full precision trajectory:

` `{.docutils .literal .notranslate}[` -eig `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (eigenval.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr/.gro/â€¦\>\] (topol.tpr)

:   Structure+mass(db): brk ent

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx) (Optional)

:   Index file

` `{.docutils .literal .notranslate}[` -tar `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.gro/.g96/â€¦\>\] (target.gro) (Optional)

:   Structure file: brk ent esp

` `{.docutils .literal .notranslate}[` -ori `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.gro/.g96/â€¦\>\] (origin.gro) (Optional)

:   Structure file: brk ent esp

Options to specify output files:

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.edi\>\] (sam.edi)

:   ED sampling input

Other options:

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   xvg plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -mon `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<string\>

:   Indices of eigenvectors for projections of x (e.g. 1,2-5,9) or
    1-100:10 means 1 11 21 31 â€¦ 91

` `{.docutils .literal .notranslate}[` -linfix `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<string\>

:   Indices of eigenvectors for fixed increment linear sampling

` `{.docutils .literal .notranslate}[` -linacc `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<string\>

:   Indices of eigenvectors for acceptance linear sampling

` `{.docutils .literal .notranslate}[` -radfix `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<string\>

:   Indices of eigenvectors for fixed increment radius expansion

` `{.docutils .literal .notranslate}[` -radacc `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<string\>

:   Indices of eigenvectors for acceptance radius expansion

` `{.docutils .literal .notranslate}[` -radcon `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<string\>

:   Indices of eigenvectors for acceptance radius contraction

` `{.docutils .literal .notranslate}[` -flood `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<string\>

:   Indices of eigenvectors for flooding

` `{.docutils .literal .notranslate}[` -outfrq `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (100)

:   Frequency (in steps) of writing output in file

` `{.docutils .literal .notranslate}[` -slope `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Minimal slope in acceptance radius expansion

` `{.docutils .literal .notranslate}[` -linstep `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<string\>

:   Stepsizes (nm/step) for fixed increment linear sampling (put in
    quotes! â€œ1.0 2.3 5.1 -3.1â€?)

` `{.docutils .literal .notranslate}[` -accdir `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<string\>

:   Directions for acceptance linear sampling - only sign counts! (put
    in quotes! â€œ-1 +1 -1.1â€?)

` `{.docutils .literal .notranslate}[` -radstep `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Stepsize (nm/step) for fixed increment radius expansion

` `{.docutils .literal .notranslate}[` -maxedsteps `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (0)

:   Maximum number of steps per cycle

` `{.docutils .literal .notranslate}[` -eqsteps `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (0)

:   Number of steps to run without any perturbations

` `{.docutils .literal .notranslate}[` -deltaF0 `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (150)

:   Target destabilization energy for flooding

` `{.docutils .literal .notranslate}[` -deltaF `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Start deltaF with this parameter - default 0, nonzero values only
    needed for restart

` `{.docutils .literal .notranslate}[` -tau `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0.1)

:   Coupling constant for adaption of flooding strength according to
    deltaF0, 0 = infinity i.e. constant flooding strength

` `{.docutils .literal .notranslate}[` -Eflnull `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   The starting value of the flooding strength. The flooding strength
    is updated according to the adaptive flooding scheme. For a constant
    flooding strength use ` `{.docutils .literal
    .notranslate}[` -tau `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} 0.

` `{.docutils .literal .notranslate}[` -T `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (300)

:   T is temperature, the value is needed if you want to do flooding

` `{.docutils .literal .notranslate}[` -alpha `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (1)

:   Scale width of gaussian flooding potential with alpha\^2

` `{.docutils .literal .notranslate}[` -[no]restrain `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Use the flooding potential with inverted sign -\> effects as
    quasiharmonic restraining potential

` `{.docutils .literal .notranslate}[` -[no]hessian `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   The eigenvectors and eigenvalues are from a Hessian matrix

` `{.docutils .literal .notranslate}[` -[no]harmonic `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   The eigenvalues are interpreted as spring constant

` `{.docutils .literal .notranslate}[` -constF `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<string\>

:   Constant force flooding: manually set the forces for the
    eigenvectors selected with -flood (put in quotes! â€œ1.0 2.3 5.1
    -3.1â€?). No other flooding parameters are needed when specifying
    the forces directly.
:::
:::
::: {#gmx-make-ndx .section}
[ ]{#id1}

# gmx make_ndx

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx make_ndx [-f [<.gro/.g96/...>]] [-n [<.ndx> [...]]] [-o [<.ndx>]]
             [-natoms <int>] [-[no]twin]
```
:::

::: {#description .section}
## Description

Index groups are necessary for almost every GROMACS program. All these
programs can generate default index groups. You ONLY have to use
` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` make_ndx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} when you need
SPECIAL index groups. There is a default index group for the whole
system, 9 default index groups for proteins, and a default index group
is generated for every other residue name.

When no index file is supplied, also ` `{.docutils .literal
.notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` make_ndx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} will generate
the default groups. With the index editor you can select on atom,
residue and chain names and numbers. When a run input file is supplied
you can also select on atom type. You can use boolean operations, you
can split groups into chains, residues or atoms. You can delete and
rename groups. Type â€˜hâ€™ in the editor for more details.

The atom numbering in the editor and the index file starts at 1.

The ` `{.docutils .literal .notranslate}[` -twin `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} switch
duplicates all index groups with an offset of ` `{.docutils .literal
.notranslate}[` -natoms `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , which is
useful for Computational Electrophysiology double-layer membrane setups.

See also ` `{.docutils .literal .notranslate}[` -on `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , which
provides an alternative way for constructing index groups. It covers
nearly all of ` `{.docutils .literal .notranslate}[` gmx `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` make_ndx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} functionality,
and in many cases much more.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.gro/.g96/â€¦\>\] (conf.gro) (Optional)

:   Structure file: brk ent esp

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\> \[â€¦\]\] (index.ndx) (Optional)

:   Index file

Options to specify output files:

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx)

:   Index file

Other options:

` `{.docutils .literal .notranslate}[` -natoms `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (0)

:   set number of atoms (default: read from coordinate or index file)

` `{.docutils .literal .notranslate}[` -[no]twin `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Duplicate all index groups with an offset of -natoms
:::
:::
::: {#gmx-mdmat .section}
[ ]{#id1}

# gmx mdmat

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx mdmat [-f [<.xtc/.trr/...>]] [-s [<.tpr/.gro/...>]] [-n [<.ndx>]]
          [-mean [<.xpm>]] [-frames [<.xpm>]] [-no [<.xvg>]]
          [-b <time>] [-e <time>] [-dt <time>] [-xvg <enum>]
          [-t <real>] [-nlevels <int>]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` mdmat `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} makes distance
matrices consisting of the smallest distance between residue pairs. With
` `{.docutils .literal .notranslate}[` -frames `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , these
distance matrices can be stored in order to see differences in tertiary
structure as a function of time. If you choose your options unwisely,
this may generate a large output file. By default, only an averaged
matrix over the whole trajectory is output. Also a count of the number
of different atomic contacts between residues over the whole trajectory
can be made. The output can be processed with to make a PostScript (tm)
plot.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (traj.xtc)

:   Trajectory:

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr/.gro/â€¦\>\] (topol.tpr)

:   Structure+mass(db): brk ent

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx) (Optional)

:   Index file

Options to specify output files:

` `{.docutils .literal .notranslate}[` -mean `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xpm\>\] (dm.xpm)

:   X PixMap compatible matrix file

` `{.docutils .literal .notranslate}[` -frames `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xpm\>\] (dmf.xpm) (Optional)

:   X PixMap compatible matrix file

` `{.docutils .literal .notranslate}[` -no `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (num.xvg) (Optional)

:   xvgr/xmgr file

Other options:

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of first frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of last frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -dt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Only use frame when t MOD dt = first time (default unit ps)

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   xvg plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -t `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (1.5)

:   trunc distance

` `{.docutils .literal .notranslate}[` -nlevels `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (40)

:   Discretize distance in this number of levels
:::
:::
::: {#gmx-mdrun .section}
[ ]{#id1}

# gmx mdrun

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx mdrun [-s [<.tpr>]] [-cpi [<.cpt>]] [-table [<.xvg>]]
          [-tablep [<.xvg>]] [-tableb [<.xvg> [...]]]
          [-rerun [<.xtc/.trr/...>]] [-ei [<.edi>]]
          [-multidir [<dir> [...]]] [-awh [<.xvg>]]
          [-membed [<.dat>]] [-mp [<.top>]] [-mn [<.ndx>]]
          [-o [<.trr/.cpt/...>]] [-x [<.xtc/.tng>]] [-cpo [<.cpt>]]
          [-c [<.gro/.g96/...>]] [-e [<.edr>]] [-g [<.log>]]
          [-dhdl [<.xvg>]] [-field [<.xvg>]] [-tpi [<.xvg>]]
          [-tpid [<.xvg>]] [-eo [<.xvg>]] [-px [<.xvg>]]
          [-pf [<.xvg>]] [-ro [<.xvg>]] [-ra [<.log>]] [-rs [<.log>]]
          [-rt [<.log>]] [-mtx [<.mtx>]] [-if [<.xvg>]]
          [-swap [<.xvg>]] [-deffnm <string>] [-xvg <enum>]
          [-dd <vector>] [-ddorder <enum>] [-npme <int>] [-nt <int>]
          [-ntmpi <int>] [-ntomp <int>] [-ntomp_pme <int>]
          [-pin <enum>] [-pinoffset <int>] [-pinstride <int>]
          [-gpu_id <string>] [-gputasks <string>] [-[no]ddcheck]
          [-rdd <real>] [-rcon <real>] [-dlb <enum>] [-dds <real>]
          [-nb <enum>] [-nstlist <int>] [-[no]tunepme] [-pme <enum>]
          [-pmefft <enum>] [-bonded <enum>] [-update <enum>] [-[no]v]
          [-pforce <real>] [-[no]reprod] [-cpt <real>] [-[no]cpnum]
          [-[no]append] [-nsteps <int>] [-maxh <real>]
          [-replex <int>] [-nex <int>] [-reseed <int>]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` mdrun `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} is the main
computational chemistry engine within GROMACS. Obviously, it performs
Molecular Dynamics simulations, but it can also perform Stochastic
Dynamics, Energy Minimization, test particle insertion or
(re)calculation of energies. Normal mode analysis is another option. In
this case ` `{.docutils .literal .notranslate}[` mdrun `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} builds
a Hessian matrix from single conformation. For usual Normal Modes-like
calculations, make sure that the structure provided is properly
energy-minimized. The generated matrix can be diagonalized by .

The ` `{.docutils .literal .notranslate}[` mdrun `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} program reads
the run input file ( ` `{.docutils .literal
.notranslate}[` -s `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ) and
distributes the topology over ranks if needed. ` `{.docutils .literal
.notranslate}[` mdrun `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} produces at
least four output files. A single log file ( ` `{.docutils .literal
.notranslate}[` -g `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ) is written.
The trajectory file ( ` `{.docutils .literal
.notranslate}[` -o `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ), contains
coordinates, velocities and optionally forces. The structure file (
` `{.docutils .literal .notranslate}[` -c `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ) contains the
coordinates and velocities of the last step. The energy file (
` `{.docutils .literal .notranslate}[` -e `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ) contains
energies, the temperature, pressure, etc, a lot of these things are also
printed in the log file. Optionally coordinates can be written to a
compressed trajectory file ( ` `{.docutils .literal
.notranslate}[` -x `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ).

The option ` `{.docutils .literal .notranslate}[` -dhdl `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} is
only used when free energy calculation is turned on.

Running mdrun efficiently in parallel is a complex topic, many aspects
of which are covered in the online User Guide. You should look there for
practical advice on using many of the options available in mdrun.

ED (essential dynamics) sampling and/or additional flooding potentials
are switched on by using the ` `{.docutils .literal
.notranslate}[` -ei `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} flag followed
by an file. The file can be produced with the ` `{.docutils .literal
.notranslate}[` make_edi `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} tool or by
using options in the essdyn menu of the WHAT IF program. ` `{.docutils
.literal .notranslate}[` mdrun `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} produces a
output file that contains projections of positions, velocities and
forces onto selected eigenvectors.

When user-defined potential functions have been selected in the file the
` `{.docutils .literal .notranslate}[` -table `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} option is used
to pass ` `{.docutils .literal .notranslate}[` mdrun `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} a
formatted table with potential functions. The file is read from either
the current directory or from the ` `{.docutils .literal
.notranslate}[` GMXLIB `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} directory. A
number of pre-formatted tables are presented in the ` `{.docutils
.literal .notranslate}[` GMXLIB `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} dir, for 6-8,
6-9, 6-10, 6-11, 6-12 Lennard-Jones potentials with normal Coulomb. When
pair interactions are present, a separate table for pair interaction
functions is read using the ` `{.docutils .literal
.notranslate}[` -tablep `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} option.

When tabulated bonded functions are present in the topology, interaction
functions are read using the ` `{.docutils .literal
.notranslate}[` -tableb `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} option. For
each different tabulated interaction type used, a table file name must
be given. For the topology to work, a file name given here must match a
character sequence before the file extension. That sequence is: an
underscore, then a â€˜bâ€™ for bonds, an â€˜aâ€™ for angles or a â€˜dâ€™
for dihedrals, and finally the matching table number index used in the
topology. Note that, these options are deprecated, and in future will be
available via grompp.

The options ` `{.docutils .literal .notranslate}[` -px `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` -pf `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} are used for
writing pull COM coordinates and forces when pulling is selected in the
file.

The option ` `{.docutils .literal .notranslate}[` -membed `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} does
what used to be g_membed, i.e. embed a protein into a membrane. This
module requires a number of settings that are provided in a data file
that is the argument of this option. For more details in membrane
embedding, see the documentation in the user guide. The options
` `{.docutils .literal .notranslate}[` -mn `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` -mp `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} are used to
provide the index and topology files used for the embedding.

The option ` `{.docutils .literal .notranslate}[` -pforce `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} is
useful when you suspect a simulation crashes due to too large forces.
With this option coordinates and forces of atoms with a force larger
than a certain value will be printed to stderr. It will also terminate
the run when non-finite forces are present.

Checkpoints containing the complete state of the system are written at
regular intervals (option ` `{.docutils .literal
.notranslate}[` -cpt `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ) to the file
` `{.docutils .literal .notranslate}[` -cpo `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , unless option
` `{.docutils .literal .notranslate}[` -cpt `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} is set to -1.
The previous checkpoint is backed up to ` `{.docutils .literal
.notranslate}[` state_prev.cpt `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} to make sure
that a recent state of the system is always available, even when the
simulation is terminated while writing a checkpoint. With ` `{.docutils
.literal .notranslate}[` -cpnum `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} all checkpoint
files are kept and appended with the step number. A simulation can be
continued by reading the full state from file with option ` `{.docutils
.literal .notranslate}[` -cpi `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . This option
is intelligent in the way that if no checkpoint file is found, GROMACS
just assumes a normal run and starts from the first step of the file. By
default the output will be appending to the existing output files. The
checkpoint file contains checksums of all output files, such that you
will never loose data when some output files are modified, corrupt or
removed. There are three scenarios with ` `{.docutils .literal
.notranslate}[` -cpi `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} :

` `{.docutils .literal .notranslate}[` * `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} no files with
matching names are present: new output files are written

` `{.docutils .literal .notranslate}[` * `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} all files are
present with names and checksums matching those stored in the checkpoint
file: files are appended

` `{.docutils .literal .notranslate}[` * `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} otherwise no
files are modified and a fatal error is generated

With ` `{.docutils .literal .notranslate}[` -noappend `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} new
output files are opened and the simulation part number is added to all
output file names. Note that in all cases the checkpoint file itself is
not renamed and will be overwritten, unless its name does not match the
` `{.docutils .literal .notranslate}[` -cpo `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} option.

With checkpointing the output is appended to previously written output
files, unless ` `{.docutils .literal
.notranslate}[` -noappend `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} is used or none
of the previous output files are present (except for the checkpoint
file). The integrity of the files to be appended is verified using
checksums which are stored in the checkpoint file. This ensures that
output can not be mixed up or corrupted due to file appending. When only
some of the previous output files are present, a fatal error is
generated and no old output files are modified and no new output files
are opened. The result with appending will be the same as from a single
run. The contents will be binary identical, unless you use a different
number of ranks or dynamic load balancing or the FFT library uses
optimizations through timing.

With option ` `{.docutils .literal .notranslate}[` -maxh `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} a
simulation is terminated and a checkpoint file is written at the first
neighbor search step where the run time exceeds ` `{.docutils .literal
.notranslate}[` -maxh `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} \*0.99 hours.
This option is particularly useful in combination with setting
` `{.docutils .literal .notranslate}[` nsteps `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} to -1 either in
the mdp or using the similarly named command line option (although the
latter is deprecated). This results in an infinite run, terminated only
when the time limit set by ` `{.docutils .literal
.notranslate}[` -maxh `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} is reached (if
any) or upon receiving a signal.

Interactive molecular dynamics (IMD) can be activated by using at least
one of the three IMD switches: The ` `{.docutils .literal
.notranslate}[` -imdterm `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} switch allows
one to terminate the simulation from the molecular viewer (e.g. VMD).
With ` `{.docutils .literal .notranslate}[` -imdwait `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} ,
` `{.docutils .literal .notranslate}[` mdrun `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} pauses whenever
no IMD client is connected. Pulling from the IMD remote can be turned on
by ` `{.docutils .literal .notranslate}[` -imdpull `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . The port
` `{.docutils .literal .notranslate}[` mdrun `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} listens to can
be altered by ` `{.docutils .literal
.notranslate}[` -imdport `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} .The file
pointed to by ` `{.docutils .literal .notranslate}[` -if `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}
contains atom indices and forces if IMD pulling is used.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr\>\] (topol.tpr)

:   Portable xdr run input file

` `{.docutils .literal .notranslate}[` -cpi `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.cpt\>\] (state.cpt) (Optional)

:   Checkpoint file

` `{.docutils .literal .notranslate}[` -table `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (table.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -tablep `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (tablep.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -tableb `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\> \[â€¦\]\] (table.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -rerun `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (rerun.xtc) (Optional)

:   Trajectory:

` `{.docutils .literal .notranslate}[` -ei `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.edi\>\] (sam.edi) (Optional)

:   ED sampling input

` `{.docutils .literal .notranslate}[` -multidir `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<dir\> \[â€¦\]\] (rundir) (Optional)

:   Run directory

` `{.docutils .literal .notranslate}[` -awh `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (awhinit.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -membed `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.dat\>\] (membed.dat) (Optional)

:   Generic data file

` `{.docutils .literal .notranslate}[` -mp `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.top\>\] (membed.top) (Optional)

:   Topology file

` `{.docutils .literal .notranslate}[` -mn `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (membed.ndx) (Optional)

:   Index file

Options to specify output files:

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.trr/.cpt/â€¦\>\] (traj.trr)

:   Full precision trajectory:

` `{.docutils .literal .notranslate}[` -x `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.tng\>\] (traj_comp.xtc) (Optional)

:   Compressed trajectory (tng format or portable xdr format)

` `{.docutils .literal .notranslate}[` -cpo `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.cpt\>\] (state.cpt) (Optional)

:   Checkpoint file

` `{.docutils .literal .notranslate}[` -c `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.gro/.g96/â€¦\>\] (confout.gro)

:   Structure file: brk ent esp

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.edr\>\] (ener.edr)

:   Energy file

` `{.docutils .literal .notranslate}[` -g `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.log\>\] (md.log)

:   Log file

` `{.docutils .literal .notranslate}[` -dhdl `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (dhdl.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -field `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (field.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -tpi `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (tpi.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -tpid `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (tpidist.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -eo `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (edsam.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -px `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (pullx.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -pf `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (pullf.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -ro `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (rotation.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -ra `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.log\>\] (rotangles.log) (Optional)

:   Log file

` `{.docutils .literal .notranslate}[` -rs `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.log\>\] (rotslabs.log) (Optional)

:   Log file

` `{.docutils .literal .notranslate}[` -rt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.log\>\] (rottorque.log) (Optional)

:   Log file

` `{.docutils .literal .notranslate}[` -mtx `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.mtx\>\] (nm.mtx) (Optional)

:   Hessian matrix

` `{.docutils .literal .notranslate}[` -if `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (imdforces.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -swap `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (swapions.xvg) (Optional)

:   xvgr/xmgr file

Other options:

` `{.docutils .literal .notranslate}[` -deffnm `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<string\>

:   Set the default filename for all file options

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   xvg plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -dd `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<vector\> (0 0 0)

:   Domain decomposition grid, 0 is optimize

` `{.docutils .literal .notranslate}[` -ddorder `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (interleave)

:   DD rank order: interleave, pp_pme, cartesian

` `{.docutils .literal .notranslate}[` -npme `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (-1)

:   Number of separate ranks to be used for PME, -1 is guess

` `{.docutils .literal .notranslate}[` -nt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (0)

:   Total number of threads to start (0 is guess)

` `{.docutils .literal .notranslate}[` -ntmpi `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (0)

:   Number of thread-MPI ranks to start (0 is guess)

` `{.docutils .literal .notranslate}[` -ntomp `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (0)

:   Number of OpenMP threads per MPI rank to start (0 is guess)

` `{.docutils .literal .notranslate}[` -ntomp_pme `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (0)

:   Number of OpenMP threads per MPI rank to start (0 is -ntomp)

` `{.docutils .literal .notranslate}[` -pin `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (auto)

:   Whether mdrun should try to set thread affinities: auto, on, off

` `{.docutils .literal .notranslate}[` -pinoffset `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (0)

:   The lowest logical core number to which mdrun should pin the first
    thread

` `{.docutils .literal .notranslate}[` -pinstride `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (0)

:   Pinning distance in logical cores for threads, use 0 to minimize the
    number of threads per physical core

` `{.docutils .literal .notranslate}[` -gpu_id `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<string\>

:   List of unique GPU device IDs available to use

` `{.docutils .literal .notranslate}[` -gputasks `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<string\>

:   List of GPU device IDs, mapping each task on a node to a device.
    Tasks include PP and PME (if present).

` `{.docutils .literal .notranslate}[` -[no]ddcheck `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Check for all bonded interactions with DD

` `{.docutils .literal .notranslate}[` -rdd `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   The maximum distance for bonded interactions with DD (nm), 0 is
    determine from initial coordinates

` `{.docutils .literal .notranslate}[` -rcon `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Maximum distance for P-LINCS (nm), 0 is estimate

` `{.docutils .literal .notranslate}[` -dlb `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (auto)

:   Dynamic load balancing (with DD): auto, no, yes

` `{.docutils .literal .notranslate}[` -dds `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0.8)

:   Fraction in (0,1) by whose reciprocal the initial DD cell size will
    be increased in order to provide a margin in which dynamic load
    balancing can act while preserving the minimum cell size.

` `{.docutils .literal .notranslate}[` -nb `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (auto)

:   Calculate non-bonded interactions on: auto, cpu, gpu

` `{.docutils .literal .notranslate}[` -nstlist `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (0)

:   Set nstlist when using a Verlet buffer tolerance (0 is guess)

` `{.docutils .literal .notranslate}[` -[no]tunepme `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Optimize PME load between PP/PME ranks or GPU/CPU

` `{.docutils .literal .notranslate}[` -pme `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (auto)

:   Perform PME calculations on: auto, cpu, gpu

` `{.docutils .literal .notranslate}[` -pmefft `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (auto)

:   Perform PME FFT calculations on: auto, cpu, gpu

` `{.docutils .literal .notranslate}[` -bonded `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (auto)

:   Perform bonded calculations on: auto, cpu, gpu

` `{.docutils .literal .notranslate}[` -update `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (auto)

:   Perform update and constraints on: auto, cpu, gpu

` `{.docutils .literal .notranslate}[` -[no]v `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Be loud and noisy

` `{.docutils .literal .notranslate}[` -pforce `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (-1)

:   Print all forces larger than this (kJ/mol nm)

` `{.docutils .literal .notranslate}[` -[no]reprod `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Avoid optimizations that affect binary reproducibility; this can
    significantly reduce performance

` `{.docutils .literal .notranslate}[` -cpt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (15)

:   Checkpoint interval (minutes)

` `{.docutils .literal .notranslate}[` -[no]cpnum `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Keep and number checkpoint files

` `{.docutils .literal .notranslate}[` -[no]append `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Append to previous output files when continuing from checkpoint
    instead of adding the simulation part number to all file names

` `{.docutils .literal .notranslate}[` -nsteps `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (-2)

:   Run this number of steps (-1 means infinite, -2 means use mdp
    option, smaller is invalid)

` `{.docutils .literal .notranslate}[` -maxh `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (-1)

:   Terminate after 0.99 times this time (hours)

` `{.docutils .literal .notranslate}[` -replex `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (0)

:   Attempt replica exchange periodically with this period (steps)

` `{.docutils .literal .notranslate}[` -nex `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (0)

:   Number of random exchanges to carry out each exchange interval (N\^3
    is one suggestion). -nex zero or not specified gives neighbor
    replica exchange.

` `{.docutils .literal .notranslate}[` -reseed `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (-1)

:   Seed for replica exchange, -1 is generate a seed
:::
:::
::: {#gmx-mindist .section}
[ ]{#id1}

# gmx mindist

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx mindist [-f [<.xtc/.trr/...>]] [-s [<.tpr/.gro/...>]] [-n [<.ndx>]]
            [-od [<.xvg>]] [-on [<.xvg>]] [-o [<.out>]]
            [-ox [<.xtc/.trr/...>]] [-or [<.xvg>]] [-b <time>]
            [-e <time>] [-dt <time>] [-tu <enum>] [-[no]w]
            [-xvg <enum>] [-[no]matrix] [-[no]max] [-d <real>]
            [-[no]group] [-[no]pi] [-[no]split] [-ng <int>]
            [-[no]pbc] [-[no]respertime] [-[no]printresname]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` mindist `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} computes the
distance between one group and a number of other groups. Both the
minimum distance (between any pair of atoms from the respective groups)
and the number of contacts within a given distance are written to two
separate output files. With the ` `{.docutils .literal
.notranslate}[` -group `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} option a
contact of an atom in another group with multiple atoms in the first
group is counted as one contact instead of as multiple contacts. With
` `{.docutils .literal .notranslate}[` -or `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , minimum
distances to each residue in the first group are determined and plotted
as a function of residue number.

With option ` `{.docutils .literal .notranslate}[` -pi `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} the
minimum distance of a group to its periodic image is plotted. This is
useful for checking if a protein has seen its periodic image during a
simulation. Only one shift in each direction is considered, giving a
total of 26 shifts. Note that periodicity information is required from
the file supplied with with ` `{.docutils .literal
.notranslate}[` -s `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , either as a
.tpr file or a .pdb file with CRYST1 fields. It also plots the maximum
distance within the group and the lengths of the three box vectors.

Also and calculate distances.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (traj.xtc)

:   Trajectory:

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr/.gro/â€¦\>\] (topol.tpr) (Optional)

:   Structure+mass(db): brk ent

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx) (Optional)

:   Index file

Options to specify output files:

` `{.docutils .literal .notranslate}[` -od `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (mindist.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -on `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (numcont.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.out\>\] (atm-pair.out) (Optional)

:   Generic output file

` `{.docutils .literal .notranslate}[` -ox `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (mindist.xtc) (Optional)

:   Trajectory:

` `{.docutils .literal .notranslate}[` -or `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (mindistres.xvg) (Optional)

:   xvgr/xmgr file

Other options:

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of first frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of last frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -dt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Only use frame when t MOD dt = first time (default unit ps)

` `{.docutils .literal .notranslate}[` -tu `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (ps)

:   Unit for time values: fs, ps, ns, us, ms, s

` `{.docutils .literal .notranslate}[` -[no]w `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   View output , , and files

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   xvg plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -[no]matrix `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Calculate half a matrix of group-group distances

` `{.docutils .literal .notranslate}[` -[no]max `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Calculate *maximum* distance instead of minimum

` `{.docutils .literal .notranslate}[` -d `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0.6)

:   Distance for contacts

` `{.docutils .literal .notranslate}[` -[no]group `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Count contacts with multiple atoms in the first group as one

` `{.docutils .literal .notranslate}[` -[no]pi `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Calculate minimum distance with periodic images

` `{.docutils .literal .notranslate}[` -[no]split `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Split graph where time is zero

` `{.docutils .literal .notranslate}[` -ng `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (1)

:   Number of secondary groups to compute distance to a central group

` `{.docutils .literal .notranslate}[` -[no]pbc `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Take periodic boundary conditions into account

` `{.docutils .literal .notranslate}[` -[no]respertime `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   When writing per-residue distances, write distance for each time
    point

` `{.docutils .literal .notranslate}[` -[no]printresname `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Write residue names
:::
:::
::: {#gmx-mk-angndx .section}
[ ]{#id1}

# gmx mk_angndx

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx mk_angndx [-s [<.tpr>]] [-n [<.ndx>]] [-type <enum>] [-[no]hyd]
             [-hq <real>]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` mk_angndx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} makes an index
file for calculation of angle distributions etc. It uses a run input
file (.tpx) for the definitions of the angles, dihedrals etc.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr\>\] (topol.tpr)

:   Portable xdr run input file

Options to specify output files:

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (angle.ndx)

:   Index file

Other options:

` `{.docutils .literal .notranslate}[` -type `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (angle)

:   Type of angle: angle, dihedral, improper, ryckaert-bellemans

` `{.docutils .literal .notranslate}[` -[no]hyd `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Include angles with atoms with mass \< 1.5

` `{.docutils .literal .notranslate}[` -hq `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (-1)

:   Ignore angles with atoms with mass \< 1.5 and magnitude of their
    charge less than this value
:::
:::
::: {#gmx-msd .section}
[ ]{#id1}

# gmx msd

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx msd [-f [<.xtc/.trr/...>]] [-s [<.tpr/.gro/...>]] [-n [<.ndx>]]
        [-o [<.xvg>]] [-mol [<.xvg>]] [-b <time>] [-e <time>]
        [-dt <time>] [-tu <enum>] [-fgroup <selection>] [-xvg <enum>]
        [-[no]rmpbc] [-[no]pbc] [-sf <file>] [-selrpos <enum>]
        [-seltype <enum>] [-sel <selection>] [-type <enum>]
        [-lateral <enum>] [-trestart <real>] [-maxtau <real>]
        [-beginfit <real>] [-endfit <real>]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` msd `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} computes the
mean square displacement (MSD) of atoms from a set of initial positions.
This provides an easy way to compute the diffusion constant using the
Einstein relation. The time between the reference points for the MSD
calculation is set with ` `{.docutils .literal
.notranslate}[` -trestart `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . The diffusion
constant is calculated by least squares fitting a straight line (D\*t +
c) through the MSD(t) from ` `{.docutils .literal
.notranslate}[` -beginfit `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} to
` `{.docutils .literal .notranslate}[` -endfit `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} (note that t is
time from the reference positions, not simulation time). An error
estimate given, which is the difference of the diffusion coefficients
obtained from fits over the two halves of the fit interval.

There are three, mutually exclusive, options to determine different
types of mean square displacement: ` `{.docutils .literal
.notranslate}[` -type `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , ` `{.docutils
.literal .notranslate}[` -lateral `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` -ten `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . Option
` `{.docutils .literal .notranslate}[` -ten `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} writes the full
MSD tensor for each group, the order in the output is: trace xx yy zz yx
zx zy.

If ` `{.docutils .literal .notranslate}[` -mol `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} is set,
` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` msd `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} plots the MSD
for individual molecules (including making molecules whole across
periodic boundaries): for each individual molecule a diffusion constant
is computed for its center of mass. The chosen index group will be split
into molecules. With -mol, only one index group can be selected.

The diffusion coefficient is determined by linear regression of the MSD.
When ` `{.docutils .literal .notranslate}[` -beginfit `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} is -1,
fitting starts at 10% and when ` `{.docutils .literal
.notranslate}[` -endfit `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} is -1, fitting
goes to 90%. Using this option one also gets an accurate error estimate
based on the statistics between individual molecules. Note that this
diffusion coefficient and error estimate are only accurate when the MSD
is completely linear between ` `{.docutils .literal
.notranslate}[` -beginfit `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` -endfit `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} .

By default, ` `{.docutils .literal .notranslate}[` gmx `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` msd `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} compares all
trajectory frames against every frame stored at ` `{.docutils .literal
.notranslate}[` -trestart `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} intervals, so
the number of frames stored scales linearly with the number of frames
processed. This can lead to long analysis times and out-of-memory errors
for long/large trajectories, and often the data at higher time deltas
lacks sufficient sampling, often manifesting as a wobbly line on the MSD
plot after a straighter region at lower time deltas. The ` `{.docutils
.literal .notranslate}[` -maxtau `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} option can be
used to cap the maximum time delta for frame comparison, which may
improve performance and can be used to avoid out-of-memory issues.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (traj.xtc) (Optional)

:   Input trajectory or single configuration:

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr/.gro/â€¦\>\] (topol.tpr) (Optional)

:   Input structure: brk ent

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx) (Optional)

:   Extra index groups

Options to specify output files:

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (msdout.xvg) (Optional)

:   MSD output

` `{.docutils .literal .notranslate}[` -mol `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (diff_mol.xvg) (Optional)

:   Report diffusion coefficients for each molecule in selection

Other options:

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   First frame (ps) to read from trajectory

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Last frame (ps) to read from trajectory

` `{.docutils .literal .notranslate}[` -dt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Only use frame if t MOD dt == first time (ps)

` `{.docutils .literal .notranslate}[` -tu `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (ps)

:   Unit for time values: fs, ps, ns, us, ms, s

` `{.docutils .literal .notranslate}[` -fgroup `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<selection\>

:   Atoms stored in the trajectory file (if not set, assume first N
    atoms)

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   Plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -[no]rmpbc `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Make molecules whole for each frame

` `{.docutils .literal .notranslate}[` -[no]pbc `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Use periodic boundary conditions for distance calculation

` `{.docutils .literal .notranslate}[` -sf `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<file\>

:   Provide selections from files

` `{.docutils .literal .notranslate}[` -selrpos `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (atom)

:   Selection reference positions: atom, res_com, res_cog, mol_com,
    mol_cog, whole_res_com, whole_res_cog, whole_mol_com, whole_mol_cog,
    part_res_com, part_res_cog, part_mol_com, part_mol_cog, dyn_res_com,
    dyn_res_cog, dyn_mol_com, dyn_mol_cog

` `{.docutils .literal .notranslate}[` -seltype `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (atom)

:   Default selection output positions: atom, res_com, res_cog, mol_com,
    mol_cog, whole_res_com, whole_res_cog, whole_mol_com, whole_mol_cog,
    part_res_com, part_res_cog, part_mol_com, part_mol_cog, dyn_res_com,
    dyn_res_cog, dyn_mol_com, dyn_mol_cog

` `{.docutils .literal .notranslate}[` -sel `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<selection\>

:   Selections to compute MSDs for from the reference

` `{.docutils .literal .notranslate}[` -type `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (unused)

:   : x, y, z, unused

` `{.docutils .literal .notranslate}[` -lateral `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (unused)

:   : x, y, z, unused

` `{.docutils .literal .notranslate}[` -trestart `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (10)

:   Time between restarting points in trajectory (ps)

` `{.docutils .literal .notranslate}[` -maxtau `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (1.79769e+308)

:   Maximum time delta between frames to calculate MSDs for (ps)

` `{.docutils .literal .notranslate}[` -beginfit `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (-1)

:   Time point at which to start fitting.

` `{.docutils .literal .notranslate}[` -endfit `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (-1)

:   End time for fitting.
:::
:::
::: {#gmx-nmeig .section}
[ ]{#id1}

# gmx nmeig

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx nmeig [-f [<.mtx>]] [-s [<.tpr>]] [-of [<.xvg>]] [-ol [<.xvg>]]
          [-os [<.xvg>]] [-qc [<.xvg>]] [-v [<.trr/.cpt/...>]]
          [-xvg <enum>] [-[no]m] [-first <int>] [-last <int>]
          [-maxspec <int>] [-T <real>] [-P <real>] [-sigma <int>]
          [-scale <real>] [-linear_toler <real>] [-[no]constr]
          [-width <real>]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` nmeig `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} calculates the
eigenvectors/values of a (Hessian) matrix, which can be calculated with
. The eigenvectors are written to a trajectory file ( ` `{.docutils
.literal .notranslate}[` -v `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ). The
structure is written first with t=0. The eigenvectors are written as
frames with the eigenvector number and eigenvalue written as step number
and timestamp, respectively. The eigenvectors can be analyzed with . An
ensemble of structures can be generated from the eigenvectors with .
When mass weighting is used, the generated eigenvectors will be scaled
back to plain Cartesian coordinates before generating the output. In
this case, they will no longer be exactly orthogonal in the standard
Cartesian norm, but in the mass-weighted norm they would be.

This program can be optionally used to compute quantum corrections to
heat capacity and enthalpy by providing an extra file argument
` `{.docutils .literal .notranslate}[` -qcorr `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . See the
GROMACS manual, Chapter 1, for details. The result includes subtracting
a harmonic degree of freedom at the given temperature. The total
correction is printed on the terminal screen. The recommended way of
getting the corrections out is:

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` nmeig `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` -s `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` topol.tpr `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` -f `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` nm.mtx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` -first `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate}[` 7 `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` -last `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` 10000 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` -T `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` 300 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` -qc `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` [-constr] `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate}

The ` `{.docutils .literal .notranslate}[` -constr `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} option should
be used when bond constraints were used during the simulation **for all
the covalent bonds** . If this is not the case, you need to analyze the
` `{.docutils .literal .notranslate}[` quant_corr.xvg `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} file
yourself.

To make things more flexible, the program can also take virtual sites
into account when computing quantum corrections. When selecting
` `{.docutils .literal .notranslate}[` -constr `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` -qc `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , the
` `{.docutils .literal .notranslate}[` -begin `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` -end `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} options will be
set automatically as well.

Based on a harmonic analysis of the normal mode frequencies,
thermochemical properties S0 (Standard Entropy), Cv (Heat capacity at
constant volume), Zero-point energy and the internal energy are
computed, much in the same manner as popular quantum chemistry programs.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.mtx\>\] (hessian.mtx)

:   Hessian matrix

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr\>\] (topol.tpr)

:   Portable xdr run input file

Options to specify output files:

` `{.docutils .literal .notranslate}[` -of `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (eigenfreq.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -ol `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (eigenval.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -os `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (spectrum.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -qc `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (quant_corr.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -v `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.trr/.cpt/â€¦\>\] (eigenvec.trr)

:   Full precision trajectory:

Other options:

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   xvg plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -[no]m `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Divide elements of Hessian by product of sqrt(mass) of involved
    atoms prior to diagonalization. This should be used for â€˜Normal
    Modesâ€™ analysis

` `{.docutils .literal .notranslate}[` -first `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (1)

:   First eigenvector to write away

` `{.docutils .literal .notranslate}[` -last `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (50)

:   Last eigenvector to write away. -1 is use all dimensions.

` `{.docutils .literal .notranslate}[` -maxspec `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (4000)

:   Highest frequency (1/cm) to consider in the spectrum

` `{.docutils .literal .notranslate}[` -T `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (298.15)

:   Temperature for computing entropy, quantum heat capacity and
    enthalpy when using normal mode calculations to correct classical
    simulations

` `{.docutils .literal .notranslate}[` -P `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (1)

:   Pressure (bar) when computing entropy

` `{.docutils .literal .notranslate}[` -sigma `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (1)

:   Number of symmetric copies used when computing entropy. E.g. for
    water the number is 2, for NH3 it is 3 and for methane it is 12.

` `{.docutils .literal .notranslate}[` -scale `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (1)

:   Factor to scale frequencies before computing thermochemistry values

` `{.docutils .literal .notranslate}[` -linear_toler `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (1e-05)

:   Tolerance for determining whether a compound is linear as determined
    from the ration of the moments inertion Ix/Iy and Ix/Iz.

` `{.docutils .literal .notranslate}[` -[no]constr `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   If constraints were used in the simulation but not in the normal
    mode analysis you will need to set this for computing the quantum
    corrections.

` `{.docutils .literal .notranslate}[` -width `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (1)

:   Width (sigma) of the gaussian peaks (1/cm) when generating a
    spectrum
:::
:::
::: {#gmx-nmens .section}
[ ]{#id1}

# gmx nmens

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx nmens [-v [<.trr/.cpt/...>]] [-e [<.xvg>]] [-s [<.tpr/.gro/...>]]
          [-n [<.ndx>]] [-o [<.xtc/.trr/...>]] [-xvg <enum>]
          [-temp <real>] [-seed <int>] [-num <int>] [-first <int>]
          [-last <int>]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` nmens `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} generates an
ensemble around an average structure in a subspace that is defined by a
set of normal modes (eigenvectors). The eigenvectors are assumed to be
mass-weighted. The position along each eigenvector is randomly taken
from a Gaussian distribution with variance kT/eigenvalue.

By default the starting eigenvector is set to 7, since the first six
normal modes are the translational and rotational degrees of freedom.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -v `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.trr/.cpt/â€¦\>\] (eigenvec.trr)

:   Full precision trajectory:

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (eigenval.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr/.gro/â€¦\>\] (topol.tpr)

:   Structure+mass(db): brk ent

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx) (Optional)

:   Index file

Options to specify output files:

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (ensemble.xtc)

:   Trajectory:

Other options:

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   xvg plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -temp `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (300)

:   Temperature in Kelvin

` `{.docutils .literal .notranslate}[` -seed `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (0)

:   Random seed (0 means generate)

` `{.docutils .literal .notranslate}[` -num `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (100)

:   Number of structures to generate

` `{.docutils .literal .notranslate}[` -first `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (7)

:   First eigenvector to use (-1 is select)

` `{.docutils .literal .notranslate}[` -last `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (-1)

:   Last eigenvector to use (-1 is till the last)
:::
:::
::: {#gmx-nmr .section}
[ ]{#id1}

# gmx nmr

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx nmr [-f [<.edr>]] [-f2 [<.edr>]] [-s [<.tpr>]] [-viol [<.xvg>]]
        [-pairs [<.xvg>]] [-ora [<.xvg>]] [-ort [<.xvg>]]
        [-oda [<.xvg>]] [-odr [<.xvg>]] [-odt [<.xvg>]]
        [-oten [<.xvg>]] [-b <time>] [-e <time>] [-[no]w]
        [-xvg <enum>] [-[no]dp] [-skip <int>] [-[no]aver]
        [-[no]orinst] [-[no]ovec]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` nmr `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} extracts
distance or orientation restraint data from an energy file. The user is
prompted to interactively select the desired terms.

When the ` `{.docutils .literal .notranslate}[` -viol `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} option
is set, the time averaged violations are plotted and the running
time-averaged and instantaneous sum of violations are recalculated.
Additionally running time-averaged and instantaneous distances between
selected pairs can be plotted with the ` `{.docutils .literal
.notranslate}[` -pairs `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} option.

Options ` `{.docutils .literal .notranslate}[` -ora `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , ` `{.docutils
.literal .notranslate}[` -ort `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , ` `{.docutils
.literal .notranslate}[` -oda `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , ` `{.docutils
.literal .notranslate}[` -odr `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` -odt `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} are used for
analyzing orientation restraint data. The first two options plot the
orientation, the last three the deviations of the orientations from the
experimental values. The options that end on an â€˜aâ€™ plot the average
over time as a function of restraint. The options that end on a â€˜tâ€™
prompt the user for restraint label numbers and plot the data as a
function of time. Option ` `{.docutils .literal
.notranslate}[` -odr `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} plots the RMS
deviation as a function of restraint. When the run used time or ensemble
averaged orientation restraints, option ` `{.docutils .literal
.notranslate}[` -orinst `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} can be used to
analyse the instantaneous, not ensemble-averaged orientations and
deviations instead of the time and ensemble averages.

Option ` `{.docutils .literal .notranslate}[` -oten `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} plots the
eigenvalues of the molecular order tensor for each orientation restraint
experiment. With option ` `{.docutils .literal
.notranslate}[` -ovec `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} also the
eigenvectors are plotted.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.edr\>\] (ener.edr)

:   Energy file

` `{.docutils .literal .notranslate}[` -f2 `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.edr\>\] (ener.edr) (Optional)

:   Energy file

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr\>\] (topol.tpr) (Optional)

:   Portable xdr run input file

Options to specify output files:

` `{.docutils .literal .notranslate}[` -viol `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (violaver.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -pairs `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (pairs.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -ora `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (orienta.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -ort `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (orientt.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -oda `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (orideva.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -odr `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (oridevr.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -odt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (oridevt.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -oten `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (oriten.xvg) (Optional)

:   xvgr/xmgr file

Other options:

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of first frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of last frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -[no]w `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   View output , , and files

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   xvg plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -[no]dp `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Print energies in high precision

` `{.docutils .literal .notranslate}[` -skip `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (0)

:   Skip number of frames between data points

` `{.docutils .literal .notranslate}[` -[no]aver `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Also print the exact average and rmsd stored in the energy frames
    (only when 1 term is requested)

` `{.docutils .literal .notranslate}[` -[no]orinst `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Analyse instantaneous orientation data

` `{.docutils .literal .notranslate}[` -[no]ovec `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Also plot the eigenvectors with ` `{.docutils .literal
    .notranslate}[` -oten `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate}
:::
:::
::: {#gmx-nmtraj .section}
[ ]{#id1}

# gmx nmtraj

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx nmtraj [-s [<.tpr/.gro/...>]] [-v [<.trr/.cpt/...>]]
           [-o [<.xtc/.trr/...>]] [-eignr <string>]
           [-phases <string>] [-temp <real>] [-amplitude <real>]
           [-nframes <int>]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` nmtraj `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} generates an
virtual trajectory from an eigenvector, corresponding to a harmonic
Cartesian oscillation around the average structure. The eigenvectors
should normally be mass-weighted, but you can use non-weighted
eigenvectors to generate orthogonal motions. The output frames are
written as a trajectory file covering an entire period, and the first
frame is the average structure. If you write the trajectory in (or
convert to) PDB format you can view it directly in PyMol and also render
a photorealistic movie. Motion amplitudes are calculated from the
eigenvalues and a preset temperature, assuming equipartition of the
energy over all modes. To make the motion clearly visible in PyMol you
might want to amplify it by setting an unrealistically high temperature.
However, be aware that both the linear Cartesian displacements and mass
weighting will lead to serious structure deformation for high
amplitudes - this is is simply a limitation of the Cartesian normal mode
model. By default the selected eigenvector is set to 7, since the first
six normal modes are the translational and rotational degrees of
freedom.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr/.gro/â€¦\>\] (topol.tpr)

:   Structure+mass(db): brk ent

` `{.docutils .literal .notranslate}[` -v `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.trr/.cpt/â€¦\>\] (eigenvec.trr)

:   Full precision trajectory:

Options to specify output files:

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (nmtraj.xtc)

:   Trajectory:

Other options:

` `{.docutils .literal .notranslate}[` -eignr `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<string\> (7)

:   String of eigenvectors to use (first is 1)

` `{.docutils .literal .notranslate}[` -phases `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<string\> (0.0)

:   String of phases (default is 0.0)

` `{.docutils .literal .notranslate}[` -temp `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (300)

:   Temperature (K)

` `{.docutils .literal .notranslate}[` -amplitude `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0.25)

:   Amplitude for modes with eigenvalue\<=0

` `{.docutils .literal .notranslate}[` -nframes `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (30)

:   Number of frames to generate
:::
:::
::: {#gmx-nonbonded-benchmark .section}
[ ]{#id1}

# gmx nonbonded-benchmark

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx nonbonded-benchmark [-o [<.csv>]] [-size <int>] [-nt <int>]
             [-simd <enum>] [-coulomb <enum>] [-[no]table]
             [-combrule <enum>] [-[no]halflj] [-[no]energy]
             [-[no]all] [-cutoff <real>] [-iter <int>]
             [-warmup <int>] [-[no]cycles] [-[no]time]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` nonbonded-benchmark `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} runs benchmarks
for one or more so-called Nbnxm non-bonded pair kernels. The non-bonded
pair kernels are the most compute intensive part of MD simulations and
usually comprise 60 to 90 percent of the runtime. For this reason they
are highly optimized and several different setups are available to
compute the same physical interactions. In addition, there are different
physical treatments of Coulomb interactions and optimizations for atoms
without Lennard-Jones interactions. There are also different physical
treatments of Lennard-Jones interactions, but only a plain cut-off is
supported in this tool, as that is by far the most common treatment. And
finally, while force output is always necessary, energy output is only
required at certain steps. In total there are 12 relevant combinations
of options. The combinations double to 24 when two different SIMD setups
are supported. These combinations can be run with a single invocation
using the ` `{.docutils .literal .notranslate}[` -all `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}
option. The behavior of each kernel is affected by caching behavior,
which is determined by the hardware used together with the system size
and the cut-off radius. The larger the number of atoms per thread, the
more L1 cache is needed to avoid L1 cache misses. The cut-off radius
mainly affects the data reuse: a larger cut-off results in more data
reuse and makes the kernel less sensitive to cache misses.

OpenMP parallelization is used to utilize multiple hardware threads
within a compute node. In these benchmarks there is no interaction
between threads, apart from starting and closing a single OpenMP
parallel region per iteration. Additionally, threads interact through
sharing and evicting data from shared caches. The number of threads to
use is set with the ` `{.docutils .literal
.notranslate}[` -nt `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} option. Thread
affinity is important, especially with SMT and shared caches. Affinities
can be set through the OpenMP library using the GOMP_CPU_AFFINITY
environment variable.

The benchmark tool times one or more kernels by running them repeatedly
for a number of iterations set by the ` `{.docutils .literal
.notranslate}[` -iter `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} option. An
initial kernel call is done to avoid additional initial cache misses.
Times are recording in cycles read from efficient, high accuracy
counters in the CPU. Note that these often do not correspond to actual
clock cycles. For each kernel, the tool reports the total number of
cycles, cycles per iteration, and (total and useful) pair interactions
per cycle. Because a cluster pair list is used instead of an atom pair
list, interactions are also computed for some atom pairs that are beyond
the cut-off distance. These pairs are not useful (except for additional
buffering, but that is not of interest here), only a side effect of the
cluster-pair setup. The SIMD 2xMM kernel has a higher useful pair ratio
then the 4xM kernel due to a smaller cluster size, but a lower total
pair throughput. It is best to run this, or for that matter any,
benchmark with locked CPU clocks, as thermal throttling can
significantly affect performance. If that is not an option, the
` `{.docutils .literal .notranslate}[` -warmup `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} option can be
used to run initial, untimed iterations to warm up the processor.

The most relevant regime is between 0.1 to 1 millisecond per iteration.
Thus it is useful to run with system sizes that cover both ends of this
regime.

The ` `{.docutils .literal .notranslate}[` -simd `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` -table `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} options select
different implementations to compute the same physics. The choice of
these options should ideally be optimized for the target hardware.
Historically, we only found tabulated Ewald correction to be useful on
2-wide SIMD or 4-wide SIMD without FMA support. As all modern
architectures are wider and support FMA, we do not use tables by
default. The only exceptions are kernels without SIMD, which only
support tables. Options ` `{.docutils .literal
.notranslate}[` -coulomb `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , ` `{.docutils
.literal .notranslate}[` -combrule `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` -halflj `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} depend on the
force field and composition of the simulated system. The optimization of
computing Lennard-Jones interactions for only half of the atoms in a
cluster is useful for water, which does not use Lennard-Jones on
hydrogen atoms in most water models. In the MD engine, any clusters
where at most half of the atoms have LJ interactions will automatically
use this kernel. And finally, the ` `{.docutils .literal
.notranslate}[` -energy `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} option selects
the computation of energies, which are usually only needed infrequently.
:::

::: {#options .section}
## Options

Options to specify output files:

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.csv\>\] (nonbonded-benchmark.csv) (Optional)

:   Also output results in csv format

Other options:

` `{.docutils .literal .notranslate}[` -size `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (1)

:   The system size is 3000 atoms times this value

` `{.docutils .literal .notranslate}[` -nt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (1)

:   The number of OpenMP threads to use

` `{.docutils .literal .notranslate}[` -simd `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (auto)

:   SIMD type, auto runs all supported SIMD setups or no SIMD when SIMD
    is not supported: auto, no, 4xm, 2xmm

` `{.docutils .literal .notranslate}[` -coulomb `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (ewald)

:   The functional form for the Coulomb interactions: ewald,
    reaction-field

` `{.docutils .literal .notranslate}[` -[no]table `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Use lookup table for Ewald correction instead of analytical

` `{.docutils .literal .notranslate}[` -combrule `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (geometric)

:   The LJ combination rule: geometric, lb, none

` `{.docutils .literal .notranslate}[` -[no]halflj `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Use optimization for LJ on half of the atoms

` `{.docutils .literal .notranslate}[` -[no]energy `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Compute energies in addition to forces

` `{.docutils .literal .notranslate}[` -[no]all `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Run all 12 combinations of options for coulomb, halflj, combrule

` `{.docutils .literal .notranslate}[` -cutoff `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (1)

:   Pair-list and interaction cut-off distance

` `{.docutils .literal .notranslate}[` -iter `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (100)

:   The number of iterations for each kernel

` `{.docutils .literal .notranslate}[` -warmup `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (0)

:   The number of iterations for initial warmup

` `{.docutils .literal .notranslate}[` -[no]cycles `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Report cycles/pair instead of pairs/cycle

` `{.docutils .literal .notranslate}[` -[no]time `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Report micro-seconds instead of cycles
:::
:::
::: {#gmx-order .section}
[ ]{#id1}

# gmx order

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx order [-f [<.xtc/.trr/...>]] [-n [<.ndx>]] [-nr [<.ndx>]]
          [-s [<.tpr>]] [-o [<.xvg>]] [-od [<.xvg>]] [-ob [<.pdb>]]
          [-os [<.xvg>]] [-Sg [<.xvg>]] [-Sk [<.xvg>]]
          [-Sgsl [<.xvg>]] [-Sksl [<.xvg>]] [-b <time>] [-e <time>]
          [-dt <time>] [-[no]w] [-xvg <enum>] [-d <enum>] [-sl <int>]
          [-[no]szonly] [-[no]permolecule] [-[no]radial]
          [-[no]calcdist]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` order `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} computes the
order parameter per atom for carbon tails. For atom i the vector i-1,
i+1 is used together with an axis. The index file should contain only
the groups to be used for calculations, with each group of equivalent
carbons along the relevant acyl chain in its own group. There should not
be any generic groups (like System, Protein) in the index file to avoid
confusing the program (this is not relevant to tetrahedral order
parameters however, which only work for water anyway).

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` order `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} can also give
all diagonal elements of the order tensor and even calculate the
deuterium order parameter Scd (default). If the option ` `{.docutils
.literal .notranslate}[` -szonly `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} is given, only
one order tensor component (specified by the ` `{.docutils .literal
.notranslate}[` -d `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} option) is
given and the order parameter per slice is calculated as well. If
` `{.docutils .literal .notranslate}[` -szonly `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} is not
selected, all diagonal elements and the deuterium order parameter is
given.

The tetrahedrality order parameters can be determined around an atom.
Both angle an distance order parameters are calculated. See P.-L. Chau
and A.J. Hardwick, Mol. Phys., 93, (1998), 511-518. for more details.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (traj.xtc)

:   Trajectory:

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx)

:   Index file

` `{.docutils .literal .notranslate}[` -nr `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx) (Optional)

:   Index file

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr\>\] (topol.tpr)

:   Portable xdr run input file

Options to specify output files:

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (order.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -od `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (deuter.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -ob `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.pdb\>\] (eiwit.pdb) (Optional)

:   Protein data bank file

` `{.docutils .literal .notranslate}[` -os `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (sliced.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -Sg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (sg-ang.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -Sk `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (sk-dist.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -Sgsl `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (sg-ang-slice.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -Sksl `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (sk-dist-slice.xvg) (Optional)

:   xvgr/xmgr file

Other options:

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of first frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of last frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -dt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Only use frame when t MOD dt = first time (default unit ps)

` `{.docutils .literal .notranslate}[` -[no]w `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   View output , , and files

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   xvg plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -d `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (z)

:   Direction of the normal on the membrane: z, x, y

` `{.docutils .literal .notranslate}[` -sl `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (1)

:   Calculate order parameter as function of box length, dividing the
    box into this number of slices.

` `{.docutils .literal .notranslate}[` -[no]szonly `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Only give Sz element of order tensor. (axis can be specified with
    ` `{.docutils .literal .notranslate}[` -d `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} )

` `{.docutils .literal .notranslate}[` -[no]permolecule `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Compute per-molecule Scd order parameters

` `{.docutils .literal .notranslate}[` -[no]radial `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Compute a radial membrane normal

` `{.docutils .literal .notranslate}[` -[no]calcdist `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Compute distance from a reference
:::

::: {#known-issues .section}
## Known Issues

-   This tool only works for saturated carbons and united atom force
    fields.

-   For anything else, it is highly recommended to use a different
    analysis method!

-   The option ` `{.docutils .literal .notranslate}[` -unsat `{.docutils
    .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}
    claimed to do analysis for unsaturated carbons

-   this but hasnâ€™t worked ever since it was added and has thus been
    removed.
:::
:::
::: {#gmx-pairdist .section}
[ ]{#id1}

# gmx pairdist

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx pairdist [-f [<.xtc/.trr/...>]] [-s [<.tpr/.gro/...>]] [-n [<.ndx>]]
             [-o [<.xvg>]] [-b <time>] [-e <time>] [-dt <time>]
             [-tu <enum>] [-fgroup <selection>] [-xvg <enum>]
             [-[no]rmpbc] [-[no]pbc] [-sf <file>] [-selrpos <enum>]
             [-seltype <enum>] [-cutoff <real>] [-type <enum>]
             [-refgrouping <enum>] [-selgrouping <enum>]
             [-ref <selection>] [-sel <selection>]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` pairdist `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} calculates
pairwise distances between one reference selection (given with
` `{.docutils .literal .notranslate}[` -ref `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ) and one or
more other selections (given with ` `{.docutils .literal
.notranslate}[` -sel `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ). It can
calculate either the minimum distance (the default), or the maximum
distance (with ` `{.docutils .literal .notranslate}[` -type `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` max `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ). Distances to
each selection provided with ` `{.docutils .literal
.notranslate}[` -sel `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} are computed
independently.

By default, the global minimum/maximum distance is computed. To compute
more distances (e.g., minimum distances to each residue in ` `{.docutils
.literal .notranslate}[` -ref `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ), use
` `{.docutils .literal .notranslate}[` -refgrouping `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and/or
` `{.docutils .literal .notranslate}[` -selgrouping `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} to specify how
the positions within each selection should be grouped.

Computed distances are written to the file specified with ` `{.docutils
.literal .notranslate}[` -o `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . If there are
N groups in ` `{.docutils .literal .notranslate}[` -ref `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} and M
groups in the first selection in ` `{.docutils .literal
.notranslate}[` -sel `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , then the
output contains N\*M columns for the first selection. The columns
contain distances like this: r1-s1, r2-s1, â€¦, r1-s2, r2-s2, â€¦, where
rn is the nâ€™th group in ` `{.docutils .literal
.notranslate}[` -ref `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and sn is the
nâ€™th group in the other selection. The distances for the second
selection comes as separate columns after the first selection, and so
on. If some selections are dynamic, only the selected positions are used
in the computation but the same number of columns is always written out.
If there are no positions contributing to some group pair, then the
cutoff value is written (see below).

` `{.docutils .literal .notranslate}[` -cutoff `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} sets a cutoff
for the computed distances. If the result would contain a distance over
the cutoff, the cutoff value is written to the output file instead. By
default, no cutoff is used, but if you are not interested in values
beyond a cutoff, or if you know that the minimum distance is smaller
than a cutoff, you should set this option to allow the tool to use
grid-based searching and be significantly faster.

If you want to compute distances between fixed pairs, may be a more
suitable tool.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (traj.xtc) (Optional)

:   Input trajectory or single configuration:

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr/.gro/â€¦\>\] (topol.tpr) (Optional)

:   Input structure: brk ent

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx) (Optional)

:   Extra index groups

Options to specify output files:

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (dist.xvg)

:   Distances as function of time

Other options:

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   First frame (ps) to read from trajectory

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Last frame (ps) to read from trajectory

` `{.docutils .literal .notranslate}[` -dt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Only use frame if t MOD dt == first time (ps)

` `{.docutils .literal .notranslate}[` -tu `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (ps)

:   Unit for time values: fs, ps, ns, us, ms, s

` `{.docutils .literal .notranslate}[` -fgroup `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<selection\>

:   Atoms stored in the trajectory file (if not set, assume first N
    atoms)

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   Plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -[no]rmpbc `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Make molecules whole for each frame

` `{.docutils .literal .notranslate}[` -[no]pbc `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Use periodic boundary conditions for distance calculation

` `{.docutils .literal .notranslate}[` -sf `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<file\>

:   Provide selections from files

` `{.docutils .literal .notranslate}[` -selrpos `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (atom)

:   Selection reference positions: atom, res_com, res_cog, mol_com,
    mol_cog, whole_res_com, whole_res_cog, whole_mol_com, whole_mol_cog,
    part_res_com, part_res_cog, part_mol_com, part_mol_cog, dyn_res_com,
    dyn_res_cog, dyn_mol_com, dyn_mol_cog

` `{.docutils .literal .notranslate}[` -seltype `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (atom)

:   Default selection output positions: atom, res_com, res_cog, mol_com,
    mol_cog, whole_res_com, whole_res_cog, whole_mol_com, whole_mol_cog,
    part_res_com, part_res_cog, part_mol_com, part_mol_cog, dyn_res_com,
    dyn_res_cog, dyn_mol_com, dyn_mol_cog

` `{.docutils .literal .notranslate}[` -cutoff `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Maximum distance to consider

` `{.docutils .literal .notranslate}[` -type `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (min)

:   Type of distances to calculate: min, max

` `{.docutils .literal .notranslate}[` -refgrouping `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (all)

:   Grouping of -ref positions to compute the min/max over: all, res,
    mol, none

` `{.docutils .literal .notranslate}[` -selgrouping `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (all)

:   Grouping of -sel positions to compute the min/max over: all, res,
    mol, none

` `{.docutils .literal .notranslate}[` -ref `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<selection\>

:   Reference positions to calculate distances from

` `{.docutils .literal .notranslate}[` -sel `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<selection\>

:   Positions to calculate distances for
:::
:::
::: {#gmx-pdb2gmx .section}
[ ]{#id1}

# gmx pdb2gmx

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx pdb2gmx [-f [<.gro/.g96/...>]] [-o [<.gro/.g96/...>]] [-p [<.top>]]
            [-i [<.itp>]] [-n [<.ndx>]] [-q [<.gro/.g96/...>]]
            [-chainsep <enum>] [-merge <enum>] [-ff <string>]
            [-water <enum>] [-[no]inter] [-[no]ss] [-[no]ter]
            [-[no]lys] [-[no]arg] [-[no]asp] [-[no]glu] [-[no]gln]
            [-[no]his] [-angle <real>] [-dist <real>] [-[no]una]
            [-[no]ignh] [-[no]missing] [-[no]v] [-posrefc <real>]
            [-vsite <enum>] [-[no]heavyh] [-[no]deuterate]
            [-[no]chargegrp] [-[no]cmap] [-[no]renum] [-[no]rtpres]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` pdb2gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} reads a (or )
file, reads some database files, adds hydrogens to the molecules and
generates coordinates in GROMACS (GROMOS), or optionally , format and a
topology in GROMACS format. These files can subsequently be processed to
generate a run input file.

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` pdb2gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} will search for
force fields by looking for a ` `{.docutils .literal
.notranslate}[` forcefield.itp `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} file in
subdirectories ` `{.docutils .literal
.notranslate}[` <forcefield>.ff `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} of the current
working directory and of the GROMACS library directory as inferred from
the path of the binary or the ` `{.docutils .literal
.notranslate}[` GMXLIB `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} environment
variable. By default the forcefield selection is interactive, but you
can use the ` `{.docutils .literal .notranslate}[` -ff `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} option
to specify one of the short names in the list on the command line
instead. In that case ` `{.docutils .literal
.notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` pdb2gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} just looks for
the corresponding ` `{.docutils .literal
.notranslate}[` <forcefield>.ff `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} directory.

After choosing a force field, all files will be read only from the
corresponding force field directory. If you want to modify or add a
residue types, you can copy the force field directory from the GROMACS
library directory to your current working directory. If you want to add
new protein residue types, you will need to modify ` `{.docutils
.literal .notranslate}[` residuetypes.dat `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} in the library
directory or copy the whole library directory to a local directory and
set the environment variable ` `{.docutils .literal
.notranslate}[` GMXLIB `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} to the name of
that directory. Check Chapter 5 of the manual for more information about
file formats.

Note that a file is nothing more than a file format, and it need not
necessarily contain a protein structure. Every kind of molecule for
which there is support in the database can be converted. If there is no
support in the database, you can add it yourself.

The program has limited intelligence, it reads a number of database
files, that allow it to make special bonds (Cys-Cys, Heme-His, etc.), if
necessary this can be done manually. The program can prompt the user to
select which kind of LYS, ASP, GLU, CYS or HIS residue is desired. For
Lys the choice is between neutral (two protons on NZ) or protonated
(three protons, default), for Asp and Glu unprotonated (default) or
protonated, for His the proton can be either on ND1, on NE2 or on both.
By default these selections are done automatically. For His, this is
based on an optimal hydrogen bonding conformation. Hydrogen bonds are
defined based on a simple geometric criterion, specified by the maximum
hydrogen-donor-acceptor angle and donor-acceptor distance, which are set
by ` `{.docutils .literal .notranslate}[` -angle `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` -dist `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} respectively.

The protonation state of N- and C-termini can be chosen interactively
with the ` `{.docutils .literal .notranslate}[` -ter `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} flag.
Default termini are ionized (NH3+ and COO-), respectively. Some force
fields support zwitterionic forms for chains of one residue, but for
polypeptides these options should NOT be selected. The AMBER force
fields have unique forms for the terminal residues, and these are
incompatible with the ` `{.docutils .literal
.notranslate}[` -ter `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} mechanism. You
need to prefix your N- or C-terminal residue names with â€œNâ€? or
â€œCâ€? respectively to use these forms, making sure you preserve the
format of the coordinate file. Alternatively, use named terminating
residues (e.g. ACE, NME).

The separation of chains is not entirely trivial since the markup in
user-generated PDB files frequently varies and sometimes it is desirable
to merge entries across a TER record, for instance if you want a
disulfide bridge or distance restraints between two protein chains or if
you have a HEME group bound to a protein. In such cases multiple chains
should be contained in a single ` `{.docutils .literal
.notranslate}[` moleculetype `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} definition. To
handle this, ` `{.docutils .literal .notranslate}[` gmx `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` pdb2gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} uses two
separate options. First, ` `{.docutils .literal
.notranslate}[` -chainsep `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} allows you to
choose when a new chemical chain should start, and termini added when
applicable. This can be done based on the existence of TER records, when
the chain id changes, or combinations of either or both of these. You
can also do the selection fully interactively. In addition, there is a
` `{.docutils .literal .notranslate}[` -merge `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} option that
controls how multiple chains are merged into one moleculetype, after
adding all the chemical termini (or not). This can be turned off (no
merging), all non-water chains can be merged into a single molecule, or
the selection can be done interactively.

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` pdb2gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} will also check
the occupancy field of the file. If any of the occupancies are not one,
indicating that the atom is not resolved well in the structure, a
warning message is issued. When a file does not originate from an X-ray
structure determination all occupancy fields may be zero. Either way, it
is up to the user to verify the correctness of the input data (read the
article!).

During processing the atoms will be reordered according to GROMACS
conventions. With ` `{.docutils .literal .notranslate}[` -n `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} an
index file can be generated that contains one group reordered in the
same way. This allows you to convert a GROMOS trajectory and coordinate
file to GROMOS. There is one limitation: reordering is done after the
hydrogens are stripped from the input and before new hydrogens are
added. This means that you should not use ` `{.docutils .literal
.notranslate}[` -ignh `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} .

The and ` `{.docutils .literal .notranslate}[` .g96 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} file formats do
not support chain identifiers. Therefore it is useful to enter a file
name at the ` `{.docutils .literal .notranslate}[` -o `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} option
when you want to convert a multi-chain file.

The option ` `{.docutils .literal .notranslate}[` -vsite `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}
removes hydrogen and fast improper dihedral motions. Angular and
out-of-plane motions can be removed by changing hydrogens into virtual
sites and fixing angles, which fixes their position relative to
neighboring atoms. Additionally, all atoms in the aromatic rings of the
standard amino acids (i.e. PHE, TRP, TYR and HIS) can be converted into
virtual sites, eliminating the fast improper dihedral fluctuations in
these rings (but this feature is deprecated). **Note** that in this case
all other hydrogen atoms are also converted to virtual sites. The mass
of all atoms that are converted into virtual sites, is added to the
heavy atoms.

Also slowing down of dihedral motion can be done with ` `{.docutils
.literal .notranslate}[` -heavyh `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} done by
increasing the hydrogen-mass by a factor of 4. This is also done for
water hydrogens to slow down the rotational motion of water. The
increase in mass of the hydrogens is subtracted from the bonded (heavy)
atom so that the total mass of the system remains the same. As a special
case, ring-closed (or cyclic) molecules are considered. ` `{.docutils
.literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` pdb2gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} automatically
determines if a cyclic molecule is present by evaluating the distance
between the terminal atoms of a given chain. If this distance is greater
than the ` `{.docutils .literal .notranslate}[` -sb `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} (â€œShort bond
warning distanceâ€?, default 0.05 nm) and less than the ` `{.docutils
.literal .notranslate}[` -lb `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} (â€œLong bond
warning distanceâ€?, default 0.25 nm) the molecule is considered to be
ring closed and will be processed as such. Please note that this does
not detect cyclic bonds over periodic boundaries.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.gro/.g96/â€¦\>\] (protein.pdb)

:   Structure file: brk ent esp

Options to specify output files:

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.gro/.g96/â€¦\>\] (conf.gro)

:   Structure file: brk ent esp

` `{.docutils .literal .notranslate}[` -p `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.top\>\] (topol.top)

:   Topology file

` `{.docutils .literal .notranslate}[` -i `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.itp\>\] (posre.itp)

:   Include file for topology

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx) (Optional)

:   Index file

` `{.docutils .literal .notranslate}[` -q `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.gro/.g96/â€¦\>\] (clean.pdb) (Optional)

:   Structure file: brk ent esp

Other options:

` `{.docutils .literal .notranslate}[` -chainsep `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (id_or_ter)

:   Condition in PDB files when a new chain should be started (adding
    termini): id_or_ter, id_and_ter, ter, id, interactive

` `{.docutils .literal .notranslate}[` -merge `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (no)

:   Merge multiple chains into a single \[moleculetype\]: no, all,
    interactive

` `{.docutils .literal .notranslate}[` -ff `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<string\> (select)

:   Force field, interactive by default. Use ` `{.docutils .literal
    .notranslate}[` -h `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} for
    information.

` `{.docutils .literal .notranslate}[` -water `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (select)

:   Water model to use: select, none, spc, spce, tip3p, tip4p, tip5p,
    tips3p

` `{.docutils .literal .notranslate}[` -[no]inter `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Set the next 8 options to interactive

` `{.docutils .literal .notranslate}[` -[no]ss `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Interactive SS bridge selection

` `{.docutils .literal .notranslate}[` -[no]ter `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Interactive termini selection, instead of charged (default)

` `{.docutils .literal .notranslate}[` -[no]lys `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Interactive lysine selection, instead of charged

` `{.docutils .literal .notranslate}[` -[no]arg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Interactive arginine selection, instead of charged

` `{.docutils .literal .notranslate}[` -[no]asp `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Interactive aspartic acid selection, instead of charged

` `{.docutils .literal .notranslate}[` -[no]glu `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Interactive glutamic acid selection, instead of charged

` `{.docutils .literal .notranslate}[` -[no]gln `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Interactive glutamine selection, instead of charged

` `{.docutils .literal .notranslate}[` -[no]his `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Interactive histidine selection, instead of checking H-bonds

` `{.docutils .literal .notranslate}[` -angle `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (135)

:   Minimum hydrogen-donor-acceptor angle for a H-bond (degrees)

` `{.docutils .literal .notranslate}[` -dist `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0.3)

:   Maximum donor-acceptor distance for a H-bond (nm)

` `{.docutils .literal .notranslate}[` -[no]una `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Select aromatic rings with united CH atoms on phenylalanine,
    tryptophane and tyrosine

` `{.docutils .literal .notranslate}[` -[no]ignh `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Ignore hydrogen atoms that are in the coordinate file

` `{.docutils .literal .notranslate}[` -[no]missing `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Continue when atoms are missing and bonds cannot be made, dangerous

` `{.docutils .literal .notranslate}[` -[no]v `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Be slightly more verbose in messages

` `{.docutils .literal .notranslate}[` -posrefc `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (1000)

:   Force constant for position restraints

` `{.docutils .literal .notranslate}[` -vsite `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (none)

:   Convert atoms to virtual sites: none, hydrogens, aromatics

` `{.docutils .literal .notranslate}[` -[no]heavyh `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Make hydrogen atoms heavy

` `{.docutils .literal .notranslate}[` -[no]deuterate `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Change the mass of hydrogens to 2 amu

` `{.docutils .literal .notranslate}[` -[no]chargegrp `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Use charge groups in the file

` `{.docutils .literal .notranslate}[` -[no]cmap `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Use cmap torsions (if enabled in the file)

` `{.docutils .literal .notranslate}[` -[no]renum `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Renumber the residues consecutively in the output

` `{.docutils .literal .notranslate}[` -[no]rtpres `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Use entry names as residue names
:::
:::
::: {#gmx-pme-error .section}
[ ]{#id1}

# gmx pme_error

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx pme_error [-s [<.tpr>]] [-o [<.out>]] [-so [<.tpr>]] [-beta <real>]
             [-[no]tune] [-self <real>] [-seed <int>] [-[no]v]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` pme_error `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} estimates the
error of the electrostatic forces if using the sPME algorithm. The flag
` `{.docutils .literal .notranslate}[` -tune `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} will determine
the splitting parameter such that the error is equally distributed over
the real and reciprocal space part. The part of the error that stems
from self interaction of the particles is computationally demanding.
However, a good a approximation is to just use a fraction of the
particles for this term which can be indicated by the flag ` `{.docutils
.literal .notranslate}[` -self `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} .
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr\>\] (topol.tpr)

:   Portable xdr run input file

Options to specify output files:

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.out\>\] (error.out)

:   Generic output file

` `{.docutils .literal .notranslate}[` -so `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr\>\] (tuned.tpr) (Optional)

:   Portable xdr run input file

Other options:

` `{.docutils .literal .notranslate}[` -beta `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (-1)

:   If positive, overwrite ewald_beta from file with this value

` `{.docutils .literal .notranslate}[` -[no]tune `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Tune the splitting parameter such that the error is equally
    distributed between real and reciprocal space

` `{.docutils .literal .notranslate}[` -self `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (1)

:   If between 0.0 and 1.0, determine self interaction error from just
    this fraction of the charged particles

` `{.docutils .literal .notranslate}[` -seed `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (0)

:   Random number seed used for Monte Carlo algorithm when ` `{.docutils
    .literal .notranslate}[` -self `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} is set to a
    value between 0.0 and 1.0

` `{.docutils .literal .notranslate}[` -[no]v `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Be loud and noisy
:::
:::
::: {#gmx-polystat .section}
[ ]{#id1}

# gmx polystat

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx polystat [-s [<.tpr>]] [-f [<.xtc/.trr/...>]] [-n [<.ndx>]]
             [-o [<.xvg>]] [-v [<.xvg>]] [-p [<.xvg>]] [-i [<.xvg>]]
             [-b <time>] [-e <time>] [-dt <time>] [-tu <enum>]
             [-[no]w] [-xvg <enum>] [-[no]mw] [-[no]pc]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` polystat `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} plots static
properties of polymers as a function of time and prints the average.

By default it determines the average end-to-end distance and radii of
gyration of polymers. It asks for an index group and split this into
molecules. The end-to-end distance is then determined using the first
and the last atom in the index group for each molecules. For the radius
of gyration the total and the three principal components for the average
gyration tensor are written. With option ` `{.docutils .literal
.notranslate}[` -v `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} the
eigenvectors are written. With option ` `{.docutils .literal
.notranslate}[` -pc `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} also the
average eigenvalues of the individual gyration tensors are written. With
option ` `{.docutils .literal .notranslate}[` -i `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} the mean square
internal distances are written.

With option ` `{.docutils .literal .notranslate}[` -p `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} the
persistence length is determined. The chosen index group should consist
of atoms that are consecutively bonded in the polymer mainchains. The
persistence length is then determined from the cosine of the angles
between bonds with an index difference that is even, the odd pairs are
not used, because straight polymer backbones are usually all trans and
therefore only every second bond aligns. The persistence length is
defined as number of bonds where the average cos reaches a value of 1/e.
This point is determined by a linear interpolation of log(\<cos\>).
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr\>\] (topol.tpr)

:   Portable xdr run input file

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (traj.xtc)

:   Trajectory:

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx) (Optional)

:   Index file

Options to specify output files:

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (polystat.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -v `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (polyvec.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -p `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (persist.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -i `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (intdist.xvg) (Optional)

:   xvgr/xmgr file

Other options:

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of first frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of last frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -dt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Only use frame when t MOD dt = first time (default unit ps)

` `{.docutils .literal .notranslate}[` -tu `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (ps)

:   Unit for time values: fs, ps, ns, us, ms, s

` `{.docutils .literal .notranslate}[` -[no]w `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   View output , , and files

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   xvg plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -[no]mw `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Use the mass weighting for radii of gyration

` `{.docutils .literal .notranslate}[` -[no]pc `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Plot average eigenvalues
:::
:::
::: {#gmx-potential .section}
[ ]{#id1}

# gmx potential

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx potential [-f [<.xtc/.trr/...>]] [-n [<.ndx>]] [-s [<.tpr>]]
             [-o [<.xvg>]] [-oc [<.xvg>]] [-of [<.xvg>]] [-b <time>]
             [-e <time>] [-dt <time>] [-[no]w] [-xvg <enum>]
             [-d <string>] [-sl <int>] [-cb <int>] [-ce <int>]
             [-tz <real>] [-[no]spherical] [-ng <int>] [-[no]center]
             [-[no]symm] [-[no]correct]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` potential `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} computes the
electrostatical potential across the box. The potential is calculated by
first summing the charges per slice and then integrating twice of this
charge distribution. Periodic boundaries are not taken into account.
Reference of potential is taken to be the left side of the box. It is
also possible to calculate the potential in spherical coordinates as
function of r by calculating a charge distribution in spherical slices
and twice integrating them. epsilon_r is taken as 1, but 2 is more
appropriate in many cases.

Option ` `{.docutils .literal .notranslate}[` -center `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}
performs the histogram binning and potential calculation relative to the
center of an arbitrary group, in absolute box coordinates. If you are
calculating profiles along the Z axis box dimension bZ, output would be
from -bZ/2 to bZ/2 if you center based on the entire system. Option
` `{.docutils .literal .notranslate}[` -symm `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} symmetrizes the
output around the center. This will automatically turn on ` `{.docutils
.literal .notranslate}[` -center `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} too.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (traj.xtc)

:   Trajectory:

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx)

:   Index file

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr\>\] (topol.tpr)

:   Portable xdr run input file

Options to specify output files:

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (potential.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -oc `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (charge.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -of `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (field.xvg)

:   xvgr/xmgr file

Other options:

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of first frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of last frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -dt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Only use frame when t MOD dt = first time (default unit ps)

` `{.docutils .literal .notranslate}[` -[no]w `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   View output , , and files

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   xvg plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -d `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<string\> (Z)

:   Take the normal on the membrane in direction X, Y or Z.

` `{.docutils .literal .notranslate}[` -sl `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (10)

:   Calculate potential as function of boxlength, dividing the box in
    this number of slices.

` `{.docutils .literal .notranslate}[` -cb `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (0)

:   Discard this number of first slices of box for integration

` `{.docutils .literal .notranslate}[` -ce `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (0)

:   Discard this number of last slices of box for integration

` `{.docutils .literal .notranslate}[` -tz `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Translate all coordinates by this distance in the direction of the
    box

` `{.docutils .literal .notranslate}[` -[no]spherical `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Calculate in spherical coordinates

` `{.docutils .literal .notranslate}[` -ng `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (1)

:   Number of groups to consider

` `{.docutils .literal .notranslate}[` -[no]center `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Perform the binning relative to the center of the (changing) box.
    Useful for bilayers.

` `{.docutils .literal .notranslate}[` -[no]symm `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Symmetrize the density along the axis, with respect to the center.
    Useful for bilayers.

` `{.docutils .literal .notranslate}[` -[no]correct `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Assume net zero charge of groups to improve accuracy
:::

::: {#known-issues .section}
## Known Issues

-   Discarding slices for integration should not be necessary.
:::
:::
::: {#gmx-principal .section}
[ ]{#id1}

# gmx principal

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx principal [-f [<.xtc/.trr/...>]] [-s [<.tpr/.gro/...>]]
             [-n [<.ndx>]] [-a1 [<.xvg>]] [-a2 [<.xvg>]]
             [-a3 [<.xvg>]] [-om [<.xvg>]] [-b <time>] [-e <time>]
             [-dt <time>] [-tu <enum>] [-[no]w] [-xvg <enum>]
             [-[no]foo]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` principal `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} calculates the
three principal axes of inertia for a group of atoms. NOTE: Old versions
of GROMACS wrote the output data in a strange transposed way. As of
GROMACS 5.0, the output file paxis1.dat contains the x/y/z components of
the first (major) principal axis for each frame, and similarly for the
middle and minor axes in paxis2.dat and paxis3.dat.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (traj.xtc)

:   Trajectory:

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr/.gro/â€¦\>\] (topol.tpr)

:   Structure+mass(db): brk ent

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx) (Optional)

:   Index file

Options to specify output files:

` `{.docutils .literal .notranslate}[` -a1 `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (paxis1.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -a2 `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (paxis2.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -a3 `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (paxis3.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -om `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (moi.xvg)

:   xvgr/xmgr file

Other options:

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of first frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of last frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -dt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Only use frame when t MOD dt = first time (default unit ps)

` `{.docutils .literal .notranslate}[` -tu `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (ps)

:   Unit for time values: fs, ps, ns, us, ms, s

` `{.docutils .literal .notranslate}[` -[no]w `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   View output , , and files

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   xvg plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -[no]foo `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Dummy option to avoid empty array
:::
:::
::: {#gmx-rama .section}
[ ]{#id1}

# gmx rama

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx rama [-f [<.xtc/.trr/...>]] [-s [<.tpr>]] [-o [<.xvg>]] [-b <time>]
         [-e <time>] [-dt <time>] [-[no]w] [-xvg <enum>]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` rama `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} selects the
phi/psi dihedral combinations from your topology file and computes these
as a function of time. Using simple Unix tools such as *grep* you can
select out specific residues.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (traj.xtc)

:   Trajectory:

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr\>\] (topol.tpr)

:   Portable xdr run input file

Options to specify output files:

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (rama.xvg)

:   xvgr/xmgr file

Other options:

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of first frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of last frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -dt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Only use frame when t MOD dt = first time (default unit ps)

` `{.docutils .literal .notranslate}[` -[no]w `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   View output , , and files

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   xvg plot formatting: xmgrace, xmgr, none
:::
:::
::: {#gmx-rdf .section}
[ ]{#id1}

# gmx rdf

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx rdf [-f [<.xtc/.trr/...>]] [-s [<.tpr/.gro/...>]] [-n [<.ndx>]]
        [-o [<.xvg>]] [-cn [<.xvg>]] [-b <time>] [-e <time>]
        [-dt <time>] [-tu <enum>] [-fgroup <selection>] [-xvg <enum>]
        [-[no]rmpbc] [-[no]pbc] [-sf <file>] [-selrpos <enum>]
        [-seltype <enum>] [-bin <real>] [-norm <enum>] [-[no]xy]
        [-[no]excl] [-cut <real>] [-rmax <real>] [-surf <enum>]
        [-ref <selection>] [-sel <selection>]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` rdf `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} calculates
radial distribution functions from one reference set of position (set
with ` `{.docutils .literal .notranslate}[` -ref `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ) to one or
more sets of positions (set with ` `{.docutils .literal
.notranslate}[` -sel `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ). To compute
the RDF with respect to the closest position in a set in ` `{.docutils
.literal .notranslate}[` -ref `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} instead, use
` `{.docutils .literal .notranslate}[` -surf `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} : if set, then
` `{.docutils .literal .notranslate}[` -ref `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} is partitioned
into sets based on the value of ` `{.docutils .literal
.notranslate}[` -surf `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , and the
closest position in each set is used. To compute the RDF around axes
parallel to the *z* -axis, i.e., only in the *x* - *y* plane, use
` `{.docutils .literal .notranslate}[` -xy `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} .

To set the bin width and maximum distance to use in the RDF, use
` `{.docutils .literal .notranslate}[` -bin `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` -rmax `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , respectively.
The latter can be used to limit the computational cost if the RDF is not
of interest up to the default (half of the box size with PBC, three
times the box size without PBC).

To use exclusions from the topology ( ` `{.docutils .literal
.notranslate}[` -s `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ), set
` `{.docutils .literal .notranslate}[` -excl `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and ensure that
both ` `{.docutils .literal .notranslate}[` -ref `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` -sel `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} only select
atoms. A rougher alternative to exclude intra-molecular peaks is to set
` `{.docutils .literal .notranslate}[` -cut `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} to a non-zero
value to clear the RDF at small distances.

The RDFs are normalized by 1) average number of positions in
` `{.docutils .literal .notranslate}[` -ref `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} (the number of
groups with ` `{.docutils .literal .notranslate}[` -surf `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} ), 2)
volume of the bin, and 3) average particle density of ` `{.docutils
.literal .notranslate}[` -sel `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} positions for
that selection. To change the normalization, use ` `{.docutils .literal
.notranslate}[` -norm `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} :

-   ` `{.docutils .literal .notranslate}[` rdf `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} : Use all
    factors for normalization. This produces a normal RDF.

-   ` `{.docutils .literal .notranslate}[` number_density `{.docutils
    .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} :
    Use the first two factors. This produces a number density as a
    function of distance.

-   ` `{.docutils .literal .notranslate}[` none `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} : Use only
    the first factor. In this case, the RDF is only scaled with the bin
    width to make the integral of the curve represent the number of
    pairs within a range.

Note that exclusions do not affect the normalization: even if
` `{.docutils .literal .notranslate}[` -excl `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} is set, or
` `{.docutils .literal .notranslate}[` -ref `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` -sel `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} contain the
same selection, the normalization factor is still N\*M, not
N\*(M-excluded).

For ` `{.docutils .literal .notranslate}[` -surf `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , the selection
provided to ` `{.docutils .literal .notranslate}[` -ref `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} must
select atoms, i.e., centers of mass are not supported. Further,
` `{.docutils .literal .notranslate}[` -nonorm `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} is implied, as
the bins have irregular shapes and the volume of a bin is not easily
computable.

Option ` `{.docutils .literal .notranslate}[` -cn `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} produces the
cumulative number RDF, i.e. the average number of particles within a
distance r.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (traj.xtc) (Optional)

:   Input trajectory or single configuration:

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr/.gro/â€¦\>\] (topol.tpr) (Optional)

:   Input structure: brk ent

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx) (Optional)

:   Extra index groups

Options to specify output files:

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (rdf.xvg)

:   Computed RDFs

` `{.docutils .literal .notranslate}[` -cn `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (rdf_cn.xvg) (Optional)

:   Cumulative RDFs

Other options:

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   First frame (ps) to read from trajectory

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Last frame (ps) to read from trajectory

` `{.docutils .literal .notranslate}[` -dt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Only use frame if t MOD dt == first time (ps)

` `{.docutils .literal .notranslate}[` -tu `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (ps)

:   Unit for time values: fs, ps, ns, us, ms, s

` `{.docutils .literal .notranslate}[` -fgroup `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<selection\>

:   Atoms stored in the trajectory file (if not set, assume first N
    atoms)

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   Plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -[no]rmpbc `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Make molecules whole for each frame

` `{.docutils .literal .notranslate}[` -[no]pbc `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Use periodic boundary conditions for distance calculation

` `{.docutils .literal .notranslate}[` -sf `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<file\>

:   Provide selections from files

` `{.docutils .literal .notranslate}[` -selrpos `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (atom)

:   Selection reference positions: atom, res_com, res_cog, mol_com,
    mol_cog, whole_res_com, whole_res_cog, whole_mol_com, whole_mol_cog,
    part_res_com, part_res_cog, part_mol_com, part_mol_cog, dyn_res_com,
    dyn_res_cog, dyn_mol_com, dyn_mol_cog

` `{.docutils .literal .notranslate}[` -seltype `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (atom)

:   Default selection output positions: atom, res_com, res_cog, mol_com,
    mol_cog, whole_res_com, whole_res_cog, whole_mol_com, whole_mol_cog,
    part_res_com, part_res_cog, part_mol_com, part_mol_cog, dyn_res_com,
    dyn_res_cog, dyn_mol_com, dyn_mol_cog

` `{.docutils .literal .notranslate}[` -bin `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0.002)

:   Bin width (nm)

` `{.docutils .literal .notranslate}[` -norm `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (rdf)

:   Normalization: rdf, number_density, none

` `{.docutils .literal .notranslate}[` -[no]xy `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Use only the x and y components of the distance

` `{.docutils .literal .notranslate}[` -[no]excl `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Use exclusions from topology

` `{.docutils .literal .notranslate}[` -cut `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Shortest distance (nm) to be considered

` `{.docutils .literal .notranslate}[` -rmax `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Largest distance (nm) to calculate

` `{.docutils .literal .notranslate}[` -surf `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (no)

:   RDF with respect to the surface of the reference: no, mol, res

` `{.docutils .literal .notranslate}[` -ref `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<selection\>

:   Reference selection for RDF computation

` `{.docutils .literal .notranslate}[` -sel `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<selection\>

:   Selections to compute RDFs for from the reference
:::
:::
::: {#gmx-report-methods .section}
[ ]{#id1}

# gmx report-methods

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx report-methods [-s [<.tpr/.gro/...>]] [-m [<.tex>]] [-o [<.out>]]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` report-methods `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} reports basic
system information for the run input file specified with ` `{.docutils
.literal .notranslate}[` -s `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} either to the
terminal, to a LaTeX formatted output file if run with the ` `{.docutils
.literal .notranslate}[` -m `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} option or to an
unformatted file with the ` `{.docutils .literal
.notranslate}[` -o `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} option. The
functionality has been moved here from its previous place in .
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr/.gro/â€¦\>\] (topol.tpr)

:   Run input file for report: brk ent

Options to specify output files:

` `{.docutils .literal .notranslate}[` -m `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tex\>\] (report.tex) (Optional)

:   LaTeX formatted report output

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.out\>\] (report.out) (Optional)

:   Unformatted report output to file
:::
:::
::: {#gmx-rms .section}
[ ]{#id1}

# gmx rms

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx rms [-s [<.tpr/.gro/...>]] [-f [<.xtc/.trr/...>]]
        [-f2 [<.xtc/.trr/...>]] [-n [<.ndx>]] [-o [<.xvg>]]
        [-mir [<.xvg>]] [-a [<.xvg>]] [-dist [<.xvg>]] [-m [<.xpm>]]
        [-bin [<.dat>]] [-bm [<.xpm>]] [-b <time>] [-e <time>]
        [-dt <time>] [-tu <enum>] [-[no]w] [-xvg <enum>]
        [-what <enum>] [-[no]pbc] [-fit <enum>] [-prev <int>]
        [-[no]split] [-skip <int>] [-skip2 <int>] [-max <real>]
        [-min <real>] [-bmax <real>] [-bmin <real>] [-[no]mw]
        [-nlevels <int>] [-ng <int>]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` rms `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} compares two
structures by computing the root mean square deviation (RMSD), the
size-independent rho similarity parameter ( ` `{.docutils .literal
.notranslate}[` rho `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ) or the scaled
rho ( ` `{.docutils .literal .notranslate}[` rhosc `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ), see Maiorov
& Crippen, Proteins **22** , 273 (1995). This is selected by
` `{.docutils .literal .notranslate}[` -what `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} .

Each structure from a trajectory ( ` `{.docutils .literal
.notranslate}[` -f `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ) is compared
to a reference structure. The reference structure is taken from the
structure file ( ` `{.docutils .literal .notranslate}[` -s `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} ).

With option ` `{.docutils .literal .notranslate}[` -mir `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} also a
comparison with the mirror image of the reference structure is
calculated. This is useful as a reference for â€˜significantâ€™ values,
see Maiorov & Crippen, Proteins **22** , 273 (1995).

Option ` `{.docutils .literal .notranslate}[` -prev `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} produces the
comparison with a previous frame the specified number of frames ago.

Option ` `{.docutils .literal .notranslate}[` -m `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} produces a
matrix in format of comparison values of each structure in the
trajectory with respect to each other structure. This file can be
visualized with for instance ` `{.docutils .literal
.notranslate}[` xv `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and can be
converted to postscript with .

Option ` `{.docutils .literal .notranslate}[` -fit `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} controls the
least-squares fitting of the structures on top of each other: complete
fit (rotation and translation), translation only, or no fitting at all.

Option ` `{.docutils .literal .notranslate}[` -mw `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} controls
whether mass weighting is done or not. If you select the option
(default) and supply a valid file masses will be taken from there,
otherwise the masses will be deduced from the ` `{.docutils .literal
.notranslate}[` atommass.dat `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} file in
` `{.docutils .literal .notranslate}[` GMXLIB `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} (deprecated).
This is fine for proteins, but not necessarily for other molecules. You
can check whether this happened by turning on the ` `{.docutils .literal
.notranslate}[` -debug `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} flag and
inspecting the log file.

With ` `{.docutils .literal .notranslate}[` -f2 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , the â€˜other
structuresâ€™ are taken from a second trajectory, this generates a
comparison matrix of one trajectory versus the other.

Option ` `{.docutils .literal .notranslate}[` -bin `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} does a binary
dump of the comparison matrix.

Option ` `{.docutils .literal .notranslate}[` -bm `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} produces a
matrix of average bond angle deviations analogously to the ` `{.docutils
.literal .notranslate}[` -m `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} option. Only
bonds between atoms in the comparison group are considered.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr/.gro/â€¦\>\] (topol.tpr)

:   Structure+mass(db): brk ent

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (traj.xtc)

:   Trajectory:

` `{.docutils .literal .notranslate}[` -f2 `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (traj.xtc) (Optional)

:   Trajectory:

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx) (Optional)

:   Index file

Options to specify output files:

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (rmsd.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -mir `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (rmsdmir.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -a `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (avgrp.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -dist `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (rmsd-dist.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -m `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xpm\>\] (rmsd.xpm) (Optional)

:   X PixMap compatible matrix file

` `{.docutils .literal .notranslate}[` -bin `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.dat\>\] (rmsd.dat) (Optional)

:   Generic data file

` `{.docutils .literal .notranslate}[` -bm `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xpm\>\] (bond.xpm) (Optional)

:   X PixMap compatible matrix file

Other options:

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of first frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of last frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -dt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Only use frame when t MOD dt = first time (default unit ps)

` `{.docutils .literal .notranslate}[` -tu `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (ps)

:   Unit for time values: fs, ps, ns, us, ms, s

` `{.docutils .literal .notranslate}[` -[no]w `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   View output , , and files

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   xvg plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -what `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (rmsd)

:   Structural difference measure: rmsd, rho, rhosc

` `{.docutils .literal .notranslate}[` -[no]pbc `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   PBC check

` `{.docutils .literal .notranslate}[` -fit `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (rot+trans)

:   Fit to reference structure: rot+trans, translation, none

` `{.docutils .literal .notranslate}[` -prev `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (0)

:   Compare with previous frame

` `{.docutils .literal .notranslate}[` -[no]split `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Split graph where time is zero

` `{.docutils .literal .notranslate}[` -skip `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (1)

:   Only write every nr-th frame to matrix

` `{.docutils .literal .notranslate}[` -skip2 `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (1)

:   Only write every nr-th frame to matrix

` `{.docutils .literal .notranslate}[` -max `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (-1)

:   Maximum level in comparison matrix

` `{.docutils .literal .notranslate}[` -min `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (-1)

:   Minimum level in comparison matrix

` `{.docutils .literal .notranslate}[` -bmax `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (-1)

:   Maximum level in bond angle matrix

` `{.docutils .literal .notranslate}[` -bmin `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (-1)

:   Minimum level in bond angle matrix

` `{.docutils .literal .notranslate}[` -[no]mw `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Use mass weighting for superposition

` `{.docutils .literal .notranslate}[` -nlevels `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (80)

:   Number of levels in the matrices

` `{.docutils .literal .notranslate}[` -ng `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (1)

:   Number of groups to compute RMS between
:::
:::
::: {#gmx-rmsdist .section}
[ ]{#id1}

# gmx rmsdist

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx rmsdist [-f [<.xtc/.trr/...>]] [-s [<.tpr/.gro/...>]] [-n [<.ndx>]]
            [-equiv [<.dat>]] [-o [<.xvg>]] [-rms [<.xpm>]]
            [-scl [<.xpm>]] [-mean [<.xpm>]] [-nmr3 [<.xpm>]]
            [-nmr6 [<.xpm>]] [-noe [<.dat>]] [-b <time>] [-e <time>]
            [-dt <time>] [-[no]w] [-xvg <enum>] [-nlevels <int>]
            [-max <real>] [-[no]sumh] [-[no]pbc]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` rmsdist `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} computes the
root mean square deviation of atom distances, which has the advantage
that no fit is needed like in standard RMS deviation as computed by .
The reference structure is taken from the structure file. The RMSD at
time t is calculated as the RMS of the differences in distance between
atom-pairs in the reference structure and the structure at time t.

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` rmsdist `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} can also
produce matrices of the rms distances, rms distances scaled with the
mean distance and the mean distances and matrices with NMR averaged
distances (1/r\^3 and 1/r\^6 averaging). Finally, lists of atom pairs
with 1/r\^3 and 1/r\^6 averaged distance below the maximum distance (
` `{.docutils .literal .notranslate}[` -max `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , which will
default to 0.6 in this case) can be generated, by default averaging over
equivalent hydrogens (all triplets of hydrogens named \*\[123\]).
Additionally a list of equivalent atoms can be supplied ( ` `{.docutils
.literal .notranslate}[` -equiv `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ), each line
containing a set of equivalent atoms specified as residue number and
name and atom name; e.g.:

` `{.docutils .literal .notranslate}[` HB* `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate}[` 3 `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` SER `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` HB1 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate}[` 3 `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` SER `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` HB2 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate}

Residue and atom names must exactly match those in the structure file,
including case. Specifying non-sequential atoms is undefined.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (traj.xtc)

:   Trajectory:

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr/.gro/â€¦\>\] (topol.tpr)

:   Structure+mass(db): brk ent

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx) (Optional)

:   Index file

` `{.docutils .literal .notranslate}[` -equiv `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.dat\>\] (equiv.dat) (Optional)

:   Generic data file

Options to specify output files:

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (distrmsd.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -rms `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xpm\>\] (rmsdist.xpm) (Optional)

:   X PixMap compatible matrix file

` `{.docutils .literal .notranslate}[` -scl `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xpm\>\] (rmsscale.xpm) (Optional)

:   X PixMap compatible matrix file

` `{.docutils .literal .notranslate}[` -mean `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xpm\>\] (rmsmean.xpm) (Optional)

:   X PixMap compatible matrix file

` `{.docutils .literal .notranslate}[` -nmr3 `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xpm\>\] (nmr3.xpm) (Optional)

:   X PixMap compatible matrix file

` `{.docutils .literal .notranslate}[` -nmr6 `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xpm\>\] (nmr6.xpm) (Optional)

:   X PixMap compatible matrix file

` `{.docutils .literal .notranslate}[` -noe `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.dat\>\] (noe.dat) (Optional)

:   Generic data file

Other options:

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of first frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of last frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -dt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Only use frame when t MOD dt = first time (default unit ps)

` `{.docutils .literal .notranslate}[` -[no]w `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   View output , , and files

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   xvg plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -nlevels `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (40)

:   Discretize RMS in this number of levels

` `{.docutils .literal .notranslate}[` -max `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (-1)

:   Maximum level in matrices

` `{.docutils .literal .notranslate}[` -[no]sumh `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Average distance over equivalent hydrogens

` `{.docutils .literal .notranslate}[` -[no]pbc `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Use periodic boundary conditions when computing distances
:::
:::
::: {#gmx-rmsf .section}
[ ]{#id1}

# gmx rmsf

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx rmsf [-f [<.xtc/.trr/...>]] [-s [<.tpr/.gro/...>]] [-n [<.ndx>]]
         [-q [<.pdb>]] [-oq [<.pdb>]] [-ox [<.pdb>]] [-o [<.xvg>]]
         [-od [<.xvg>]] [-oc [<.xvg>]] [-dir [<.log>]] [-b <time>]
         [-e <time>] [-dt <time>] [-[no]w] [-xvg <enum>] [-[no]res]
         [-[no]aniso] [-[no]fit]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` rmsf `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} computes the
root mean square fluctuation (RMSF, i.e. standard deviation) of atomic
positions in the trajectory (supplied with ` `{.docutils .literal
.notranslate}[` -f `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ) after
(optionally) fitting to a reference frame (supplied with ` `{.docutils
.literal .notranslate}[` -s `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ).

With option ` `{.docutils .literal .notranslate}[` -oq `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} the
RMSF values are converted to B-factor values, which are written to a
file. By default, the coordinates in this output file are taken from the
structure file provided with ` `{.docutils .literal
.notranslate}[` -s `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ,although you
can also use coordinates read from a different fileprovided with
` `{.docutils .literal .notranslate}[` -q `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . There is very
little error checking, so in this caseit is your responsibility to make
sure all atoms in the structure fileand file correspond exactly to each
other.

Option ` `{.docutils .literal .notranslate}[` -ox `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} writes the
B-factors to a file with the average coordinates in the trajectory.

With the option ` `{.docutils .literal .notranslate}[` -od `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} the
root mean square deviation with respect to the reference structure is
calculated.

With the option ` `{.docutils .literal
.notranslate}[` -aniso `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , ` `{.docutils
.literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` rmsf `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} will compute
anisotropic temperature factors and then it will also output average
coordinates and a file with ANISOU records (corresponding to the
` `{.docutils .literal .notranslate}[` -oq `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} or
` `{.docutils .literal .notranslate}[` -ox `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} option). Please
note that the U values are orientation-dependent, so before comparison
with experimental data you should verify that you fit to the
experimental coordinates.

When a input file is passed to the program and the ` `{.docutils
.literal .notranslate}[` -aniso `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} flag is set a
correlation plot of the Uij will be created, if any anisotropic
temperature factors are present in the file.

With option ` `{.docutils .literal .notranslate}[` -dir `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} the
average MSF (3x3) matrix is diagonalized. This shows the directions in
which the atoms fluctuate the most and the least.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (traj.xtc)

:   Trajectory:

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr/.gro/â€¦\>\] (topol.tpr)

:   Structure+mass(db): brk ent

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx) (Optional)

:   Index file

` `{.docutils .literal .notranslate}[` -q `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.pdb\>\] (eiwit.pdb) (Optional)

:   Protein data bank file

Options to specify output files:

` `{.docutils .literal .notranslate}[` -oq `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.pdb\>\] (bfac.pdb) (Optional)

:   Protein data bank file

` `{.docutils .literal .notranslate}[` -ox `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.pdb\>\] (xaver.pdb) (Optional)

:   Protein data bank file

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (rmsf.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -od `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (rmsdev.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -oc `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (correl.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -dir `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.log\>\] (rmsf.log) (Optional)

:   Log file

Other options:

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of first frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of last frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -dt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Only use frame when t MOD dt = first time (default unit ps)

` `{.docutils .literal .notranslate}[` -[no]w `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   View output , , and files

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   xvg plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -[no]res `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Calculate averages for each residue

` `{.docutils .literal .notranslate}[` -[no]aniso `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Compute anisotropic temperature factors

` `{.docutils .literal .notranslate}[` -[no]fit `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Do a least squares superposition before computing RMSF. Without this
    you must make sure that the reference structure and the trajectory
    match.
:::
:::
::: {#gmx-rotacf .section}
[ ]{#id1}

# gmx rotacf

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx rotacf [-f [<.xtc/.trr/...>]] [-s [<.tpr>]] [-n [<.ndx>]]
           [-o [<.xvg>]] [-b <time>] [-e <time>] [-dt <time>]
           [-[no]w] [-xvg <enum>] [-[no]d] [-[no]aver]
           [-acflen <int>] [-[no]normalize] [-P <enum>]
           [-fitfn <enum>] [-beginfit <real>] [-endfit <real>]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` rotacf `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} calculates the
rotational correlation function for molecules. Atom triplets (i,j,k)
must be given in the index file, defining two vectors ij and jk. The
rotational ACF is calculated as the autocorrelation function of the
vector n = ij x jk, i.e. the cross product of the two vectors. Since
three atoms span a plane, the order of the three atoms does not matter.
Optionally, by invoking the ` `{.docutils .literal
.notranslate}[` -d `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} switch, you can
calculate the rotational correlation function for linear molecules by
specifying atom pairs (i,j) in the index file.

EXAMPLES

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` rotacf `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` -P `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate}[` 1 `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` -nparm `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate}[` 2 `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` -fft `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` -n `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` index `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` -o `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` rotacf-x-P1 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` -fa `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` expfit-x-P1 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` -beginfit `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` 2.5 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` -endfit `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` 20.0 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate}

This will calculate the rotational correlation function using a first
order Legendre polynomial of the angle of a vector defined by the index
file. The correlation function will be fitted from 2.5 ps until 20.0 ps
to a two-parameter exponential.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (traj.xtc)

:   Trajectory:

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr\>\] (topol.tpr)

:   Portable xdr run input file

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx)

:   Index file

Options to specify output files:

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (rotacf.xvg)

:   xvgr/xmgr file

Other options:

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of first frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of last frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -dt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Only use frame when t MOD dt = first time (default unit ps)

` `{.docutils .literal .notranslate}[` -[no]w `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   View output , , and files

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   xvg plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -[no]d `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Use index doublets (vectors) for correlation function instead of
    triplets (planes)

` `{.docutils .literal .notranslate}[` -[no]aver `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Average over molecules

` `{.docutils .literal .notranslate}[` -acflen `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (-1)

:   Length of the ACF, default is half the number of frames

` `{.docutils .literal .notranslate}[` -[no]normalize `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Normalize ACF

` `{.docutils .literal .notranslate}[` -P `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (0)

:   Order of Legendre polynomial for ACF (0 indicates none): 0, 1, 2, 3

` `{.docutils .literal .notranslate}[` -fitfn `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (none)

:   Fit function: none, exp, aexp, exp_exp, exp5, exp7, exp9

` `{.docutils .literal .notranslate}[` -beginfit `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Time where to begin the exponential fit of the correlation function

` `{.docutils .literal .notranslate}[` -endfit `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (-1)

:   Time where to end the exponential fit of the correlation function,
    -1 is until the end
:::
:::
::: {#gmx-rotmat .section}
[ ]{#id1}

# gmx rotmat

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx rotmat [-f [<.xtc/.trr/...>]] [-s [<.tpr/.gro/...>]] [-n [<.ndx>]]
           [-o [<.xvg>]] [-b <time>] [-e <time>] [-dt <time>]
           [-[no]w] [-xvg <enum>] [-ref <enum>] [-skip <int>]
           [-[no]fitxy] [-[no]mw]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` rotmat `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} plots the
rotation matrix required for least squares fitting a conformation onto
the reference conformation provided with ` `{.docutils .literal
.notranslate}[` -s `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . Translation
is removed before fitting. The output are the three vectors that give
the new directions of the x, y and z directions of the reference
conformation, for example: (zx,zy,zz) is the orientation of the
reference z-axis in the trajectory frame.

This tool is useful for, for instance, determining the orientation of a
molecule at an interface, possibly on a trajectory produced with
` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` trjconv `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` -fit `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` rotxy+transxy `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} to remove the
rotation in the *x-y* plane.

Option ` `{.docutils .literal .notranslate}[` -ref `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} determines a
reference structure for fitting, instead of using the structure from
` `{.docutils .literal .notranslate}[` -s `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . The structure
with the lowest sum of RMSDâ€™s to all other structures is used. Since
the computational cost of this procedure grows with the square of the
number of frames, the ` `{.docutils .literal
.notranslate}[` -skip `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} option can be
useful. A full fit or only a fit in the *x-y* plane can be performed.

Option ` `{.docutils .literal .notranslate}[` -fitxy `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} fits
in the *x-y* plane before determining the rotation matrix.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (traj.xtc)

:   Trajectory:

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr/.gro/â€¦\>\] (topol.tpr)

:   Structure+mass(db): brk ent

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx) (Optional)

:   Index file

Options to specify output files:

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (rotmat.xvg)

:   xvgr/xmgr file

Other options:

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of first frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of last frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -dt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Only use frame when t MOD dt = first time (default unit ps)

` `{.docutils .literal .notranslate}[` -[no]w `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   View output , , and files

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   xvg plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -ref `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (none)

:   Determine the optimal reference structure: none, xyz, xy

` `{.docutils .literal .notranslate}[` -skip `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (1)

:   Use every nr-th frame for ` `{.docutils .literal
    .notranslate}[` -ref `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate}

` `{.docutils .literal .notranslate}[` -[no]fitxy `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Fit the x/y rotation before determining the rotation

` `{.docutils .literal .notranslate}[` -[no]mw `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Use mass weighted fitting
:::
:::
::: {#gmx-saltbr .section}
[ ]{#id1}

# gmx saltbr

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx saltbr [-f [<.xtc/.trr/...>]] [-s [<.tpr>]] [-b <time>] [-e <time>]
           [-dt <time>] [-t <real>] [-[no]sep]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` saltbr `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} plots the
distance between all combination of charged groups as a function of
time. The groups are combined in different ways. A minimum distance can
be given (i.e. a cut-off), such that groups that are never closer than
that distance will not be plotted.

Output will be in a number of fixed filenames, ` `{.docutils .literal
.notranslate}[` min-min.xvg `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , ` `{.docutils
.literal .notranslate}[` plus-min.xvg `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` plus-plus.xvg `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} , or
files for every individual ion pair if the ` `{.docutils .literal
.notranslate}[` -sep `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} option is
selected. In this case, files are named as ` `{.docutils .literal
.notranslate}[` sb-(Resname)(Resnr)-(Atomnr) `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . There may be
**many** such files.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (traj.xtc)

:   Trajectory:

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr\>\] (topol.tpr)

:   Portable xdr run input file

Other options:

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of first frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of last frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -dt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Only use frame when t MOD dt = first time (default unit ps)

` `{.docutils .literal .notranslate}[` -t `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (1000)

:   Groups that are never closer than this distance are not plotted

` `{.docutils .literal .notranslate}[` -[no]sep `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Use separate files for each interaction (may be MANY)
:::
:::
::: {#gmx-sans-legacy .section}
[ ]{#id1}

# gmx sans-legacy

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx sans-legacy [-s [<.tpr>]] [-f [<.xtc/.trr/...>]] [-n [<.ndx>]]
             [-d [<.dat>]] [-pr [<.xvg>]] [-sq [<.xvg>]]
             [-prframe [<.xvg>]] [-sqframe [<.xvg>]] [-b <time>]
             [-e <time>] [-dt <time>] [-tu <enum>] [-xvg <enum>]
             [-mode <enum>] [-mcover <real>] [-[no]pbc]
             [-startq <real>] [-endq <real>] [-qstep <real>]
             [-seed <int>] [-nt <int>]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` sans-legacy `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} computes SANS
spectra using Debye formula. It currently uses topology file (since it
need to assign element for each atom).

Parameters:

` `{.docutils .literal .notranslate}[` -pr `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} Computes
normalized g(r) function averaged over trajectory

` `{.docutils .literal .notranslate}[` -prframe `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} Computes
normalized g(r) function for each frame

` `{.docutils .literal .notranslate}[` -sq `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} Computes SANS
intensity curve averaged over trajectory

` `{.docutils .literal .notranslate}[` -sqframe `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} Computes SANS
intensity curve for each frame

` `{.docutils .literal .notranslate}[` -startq `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} Starting q
value in nm

` `{.docutils .literal .notranslate}[` -endq `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} Ending q value
in nm

` `{.docutils .literal .notranslate}[` -qstep `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} Stepping in q
space

Note: When using Debye direct method computational cost increases as 1/2
\* N \* (N - 1) where N is atom number in group of interest.

WARNING: If sq or pr specified this tool can produce large number of
files! Up to two times larger than number of frames!
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr\>\] (topol.tpr)

:   Portable xdr run input file

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (traj.xtc)

:   Trajectory:

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx) (Optional)

:   Index file

` `{.docutils .literal .notranslate}[` -d `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.dat\>\] (nsfactor.dat) (Optional)

:   Generic data file

Options to specify output files:

` `{.docutils .literal .notranslate}[` -pr `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (pr.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -sq `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (sq.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -prframe `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (prframe.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -sqframe `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (sqframe.xvg) (Optional)

:   xvgr/xmgr file

Other options:

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of first frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of last frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -dt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Only use frame when t MOD dt = first time (default unit ps)

` `{.docutils .literal .notranslate}[` -tu `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (ps)

:   Unit for time values: fs, ps, ns, us, ms, s

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   xvg plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -mode `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (direct)

:   Mode for sans spectra calculation: direct, mc

` `{.docutils .literal .notranslate}[` -mcover `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (-1)

:   Monte-Carlo coverage should be -1(default) or (0,1\]

` `{.docutils .literal .notranslate}[` -[no]pbc `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Use periodic boundary conditions for computing distances

` `{.docutils .literal .notranslate}[` -startq `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Starting q (1/nm)

` `{.docutils .literal .notranslate}[` -endq `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (2)

:   Ending q (1/nm)

` `{.docutils .literal .notranslate}[` -qstep `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0.01)

:   Stepping in q (1/nm)

` `{.docutils .literal .notranslate}[` -seed `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (0)

:   Random seed for Monte-Carlo

` `{.docutils .literal .notranslate}[` -nt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (96)

:   Number of threads to start
:::
:::
::: {#gmx-sasa .section}
[ ]{#id1}

# gmx sasa

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx sasa [-f [<.xtc/.trr/...>]] [-s [<.tpr/.gro/...>]] [-n [<.ndx>]]
         [-o [<.xvg>]] [-odg [<.xvg>]] [-or [<.xvg>]] [-oa [<.xvg>]]
         [-tv [<.xvg>]] [-q [<.pdb>]] [-b <time>] [-e <time>]
         [-dt <time>] [-tu <enum>] [-fgroup <selection>]
         [-xvg <enum>] [-[no]rmpbc] [-[no]pbc] [-sf <file>]
         [-selrpos <enum>] [-probe <real>] [-ndots <int>] [-[no]prot]
         [-dgs <real>] [-surface <selection>] [-output <selection>]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` sasa `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} computes
solvent accessible surface areas. See Eisenhaber F, Lijnzaad P, Argos P,
Sander C, & Scharf M (1995) J. Comput. Chem. 16, 273-284 for the
algorithm used. With ` `{.docutils .literal
.notranslate}[` -q `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , the Connolly
surface can be generated as well in a file where the nodes are
represented as atoms and the edges connecting the nearest nodes as
CONECT records. ` `{.docutils .literal .notranslate}[` -odg `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} allows
for estimation of solvation free energies from per-atom solvation
energies per exposed surface area.

The program requires a selection for the surface calculation to be
specified with ` `{.docutils .literal
.notranslate}[` -surface `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . This should
always consist of all non-solvent atoms in the system. The area of this
group is always calculated. Optionally, ` `{.docutils .literal
.notranslate}[` -output `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} can specify
additional selections, which should be subsets of the calculation group.
The solvent-accessible areas for these groups are also extracted from
the full surface.

The average and standard deviation of the area over the trajectory can
be calculated per residue and atom (options ` `{.docutils .literal
.notranslate}[` -or `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` -oa `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ).

With the ` `{.docutils .literal .notranslate}[` -tv `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} option the
total volume and density of the molecule can be computed. With
` `{.docutils .literal .notranslate}[` -pbc `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} (the default),
you must ensure that your molecule/surface group is not split across
PBC. Otherwise, you will get non-sensical results. Please also consider
whether the normal probe radius is appropriate in this case or whether
you would rather use, e.g., 0. It is good to keep in mind that the
results for volume and density are very approximate. For example, in ice
Ih, one can easily fit water molecules in the pores which would yield a
volume that is too low, and surface area and density that are both too
high.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (traj.xtc) (Optional)

:   Input trajectory or single configuration:

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr/.gro/â€¦\>\] (topol.tpr) (Optional)

:   Input structure: brk ent

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx) (Optional)

:   Extra index groups

Options to specify output files:

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (area.xvg)

:   Total area as a function of time

` `{.docutils .literal .notranslate}[` -odg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (dgsolv.xvg) (Optional)

:   Estimated solvation free energy as a function of time

` `{.docutils .literal .notranslate}[` -or `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (resarea.xvg) (Optional)

:   Average area per residue

` `{.docutils .literal .notranslate}[` -oa `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (atomarea.xvg) (Optional)

:   Average area per atom

` `{.docutils .literal .notranslate}[` -tv `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (volume.xvg) (Optional)

:   Total volume and density as a function of time

` `{.docutils .literal .notranslate}[` -q `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.pdb\>\] (connolly.pdb) (Optional)

:   PDB file for Connolly surface

Other options:

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   First frame (ps) to read from trajectory

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Last frame (ps) to read from trajectory

` `{.docutils .literal .notranslate}[` -dt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Only use frame if t MOD dt == first time (ps)

` `{.docutils .literal .notranslate}[` -tu `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (ps)

:   Unit for time values: fs, ps, ns, us, ms, s

` `{.docutils .literal .notranslate}[` -fgroup `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<selection\>

:   Atoms stored in the trajectory file (if not set, assume first N
    atoms)

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   Plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -[no]rmpbc `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Make molecules whole for each frame

` `{.docutils .literal .notranslate}[` -[no]pbc `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Use periodic boundary conditions for distance calculation

` `{.docutils .literal .notranslate}[` -sf `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<file\>

:   Provide selections from files

` `{.docutils .literal .notranslate}[` -selrpos `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (atom)

:   Selection reference positions: atom, res_com, res_cog, mol_com,
    mol_cog, whole_res_com, whole_res_cog, whole_mol_com, whole_mol_cog,
    part_res_com, part_res_cog, part_mol_com, part_mol_cog, dyn_res_com,
    dyn_res_cog, dyn_mol_com, dyn_mol_cog

` `{.docutils .literal .notranslate}[` -probe `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0.14)

:   Radius of the solvent probe (nm)

` `{.docutils .literal .notranslate}[` -ndots `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (24)

:   Number of dots per sphere, more dots means more accuracy

` `{.docutils .literal .notranslate}[` -[no]prot `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Output the protein to the Connolly file too

` `{.docutils .literal .notranslate}[` -dgs `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Default value for solvation free energy per area (kJ/mol/nm\^2)

` `{.docutils .literal .notranslate}[` -surface `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<selection\>

:   Surface calculation selection

` `{.docutils .literal .notranslate}[` -output `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<selection\>

:   Output selection(s)
:::
:::
::: {#gmx-saxs-legacy .section}
[ ]{#id1}

# gmx saxs-legacy

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx saxs-legacy [-f [<.xtc/.trr/...>]] [-s [<.tpr/.gro/...>]]
             [-n [<.ndx>]] [-d [<.dat>]] [-sq [<.xvg>]] [-b <time>]
             [-e <time>] [-dt <time>] [-xvg <enum>] [-ng <int>]
             [-startq <real>] [-endq <real>] [-energy <real>]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` saxs-legacy `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} calculates SAXS
structure factors for given index groups based on Cromerâ€™s method.
Both topology and trajectory files are required.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (traj.xtc)

:   Trajectory:

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr/.gro/â€¦\>\] (topol.tpr)

:   Structure+mass(db): brk ent

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx) (Optional)

:   Index file

` `{.docutils .literal .notranslate}[` -d `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.dat\>\] (sfactor.dat) (Optional)

:   Generic data file

Options to specify output files:

` `{.docutils .literal .notranslate}[` -sq `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (sq.xvg)

:   xvgr/xmgr file

Other options:

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of first frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of last frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -dt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Only use frame when t MOD dt = first time (default unit ps)

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   xvg plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -ng `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (1)

:   Number of groups to compute SAXS

` `{.docutils .literal .notranslate}[` -startq `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Starting q (1/nm)

` `{.docutils .literal .notranslate}[` -endq `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (60)

:   Ending q (1/nm)

` `{.docutils .literal .notranslate}[` -energy `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (12)

:   Energy of the incoming X-ray (keV)
:::
:::
::: {#gmx-scattering .section}
[ ]{#id1}

# gmx scattering

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx scattering [-f [<.xtc/.trr/...>]] [-s [<.tpr/.gro/...>]]
             [-n [<.ndx>]] [-o [<.xvg>]] [-b <time>] [-e <time>]
             [-dt <time>] [-tu <enum>] [-fgroup <selection>]
             [-xvg <enum>] [-[no]rmpbc] [-[no]pbc] [-sf <file>]
             [-selrpos <enum>] [-seltype <enum>] [-sel <selection>]
             [-startq <real>] [-endq <real>] [-qspacing <real>]
             [-binwidth <real>] [-mc-coverage <real>] [-seed <int>]
             [-[no]norm] [-[no]mc] [-scattering-type <enum>]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` scattering `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} calculates SANS
and SAXS scattering curves using Debye method.

The scattering intensity, I(q), as a function of scattering angle q with
averaging over frames.

Note that this is a new implementation of the SANS/SAXS utilities added
in GROMACS 2024. If you need the old ones, use ` `{.docutils .literal
.notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` sans-legacy `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} or
` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` saxs-legacy `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} .
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (traj.xtc) (Optional)

:   Input trajectory or single configuration:

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr/.gro/â€¦\>\] (topol.tpr) (Optional)

:   Input structure: brk ent

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx) (Optional)

:   Extra index groups

Options to specify output files:

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (scattering.xvg) (Optional)

:   scattering intensity as a function of q

Other options:

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   First frame (ps) to read from trajectory

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Last frame (ps) to read from trajectory

` `{.docutils .literal .notranslate}[` -dt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Only use frame if t MOD dt == first time (ps)

` `{.docutils .literal .notranslate}[` -tu `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (ps)

:   Unit for time values: fs, ps, ns, us, ms, s

` `{.docutils .literal .notranslate}[` -fgroup `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<selection\>

:   Atoms stored in the trajectory file (if not set, assume first N
    atoms)

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   Plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -[no]rmpbc `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Make molecules whole for each frame

` `{.docutils .literal .notranslate}[` -[no]pbc `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Use periodic boundary conditions for distance calculation

` `{.docutils .literal .notranslate}[` -sf `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<file\>

:   Provide selections from files

` `{.docutils .literal .notranslate}[` -selrpos `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (atom)

:   Selection reference positions: atom, res_com, res_cog, mol_com,
    mol_cog, whole_res_com, whole_res_cog, whole_mol_com, whole_mol_cog,
    part_res_com, part_res_cog, part_mol_com, part_mol_cog, dyn_res_com,
    dyn_res_cog, dyn_mol_com, dyn_mol_cog

` `{.docutils .literal .notranslate}[` -seltype `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (atom)

:   Default selection output positions: atom, res_com, res_cog, mol_com,
    mol_cog, whole_res_com, whole_res_cog, whole_mol_com, whole_mol_cog,
    part_res_com, part_res_cog, part_mol_com, part_mol_cog, dyn_res_com,
    dyn_res_cog, dyn_mol_com, dyn_mol_cog

` `{.docutils .literal .notranslate}[` -sel `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<selection\>

:   Selection for Scattering calculation

` `{.docutils .literal .notranslate}[` -startq `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   smallest q value (1/nm)

` `{.docutils .literal .notranslate}[` -endq `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (2)

:   largest q value (1/nm)

` `{.docutils .literal .notranslate}[` -qspacing `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0.01)

:   spacing of q values (1/nm)

` `{.docutils .literal .notranslate}[` -binwidth `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0.1)

:   Bin width (nm) for P(r)

` `{.docutils .literal .notranslate}[` -mc-coverage `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0.2)

:   coverage of Monte Carlo (%)

` `{.docutils .literal .notranslate}[` -seed `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (2023)

:   random seed for Monte Carlo

` `{.docutils .literal .notranslate}[` -[no]norm `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   normalize scattering intensities

` `{.docutils .literal .notranslate}[` -[no]mc `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   use Monte Carlo to scattering intensities

` `{.docutils .literal .notranslate}[` -scattering-type `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (sans)

:   Scattering type: saxs, sans
:::
:::
::: {#gmx-select .section}
[ ]{#id1}

# gmx select

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx select [-f [<.xtc/.trr/...>]] [-s [<.tpr/.gro/...>]] [-n [<.ndx>]]
           [-os [<.xvg>]] [-oc [<.xvg>]] [-oi [<.dat>]]
           [-on [<.ndx>]] [-om [<.xvg>]] [-of [<.xvg>]]
           [-ofpdb [<.pdb>]] [-olt [<.xvg>]] [-b <time>] [-e <time>]
           [-dt <time>] [-tu <enum>] [-fgroup <selection>]
           [-xvg <enum>] [-[no]rmpbc] [-[no]pbc] [-sf <file>]
           [-selrpos <enum>] [-seltype <enum>] [-select <selection>]
           [-[no]norm] [-[no]cfnorm] [-resnr <enum>]
           [-pdbatoms <enum>] [-[no]cumlt]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` select `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} writes out
basic data about dynamic selections. It can be used for some simple
analyses, or the output can be combined with output from other programs
and/or external analysis programs to calculate more complex things. For
detailed help on the selection syntax, please use ` `{.docutils .literal
.notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` help `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` selections `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} .

Any combination of the output options is possible, but note that
` `{.docutils .literal .notranslate}[` -om `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} only operates
on the first selection. Also note that if you provide no output options,
no output is produced.

With ` `{.docutils .literal .notranslate}[` -os `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , calculates
the number of positions in each selection for each frame. With
` `{.docutils .literal .notranslate}[` -norm `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , the output is
between 0 and 1 and describes the fraction from the maximum number of
positions (e.g., for selection â€˜resname RA and x \< 5â€™ the maximum
number of positions is the number of atoms in RA residues). With
` `{.docutils .literal .notranslate}[` -cfnorm `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , the output is
divided by the fraction covered by the selection. ` `{.docutils .literal
.notranslate}[` -norm `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` -cfnorm `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} can be
specified independently of one another.

With ` `{.docutils .literal .notranslate}[` -oc `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , the fraction
covered by each selection is written out as a function of time.

With ` `{.docutils .literal .notranslate}[` -oi `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , the selected
atoms/residues/molecules are written out as a function of time. In the
output, the first column contains the frame time, the second contains
the number of positions, followed by the atom/residue/molecule numbers.
If more than one selection is specified, the size of the second group
immediately follows the last number of the first group and so on.

With ` `{.docutils .literal .notranslate}[` -on `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , the selected
atoms are written as a index file compatible with ` `{.docutils .literal
.notranslate}[` make_ndx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and the
analyzing tools. Each selection is written as a selection group and for
dynamic selections a group is written for each frame.

For residue numbers, the output of ` `{.docutils .literal
.notranslate}[` -oi `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} can be
controlled with ` `{.docutils .literal
.notranslate}[` -resnr `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} : ` `{.docutils
.literal .notranslate}[` number `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} (default)
prints the residue numbers as they appear in the input file, while
` `{.docutils .literal .notranslate}[` index `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} prints unique
numbers assigned to the residues in the order they appear in the input
file, starting with 1. The former is more intuitive, but if the input
contains multiple residues with the same number, the output can be less
useful.

With ` `{.docutils .literal .notranslate}[` -om `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , a mask is
printed for the first selection as a function of time. Each line in the
output corresponds to one frame, and contains either 0/1 for each
atom/residue/molecule possibly selected. 1 stands for the
atom/residue/molecule being selected for the current frame, 0 for not
selected.

With ` `{.docutils .literal .notranslate}[` -of `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , the occupancy
fraction of each position (i.e., the fraction of frames where the
position is selected) is printed.

With ` `{.docutils .literal .notranslate}[` -ofpdb `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , a PDB file is
written out where the occupancy column is filled with the occupancy
fraction of each atom in the selection. The coordinates in the PDB file
will be those from the input topology. ` `{.docutils .literal
.notranslate}[` -pdbatoms `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} can be used to
control which atoms appear in the output PDB file: with ` `{.docutils
.literal .notranslate}[` all `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} all atoms are
present, with ` `{.docutils .literal .notranslate}[` maxsel `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} all
atoms possibly selected by the selection are present, and with
` `{.docutils .literal .notranslate}[` selected `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} only atoms that
are selected at least in one frame are present.

With ` `{.docutils .literal .notranslate}[` -olt `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , a histogram
is produced that shows the number of selected positions as a function of
the time the position was continuously selected. ` `{.docutils .literal
.notranslate}[` -cumlt `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} can be used to
control whether subintervals of longer intervals are included in the
histogram.

` `{.docutils .literal .notranslate}[` -om `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , ` `{.docutils
.literal .notranslate}[` -of `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , and
` `{.docutils .literal .notranslate}[` -olt `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} only make sense
with dynamic selections.

To plot coordinates for selections, use .
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (traj.xtc) (Optional)

:   Input trajectory or single configuration:

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr/.gro/â€¦\>\] (topol.tpr) (Optional)

:   Input structure: brk ent

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx) (Optional)

:   Extra index groups

Options to specify output files:

` `{.docutils .literal .notranslate}[` -os `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (size.xvg) (Optional)

:   Number of positions in each selection

` `{.docutils .literal .notranslate}[` -oc `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (cfrac.xvg) (Optional)

:   Covered fraction for each selection

` `{.docutils .literal .notranslate}[` -oi `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.dat\>\] (index.dat) (Optional)

:   Indices selected by each selection

` `{.docutils .literal .notranslate}[` -on `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx) (Optional)

:   Index file from the selection

` `{.docutils .literal .notranslate}[` -om `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (mask.xvg) (Optional)

:   Mask for selected positions

` `{.docutils .literal .notranslate}[` -of `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (occupancy.xvg) (Optional)

:   Occupied fraction for selected positions

` `{.docutils .literal .notranslate}[` -ofpdb `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.pdb\>\] (occupancy.pdb) (Optional)

:   PDB file with occupied fraction for selected positions

` `{.docutils .literal .notranslate}[` -olt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (lifetime.xvg) (Optional)

:   Lifetime histogram

Other options:

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   First frame (ps) to read from trajectory

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Last frame (ps) to read from trajectory

` `{.docutils .literal .notranslate}[` -dt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Only use frame if t MOD dt == first time (ps)

` `{.docutils .literal .notranslate}[` -tu `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (ps)

:   Unit for time values: fs, ps, ns, us, ms, s

` `{.docutils .literal .notranslate}[` -fgroup `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<selection\>

:   Atoms stored in the trajectory file (if not set, assume first N
    atoms)

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   Plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -[no]rmpbc `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Make molecules whole for each frame

` `{.docutils .literal .notranslate}[` -[no]pbc `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Use periodic boundary conditions for distance calculation

` `{.docutils .literal .notranslate}[` -sf `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<file\>

:   Provide selections from files

` `{.docutils .literal .notranslate}[` -selrpos `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (atom)

:   Selection reference positions: atom, res_com, res_cog, mol_com,
    mol_cog, whole_res_com, whole_res_cog, whole_mol_com, whole_mol_cog,
    part_res_com, part_res_cog, part_mol_com, part_mol_cog, dyn_res_com,
    dyn_res_cog, dyn_mol_com, dyn_mol_cog

` `{.docutils .literal .notranslate}[` -seltype `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (atom)

:   Default selection output positions: atom, res_com, res_cog, mol_com,
    mol_cog, whole_res_com, whole_res_cog, whole_mol_com, whole_mol_cog,
    part_res_com, part_res_cog, part_mol_com, part_mol_cog, dyn_res_com,
    dyn_res_cog, dyn_mol_com, dyn_mol_cog

` `{.docutils .literal .notranslate}[` -select `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<selection\>

:   Selections to analyze

` `{.docutils .literal .notranslate}[` -[no]norm `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Normalize by total number of positions with -os

` `{.docutils .literal .notranslate}[` -[no]cfnorm `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Normalize by covered fraction with -os

` `{.docutils .literal .notranslate}[` -resnr `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (number)

:   Residue number output type with -oi and -on: number, index

` `{.docutils .literal .notranslate}[` -pdbatoms `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (all)

:   Atoms to write with -ofpdb: all, maxsel, selected

` `{.docutils .literal .notranslate}[` -[no]cumlt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Cumulate subintervals of longer intervals in -olt
:::
:::
::: {#gmx-sham .section}
[ ]{#id1}

# gmx sham

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx sham [-f [<.xvg>]] [-ge [<.xvg>]] [-ene [<.xvg>]] [-dist [<.xvg>]]
         [-histo [<.xvg>]] [-bin [<.ndx>]] [-lp [<.xpm>]]
         [-ls [<.xpm>]] [-lsh [<.xpm>]] [-lss [<.xpm>]]
         [-ls3 [<.pdb>]] [-g [<.log>]] [-[no]w] [-xvg <enum>]
         [-[no]time] [-b <real>] [-e <real>] [-ttol <real>]
         [-n <int>] [-[no]d] [-[no]sham] [-tsham <real>]
         [-pmin <real>] [-dim <vector>] [-ngrid <vector>]
         [-xmin <vector>] [-xmax <vector>] [-pmax <real>]
         [-gmax <real>] [-emin <real>] [-emax <real>]
         [-nlevels <int>]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` sham `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} makes
multi-dimensional free-energy, enthalpy and entropy plots. ` `{.docutils
.literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` sham `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} reads one or
more files and analyzes data sets. The basic purpose of ` `{.docutils
.literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` sham `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} is to plot
Gibbs free energy landscapes (option ` `{.docutils .literal
.notranslate}[` -ls `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ) by Bolzmann
inverting multi-dimensional histograms (option ` `{.docutils .literal
.notranslate}[` -lp `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ), but it can
also make enthalpy (option ` `{.docutils .literal
.notranslate}[` -lsh `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ) and entropy
(option ` `{.docutils .literal .notranslate}[` -lss `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ) plots. The
histograms can be made for any quantities the user supplies. A line in
the input file may start with a time (see option ` `{.docutils .literal
.notranslate}[` -time `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ) and any
number of *y* -values may follow. Multiple sets can also be read when
they are separated by & (option ` `{.docutils .literal
.notranslate}[` -n `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ), in this case
only one *y* -value is read from each line. All lines starting with \#
and @ are skipped.

Option ` `{.docutils .literal .notranslate}[` -ge `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} can be used to
supply a file with free energies when the ensemble is not a Boltzmann
ensemble, but needs to be biased by this free energy. One free energy
value is required for each (multi-dimensional) data point in the
` `{.docutils .literal .notranslate}[` -f `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} input.

Option ` `{.docutils .literal .notranslate}[` -ene `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} can be used to
supply a file with energies. These energies are used as a weighting
function in the single histogram analysis method by Kumar et al. When
temperatures are supplied (as a second column in the file), an
experimental weighting scheme is applied. In addition the vales are used
for making enthalpy and entropy plots.

With option ` `{.docutils .literal .notranslate}[` -dim `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} ,
dimensions can be gives for distances. When a distance is 2- or
3-dimensional, the circumference or surface sampled by two particles
increases with increasing distance. Depending on what one would like to
show, one can choose to correct the histogram and free-energy for this
volume effect. The probability is normalized by r and r\^2 for
dimensions of 2 and 3, respectively. A value of -1 is used to indicate
an angle in degrees between two vectors: a sin(angle) normalization will
be applied. **Note** that for angles between vectors the inner-product
or cosine is the natural quantity to use, as it will produce bins of the
same volume.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (graph.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -ge `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (gibbs.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -ene `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (esham.xvg) (Optional)

:   xvgr/xmgr file

Options to specify output files:

` `{.docutils .literal .notranslate}[` -dist `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (ener.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -histo `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (edist.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -bin `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (bindex.ndx) (Optional)

:   Index file

` `{.docutils .literal .notranslate}[` -lp `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xpm\>\] (prob.xpm) (Optional)

:   X PixMap compatible matrix file

` `{.docutils .literal .notranslate}[` -ls `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xpm\>\] (gibbs.xpm) (Optional)

:   X PixMap compatible matrix file

` `{.docutils .literal .notranslate}[` -lsh `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xpm\>\] (enthalpy.xpm) (Optional)

:   X PixMap compatible matrix file

` `{.docutils .literal .notranslate}[` -lss `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xpm\>\] (entropy.xpm) (Optional)

:   X PixMap compatible matrix file

` `{.docutils .literal .notranslate}[` -ls3 `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.pdb\>\] (gibbs3.pdb) (Optional)

:   Protein data bank file

` `{.docutils .literal .notranslate}[` -g `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.log\>\] (shamlog.log) (Optional)

:   Log file

Other options:

` `{.docutils .literal .notranslate}[` -[no]w `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   View output , , and files

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   xvg plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -[no]time `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Expect a time in the input

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (-1)

:   First time to read from set

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (-1)

:   Last time to read from set

` `{.docutils .literal .notranslate}[` -ttol `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Tolerance on time in appropriate units (usually ps)

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (1)

:   Read this number of sets separated by lines containing only an
    ampersand

` `{.docutils .literal .notranslate}[` -[no]d `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Use the derivative

` `{.docutils .literal .notranslate}[` -[no]sham `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Turn off energy weighting even if energies are given

` `{.docutils .literal .notranslate}[` -tsham `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (298.15)

:   Temperature for single histogram analysis

` `{.docutils .literal .notranslate}[` -pmin `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Minimum probability. Anything lower than this will be set to zero

` `{.docutils .literal .notranslate}[` -dim `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<vector\> (1 1 1)

:   Dimensions for distances, used for volume correction (max 3 values,
    dimensions \> 3 will get the same value as the last)

` `{.docutils .literal .notranslate}[` -ngrid `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<vector\> (32 32 32)

:   Number of bins for energy landscapes (max 3 values, dimensions \> 3
    will get the same value as the last)

` `{.docutils .literal .notranslate}[` -xmin `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<vector\> (0 0 0)

:   Minimum for the axes in energy landscape (see above for \> 3
    dimensions)

` `{.docutils .literal .notranslate}[` -xmax `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<vector\> (1 1 1)

:   Maximum for the axes in energy landscape (see above for \> 3
    dimensions)

` `{.docutils .literal .notranslate}[` -pmax `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Maximum probability in output, default is calculate

` `{.docutils .literal .notranslate}[` -gmax `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Maximum free energy in output, default is calculate

` `{.docutils .literal .notranslate}[` -emin `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Minimum enthalpy in output, default is calculate

` `{.docutils .literal .notranslate}[` -emax `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Maximum enthalpy in output, default is calculate

` `{.docutils .literal .notranslate}[` -nlevels `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (25)

:   Number of levels for energy landscape
:::
:::
::: {#gmx-sigeps .section}
[ ]{#id1}

# gmx sigeps

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx sigeps [-o [<.xvg>]] [-[no]w] [-xvg <enum>] [-c6 <real>]
           [-cn <real>] [-pow <int>] [-sig <real>] [-eps <real>]
           [-A <real>] [-B <real>] [-C <real>] [-qi <real>]
           [-qj <real>] [-sigfac <real>]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` sigeps `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} is a simple
utility that converts C6/C12 or C6/Cn combinations to sigma and epsilon,
or vice versa. It can also plot the potential in file. In addition, it
makes an approximation of a Buckingham potential to a Lennard-Jones
potential.
:::

::: {#options .section}
## Options

Options to specify output files:

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (potje.xvg)

:   xvgr/xmgr file

Other options:

` `{.docutils .literal .notranslate}[` -[no]w `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   View output , , and files

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   xvg plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -c6 `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0.001)

:   C6

` `{.docutils .literal .notranslate}[` -cn `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (1e-06)

:   Constant for repulsion

` `{.docutils .literal .notranslate}[` -pow `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (12)

:   Power of the repulsion term

` `{.docutils .literal .notranslate}[` -sig `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0.3)

:   sigma

` `{.docutils .literal .notranslate}[` -eps `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (1)

:   epsilon

` `{.docutils .literal .notranslate}[` -A `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (100000)

:   Buckingham A

` `{.docutils .literal .notranslate}[` -B `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (32)

:   Buckingham B

` `{.docutils .literal .notranslate}[` -C `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0.001)

:   Buckingham C

` `{.docutils .literal .notranslate}[` -qi `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   qi

` `{.docutils .literal .notranslate}[` -qj `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   qj

` `{.docutils .literal .notranslate}[` -sigfac `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0.7)

:   Factor in front of sigma for starting the plot
:::
:::
::: {#gmx-solvate .section}
[ ]{#id1}

# gmx solvate

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx solvate [-cp [<.gro/.g96/...>]] [-cs [<.gro/.g96/...>]]
            [-p [<.top>]] [-o [<.gro/.g96/...>]] [-box <vector>]
            [-radius <real>] [-scale <real>] [-shell <real>]
            [-maxsol <int>] [-[no]vel]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` solvate `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} can do one of 2
things:

1\) Generate a box of solvent. Specify ` `{.docutils .literal
.notranslate}[` -cs `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` -box `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . Or specify
` `{.docutils .literal .notranslate}[` -cs `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` -cp `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} with a
structure file with a box, but without atoms.

2\) Solvate a solute configuration, e.g. a protein, in a bath of solvent
molecules. Specify ` `{.docutils .literal
.notranslate}[` -cp `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} (solute) and
` `{.docutils .literal .notranslate}[` -cs `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} (solvent). The
box specified in the solute coordinate file ( ` `{.docutils .literal
.notranslate}[` -cp `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ) is used,
unless ` `{.docutils .literal .notranslate}[` -box `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} is set. If you
want the solute to be centered in the box, the program has sophisticated
options to change the box dimensions and center the solute. Solvent
molecules are removed from the box where the distance between any atom
of the solute molecule(s) and any atom of the solvent molecule is less
than the sum of the scaled van der Waals radii of both atoms. A database
( ` `{.docutils .literal .notranslate}[` vdwradii.dat `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} ) of
van der Waals radii is read by the program, and the resulting radii
scaled by ` `{.docutils .literal .notranslate}[` -scale `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} . If
radii are not found in the database, those atoms are assigned the
(pre-scaled) distance ` `{.docutils .literal
.notranslate}[` -radius `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . Note that the
usefulness of those radii depends on the atom names, and thus varies
widely with force field.

The default solvent is Simple Point Charge water (SPC), with coordinates
from ` `{.docutils .literal
.notranslate}[` $GMXLIB/spc216.gro `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . These
coordinates can also be used for other 3-site water models, since a
short equibilibration will remove the small differences between the
models. Other solvents are also supported, as well as mixed solvents.
The only restriction to solvent types is that a solvent molecule
consists of exactly one residue. The residue information in the
coordinate files is used, and should therefore be more or less
consistent. In practice this means that two subsequent solvent molecules
in the solvent coordinate file should have different residue number. The
box of solute is built by stacking the coordinates read from the
coordinate file. This means that these coordinates should be equlibrated
in periodic boundary conditions to ensure a good alignment of molecules
on the stacking interfaces. The ` `{.docutils .literal
.notranslate}[` -maxsol `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} option simply
adds only the first ` `{.docutils .literal
.notranslate}[` -maxsol `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} solvent
molecules and leaves out the rest that would have fitted into the box.
This can create a void that can cause problems later. Choose your volume
wisely.

Setting ` `{.docutils .literal .notranslate}[` -shell `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} larger
than zero will place a layer of water of the specified thickness (nm)
around the solute. Hint: it is a good idea to put the protein in the
center of a box first (using ).

Finally, ` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` solvate `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} will optionally
remove lines from your topology file in which a number of solvent
molecules is already added, and adds a line with the total number of
solvent molecules in your coordinate file.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -cp `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.gro/.g96/â€¦\>\] (protein.gro) (Optional)

:   Structure file: brk ent esp

` `{.docutils .literal .notranslate}[` -cs `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.gro/.g96/â€¦\>\] (spc216.gro) (Library)

:   Structure file: brk ent esp

Options to specify input/output files:

` `{.docutils .literal .notranslate}[` -p `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.top\>\] (topol.top) (Optional)

:   Topology file

Options to specify output files:

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.gro/.g96/â€¦\>\] (out.gro)

:   Structure file: brk ent esp

Other options:

` `{.docutils .literal .notranslate}[` -box `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<vector\> (0 0 0)

:   Box size (in nm)

` `{.docutils .literal .notranslate}[` -radius `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0.105)

:   Default van der Waals distance

` `{.docutils .literal .notranslate}[` -scale `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0.57)

:   Scale factor to multiply Van der Waals radii from the database in
    share/gromacs/top/vdwradii.dat. The default value of 0.57 yields
    density close to 1000 g/l for proteins in water.

` `{.docutils .literal .notranslate}[` -shell `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Thickness of optional water layer around solute

` `{.docutils .literal .notranslate}[` -maxsol `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (0)

:   Maximum number of solvent molecules to add if they fit in the box.
    If zero (default) this is ignored

` `{.docutils .literal .notranslate}[` -[no]vel `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Keep velocities from input solute and solvent
:::

::: {#known-issues .section}
## Known Issues

-   Molecules must be whole in the initial configurations.
:::
:::
::: {#gmx-sorient .section}
[ ]{#id1}

# gmx sorient

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx sorient [-f [<.xtc/.trr/...>]] [-s [<.tpr/.gro/...>]] [-n [<.ndx>]]
            [-o [<.xvg>]] [-no [<.xvg>]] [-ro [<.xvg>]]
            [-co [<.xvg>]] [-rc [<.xvg>]] [-b <time>] [-e <time>]
            [-dt <time>] [-[no]w] [-xvg <enum>] [-[no]com] [-[no]v23]
            [-rmin <real>] [-rmax <real>] [-cbin <real>]
            [-rbin <real>] [-[no]pbc]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` sorient `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} analyzes
solvent orientation around solutes. It calculates two angles between the
vector from one or more reference positions to the first atom of each
solvent molecule:

> <div>
>
> -   theta_1: the angle with the vector from the first atom of the
>     solvent molecule to the midpoint between atoms 2 and 3.
>
> -   theta_2: the angle with the normal of the solvent plane, defined
>     by the same three atoms, or, when the option ` `{.docutils
>     .literal .notranslate}[` -v23 `{.docutils .literal
>     .notranslate}]{.pre}` `{.docutils .literal .notranslate} is set,
>     the angle with the vector between atoms 2 and 3.
>
> </div>

The reference can be a set of atoms or the center of mass of a set of
atoms. The group of solvent atoms should consist of 3 atoms per solvent
molecule. Only solvent molecules between ` `{.docutils .literal
.notranslate}[` -rmin `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` -rmax `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} are considered
for ` `{.docutils .literal .notranslate}[` -o `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` -no `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} each frame.

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} : distribution
of cos(theta_1) for rmin\<=r\<=rmax.

` `{.docutils .literal .notranslate}[` -no `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} : distribution
of cos(theta_2) for rmin\<=r\<=rmax.

` `{.docutils .literal .notranslate}[` -ro `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} :
\<cos(theta_1)\> and \<3cos(\^2theta_2)-1\> as a function of the
distance.

` `{.docutils .literal .notranslate}[` -co `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} : the sum over
all solvent molecules within distance r of cos(theta_1) and
3cos(\^2(theta_2)-1) as a function of r.

` `{.docutils .literal .notranslate}[` -rc `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} : the
distribution of the solvent molecules as a function of r
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (traj.xtc)

:   Trajectory:

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr/.gro/â€¦\>\] (topol.tpr)

:   Structure+mass(db): brk ent

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx) (Optional)

:   Index file

Options to specify output files:

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (sori.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -no `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (snor.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -ro `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (sord.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -co `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (scum.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -rc `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (scount.xvg)

:   xvgr/xmgr file

Other options:

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of first frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of last frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -dt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Only use frame when t MOD dt = first time (default unit ps)

` `{.docutils .literal .notranslate}[` -[no]w `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   View output , , and files

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   xvg plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -[no]com `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Use the center of mass as the reference position

` `{.docutils .literal .notranslate}[` -[no]v23 `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Use the vector between atoms 2 and 3

` `{.docutils .literal .notranslate}[` -rmin `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Minimum distance (nm)

` `{.docutils .literal .notranslate}[` -rmax `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0.5)

:   Maximum distance (nm)

` `{.docutils .literal .notranslate}[` -cbin `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0.02)

:   Binwidth for the cosine

` `{.docutils .literal .notranslate}[` -rbin `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0.02)

:   Binwidth for r (nm)

` `{.docutils .literal .notranslate}[` -[no]pbc `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Check PBC for the center of mass calculation. Only necessary when
    your reference group consists of several molecules.
:::
:::
::: {#gmx-spatial .section}
[ ]{#id1}

# gmx spatial

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx spatial [-s [<.tpr/.gro/...>]] [-f [<.xtc/.trr/...>]] [-n [<.ndx>]]
            [-b <time>] [-e <time>] [-dt <time>] [-[no]w] [-[no]pbc]
            [-[no]div] [-ign <int>] [-bin <real>] [-nab <int>]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` spatial `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} calculates the
spatial distribution function and outputs it in a form that can be read
by VMD as Gaussian98 cube format. For a system of 32,000 atoms and a 50
ns trajectory, the SDF can be generated in about 30 minutes, with most
of the time dedicated to the two runs through ` `{.docutils .literal
.notranslate}[` trjconv `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} that are
required to center everything properly. This also takes a whole bunch of
space (3 copies of the trajectory file). Still, the pictures are pretty
and very informative when the fitted selection is properly made. 3-4
atoms in a widely mobile group (like a free amino acid in solution)
works well, or select the protein backbone in a stable folded structure
to get the SDF of solvent and look at the time-averaged solvation shell.
It is also possible using this program to generate the SDF based on some
arbitrary Cartesian coordinate. To do that, simply omit the preliminary
steps.

Usage:

> <div>
>
> 1.  Use to create a group containing the atoms around which you want
>     the SDF
>
> 2.  ` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
>     .notranslate}]{.pre}` `{.docutils .literal
>     .notranslate}[` trjconv `{.docutils .literal
>     .notranslate}]{.pre}` `{.docutils .literal
>     .notranslate}[` -s `{.docutils .literal
>     .notranslate}]{.pre}` `{.docutils .literal
>     .notranslate}[` a.tpr `{.docutils .literal
>     .notranslate}]{.pre}` `{.docutils .literal
>     .notranslate}[` -f `{.docutils .literal
>     .notranslate}]{.pre}` `{.docutils .literal
>     .notranslate}[` a.tng `{.docutils .literal
>     .notranslate}]{.pre}` `{.docutils .literal
>     .notranslate}[` -o `{.docutils .literal
>     .notranslate}]{.pre}` `{.docutils .literal
>     .notranslate}[` b.tng `{.docutils .literal
>     .notranslate}]{.pre}` `{.docutils .literal
>     .notranslate}[` -boxcenter `{.docutils .literal
>     .notranslate}]{.pre}` `{.docutils .literal
>     .notranslate}[` tric `{.docutils .literal
>     .notranslate}]{.pre}` `{.docutils .literal
>     .notranslate}[` -ur `{.docutils .literal
>     .notranslate}]{.pre}` `{.docutils .literal
>     .notranslate}[` compact `{.docutils .literal
>     .notranslate}]{.pre}` `{.docutils .literal
>     .notranslate}[` -pbc `{.docutils .literal
>     .notranslate}]{.pre}` `{.docutils .literal
>     .notranslate}[` none `{.docutils .literal
>     .notranslate}]{.pre}` `{.docutils .literal .notranslate}
>
> 3.  ` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
>     .notranslate}]{.pre}` `{.docutils .literal
>     .notranslate}[` trjconv `{.docutils .literal
>     .notranslate}]{.pre}` `{.docutils .literal
>     .notranslate}[` -s `{.docutils .literal
>     .notranslate}]{.pre}` `{.docutils .literal
>     .notranslate}[` a.tpr `{.docutils .literal
>     .notranslate}]{.pre}` `{.docutils .literal
>     .notranslate}[` -f `{.docutils .literal
>     .notranslate}]{.pre}` `{.docutils .literal
>     .notranslate}[` b.tng `{.docutils .literal
>     .notranslate}]{.pre}` `{.docutils .literal
>     .notranslate}[` -o `{.docutils .literal
>     .notranslate}]{.pre}` `{.docutils .literal
>     .notranslate}[` c.tng `{.docutils .literal
>     .notranslate}]{.pre}` `{.docutils .literal
>     .notranslate}[` -fit `{.docutils .literal
>     .notranslate}]{.pre}` `{.docutils .literal
>     .notranslate}[` rot+trans `{.docutils .literal
>     .notranslate}]{.pre}` `{.docutils .literal .notranslate}
>
> 4.  run ` `{.docutils .literal .notranslate}[` gmx `{.docutils
>     .literal .notranslate}]{.pre}` `{.docutils .literal
>     .notranslate}[` spatial `{.docutils .literal
>     .notranslate}]{.pre}` `{.docutils .literal .notranslate} on the
>     ` `{.docutils .literal .notranslate}[` c.tng `{.docutils .literal
>     .notranslate}]{.pre}` `{.docutils .literal .notranslate} output of
>     step #3.
>
> 5.  Load ` `{.docutils .literal .notranslate}[` grid.cube `{.docutils
>     .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}
>     into VMD and view as an isosurface.
>
> </div>

**Note** that systems such as micelles will require ` `{.docutils
.literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` trjconv `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` -pbc `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` cluster `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} between steps 1
and 2.

::: {#warnings .section}
### Warnings

The SDF will be generated for a cube that contains all bins that have
some non-zero occupancy. However, the preparatory ` `{.docutils .literal
.notranslate}[` -fit `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` rot+trans `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} option to
implies that your system will be rotating and translating in space (in
order that the selected group does not). Therefore the values that are
returned will only be valid for some region around your central
group/coordinate that has full overlap with system volume throughout the
entire translated/rotated system over the course of the trajectory. It
is up to the user to ensure that this is the case.
:::

::: {#risky-options .section}
### Risky options

To reduce the amount of space and time required, you can output only the
coords that are going to be used in the first and subsequent run through
. However, be sure to set the ` `{.docutils .literal
.notranslate}[` -nab `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} option to a
sufficiently high value since memory is allocated for cube bins based on
the initial coordinates and the ` `{.docutils .literal
.notranslate}[` -nab `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} option value.
:::
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr/.gro/â€¦\>\] (topol.tpr)

:   Structure+mass(db): brk ent

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (traj.xtc)

:   Trajectory:

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx) (Optional)

:   Index file

Other options:

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of first frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of last frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -dt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Only use frame when t MOD dt = first time (default unit ps)

` `{.docutils .literal .notranslate}[` -[no]w `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   View output , , and files

` `{.docutils .literal .notranslate}[` -[no]pbc `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Use periodic boundary conditions for computing distances

` `{.docutils .literal .notranslate}[` -[no]div `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Calculate and apply the divisor for bin occupancies based on
    atoms/minimal cube size. Set as TRUE for visualization and as FALSE
    ( ` `{.docutils .literal .notranslate}[` -nodiv `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} ) to get
    accurate counts per frame

` `{.docutils .literal .notranslate}[` -ign `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (-1)

:   Do not display this number of outer cubes (positive values may
    reduce boundary speckles; -1 ensures outer surface is visible)

` `{.docutils .literal .notranslate}[` -bin `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0.05)

:   Width of the bins (nm)

` `{.docutils .literal .notranslate}[` -nab `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (16)

:   Number of additional bins to ensure proper memory allocation
:::

::: {#known-issues .section}
## Known Issues

-   When the allocated memory is not large enough, an error may occur
    suggesting the use of the ` `{.docutils .literal
    .notranslate}[` -nab `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} (Number of
    Additional Bins) option or increasing the ` `{.docutils .literal
    .notranslate}[` -nab `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} value.
:::
:::
::: {#gmx-spol .section}
[ ]{#id1}

# gmx spol

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx spol [-f [<.xtc/.trr/...>]] [-s [<.tpr>]] [-n [<.ndx>]]
         [-o [<.xvg>]] [-b <time>] [-e <time>] [-dt <time>] [-[no]w]
         [-xvg <enum>] [-[no]com] [-refat <int>] [-rmin <real>]
         [-rmax <real>] [-dip <real>] [-bw <real>]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` spol `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} analyzes
dipoles around a solute; it is especially useful for polarizable water.
A group of reference atoms, or a center of mass reference (option
` `{.docutils .literal .notranslate}[` -com `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ) and a group
of solvent atoms is required. The program splits the group of solvent
atoms into molecules. For each solvent molecule the distance to the
closest atom in reference group or to the COM is determined. A
cumulative distribution of these distances is plotted. For each distance
between ` `{.docutils .literal .notranslate}[` -rmin `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` -rmax `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} the inner
product of the distance vector and the dipole of the solvent molecule is
determined. For solvent molecules with net charge (ions), the net charge
of the ion is subtracted evenly from all atoms in the selection of each
ion. The average of these dipole components is printed. The same is done
for the polarization, where the average dipole is subtracted from the
instantaneous dipole. The magnitude of the average dipole is set with
the option ` `{.docutils .literal .notranslate}[` -dip `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} , the
direction is defined by the vector from the first atom in the selected
solvent group to the midpoint between the second and the third atom.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (traj.xtc)

:   Trajectory:

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr\>\] (topol.tpr)

:   Portable xdr run input file

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx) (Optional)

:   Index file

Options to specify output files:

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (scdist.xvg)

:   xvgr/xmgr file

Other options:

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of first frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of last frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -dt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Only use frame when t MOD dt = first time (default unit ps)

` `{.docutils .literal .notranslate}[` -[no]w `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   View output , , and files

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   xvg plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -[no]com `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Use the center of mass as the reference position

` `{.docutils .literal .notranslate}[` -refat `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (1)

:   The reference atom of the solvent molecule

` `{.docutils .literal .notranslate}[` -rmin `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Maximum distance (nm)

` `{.docutils .literal .notranslate}[` -rmax `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0.32)

:   Maximum distance (nm)

` `{.docutils .literal .notranslate}[` -dip `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   The average dipole (D)

` `{.docutils .literal .notranslate}[` -bw `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0.01)

:   The bin width
:::
:::
::: {#gmx-tcaf .section}
[ ]{#id1}

# gmx tcaf

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx tcaf [-f [<.trr/.cpt/...>]] [-s [<.tpr/.gro/...>]] [-n [<.ndx>]]
         [-ot [<.xvg>]] [-oa [<.xvg>]] [-o [<.xvg>]] [-of [<.xvg>]]
         [-oc [<.xvg>]] [-ov [<.xvg>]] [-b <time>] [-e <time>]
         [-dt <time>] [-[no]w] [-xvg <enum>] [-[no]mol] [-[no]k34]
         [-wt <real>] [-acflen <int>] [-[no]normalize] [-P <enum>]
         [-fitfn <enum>] [-beginfit <real>] [-endfit <real>]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` tcaf `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} computes
tranverse current autocorrelations. These are used to estimate the shear
viscosity, eta. For details see: Palmer, Phys. Rev. E 49 (1994) pp
359-366.

Transverse currents are calculated using the k-vectors (1,0,0) and
(2,0,0) each also in the *y* - and *z* -direction, (1,1,0) and (1,-1,0)
each also in the 2 other planes (these vectors are not independent) and
(1,1,1) and the 3 other box diagonals (also not independent). For each
k-vector the sine and cosine are used, in combination with the velocity
in 2 perpendicular directions. This gives a total of 16\*2\*2=64
transverse currents. One autocorrelation is calculated fitted for each
k-vector, which gives 16 TCAFs. Each of these TCAFs is fitted to f(t) =
exp(-v)(cosh(Wv) + 1/W sinh(Wv)), v = -t/(2 tau), W = sqrt(1 - 4 tau
eta/rho k\^2), which gives 16 values of tau and eta. The fit weights
decay exponentially with time constant w (given with ` `{.docutils
.literal .notranslate}[` -wt `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ) as exp(-t/w),
and the TCAF and fit are calculated up to time 5\*w. The eta values
should be fitted to 1 - a eta(k) k\^2, from which one can estimate the
shear viscosity at k=0.

When the box is cubic, one can use the option ` `{.docutils .literal
.notranslate}[` -oc `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , which
averages the TCAFs over all k-vectors with the same length. This results
in more accurate TCAFs. Both the cubic TCAFs and fits are written to
` `{.docutils .literal .notranslate}[` -oc `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} The cubic eta
estimates are also written to ` `{.docutils .literal
.notranslate}[` -ov `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} .

With option ` `{.docutils .literal .notranslate}[` -mol `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} , the
transverse current is determined of molecules instead of atoms. In this
case, the index group should consist of molecule numbers instead of atom
numbers.

The k-dependent viscosities in the ` `{.docutils .literal
.notranslate}[` -ov `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} file should be
fitted to eta(k) = eta_0 (1 - a k\^2) to obtain the viscosity at
infinite wavelength.

**Note:** make sure you write coordinates and velocities often enough.
The initial, non-exponential, part of the autocorrelation function is
very important for obtaining a good fit.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.trr/.cpt/â€¦\>\] (traj.trr)

:   Full precision trajectory:

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr/.gro/â€¦\>\] (topol.tpr) (Optional)

:   Structure+mass(db): brk ent

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx) (Optional)

:   Index file

Options to specify output files:

` `{.docutils .literal .notranslate}[` -ot `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (transcur.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -oa `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (tcaf_all.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (tcaf.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -of `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (tcaf_fit.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -oc `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (tcaf_cub.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -ov `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (visc_k.xvg)

:   xvgr/xmgr file

Other options:

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of first frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of last frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -dt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Only use frame when t MOD dt = first time (default unit ps)

` `{.docutils .literal .notranslate}[` -[no]w `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   View output , , and files

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   xvg plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -[no]mol `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Calculate TCAF of molecules

` `{.docutils .literal .notranslate}[` -[no]k34 `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Also use k=(3,0,0) and k=(4,0,0)

` `{.docutils .literal .notranslate}[` -wt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (5)

:   Exponential decay time for the TCAF fit weights

` `{.docutils .literal .notranslate}[` -acflen `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (-1)

:   Length of the ACF, default is half the number of frames

` `{.docutils .literal .notranslate}[` -[no]normalize `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Normalize ACF

` `{.docutils .literal .notranslate}[` -P `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (0)

:   Order of Legendre polynomial for ACF (0 indicates none): 0, 1, 2, 3

` `{.docutils .literal .notranslate}[` -fitfn `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (none)

:   Fit function: none, exp, aexp, exp_exp, exp5, exp7, exp9

` `{.docutils .literal .notranslate}[` -beginfit `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Time where to begin the exponential fit of the correlation function

` `{.docutils .literal .notranslate}[` -endfit `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (-1)

:   Time where to end the exponential fit of the correlation function,
    -1 is until the end
:::
:::
::: {#gmx-traj .section}
[ ]{#id1}

# gmx traj

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx traj [-f [<.xtc/.trr/...>]] [-s [<.tpr/.gro/...>]] [-n [<.ndx>]]
         [-ox [<.xvg>]] [-oxt [<.xtc/.trr/...>]] [-ov [<.xvg>]]
         [-of [<.xvg>]] [-ob [<.xvg>]] [-ot [<.xvg>]] [-ekt [<.xvg>]]
         [-ekr [<.xvg>]] [-vd [<.xvg>]] [-cv [<.pdb>]] [-cf [<.pdb>]]
         [-av [<.xvg>]] [-af [<.xvg>]] [-b <time>] [-e <time>]
         [-dt <time>] [-tu <enum>] [-[no]w] [-xvg <enum>] [-[no]com]
         [-[no]pbc] [-[no]mol] [-[no]nojump] [-[no]x] [-[no]y]
         [-[no]z] [-ng <int>] [-[no]len] [-[no]fp] [-bin <real>]
         [-ctime <real>] [-scale <real>]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` traj `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} plots
coordinates, velocities, forces and/or the box. With ` `{.docutils
.literal .notranslate}[` -com `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} the
coordinates, velocities and forces are calculated for the center of mass
of each group. When ` `{.docutils .literal
.notranslate}[` -mol `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} is set, the
numbers in the index file are interpreted as molecule numbers and the
same procedure as with ` `{.docutils .literal
.notranslate}[` -com `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} is used for
each molecule.

Option ` `{.docutils .literal .notranslate}[` -ot `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} plots the
temperature of each group, provided velocities are present in the
trajectory file. No corrections are made for constrained degrees of
freedom! This implies ` `{.docutils .literal
.notranslate}[` -com `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} .

Options ` `{.docutils .literal .notranslate}[` -ekt `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` -ekr `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} plot the
translational and rotational kinetic energy of each group, provided
velocities are present in the trajectory file. This implies
` `{.docutils .literal .notranslate}[` -com `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} .

Options ` `{.docutils .literal .notranslate}[` -cv `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` -cf `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} write the
average velocities and average forces as temperature factors to a file
with the average coordinates or the coordinates at ` `{.docutils
.literal .notranslate}[` -ctime `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . The
temperature factors are scaled such that the maximum is 10. The scaling
can be changed with the option ` `{.docutils .literal
.notranslate}[` -scale `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . To get the
velocities or forces of one frame set both ` `{.docutils .literal
.notranslate}[` -b `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` -e `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} to the time of
desired frame. When averaging over frames you might need to use the
` `{.docutils .literal .notranslate}[` -nojump `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} option to
obtain the correct average coordinates. If you select either of these
option the average force and velocity for each atom are written to an
file as well (specified with ` `{.docutils .literal
.notranslate}[` -av `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} or
` `{.docutils .literal .notranslate}[` -af `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ).

Option ` `{.docutils .literal .notranslate}[` -vd `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} computes a
velocity distribution, i.e. the norm of the vector is plotted. In
addition in the same graph the kinetic energy distribution is given.

See for plotting similar data for selections.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (traj.xtc)

:   Trajectory:

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr/.gro/â€¦\>\] (topol.tpr)

:   Structure+mass(db): brk ent

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx) (Optional)

:   Index file

Options to specify output files:

` `{.docutils .literal .notranslate}[` -ox `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (coord.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -oxt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (coord.xtc) (Optional)

:   Trajectory:

` `{.docutils .literal .notranslate}[` -ov `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (veloc.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -of `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (force.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -ob `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (box.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -ot `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (temp.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -ekt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (ektrans.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -ekr `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (ekrot.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -vd `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (veldist.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -cv `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.pdb\>\] (veloc.pdb) (Optional)

:   Protein data bank file

` `{.docutils .literal .notranslate}[` -cf `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.pdb\>\] (force.pdb) (Optional)

:   Protein data bank file

` `{.docutils .literal .notranslate}[` -av `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (all_veloc.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -af `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (all_force.xvg) (Optional)

:   xvgr/xmgr file

Other options:

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of first frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of last frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -dt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Only use frame when t MOD dt = first time (default unit ps)

` `{.docutils .literal .notranslate}[` -tu `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (ps)

:   Unit for time values: fs, ps, ns, us, ms, s

` `{.docutils .literal .notranslate}[` -[no]w `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   View output , , and files

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   xvg plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -[no]com `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Plot data for the com of each group

` `{.docutils .literal .notranslate}[` -[no]pbc `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Make molecules whole for COM

` `{.docutils .literal .notranslate}[` -[no]mol `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Index contains molecule numbers instead of atom numbers

` `{.docutils .literal .notranslate}[` -[no]nojump `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Remove jumps of atoms across the box

` `{.docutils .literal .notranslate}[` -[no]x `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Plot X-component

` `{.docutils .literal .notranslate}[` -[no]y `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Plot Y-component

` `{.docutils .literal .notranslate}[` -[no]z `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Plot Z-component

` `{.docutils .literal .notranslate}[` -ng `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (1)

:   Number of groups to consider

` `{.docutils .literal .notranslate}[` -[no]len `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Plot vector length

` `{.docutils .literal .notranslate}[` -[no]fp `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Full precision output

` `{.docutils .literal .notranslate}[` -bin `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (1)

:   Binwidth for velocity histogram (nm/ps)

` `{.docutils .literal .notranslate}[` -ctime `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (-1)

:   Use frame at this time for x in ` `{.docutils .literal
    .notranslate}[` -cv `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} and
    ` `{.docutils .literal .notranslate}[` -cf `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} instead of
    the average x

` `{.docutils .literal .notranslate}[` -scale `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Scale factor for output, 0 is autoscale
:::
:::
::: {#gmx-trajectory .section}
[ ]{#id1}

# gmx trajectory

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx trajectory [-f [<.xtc/.trr/...>]] [-s [<.tpr/.gro/...>]]
             [-n [<.ndx>]] [-ox [<.xvg>]] [-ov [<.xvg>]]
             [-of [<.xvg>]] [-b <time>] [-e <time>] [-dt <time>]
             [-tu <enum>] [-fgroup <selection>] [-xvg <enum>]
             [-[no]rmpbc] [-[no]pbc] [-sf <file>] [-selrpos <enum>]
             [-seltype <enum>] [-select <selection>] [-[no]x]
             [-[no]y] [-[no]z] [-[no]len]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` trajectory `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} plots
coordinates, velocities, and/or forces for provided selections. By
default, the X, Y, and Z components for the requested vectors are
plotted, but specifying one or more of ` `{.docutils .literal
.notranslate}[` -len `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , ` `{.docutils
.literal .notranslate}[` -x `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , ` `{.docutils
.literal .notranslate}[` -y `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , and
` `{.docutils .literal .notranslate}[` -z `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} overrides this.

For dynamic selections, currently the values are written out for all
positions that the selection could select.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (traj.xtc) (Optional)

:   Input trajectory or single configuration:

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr/.gro/â€¦\>\] (topol.tpr) (Optional)

:   Input structure: brk ent

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx) (Optional)

:   Extra index groups

Options to specify output files:

` `{.docutils .literal .notranslate}[` -ox `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (coord.xvg) (Optional)

:   Coordinates for each position as a function of time

` `{.docutils .literal .notranslate}[` -ov `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (veloc.xvg) (Optional)

:   Velocities for each position as a function of time

` `{.docutils .literal .notranslate}[` -of `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (force.xvg) (Optional)

:   Forces for each position as a function of time

Other options:

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   First frame (ps) to read from trajectory

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Last frame (ps) to read from trajectory

` `{.docutils .literal .notranslate}[` -dt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Only use frame if t MOD dt == first time (ps)

` `{.docutils .literal .notranslate}[` -tu `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (ps)

:   Unit for time values: fs, ps, ns, us, ms, s

` `{.docutils .literal .notranslate}[` -fgroup `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<selection\>

:   Atoms stored in the trajectory file (if not set, assume first N
    atoms)

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   Plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -[no]rmpbc `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Make molecules whole for each frame

` `{.docutils .literal .notranslate}[` -[no]pbc `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Use periodic boundary conditions for distance calculation

` `{.docutils .literal .notranslate}[` -sf `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<file\>

:   Provide selections from files

` `{.docutils .literal .notranslate}[` -selrpos `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (atom)

:   Selection reference positions: atom, res_com, res_cog, mol_com,
    mol_cog, whole_res_com, whole_res_cog, whole_mol_com, whole_mol_cog,
    part_res_com, part_res_cog, part_mol_com, part_mol_cog, dyn_res_com,
    dyn_res_cog, dyn_mol_com, dyn_mol_cog

` `{.docutils .literal .notranslate}[` -seltype `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (atom)

:   Default selection output positions: atom, res_com, res_cog, mol_com,
    mol_cog, whole_res_com, whole_res_cog, whole_mol_com, whole_mol_cog,
    part_res_com, part_res_cog, part_mol_com, part_mol_cog, dyn_res_com,
    dyn_res_cog, dyn_mol_com, dyn_mol_cog

` `{.docutils .literal .notranslate}[` -select `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<selection\>

:   Selections to analyze

` `{.docutils .literal .notranslate}[` -[no]x `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Plot X component

` `{.docutils .literal .notranslate}[` -[no]y `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Plot Y component

` `{.docutils .literal .notranslate}[` -[no]z `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Plot Z component

` `{.docutils .literal .notranslate}[` -[no]len `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Plot vector length
:::
:::
::: {#gmx-trjcat .section}
[ ]{#id1}

# gmx trjcat

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx trjcat [-f [<.xtc/.trr/...> [...]]] [-n [<.ndx>]] [-demux [<.xvg>]]
           [-o [<.xtc/.trr/...> [...]]] [-tu <enum>] [-xvg <enum>]
           [-b <time>] [-e <time>] [-dt <time>] [-[no]settime]
           [-[no]sort] [-[no]keeplast] [-[no]overwrite] [-[no]cat]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` trjcat `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} concatenates
several input trajectory files in sorted order. In case of double time
frames the one in the later file is used. By specifying ` `{.docutils
.literal .notranslate}[` -settime `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} you will be
asked for the start time of each file. The input files are taken from
the command line, such that a command like ` `{.docutils .literal
.notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` trjcat `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` -f `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` *.trr `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` -o `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` fixed.trr `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} should do the
trick. Using ` `{.docutils .literal .notranslate}[` -cat `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} , you
can simply paste several files together without removal of frames with
identical time stamps.

One important option is inferred when the output file is amongst the
input files. In that case that particular file will be appended to which
implies you do not need to store double the amount of data. Obviously
the file to append to has to be the one with lowest starting time since
one can only append at the end of a file.

If the ` `{.docutils .literal .notranslate}[` -demux `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} option
is given, the N trajectories that are read, are written in another order
as specified in the file. The file should contain something like:

::: {.highlight-default .notranslate}
::: highlight
    0  0  1  2  3  4  5
    2  1  0  2  3  5  4
:::
:::

The first number is the time, and subsequent numbers point to trajectory
indices. The frames corresponding to the numbers present at the first
line are collected into the output trajectory. If the number of frames
in the trajectory does not match that in the file then the program tries
to be smart. Beware.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\> \[â€¦\]\] (traj.xtc)

:   Trajectory:

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx) (Optional)

:   Index file

` `{.docutils .literal .notranslate}[` -demux `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (remd.xvg) (Optional)

:   xvgr/xmgr file

Options to specify output files:

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\> \[â€¦\]\] (trajout.xtc)

:   Trajectory:

Other options:

` `{.docutils .literal .notranslate}[` -tu `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (ps)

:   Unit for time values: fs, ps, ns, us, ms, s

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   xvg plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (-1)

:   First time to use (ps)

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (-1)

:   Last time to use (ps)

` `{.docutils .literal .notranslate}[` -dt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Only write frame when t MOD dt = first time (ps)

` `{.docutils .literal .notranslate}[` -[no]settime `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Change starting time interactively

` `{.docutils .literal .notranslate}[` -[no]sort `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Sort trajectory files (not frames)

` `{.docutils .literal .notranslate}[` -[no]keeplast `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Keep overlapping frames at end of trajectory

` `{.docutils .literal .notranslate}[` -[no]overwrite `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Overwrite overlapping frames during appending

` `{.docutils .literal .notranslate}[` -[no]cat `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Do not discard double time frames
:::
:::
::: {#gmx-trjconv .section}
[ ]{#id1}

# gmx trjconv

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx trjconv [-f [<.xtc/.trr/...>]] [-s [<.tpr/.gro/...>]] [-n [<.ndx>]]
            [-fr [<.ndx>]] [-sub [<.ndx>]] [-drop [<.xvg>]]
            [-o [<.xtc/.trr/...>]] [-b <time>] [-e <time>]
            [-tu <enum>] [-[no]w] [-xvg <enum>] [-skip <int>]
            [-dt <time>] [-[no]round] [-dump <time>] [-t0 <time>]
            [-timestep <time>] [-pbc <enum>] [-ur <enum>]
            [-[no]center] [-boxcenter <enum>] [-box <vector>]
            [-trans <vector>] [-shift <vector>] [-fit <enum>]
            [-ndec <int>] [-[no]vel] [-[no]force] [-trunc <time>]
            [-exec <string>] [-split <time>] [-[no]sep]
            [-nzero <int>] [-dropunder <real>] [-dropover <real>]
            [-[no]conect]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` trjconv `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} can convert
trajectory files in many ways:

-   from one format to another

-   select a subset of atoms

-   change the periodicity representation

-   keep multimeric molecules together

-   center atoms in the box

-   fit atoms to reference structure

-   reduce the number of frames

-   change the timestamps of the frames ( ` `{.docutils .literal
    .notranslate}[` -t0 `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} and
    ` `{.docutils .literal .notranslate}[` -timestep `{.docutils
    .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} )

-   select frames within a certain range of a quantity given in an file.

The option to write subtrajectories (-sub) based on the information
obtained from cluster analysis has been removed from ` `{.docutils
.literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` trjconv `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and is now part
of \[gmx extract-cluster\]

is better suited for concatenating multiple trajectory files.

The following formats are supported for input and output: , , ,
` `{.docutils .literal .notranslate}[` .g96 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , and . The
file formats are detected from the file extension. The precision of the
output is taken from the input file for , and , and from the
` `{.docutils .literal .notranslate}[` -ndec `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} option for
other input formats. The precision is always taken from ` `{.docutils
.literal .notranslate}[` -ndec `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , when this
option is set. All other formats have fixed precision. output can be
single or double precision, depending on the precision of the
` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` trjconv `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} binary. Note
that velocities are only supported in , , and ` `{.docutils .literal
.notranslate}[` .g96 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} files.

Option ` `{.docutils .literal .notranslate}[` -sep `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} can be used to
write every frame to a separate ` `{.docutils .literal
.notranslate}[` .gro, `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` .g96 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} or file. By
default, all frames all written to one file. files with all frames
concatenated can be viewed with ` `{.docutils .literal
.notranslate}[` rasmol `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` -nmrpdb `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} .

It is possible to select part of your trajectory and write it out to a
new trajectory file in order to save disk space, e.g. for leaving out
the water from a trajectory of a protein in water. **ALWAYS** put the
original trajectory on tape! We recommend to use the portable format for
your analysis to save disk space and to have portable files. When
writing output the file will contain one molecule type of the correct
count if the selection name matches the molecule name and the selected
atoms match all atoms of that molecule. Otherwise the whole selection
will be treated as one single molecule containing all the selected
atoms.

There are two options for fitting the trajectory to a reference either
for essential dynamics analysis, etc. The first option is just plain
fitting to a reference structure in the structure file. The second
option is a progressive fit in which the first timeframe is fitted to
the reference structure in the structure file to obtain and each
subsequent timeframe is fitted to the previously fitted structure. This
way a continuous trajectory is generated, which might not be the case
when using the regular fit method, e.g. when your protein undergoes
large conformational transitions.

Option ` `{.docutils .literal .notranslate}[` -pbc `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} sets the type
of periodic boundary condition treatment:

> <div>
>
> -   ` `{.docutils .literal .notranslate}[` mol `{.docutils .literal
>     .notranslate}]{.pre}` `{.docutils .literal .notranslate} puts the
>     center of mass of molecules in the box, and requires a run input
>     file to be supplied with ` `{.docutils .literal
>     .notranslate}[` -s `{.docutils .literal
>     .notranslate}]{.pre}` `{.docutils .literal .notranslate} .
>
> -   ` `{.docutils .literal .notranslate}[` res `{.docutils .literal
>     .notranslate}]{.pre}` `{.docutils .literal .notranslate} puts the
>     center of mass of residues in the box.
>
> -   ` `{.docutils .literal .notranslate}[` atom `{.docutils .literal
>     .notranslate}]{.pre}` `{.docutils .literal .notranslate} puts all
>     the atoms in the box.
>
> -   ` `{.docutils .literal .notranslate}[` nojump `{.docutils .literal
>     .notranslate}]{.pre}` `{.docutils .literal .notranslate} checks if
>     atoms jump across the box and then puts them back. This has the
>     effect that all molecules will remain whole (provided they were
>     whole in the initial conformation). **Note** that this ensures a
>     continuous trajectory but molecules may diffuse out of the box.
>     The starting configuration for this procedure is taken from the
>     structure file, if one is supplied, otherwise it is the first
>     frame.
>
> -   ` `{.docutils .literal .notranslate}[` cluster `{.docutils
>     .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}
>     clusters all the atoms in the selected index such that they are
>     all closest to the center of mass of the cluster, which is
>     iteratively updated. **Note** that this will only give meaningful
>     results if you in fact have a cluster. Luckily that can be checked
>     afterwards using a trajectory viewer. Note also that if your
>     molecules are broken this will not work either.
>
> -   ` `{.docutils .literal .notranslate}[` whole `{.docutils .literal
>     .notranslate}]{.pre}` `{.docutils .literal .notranslate} only
>     makes broken molecules whole.
>
> </div>

Option ` `{.docutils .literal .notranslate}[` -ur `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} sets the unit
cell representation for options ` `{.docutils .literal
.notranslate}[` mol `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , ` `{.docutils
.literal .notranslate}[` res `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` atom `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} of
` `{.docutils .literal .notranslate}[` -pbc `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . All three
options give different results for triclinic boxes and identical results
for rectangular boxes. ` `{.docutils .literal
.notranslate}[` rect `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} is the ordinary
brick shape. ` `{.docutils .literal .notranslate}[` tric `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} is the
triclinic unit cell. ` `{.docutils .literal
.notranslate}[` compact `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} puts all atoms
at the closest distance from the center of the box. This can be useful
for visualizing e.g. truncated octahedra or rhombic dodecahedra. The
center for options ` `{.docutils .literal
.notranslate}[` tric `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` compact `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} is
` `{.docutils .literal .notranslate}[` tric `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} (see below),
unless the option ` `{.docutils .literal
.notranslate}[` -boxcenter `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} is set
differently.

Option ` `{.docutils .literal .notranslate}[` -center `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}
centers the system in the box. The user can select the group which is
used to determine the geometrical center. Option ` `{.docutils .literal
.notranslate}[` -boxcenter `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} sets the
location of the center of the box for options ` `{.docutils .literal
.notranslate}[` -pbc `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` -center `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . The center
options are: ` `{.docutils .literal .notranslate}[` tric `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} : half
of the sum of the box vectors, ` `{.docutils .literal
.notranslate}[` rect `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} : half of the
box diagonal, ` `{.docutils .literal .notranslate}[` zero `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} :
zero. Use option ` `{.docutils .literal .notranslate}[` -pbc `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` mol `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} in addition to
` `{.docutils .literal .notranslate}[` -center `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} when you want
all molecules in the box after the centering.

Option ` `{.docutils .literal .notranslate}[` -box `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} sets the size
of the new box. This option only works for leading dimensions and is
thus generally only useful for rectangular boxes. If you want to modify
only some of the dimensions, e.g. when reading from a trajectory, you
can use -1 for those dimensions that should stay the same It is not
always possible to use combinations of ` `{.docutils .literal
.notranslate}[` -pbc `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , ` `{.docutils
.literal .notranslate}[` -fit `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , ` `{.docutils
.literal .notranslate}[` -ur `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` -center `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} to do exactly
what you want in one call to ` `{.docutils .literal
.notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` trjconv `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . Consider
using multiple calls, and check out the GROMACS website for suggestions.

With ` `{.docutils .literal .notranslate}[` -dt `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , it is
possible to reduce the number of frames in the output. This option
relies on the accuracy of the times in your input trajectory, so if
these are inaccurate use the ` `{.docutils .literal
.notranslate}[` -timestep `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} option to
modify the time (this can be done simultaneously). For making smooth
movies, the program can reduce the number of frames while using low-pass
frequency filtering, this reduces aliasing of high frequency motions.

Using ` `{.docutils .literal .notranslate}[` -trunc `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ` `{.docutils
.literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` trjconv `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} can truncate in
place, i.e. without copying the file. This is useful when a run has
crashed during disk I/O (i.e. full disk), or when two contiguous
trajectories must be concatenated without having double frames.

Option ` `{.docutils .literal .notranslate}[` -dump `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} can be used to
extract a frame at or near one specific time from your trajectory. If
the frames in the trajectory are not in temporal order, the result is
unspecified.

Option ` `{.docutils .literal .notranslate}[` -drop `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} reads an file
with times and values. When options ` `{.docutils .literal
.notranslate}[` -dropunder `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and/or
` `{.docutils .literal .notranslate}[` -dropover `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} are set, frames
with a value below and above the value of the respective options will
not be written.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (traj.xtc)

:   Trajectory:

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr/.gro/â€¦\>\] (topol.tpr) (Optional)

:   Structure+mass(db): brk ent

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx) (Optional)

:   Index file

` `{.docutils .literal .notranslate}[` -fr `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (frames.ndx) (Optional)

:   Index file

` `{.docutils .literal .notranslate}[` -sub `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (cluster.ndx) (Optional)

:   Index file

` `{.docutils .literal .notranslate}[` -drop `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (drop.xvg) (Optional)

:   xvgr/xmgr file

Options to specify output files:

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (trajout.xtc)

:   Trajectory:

Other options:

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of first frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of last frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -tu `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (ps)

:   Unit for time values: fs, ps, ns, us, ms, s

` `{.docutils .literal .notranslate}[` -[no]w `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   View output , , and files

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   xvg plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -skip `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (1)

:   Only write every nr-th frame

` `{.docutils .literal .notranslate}[` -dt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Only write frame when t MOD dt = first time (ps)

` `{.docutils .literal .notranslate}[` -[no]round `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Round measurements to nearest picosecond

` `{.docutils .literal .notranslate}[` -dump `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (-1)

:   Dump frame nearest specified time (ps)

` `{.docutils .literal .notranslate}[` -t0 `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Starting time (ps) (default: donâ€™t change)

` `{.docutils .literal .notranslate}[` -timestep `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Change time step between input frames (ps)

` `{.docutils .literal .notranslate}[` -pbc `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (none)

:   PBC treatment (see help text for full description): none, mol, res,
    atom, nojump, cluster, whole

` `{.docutils .literal .notranslate}[` -ur `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (rect)

:   Unit-cell representation: rect, tric, compact

` `{.docutils .literal .notranslate}[` -[no]center `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Center atoms in box

` `{.docutils .literal .notranslate}[` -boxcenter `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (tric)

:   Center for -pbc and -center: tric, rect, zero

` `{.docutils .literal .notranslate}[` -box `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<vector\> (0 0 0)

:   Size for new cubic box (default: read from input)

` `{.docutils .literal .notranslate}[` -trans `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<vector\> (0 0 0)

:   All coordinates will be translated by trans. This can advantageously
    be combined with -pbc mol -ur compact.

` `{.docutils .literal .notranslate}[` -shift `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<vector\> (0 0 0)

:   All coordinates will be shifted by framenr\*shift

` `{.docutils .literal .notranslate}[` -fit `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (none)

:   Fit molecule to ref structure in the structure file: none,
    rot+trans, rotxy+transxy, translation, transxy, progressive

` `{.docutils .literal .notranslate}[` -ndec `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (3)

:   Number of decimal places to write to .xtc output

` `{.docutils .literal .notranslate}[` -[no]vel `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Read and write velocities if possible

` `{.docutils .literal .notranslate}[` -[no]force `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Read and write forces if possible

` `{.docutils .literal .notranslate}[` -trunc `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (-1)

:   Truncate input trajectory file after this time (ps)

` `{.docutils .literal .notranslate}[` -exec `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<string\>

:   Execute command for every output frame with the frame number as
    argument

` `{.docutils .literal .notranslate}[` -split `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Start writing new file when t MOD split = first time (ps)

` `{.docutils .literal .notranslate}[` -[no]sep `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Write each frame to a separate .gro, .g96 or .pdb file

` `{.docutils .literal .notranslate}[` -nzero `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (0)

:   If the -sep flag is set, use these many digits for the file numbers
    and prepend zeros as needed

` `{.docutils .literal .notranslate}[` -dropunder `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Drop all frames below this value

` `{.docutils .literal .notranslate}[` -dropover `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Drop all frames above this value

` `{.docutils .literal .notranslate}[` -[no]conect `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Add CONECT PDB records when writing files. Useful for visualization
    of non-standard molecules, e.g. coarse grained ones
:::
:::
::: {#gmx-trjorder .section}
[ ]{#id1}

# gmx trjorder

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx trjorder [-f [<.xtc/.trr/...>]] [-s [<.tpr/.gro/...>]] [-n [<.ndx>]]
             [-o [<.xtc/.trr/...>]] [-nshell [<.xvg>]] [-b <time>]
             [-e <time>] [-dt <time>] [-xvg <enum>] [-na <int>]
             [-da <int>] [-[no]com] [-r <real>] [-[no]z]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` trjorder `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} orders
molecules according to the smallest distance to atoms in a reference
group or on z-coordinate (with option ` `{.docutils .literal
.notranslate}[` -z `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ). With
distance ordering, it will ask for a group of reference atoms and a
group of molecules. For each frame of the trajectory the selected
molecules will be reordered according to the shortest distance between
atom number ` `{.docutils .literal .notranslate}[` -da `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} in the
molecule and all the atoms in the reference group. The center of mass of
the molecules can be used instead of a reference atom by setting
` `{.docutils .literal .notranslate}[` -da `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} to 0. All atoms
in the trajectory are written to the output trajectory.

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` trjorder `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} can be useful
for e.g. analyzing the n waters closest to a protein. In that case the
reference group would be the protein and the group of molecules would
consist of all the water atoms. When an index group of the first n
waters is made, the ordered trajectory can be used with any GROMACS
program to analyze the n closest waters.

If the output file is a file, the distance to the reference target will
be stored in the B-factor field in order to color with e.g. Rasmol.

With option ` `{.docutils .literal .notranslate}[` -nshell `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} the
number of molecules within a shell of radius ` `{.docutils .literal
.notranslate}[` -r `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} around the
reference group are printed.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (traj.xtc)

:   Trajectory:

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr/.gro/â€¦\>\] (topol.tpr)

:   Structure+mass(db): brk ent

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx) (Optional)

:   Index file

Options to specify output files:

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (ordered.xtc) (Optional)

:   Trajectory:

` `{.docutils .literal .notranslate}[` -nshell `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (nshell.xvg) (Optional)

:   xvgr/xmgr file

Other options:

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of first frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of last frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -dt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Only use frame when t MOD dt = first time (default unit ps)

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   xvg plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -na `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (3)

:   Number of atoms in a molecule

` `{.docutils .literal .notranslate}[` -da `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (1)

:   Atom used for the distance calculation, 0 is COM

` `{.docutils .literal .notranslate}[` -[no]com `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Use the distance to the center of mass of the reference group

` `{.docutils .literal .notranslate}[` -r `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Cutoff used for the distance calculation when computing the number
    of molecules in a shell around e.g. a protein

` `{.docutils .literal .notranslate}[` -[no]z `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Order molecules on z-coordinate
:::
:::
::: {#gmx-tune-pme .section}
[ ]{#id1}

# gmx tune_pme

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx tune_pme [-s [<.tpr>]] [-cpi [<.cpt>]] [-table [<.xvg>]]
             [-tablep [<.xvg>]] [-tableb [<.xvg>]]
             [-rerun [<.xtc/.trr/...>]] [-ei [<.edi>]] [-p [<.out>]]
             [-err [<.log>]] [-so [<.tpr>]] [-o [<.trr/.cpt/...>]]
             [-x [<.xtc/.tng>]] [-cpo [<.cpt>]]
             [-c [<.gro/.g96/...>]] [-e [<.edr>]] [-g [<.log>]]
             [-dhdl [<.xvg>]] [-field [<.xvg>]] [-tpi [<.xvg>]]
             [-tpid [<.xvg>]] [-eo [<.xvg>]] [-px [<.xvg>]]
             [-pf [<.xvg>]] [-ro [<.xvg>]] [-ra [<.log>]]
             [-rs [<.log>]] [-rt [<.log>]] [-mtx [<.mtx>]]
             [-swap [<.xvg>]] [-bo [<.trr/.cpt/...>]] [-bx [<.xtc>]]
             [-bcpo [<.cpt>]] [-bc [<.gro/.g96/...>]] [-be [<.edr>]]
             [-bg [<.log>]] [-beo [<.xvg>]] [-bdhdl [<.xvg>]]
             [-bfield [<.xvg>]] [-btpi [<.xvg>]] [-btpid [<.xvg>]]
             [-bdevout [<.xvg>]] [-brunav [<.xvg>]] [-bpx [<.xvg>]]
             [-bpf [<.xvg>]] [-bro [<.xvg>]] [-bra [<.log>]]
             [-brs [<.log>]] [-brt [<.log>]] [-bmtx [<.mtx>]]
             [-bdn [<.ndx>]] [-bswap [<.xvg>]] [-xvg <enum>]
             [-mdrun <string>] [-np <int>] [-npstring <enum>]
             [-ntmpi <int>] [-r <int>] [-max <real>] [-min <real>]
             [-npme <enum>] [-fix <int>] [-rmax <real>]
             [-rmin <real>] [-[no]scalevdw] [-ntpr <int>]
             [-steps <int>] [-resetstep <int>] [-nsteps <int>]
             [-[no]launch] [-[no]bench] [-[no]check]
             [-gpu_id <string>] [-[no]append] [-[no]cpnum]
             [-deffnm <string>]
```
:::

::: {#description .section}
## Description

For a given number ` `{.docutils .literal
.notranslate}[` -np `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} or
` `{.docutils .literal .notranslate}[` -ntmpi `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} of ranks,
` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` tune_pme `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} systematically
times with various numbers of PME-only ranks and determines which
setting is fastest. It will also test whether performance can be
enhanced by shifting load from the reciprocal to the real space part of
the Ewald sum. Simply pass your file to ` `{.docutils .literal
.notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` tune_pme `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} together with
other options for as needed.

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` tune_pme `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} needs to call
and so requires that you specify how to call mdrun with the argument to
the ` `{.docutils .literal .notranslate}[` -mdrun `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} parameter.
Depending how you have built GROMACS, values such as â€˜gmx mdrunâ€™,
â€˜gmx_d mdrunâ€™, or â€˜gmx_mpi mdrunâ€™ might be needed.

The program that runs MPI programs can be set in the environment
variable MPIRUN (defaults to â€˜mpirunâ€™). Note that for certain MPI
frameworks, you need to provide a machine- or hostfile. This can also be
passed via the MPIRUN variable, e.g.

` `{.docutils .literal .notranslate}[` export `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` MPIRUN="/usr/local/mpirun `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` -machinefile `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` hosts" `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} Note that in
such cases it is normally necessary to compile and/or run ` `{.docutils
.literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` tune_pme `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} without MPI
support, so that it can call the MPIRUN program.

Before doing the actual benchmark runs, ` `{.docutils .literal
.notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` tune_pme `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} will do a quick
check whether works as expected with the provided parallel settings if
the ` `{.docutils .literal .notranslate}[` -check `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} option is
activated (the default). Please call ` `{.docutils .literal
.notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` tune_pme `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} with the normal
options you would pass to and add ` `{.docutils .literal
.notranslate}[` -np `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} for the number
of ranks to perform the tests on, or ` `{.docutils .literal
.notranslate}[` -ntmpi `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} for the number
of threads. You can also add ` `{.docutils .literal
.notranslate}[` -r `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} to repeat each
test several times to get better statistics.

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` tune_pme `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} can test
various real space / reciprocal space workloads for you. With
` `{.docutils .literal .notranslate}[` -ntpr `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} you control how
many extra files will be written with enlarged cutoffs and smaller
Fourier grids respectively. Typically, the first test (number 0) will be
with the settings from the input file; the last test (number
` `{.docutils .literal .notranslate}[` ntpr `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ) will have the
Coulomb cutoff specified by ` `{.docutils .literal
.notranslate}[` -rmax `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} with a somewhat
smaller PME grid at the same time. In this last test, the Fourier
spacing is multiplied with ` `{.docutils .literal
.notranslate}[` rmax `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} /rcoulomb. The
remaining files will have equally-spaced Coulomb radii (and Fourier
spacings) between these extremes. **Note** that you can set
` `{.docutils .literal .notranslate}[` -ntpr `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} to 1 if you
just seek the optimal number of PME-only ranks; in that case your input
file will remain unchanged.

For the benchmark runs, the default of 1000 time steps should suffice
for most MD systems. The dynamic load balancing needs about 100 time
steps to adapt to local load imbalances, therefore the time step
counters are by default reset after 100 steps. For large systems (\>1M
atoms), as well as for a higher accuracy of the measurements, you should
set ` `{.docutils .literal .notranslate}[` -resetstep `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} to a
higher value. From the â€˜DDâ€™ load imbalance entries in the md.log
output file you can tell after how many steps the load is sufficiently
balanced. Example call:

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` tune_pme `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` -np `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` 64 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` -s `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` protein.tpr `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` -launch `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate}

After calling several times, detailed performance information is
available in the output file ` `{.docutils .literal
.notranslate}[` perf.out `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . **Note** that
during the benchmarks, a couple of temporary files are written (options
` `{.docutils .literal .notranslate}[` -b* `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ), these will
be automatically deleted after each test.

If you want the simulation to be started automatically with the
optimized parameters, use the command line option ` `{.docutils .literal
.notranslate}[` -launch `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} .

Basic support for GPU-enabled ` `{.docutils .literal
.notranslate}[` mdrun `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} exists. Give a
string containing the IDs of the GPUs that you wish to use in the
optimization in the ` `{.docutils .literal
.notranslate}[` -gpu_id `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} command-line
argument. This works exactly like ` `{.docutils .literal
.notranslate}[` mdrun `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` -gpu_id `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , does not
imply a mapping, and merely declares the eligible set of GPU devices.
` `{.docutils .literal .notranslate}[` gmx-tune_pme `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} will construct
calls to mdrun that use this set appropriately. ` `{.docutils .literal
.notranslate}[` gmx-tune_pme `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} does not
support ` `{.docutils .literal .notranslate}[` -gputasks `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} .
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr\>\] (topol.tpr)

:   Portable xdr run input file

` `{.docutils .literal .notranslate}[` -cpi `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.cpt\>\] (state.cpt) (Optional)

:   Checkpoint file

` `{.docutils .literal .notranslate}[` -table `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (table.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -tablep `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (tablep.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -tableb `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (table.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -rerun `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (rerun.xtc) (Optional)

:   Trajectory:

` `{.docutils .literal .notranslate}[` -ei `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.edi\>\] (sam.edi) (Optional)

:   ED sampling input

Options to specify output files:

` `{.docutils .literal .notranslate}[` -p `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.out\>\] (perf.out)

:   Generic output file

` `{.docutils .literal .notranslate}[` -err `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.log\>\] (bencherr.log)

:   Log file

` `{.docutils .literal .notranslate}[` -so `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr\>\] (tuned.tpr)

:   Portable xdr run input file

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.trr/.cpt/â€¦\>\] (traj.trr)

:   Full precision trajectory:

` `{.docutils .literal .notranslate}[` -x `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.tng\>\] (traj_comp.xtc) (Optional)

:   Compressed trajectory (tng format or portable xdr format)

` `{.docutils .literal .notranslate}[` -cpo `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.cpt\>\] (state.cpt) (Optional)

:   Checkpoint file

` `{.docutils .literal .notranslate}[` -c `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.gro/.g96/â€¦\>\] (confout.gro)

:   Structure file: brk ent esp

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.edr\>\] (ener.edr)

:   Energy file

` `{.docutils .literal .notranslate}[` -g `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.log\>\] (md.log)

:   Log file

` `{.docutils .literal .notranslate}[` -dhdl `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (dhdl.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -field `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (field.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -tpi `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (tpi.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -tpid `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (tpidist.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -eo `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (edsam.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -px `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (pullx.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -pf `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (pullf.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -ro `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (rotation.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -ra `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.log\>\] (rotangles.log) (Optional)

:   Log file

` `{.docutils .literal .notranslate}[` -rs `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.log\>\] (rotslabs.log) (Optional)

:   Log file

` `{.docutils .literal .notranslate}[` -rt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.log\>\] (rottorque.log) (Optional)

:   Log file

` `{.docutils .literal .notranslate}[` -mtx `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.mtx\>\] (nm.mtx) (Optional)

:   Hessian matrix

` `{.docutils .literal .notranslate}[` -swap `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (swapions.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -bo `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.trr/.cpt/â€¦\>\] (bench.trr)

:   Full precision trajectory:

` `{.docutils .literal .notranslate}[` -bx `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc\>\] (bench.xtc)

:   Compressed trajectory (portable xdr format): xtc

` `{.docutils .literal .notranslate}[` -bcpo `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.cpt\>\] (bench.cpt)

:   Checkpoint file

` `{.docutils .literal .notranslate}[` -bc `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.gro/.g96/â€¦\>\] (bench.gro)

:   Structure file: brk ent esp

` `{.docutils .literal .notranslate}[` -be `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.edr\>\] (bench.edr)

:   Energy file

` `{.docutils .literal .notranslate}[` -bg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.log\>\] (bench.log)

:   Log file

` `{.docutils .literal .notranslate}[` -beo `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (benchedo.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -bdhdl `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (benchdhdl.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -bfield `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (benchfld.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -btpi `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (benchtpi.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -btpid `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (benchtpid.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -bdevout `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (benchdev.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -brunav `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (benchrnav.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -bpx `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (benchpx.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -bpf `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (benchpf.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -bro `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (benchrot.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -bra `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.log\>\] (benchrota.log) (Optional)

:   Log file

` `{.docutils .literal .notranslate}[` -brs `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.log\>\] (benchrots.log) (Optional)

:   Log file

` `{.docutils .literal .notranslate}[` -brt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.log\>\] (benchrott.log) (Optional)

:   Log file

` `{.docutils .literal .notranslate}[` -bmtx `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.mtx\>\] (benchn.mtx) (Optional)

:   Hessian matrix

` `{.docutils .literal .notranslate}[` -bdn `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (bench.ndx) (Optional)

:   Index file

` `{.docutils .literal .notranslate}[` -bswap `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (benchswp.xvg) (Optional)

:   xvgr/xmgr file

Other options:

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   xvg plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -mdrun `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<string\>

:   Command line to run a simulation, e.g. â€˜gmx mdrunâ€™ or â€˜gmx_mpi
    mdrunâ€™

` `{.docutils .literal .notranslate}[` -np `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (1)

:   Number of ranks to run the tests on (must be \> 2 for separate PME
    ranks)

` `{.docutils .literal .notranslate}[` -npstring `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (np)

:   Name of the ` `{.docutils .literal
    .notranslate}[` $MPIRUN `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} option that
    specifies the number of ranks to use (â€˜npâ€™, or â€˜nâ€™; use
    â€˜noneâ€™ if there is no such option): np, n, none

` `{.docutils .literal .notranslate}[` -ntmpi `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (1)

:   Number of MPI-threads to run the tests on (turns MPI & mpirun off)

` `{.docutils .literal .notranslate}[` -r `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (2)

:   Repeat each test this often

` `{.docutils .literal .notranslate}[` -max `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0.5)

:   Max fraction of PME ranks to test with

` `{.docutils .literal .notranslate}[` -min `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0.25)

:   Min fraction of PME ranks to test with

` `{.docutils .literal .notranslate}[` -npme `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (auto)

:   Within -min and -max, benchmark all possible values for
    ` `{.docutils .literal .notranslate}[` -npme `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} , or just a
    reasonable subset. Auto neglects -min and -max and chooses
    reasonable values around a guess for npme derived from the .tpr:
    auto, all, subset

` `{.docutils .literal .notranslate}[` -fix `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (-2)

:   If \>= -1, do not vary the number of PME-only ranks, instead use
    this fixed value and only vary rcoulomb and the PME grid spacing.

` `{.docutils .literal .notranslate}[` -rmax `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   If \>0, maximal rcoulomb for -ntpr\>1 (rcoulomb upscaling results in
    fourier grid downscaling)

` `{.docutils .literal .notranslate}[` -rmin `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   If \>0, minimal rcoulomb for -ntpr\>1

` `{.docutils .literal .notranslate}[` -[no]scalevdw `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Scale rvdw along with rcoulomb

` `{.docutils .literal .notranslate}[` -ntpr `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (0)

:   Number of files to benchmark. Create this many files with different
    rcoulomb scaling factors depending on -rmin and -rmax. If \< 1,
    automatically choose the number of files to test

` `{.docutils .literal .notranslate}[` -steps `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (1000)

:   Take timings for this many steps in the benchmark runs

` `{.docutils .literal .notranslate}[` -resetstep `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (1500)

:   Let dlb equilibrate this many steps before timings are taken (reset
    cycle counters after this many steps)

` `{.docutils .literal .notranslate}[` -nsteps `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (-1)

:   If non-negative, perform this many steps in the real run (overwrites
    nsteps from , add steps)

` `{.docutils .literal .notranslate}[` -[no]launch `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Launch the real simulation after optimization

` `{.docutils .literal .notranslate}[` -[no]bench `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Run the benchmarks or just create the input files?

` `{.docutils .literal .notranslate}[` -[no]check `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Before the benchmark runs, check whether mdrun works in parallel

` `{.docutils .literal .notranslate}[` -gpu_id `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<string\>

:   List of unique GPU device IDs that are eligible for use

` `{.docutils .literal .notranslate}[` -[no]append `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Append to previous output files when continuing from checkpoint
    instead of adding the simulation part number to all file names (for
    launch only)

` `{.docutils .literal .notranslate}[` -[no]cpnum `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Keep and number checkpoint files (launch only)

` `{.docutils .literal .notranslate}[` -deffnm `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<string\>

:   Set the default filenames (launch only)
:::
:::
::: {#gmx-vanhove .section}
[ ]{#id1}

# gmx vanhove

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx vanhove [-f [<.xtc/.trr/...>]] [-s [<.tpr/.gro/...>]] [-n [<.ndx>]]
            [-om [<.xpm>]] [-or [<.xvg>]] [-ot [<.xvg>]] [-b <time>]
            [-e <time>] [-dt <time>] [-[no]w] [-xvg <enum>]
            [-sqrt <real>] [-fm <int>] [-rmax <real>] [-rbin <real>]
            [-mmax <real>] [-nlevels <int>] [-nr <int>] [-fr <int>]
            [-rt <real>] [-ft <int>]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` vanhove `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} computes the
Van Hove correlation function. The Van Hove G(r,t) is the probability
that a particle that is at r_0 at time zero can be found at position
r_0+r at time t. ` `{.docutils .literal .notranslate}[` gmx `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` vanhove `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} determines G
not for a vector r, but for the length of r. Thus it gives the
probability that a particle moves a distance of r in time t. Jumps
across the periodic boundaries are removed. Corrections are made for
scaling due to isotropic or anisotropic pressure coupling.

With option ` `{.docutils .literal .notranslate}[` -om `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} the
whole matrix can be written as a function of t and r or as a function of
sqrt(t) and r (option ` `{.docutils .literal
.notranslate}[` -sqrt `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ).

With option ` `{.docutils .literal .notranslate}[` -or `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} the
Van Hove function is plotted for one or more values of t. Option
` `{.docutils .literal .notranslate}[` -nr `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} sets the number
of times, option ` `{.docutils .literal .notranslate}[` -fr `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} the
number spacing between the times. The binwidth is set with option
` `{.docutils .literal .notranslate}[` -rbin `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . The number of
bins is determined automatically.

With option ` `{.docutils .literal .notranslate}[` -ot `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} the
integral up to a certain distance (option ` `{.docutils .literal
.notranslate}[` -rt `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ) is plotted as
a function of time.

For all frames that are read the coordinates of the selected particles
are stored in memory. Therefore the program may use a lot of memory. For
options ` `{.docutils .literal .notranslate}[` -om `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` -ot `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} the program may
be slow. This is because the calculation scales as the number of frames
times ` `{.docutils .literal .notranslate}[` -fm `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} or
` `{.docutils .literal .notranslate}[` -ft `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . Note that
with the ` `{.docutils .literal .notranslate}[` -dt `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} option the
memory usage and calculation time can be reduced.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xtc/.trr/â€¦\>\] (traj.xtc)

:   Trajectory:

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr/.gro/â€¦\>\] (topol.tpr)

:   Structure+mass(db): brk ent

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx) (Optional)

:   Index file

Options to specify output files:

` `{.docutils .literal .notranslate}[` -om `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xpm\>\] (vanhove.xpm) (Optional)

:   X PixMap compatible matrix file

` `{.docutils .literal .notranslate}[` -or `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (vanhove_r.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -ot `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (vanhove_t.xvg) (Optional)

:   xvgr/xmgr file

Other options:

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of first frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of last frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -dt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Only use frame when t MOD dt = first time (default unit ps)

` `{.docutils .literal .notranslate}[` -[no]w `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   View output , , and files

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   xvg plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -sqrt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Use sqrt(t) on the matrix axis which binspacing \# in sqrt(ps)

` `{.docutils .literal .notranslate}[` -fm `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (0)

:   Number of frames in the matrix, 0 is plot all

` `{.docutils .literal .notranslate}[` -rmax `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (2)

:   Maximum r in the matrix (nm)

` `{.docutils .literal .notranslate}[` -rbin `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0.01)

:   Binwidth in the matrix and for ` `{.docutils .literal
    .notranslate}[` -or `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} (nm)

` `{.docutils .literal .notranslate}[` -mmax `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Maximum density in the matrix, 0 is calculate (1/nm)

` `{.docutils .literal .notranslate}[` -nlevels `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (81)

:   Number of levels in the matrix

` `{.docutils .literal .notranslate}[` -nr `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (1)

:   Number of curves for the ` `{.docutils .literal
    .notranslate}[` -or `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} output

` `{.docutils .literal .notranslate}[` -fr `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (0)

:   Frame spacing for the ` `{.docutils .literal
    .notranslate}[` -or `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} output

` `{.docutils .literal .notranslate}[` -rt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Integration limit for the ` `{.docutils .literal
    .notranslate}[` -ot `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} output (nm)

` `{.docutils .literal .notranslate}[` -ft `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (0)

:   Number of frames in the ` `{.docutils .literal
    .notranslate}[` -ot `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} output, 0
    is plot all
:::
:::
::: {#gmx-velacc .section}
[ ]{#id1}

# gmx velacc

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx velacc [-f [<.trr/.cpt/...>]] [-s [<.tpr/.gro/...>]] [-n [<.ndx>]]
           [-o [<.xvg>]] [-os [<.xvg>]] [-b <time>] [-e <time>]
           [-dt <time>] [-[no]w] [-xvg <enum>] [-[no]m] [-[no]recip]
           [-[no]mol] [-acflen <int>] [-[no]normalize] [-P <enum>]
           [-fitfn <enum>] [-beginfit <real>] [-endfit <real>]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` velacc `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} computes the
velocity autocorrelation function. When the ` `{.docutils .literal
.notranslate}[` -m `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} option is used,
the momentum autocorrelation function is calculated.

With option ` `{.docutils .literal .notranslate}[` -mol `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} the
velocity autocorrelation function of molecules is calculated. In this
case the index group should consist of molecule numbers instead of atom
numbers.

By using option ` `{.docutils .literal .notranslate}[` -os `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} you
can also extract the estimated (vibrational) power spectrum, which is
the Fourier transform of the velocity autocorrelation function. Be sure
that your trajectory contains frames with velocity information (i.e.
` `{.docutils .literal .notranslate}[` nstvout `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} was set in your
original file), and that the time interval between data collection
points is much shorter than the time scale of the autocorrelation.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.trr/.cpt/â€¦\>\] (traj.trr)

:   Full precision trajectory:

` `{.docutils .literal .notranslate}[` -s `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.tpr/.gro/â€¦\>\] (topol.tpr) (Optional)

:   Structure+mass(db): brk ent

` `{.docutils .literal .notranslate}[` -n `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.ndx\>\] (index.ndx) (Optional)

:   Index file

Options to specify output files:

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (vac.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -os `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (spectrum.xvg) (Optional)

:   xvgr/xmgr file

Other options:

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of first frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Time of last frame to read from trajectory (default unit ps)

` `{.docutils .literal .notranslate}[` -dt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<time\> (0)

:   Only use frame when t MOD dt = first time (default unit ps)

` `{.docutils .literal .notranslate}[` -[no]w `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   View output , , and files

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   xvg plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -[no]m `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Calculate the momentum autocorrelation function

` `{.docutils .literal .notranslate}[` -[no]recip `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Use cm\^-1 on X-axis instead of 1/ps for spectra.

` `{.docutils .literal .notranslate}[` -[no]mol `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Calculate the velocity acf of molecules

` `{.docutils .literal .notranslate}[` -acflen `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (-1)

:   Length of the ACF, default is half the number of frames

` `{.docutils .literal .notranslate}[` -[no]normalize `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Normalize ACF

` `{.docutils .literal .notranslate}[` -P `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (0)

:   Order of Legendre polynomial for ACF (0 indicates none): 0, 1, 2, 3

` `{.docutils .literal .notranslate}[` -fitfn `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (none)

:   Fit function: none, exp, aexp, exp_exp, exp5, exp7, exp9

` `{.docutils .literal .notranslate}[` -beginfit `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Time where to begin the exponential fit of the correlation function

` `{.docutils .literal .notranslate}[` -endfit `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (-1)

:   Time where to end the exponential fit of the correlation function,
    -1 is until the end
:::
:::
::: {#gmx-wham .section}
[ ]{#id1}

# gmx wham

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx wham [-ix [<.dat>]] [-if [<.dat>]] [-it [<.dat>]] [-is [<.dat>]]
         [-iiact [<.dat>]] [-tab [<.dat>]] [-o [<.xvg>]]
         [-hist [<.xvg>]] [-oiact [<.xvg>]] [-bsres [<.xvg>]]
         [-bsprof [<.xvg>]] [-xvg <enum>] [-min <real>] [-max <real>]
         [-[no]auto] [-bins <int>] [-temp <real>] [-tol <real>]
         [-[no]v] [-b <real>] [-e <real>] [-dt <real>]
         [-[no]histonly] [-[no]boundsonly] [-[no]log] [-unit <enum>]
         [-zprof0 <real>] [-[no]cycl] [-[no]sym] [-[no]ac]
         [-acsig <real>] [-ac-trestart <real>] [-nBootstrap <int>]
         [-bs-method <enum>] [-bs-tau <real>] [-bs-seed <int>]
         [-histbs-block <int>] [-[no]vbs]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` wham `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} is an analysis
program that implements the Weighted Histogram Analysis Method (WHAM).
It is intended to analyze output files generated by umbrella sampling
simulations to compute a potential of mean force (PMF).

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` wham `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} is currently
not fully up to date. It only supports pull setups where the first pull
coordinate(s) is/are umbrella pull coordinates and, if multiple
coordinates need to be analyzed, all used the same geometry and
dimensions. In most cases this is not an issue.

At present, three input modes are supported.

-   With option ` `{.docutils .literal .notranslate}[` -it `{.docutils
    .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} ,
    the user provides a file which contains the file names of the
    umbrella simulation run-input files ( files), AND, with option
    ` `{.docutils .literal .notranslate}[` -ix `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} , a file
    which contains file names of the pullx ` `{.docutils .literal
    .notranslate}[` mdrun `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} output
    files. The and pullx files must be in corresponding order, i.e. the
    first created the first pullx, etc.

-   Same as the previous input mode, except that the user provides the
    pull force output file names ( ` `{.docutils .literal
    .notranslate}[` pullf.xvg `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} ) with
    option ` `{.docutils .literal .notranslate}[` -if `{.docutils
    .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} .
    From the pull force the position in the umbrella potential is
    computed. This does not work with tabulated umbrella potentials.

By default, all pull coordinates found in all pullx/pullf files are used
in WHAM. If only some of the pull coordinates should be used, a pull
coordinate selection file (option ` `{.docutils .literal
.notranslate}[` -is `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ) can be
provided. The selection file must contain one line for each tpr file in
tpr-files.dat. Each of these lines must contain one digit (0 or 1) for
each pull coordinate in the tpr file. Here, 1 indicates that the pull
coordinate is used in WHAM, and 0 means it is omitted. Example: If you
have three tpr files, each containing 4 pull coordinates, but only pull
coordinates 1 and 2 should be used, coordsel.dat looks like this:

::: {.highlight-default .notranslate}
::: highlight
    1 1 0 0
    1 1 0 0
    1 1 0 0
:::
:::

By default, the output files are:

::: {.highlight-default .notranslate}
::: highlight
    ``-o``      PMF output file
    ``-hist``   Histograms output file
:::
:::

Always check whether the histograms sufficiently overlap.

The umbrella potential is assumed to be harmonic and the force constants
are read from the files. If a non-harmonic umbrella force was applied a
tabulated potential can be provided with ` `{.docutils .literal
.notranslate}[` -tab `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} .

::: {#wham-options .section}
### WHAM options

-   ` `{.docutils .literal .notranslate}[` -bins `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} Number of
    bins used in analysis

-   ` `{.docutils .literal .notranslate}[` -temp `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} Temperature
    in the simulations

-   ` `{.docutils .literal .notranslate}[` -tol `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} Stop
    iteration if profile (probability) changed less than tolerance

-   ` `{.docutils .literal .notranslate}[` -auto `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} Automatic
    determination of boundaries

-   ` `{.docutils .literal .notranslate}[` -min,-max `{.docutils
    .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}
    Boundaries of the profile

The data points that are used to compute the profile can be restricted
with options ` `{.docutils .literal .notranslate}[` -b `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} ,
` `{.docutils .literal .notranslate}[` -e `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , and
` `{.docutils .literal .notranslate}[` -dt `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . Adjust
` `{.docutils .literal .notranslate}[` -b `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} to ensure
sufficient equilibration in each umbrella window.

With ` `{.docutils .literal .notranslate}[` -log `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} (default) the
profile is written in energy units, otherwise (with ` `{.docutils
.literal .notranslate}[` -nolog `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ) as
probability. The unit can be specified with ` `{.docutils .literal
.notranslate}[` -unit `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . With energy
output, the energy in the first bin is defined to be zero. If you want
the free energy at a different position to be zero, set ` `{.docutils
.literal .notranslate}[` -zprof0 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} (useful with
bootstrapping, see below).

For cyclic or periodic reaction coordinates (dihedral angle, channel PMF
without osmotic gradient), the option ` `{.docutils .literal
.notranslate}[` -cycl `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} is useful.
` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` wham `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} will make use
of the periodicity of the system and generate a periodic PMF. The first
and the last bin of the reaction coordinate will assumed be be
neighbors.

Option ` `{.docutils .literal .notranslate}[` -sym `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} symmetrizes the
profile around z=0 before output, which may be useful for, e.g.
membranes.
:::

::: {#parallelization .section}
### Parallelization

If available, the number of OpenMP threads used by gmx wham can be
controlled by setting the ` `{.docutils .literal
.notranslate}[` OMP_NUM_THREADS `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} environment
variable.
:::

::: {#autocorrelations .section}
### Autocorrelations

With ` `{.docutils .literal .notranslate}[` -ac `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , ` `{.docutils
.literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` wham `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} estimates the
integrated autocorrelation time (IACT) tau for each umbrella window and
weights the respective window with 1/\[1+2\*tau/dt\]. The IACTs are
written to the file defined with ` `{.docutils .literal
.notranslate}[` -oiact `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . In verbose
mode, all autocorrelation functions (ACFs) are written to ` `{.docutils
.literal .notranslate}[` hist_autocorr.xvg `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . Because the
IACTs can be severely underestimated in case of limited sampling, option
` `{.docutils .literal .notranslate}[` -acsig `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} allows one to
smooth the IACTs along the reaction coordinate with a Gaussian (sigma
provided with ` `{.docutils .literal .notranslate}[` -acsig `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} , see
output in ` `{.docutils .literal .notranslate}[` iact.xvg `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} ).
Note that the IACTs are estimated by simple integration of the ACFs
while the ACFs are larger 0.05. If you prefer to compute the IACTs by a
more sophisticated (but possibly less robust) method such as fitting to
a double exponential, you can compute the IACTs with and provide them to
` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` wham `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} with the file
` `{.docutils .literal .notranslate}[` iact-in.dat `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} (option
` `{.docutils .literal .notranslate}[` -iiact `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ), which should
contain one line per input file (pullx/pullf file) and one column per
pull coordinate in the respective file.
:::

::: {#error-analysis .section}
### Error analysis

Statistical errors may be estimated with bootstrap analysis. Use it with
care, otherwise the statistical error may be substantially
underestimated. More background and examples for the bootstrap technique
can be found in Hub, de Groot and Van der Spoel, JCTC (2010) 6:
3713-3720. ` `{.docutils .literal
.notranslate}[` -nBootstrap `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} defines the
number of bootstraps (use, e.g., 100). Four bootstrapping methods are
supported and selected with ` `{.docutils .literal
.notranslate}[` -bs-method `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} .

-   ` `{.docutils .literal .notranslate}[` b-hist `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} Default:
    complete histograms are considered as independent data points, and
    the bootstrap is carried out by assigning random weights to the
    histograms (â€œBayesian bootstrapâ€?). Note that each point along
    the reaction coordinate must be covered by multiple independent
    histograms (e.g. 10 histograms), otherwise the statistical error is
    underestimated.

-   ` `{.docutils .literal .notranslate}[` hist `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} Complete
    histograms are considered as independent data points. For each
    bootstrap, N histograms are randomly chosen from the N given
    histograms (allowing duplication, i.e. sampling with replacement).
    To avoid gaps without data along the reaction coordinate blocks of
    histograms ( ` `{.docutils .literal
    .notranslate}[` -histbs-block `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} ) may be
    defined. In that case, the given histograms are divided into blocks
    and only histograms within each block are mixed. Note that the
    histograms within each block must be representative for all possible
    histograms, otherwise the statistical error is underestimated.

-   ` `{.docutils .literal .notranslate}[` traj `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} The given
    histograms are used to generate new random trajectories, such that
    the generated data points are distributed according the given
    histograms and properly autocorrelated. The autocorrelation time
    (ACT) for each window must be known, so use ` `{.docutils .literal
    .notranslate}[` -ac `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} or provide
    the ACT with ` `{.docutils .literal
    .notranslate}[` -iiact `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} . If the
    ACT of all windows are identical (and known), you can also provide
    them with ` `{.docutils .literal .notranslate}[` -bs-tau `{.docutils
    .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} .
    Note that this method may severely underestimate the error in case
    of limited sampling, that is if individual histograms do not
    represent the complete phase space at the respective positions.

-   ` `{.docutils .literal .notranslate}[` traj-gauss `{.docutils
    .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}
    The same as method ` `{.docutils .literal
    .notranslate}[` traj `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} , but the
    trajectories are not bootstrapped from the umbrella histograms but
    from Gaussians with the average and width of the umbrella
    histograms. That method yields similar error estimates like method
    ` `{.docutils .literal .notranslate}[` traj `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} .

Bootstrapping output:

-   ` `{.docutils .literal .notranslate}[` -bsres `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} Average
    profile and standard deviations

-   ` `{.docutils .literal .notranslate}[` -bsprof `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} All
    bootstrapping profiles

With ` `{.docutils .literal .notranslate}[` -vbs `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} (verbose
bootstrapping), the histograms of each bootstrap are written, and, with
bootstrap method ` `{.docutils .literal .notranslate}[` traj `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} , the
cumulative distribution functions of the histograms.
:::
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -ix `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.dat\>\] (pullx-files.dat) (Optional)

:   Generic data file

` `{.docutils .literal .notranslate}[` -if `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.dat\>\] (pullf-files.dat) (Optional)

:   Generic data file

` `{.docutils .literal .notranslate}[` -it `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.dat\>\] (tpr-files.dat) (Optional)

:   Generic data file

` `{.docutils .literal .notranslate}[` -is `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.dat\>\] (coordsel.dat) (Optional)

:   Generic data file

` `{.docutils .literal .notranslate}[` -iiact `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.dat\>\] (iact-in.dat) (Optional)

:   Generic data file

` `{.docutils .literal .notranslate}[` -tab `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.dat\>\] (umb-pot.dat) (Optional)

:   Generic data file

Options to specify output files:

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (profile.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -hist `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (histo.xvg)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -oiact `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (iact.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -bsres `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (bsResult.xvg) (Optional)

:   xvgr/xmgr file

` `{.docutils .literal .notranslate}[` -bsprof `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xvg\>\] (bsProfs.xvg) (Optional)

:   xvgr/xmgr file

Other options:

` `{.docutils .literal .notranslate}[` -xvg `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (xmgrace)

:   xvg plot formatting: xmgrace, xmgr, none

` `{.docutils .literal .notranslate}[` -min `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Minimum coordinate in profile

` `{.docutils .literal .notranslate}[` -max `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Maximum coordinate in profile

` `{.docutils .literal .notranslate}[` -[no]auto `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Determine min and max automatically

` `{.docutils .literal .notranslate}[` -bins `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (200)

:   Number of bins in profile

` `{.docutils .literal .notranslate}[` -temp `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (298)

:   Temperature

` `{.docutils .literal .notranslate}[` -tol `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (1e-06)

:   Tolerance

` `{.docutils .literal .notranslate}[` -[no]v `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Verbose mode

` `{.docutils .literal .notranslate}[` -b `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (50)

:   First time to analyse (ps)

` `{.docutils .literal .notranslate}[` -e `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (1e+20)

:   Last time to analyse (ps)

` `{.docutils .literal .notranslate}[` -dt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Analyse only every dt ps

` `{.docutils .literal .notranslate}[` -[no]histonly `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Write histograms and exit

` `{.docutils .literal .notranslate}[` -[no]boundsonly `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Determine min and max and exit (with ` `{.docutils .literal
    .notranslate}[` -auto `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} )

` `{.docutils .literal .notranslate}[` -[no]log `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Calculate the log of the profile before printing

` `{.docutils .literal .notranslate}[` -unit `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (kJ)

:   Energy unit in case of log output: kJ, kCal, kT

` `{.docutils .literal .notranslate}[` -zprof0 `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Define profile to 0.0 at this position (with ` `{.docutils .literal
    .notranslate}[` -log `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} )

` `{.docutils .literal .notranslate}[` -[no]cycl `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Create cyclic/periodic profile. Assumes min and max are the same
    point.

` `{.docutils .literal .notranslate}[` -[no]sym `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Symmetrize profile around z=0

` `{.docutils .literal .notranslate}[` -[no]ac `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Calculate integrated autocorrelation times and use in wham

` `{.docutils .literal .notranslate}[` -acsig `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Smooth autocorrelation times along reaction coordinate with Gaussian
    of this sigma

` `{.docutils .literal .notranslate}[` -ac-trestart `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (1)

:   When computing autocorrelation functions, restart computing every ..
    (ps)

` `{.docutils .literal .notranslate}[` -nBootstrap `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (0)

:   nr of bootstraps to estimate statistical uncertainty (e.g., 200)

` `{.docutils .literal .notranslate}[` -bs-method `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (b-hist)

:   Bootstrap method: b-hist, hist, traj, traj-gauss

` `{.docutils .literal .notranslate}[` -bs-tau `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Autocorrelation time (ACT) assumed for all histograms. Use option
    ` `{.docutils .literal .notranslate}[` -ac `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} if ACT is
    unknown.

` `{.docutils .literal .notranslate}[` -bs-seed `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (-1)

:   Seed for bootstrapping. (-1 = use time)

` `{.docutils .literal .notranslate}[` -histbs-block `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (8)

:   When mixing histograms only mix within blocks of ` `{.docutils
    .literal .notranslate}[` -histbs-block `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} .

` `{.docutils .literal .notranslate}[` -[no]vbs `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Verbose bootstrapping. Print the CDFs and a histogram file for each
    bootstrap.
:::
:::
::: {#gmx-wheel .section}
[ ]{#id1}

# gmx wheel

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx wheel [-f [<.dat>]] [-o [<.eps>]] [-r0 <int>] [-rot0 <real>]
          [-T <string>] [-[no]nn]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` wheel `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} plots a helical
wheel representation of your sequence. The input sequence is in the file
where the first line contains the number of residues and each
consecutive line contains a residue name.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.dat\>\] (nnnice.dat)

:   Generic data file

Options to specify output files:

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.eps\>\] (plot.eps)

:   Encapsulated PostScript (tm) file

Other options:

` `{.docutils .literal .notranslate}[` -r0 `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (1)

:   The first residue number in the sequence

` `{.docutils .literal .notranslate}[` -rot0 `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Rotate around an angle initially (90 degrees makes sense)

` `{.docutils .literal .notranslate}[` -T `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<string\>

:   Plot a title in the center of the wheel (must be shorter than 10
    characters, or it will overwrite the wheel)

` `{.docutils .literal .notranslate}[` -[no]nn `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Toggle numbers
:::
:::
::: {#gmx-x2top .section}
[ ]{#id1}

# gmx x2top

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx x2top [-f [<.gro/.g96/...>]] [-o [<.top>]] [-r [<.rtp>]]
          [-ff <string>] [-[no]v] [-nexcl <int>] [-[no]H14]
          [-[no]alldih] [-[no]remdih] [-[no]pairs] [-name <string>]
          [-[no]pbc] [-[no]pdbq] [-[no]param] [-[no]round]
          [-kb <real>] [-kt <real>] [-kp <real>]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` x2top `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} generates a
primitive topology from a coordinate file. The program assumes all
hydrogens are present when defining the hybridization from the atom name
and the number of bonds. The program can also make an entry, which you
can then add to the database.

When ` `{.docutils .literal .notranslate}[` -param `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} is set,
equilibrium distances and angles and force constants will be printed in
the topology for all interactions. The equilibrium distances and angles
are taken from the input coordinates, the force constant are set with
command line options. The force fields somewhat supported currently are:

G53a5 GROMOS96 53a5 Forcefield (official distribution)

oplsaa OPLS-AA/L all-atom force field (2001 aminoacid dihedrals)

The corresponding data files can be found in the library directory with
name ` `{.docutils .literal
.notranslate}[` atomname2type.n2t `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . Check Chapter
5 of the manual for more information about file formats. By default, the
force field selection is interactive, but you can use the ` `{.docutils
.literal .notranslate}[` -ff `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} option to
specify one of the short names above on the command line instead. In
that case ` `{.docutils .literal .notranslate}[` gmx `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` x2top `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} just looks for
the corresponding file.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.gro/.g96/â€¦\>\] (conf.gro)

:   Structure file: brk ent esp

Options to specify output files:

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.top\>\] (out.top) (Optional)

:   Topology file

` `{.docutils .literal .notranslate}[` -r `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.rtp\>\] (out.rtp) (Optional)

:   Residue Type file used by pdb2gmx

Other options:

` `{.docutils .literal .notranslate}[` -ff `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<string\> (oplsaa)

:   Force field for your simulation. Type â€œselectâ€? for interactive
    selection.

` `{.docutils .literal .notranslate}[` -[no]v `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Generate verbose output in the top file.

` `{.docutils .literal .notranslate}[` -nexcl `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (3)

:   Number of exclusions

` `{.docutils .literal .notranslate}[` -[no]H14 `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Use 3rd neighbour interactions for hydrogen atoms

` `{.docutils .literal .notranslate}[` -[no]alldih `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Generate all proper dihedrals

` `{.docutils .literal .notranslate}[` -[no]remdih `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Remove dihedrals on the same bond as an improper

` `{.docutils .literal .notranslate}[` -[no]pairs `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Output 1-4 interactions (pairs) in topology file

` `{.docutils .literal .notranslate}[` -name `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<string\> (ICE)

:   Name of your molecule

` `{.docutils .literal .notranslate}[` -[no]pbc `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Use periodic boundary conditions.

` `{.docutils .literal .notranslate}[` -[no]pdbq `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Use the B-factor supplied in a file for the atomic charges

` `{.docutils .literal .notranslate}[` -[no]param `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Print parameters in the output

` `{.docutils .literal .notranslate}[` -[no]round `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Round off measured values

` `{.docutils .literal .notranslate}[` -kb `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (400000)

:   Bonded force constant (kJ/mol/nm\^2)

` `{.docutils .literal .notranslate}[` -kt `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (400)

:   Angle force constant (kJ/mol/rad\^2)

` `{.docutils .literal .notranslate}[` -kp `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (5)

:   Dihedral angle force constant (kJ/mol/rad\^2)
:::

::: {#known-issues .section}
## Known Issues

-   The atom type selection is primitive. Virtually no chemical
    knowledge is used

-   Periodic boundary conditions screw up the bonding

-   No improper dihedrals are generated

-   The atoms to atomtype translation table is incomplete (
    ` `{.docutils .literal .notranslate}[` atomname2type.n2t `{.docutils
    .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}
    file in the data directory). Please extend it and send the results
    back to the GROMACS crew.
:::
:::
::: {#gmx-xpm2ps .section}
[ ]{#id1}

# gmx xpm2ps

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx xpm2ps [-f [<.xpm>]] [-f2 [<.xpm>]] [-di [<.m2p>]] [-do [<.m2p>]]
           [-o [<.eps>]] [-xpm [<.xpm>]] [-[no]w] [-[no]frame]
           [-title <enum>] [-[no]yonce] [-legend <enum>]
           [-diag <enum>] [-size <real>] [-bx <real>] [-by <real>]
           [-rainbow <enum>] [-gradient <vector>] [-skip <int>]
           [-[no]zeroline] [-legoffset <int>] [-combine <enum>]
           [-cmin <real>] [-cmax <real>]
```
:::

::: {#description .section}
## Description

` `{.docutils .literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` xpm2ps `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} makes a
beautiful color plot of an XPixelMap file. Labels and axis can be
displayed, when they are supplied in the correct matrix format. Matrix
data may be generated by programs such as or .

Parameters are set in the ` `{.docutils .literal
.notranslate}[` .m2p `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} file optionally
supplied with ` `{.docutils .literal .notranslate}[` -di `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} .
Reasonable defaults are provided. Settings for the *y* -axis default to
those for the *x* -axis. Font names have a defaulting hierarchy:
titlefont -\> legendfont; titlefont -\> (xfont -\> yfont -\> ytickfont)
-\> xtickfont, e.g. setting titlefont sets all fonts, setting xfont sets
yfont, ytickfont and xtickfont.

When no ` `{.docutils .literal .notranslate}[` .m2p `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} file is
supplied, many settings are taken from command line options. The most
important option is ` `{.docutils .literal
.notranslate}[` -size `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , which sets
the size of the whole matrix in postscript units. This option can be
overridden with the ` `{.docutils .literal
.notranslate}[` -bx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` -by `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} options (and
the corresponding parameters in the ` `{.docutils .literal
.notranslate}[` .m2p `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} file), which
set the size of a single matrix element.

With ` `{.docutils .literal .notranslate}[` -f2 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} a second matrix
file can be supplied. Both matrix files will be read simultaneously and
the upper left half of the first one ( ` `{.docutils .literal
.notranslate}[` -f `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ) is plotted
together with the lower right half of the second one ( ` `{.docutils
.literal .notranslate}[` -f2 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ). The diagonal
will contain values from the matrix file selected with ` `{.docutils
.literal .notranslate}[` -diag `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . Plotting of
the diagonal values can be suppressed altogether by setting
` `{.docutils .literal .notranslate}[` -diag `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} to
` `{.docutils .literal .notranslate}[` none `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . In this case,
a new color map will be generated with a red gradient for negative
numbers and a blue for positive. If the color coding and legend labels
of both matrices are identical, only one legend will be displayed, else
two separate legends are displayed. With ` `{.docutils .literal
.notranslate}[` -combine `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , an
alternative operation can be selected to combine the matrices. The
output range is automatically set to the actual range of the combined
matrix. This can be overridden with ` `{.docutils .literal
.notranslate}[` -cmin `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` -cmax `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} .

` `{.docutils .literal .notranslate}[` -title `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} can be set to
` `{.docutils .literal .notranslate}[` none `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} to suppress the
title, or to ` `{.docutils .literal .notranslate}[` ylabel `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} to
show the title in the Y-label position (alongside the *y* -axis).

With the ` `{.docutils .literal .notranslate}[` -rainbow `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}
option, dull grayscale matrices can be turned into attractive color
pictures.

Merged or rainbowed matrices can be written to an XPixelMap file with
the ` `{.docutils .literal .notranslate}[` -xpm `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} option.
:::

::: {#options .section}
## Options

Options to specify input files:

` `{.docutils .literal .notranslate}[` -f `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xpm\>\] (root.xpm)

:   X PixMap compatible matrix file

` `{.docutils .literal .notranslate}[` -f2 `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xpm\>\] (root2.xpm) (Optional)

:   X PixMap compatible matrix file

` `{.docutils .literal .notranslate}[` -di `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.m2p\>\] (ps.m2p) (Optional, Library)

:   Input file for mat2ps

Options to specify output files:

` `{.docutils .literal .notranslate}[` -do `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.m2p\>\] (out.m2p) (Optional)

:   Input file for mat2ps

` `{.docutils .literal .notranslate}[` -o `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.eps\>\] (plot.eps) (Optional)

:   Encapsulated PostScript (tm) file

` `{.docutils .literal .notranslate}[` -xpm `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \[\<.xpm\>\] (root.xpm) (Optional)

:   X PixMap compatible matrix file

Other options:

` `{.docutils .literal .notranslate}[` -[no]w `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   View output , , and files

` `{.docutils .literal .notranslate}[` -[no]frame `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Display frame, ticks, labels, title and legend

` `{.docutils .literal .notranslate}[` -title `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (top)

:   Show title at: top, once, ylabel, none

` `{.docutils .literal .notranslate}[` -[no]yonce `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Show y-label only once

` `{.docutils .literal .notranslate}[` -legend `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (both)

:   Show legend: both, first, second, none

` `{.docutils .literal .notranslate}[` -diag `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (first)

:   Diagonal: first, second, none

` `{.docutils .literal .notranslate}[` -size `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (400)

:   Horizontal size of the matrix in ps units

` `{.docutils .literal .notranslate}[` -bx `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Element x-size, overrides ` `{.docutils .literal
    .notranslate}[` -size `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} (also
    y-size when ` `{.docutils .literal .notranslate}[` -by `{.docutils
    .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} is
    not set)

` `{.docutils .literal .notranslate}[` -by `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Element y-size

` `{.docutils .literal .notranslate}[` -rainbow `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (no)

:   Rainbow colors, convert white to: no, blue, red

` `{.docutils .literal .notranslate}[` -gradient `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<vector\> (0 0 0)

:   Re-scale colormap to a smooth gradient from white {1,1,1} to {r,g,b}

` `{.docutils .literal .notranslate}[` -skip `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (1)

:   only write out every nr-th row and column

` `{.docutils .literal .notranslate}[` -[no]zeroline `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   insert line in matrix where axis label is zero

` `{.docutils .literal .notranslate}[` -legoffset `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (0)

:   Skip first N colors from file for the legend

` `{.docutils .literal .notranslate}[` -combine `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<enum\> (halves)

:   Combine two matrices: halves, add, sub, mult, div

` `{.docutils .literal .notranslate}[` -cmin `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Minimum for combination output

` `{.docutils .literal .notranslate}[` -cmax `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<real\> (0)

:   Maximum for combination output
:::
:::
::: {#known-issues-affecting-users-of-gromacs .section}
# Known issues affecting users of GROMACS

Here is a non-exhaustive list of issues that are we are aware of that
are affecting regular users of GROMACS.

::: {#unable-to-compile-with-cuda-11-3 .section}
## Unable to compile with CUDA 11.3

Due to a bug in the nvcc compiler, it is currently not possible to
compile NVIDIA GPU-enabled GROMACS with version 11.3 of the CUDA
compiler. We recommend using CUDA 11.4 or newer.
:::

::: {#the-deform-option-is-not-suitable-for-flow .section}
## The deform option is not suitable for flow

The deform option currently scales the coordinates, but for flow the
deformation should only be driven by changing periodic vectors. In
addition the velocities of particles need to be corrected when they are
displaced by periodic vectors. Therefore the deform option is currently
only suitable for slowly deforming systems.
:::

::: {#sycl-build-unstable-when-using-oneapi-with-levelzero-backend .section}
## SYCL build unstable when using oneAPI with LevelZero backend

There are multiple issues with different versions of Intel oneAPI when
using the LevelZero backend.

In many cases, it works fine, and if it fails, it does so explicitly
(either crash or hang), so it should be fine to experiment with.

For most cases, we recommend using OpenCL backend (the default) when
running SYCL build of GROMACS on Intel GPUs.
:::

::: {#unable-to-build-with-cuda-11-5-11-6-and-gcc-11-on-ubuntu-22-04 .section}
## Unable to build with CUDA 11.5-11.6 and GCC 11 on Ubuntu 22.04

A bug in the nvcc toolchain, versions 11.5.0-11.6.1, makes it impossible
to build recent GROMACS with GCC 11.2 shipped with Ubuntu 22.04. We
recommend the users to either use an different version of GCC (at the
time of writing 9.x or 10.x have been reported to work), or manually
update the nvcc toolchain to version 11.6.2 or newer.

Some non-Ubuntu installations of GCC 11.2 library have been observed to
work fine.

When an incompatible combination is used, an error will be raised from
CMake or later during build.
:::

::: {#fft-errors-with-nvidia-rtx-40xx-series-gpus-and-cuda-11-7-or-earlier .section}
## FFT errors with NVIDIA RTX 40xx-series GPUs and CUDA 11.7 or earlier

cuFFT library only has full support for RTX 40xx GPUs since version
11.8. If you are using older CUDA, you might encounter ` `{.docutils
.literal .notranslate}[` cufftPlanMany `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` R2C `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` plan `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` failure `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} error when
running a simulation with PME on such a GPU. To resolve, upgrade to CUDA
11.8 or 12.x.
:::

::: {#cannot-find-a-working-standard-library-error-with-rocm-clang .section}
## â€œCannot find a working standard libraryâ€? error with ROCm Clang

Some Clang installations donâ€™t contain a compatible C++ standard
library. In such cases, you might have to install ` `{.docutils .literal
.notranslate}[` g++ `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and help CMake
find it by setting ` `{.docutils .literal
.notranslate}[` -DGMX_GPLUSGPLUS_PATH=/path/to/bin/g++ `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} .

On Ubuntu 22.04, installing GCC 12 standard library (with ` `{.docutils
.literal .notranslate}[` sudo `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` apt `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` install `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` libstdc++-12-dev `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ) usually works
well even without setting ` `{.docutils .literal
.notranslate}[` -DGMX_GPLUSGPLUS_PATH `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} .
:::

::: {#expanded-ensemble-does-not-checkpoint-correctly .section}
## Expanded ensemble does not checkpoint correctly

In the legacy simulator, because of shortcomings in the implementation,
successful expanded-ensemble MC steps that occured on checkpoint steps
were not recorded in the checkpoint. If that checkpoint was used for a
restart, then it would not necessarily behave correctly and reproducibly
afterwards. So checkpointing of expanded-ensemble simulations is
disabled for the legacy simulator.

Checkpointing of expanded ensemble in the modular simulator works
correctly.

To work around the issue, either avoid ` `{.docutils .literal
.notranslate}[` -update `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` gpu `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} (so that it
uses the modular simulator path which does not have the bug), or use an
older version of GROMACS (which does do the buggy checkpointing), or
refrain from restarting from checkpoints in the affected case.
:::

::: {#compiling-with-gcc-12-on-power9-architectures .section}
## Compiling with GCC 12 on POWER9 architectures

There are multiple failing unit tests after compilation with GCC 12.2
and 12.3 on POWER9 architectures. It is possible that other GCC 12 and
newer versions are affected.
:::
:::
::: {#managing-long-simulations .section}
[ ]{#id1}

# Managing long simulations

Molecular simulations often extend beyond the lifetime of a single UNIX
command-line process. It is useful to be able to stop and restart the
simulation in a way that is equivalent to a single run. When is halted,
it writes a checkpoint file that can restart the simulation exactly as
if there was no interruption. To do this, the checkpoint retains a
full-precision version of the positions and velocities, along with state
information necessary to restart algorithms e.g. that implement coupling
to external thermal reservoirs. A restart can be attempted using e.g. a
file with velocities, but since the file has significantly less
precision, and none of the coupling algorithms will have their state
carried over, such a restart is less continuous than a normal MD step.

Such a checkpoint file is also written periodically by during the run.
The interval is given by the ` `{.docutils .literal
.notranslate}[` -cpt `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} flag to . When
attempts to write each successive checkpoint file, it first renames the
old file with the suffix ` `{.docutils .literal
.notranslate}[` _prev `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , so that even
if something goes wrong while writing the new checkpoint file, only
recent progress can be lost.

can be halted in several ways:

-   the number of simulation can expire

-   the user issues a termination signal (e.g. with Ctrl-C on the
    terminal)

-   the job scheduler issues a termination signal when time expires

-   when detects that the length specified with ` `{.docutils .literal
    .notranslate}[` -maxh `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} has elapsed
    (this option is useful to help cooperate with a job scheduler, but
    can be problematic if jobs can be suspended)

-   some kind of catastrophic failure, such as loss of power, or a disk
    filling up, or a network failing

To use the checkpoint file for a restart, use a command line such as

::: {.highlight-default .notranslate}
::: highlight
    gmx mdrun -cpi state
:::
:::

which directs mdrun to use the checkpoint file (which is named
` `{.docutils .literal .notranslate}[` state.cpt `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} by default).
You can choose to give the output checkpoint file a different name with
the ` `{.docutils .literal .notranslate}[` -cpo `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} flag, but if so
then you must provide that name as input to ` `{.docutils .literal
.notranslate}[` -cpi `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} when you later
use that file. You can query the contents of checkpoint files with and .

::: {#appending-to-output-files .section}
## Appending to output files

By default, will append to the old output files. If the previous part
ended in a regular way, then the performance data at the end of the log
file will will be removed, some new information about the run context
written, and the simulation will proceed. Otherwise, mdrun will truncate
all the output files back to the time of the last written checkpoint
file, and continue from there, as if the simulation stopped at that
checkpoint in a regular way.

You can choose not to append the output files by using the ` `{.docutils
.literal .notranslate}[` -noappend `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} flag, which
forces mdrun to write each output to a separate file, whose name
includes a â€œ.partXXXXâ€? string to describe which simulation part is
contained in this file. This numbering starts from zero and increases
monotonically as simulations are restarted, but does not reflect the
number of simulation steps in each part. The option can be used to set
this number manually in , which can be useful if data has been lost,
e.g. through filesystem failure or user error.

Appending will not work if any output files have been modified or
removed after mdrun wrote them, because the checkpoint file maintains a
checksum of each file that it will verify before it writes to them
again. In such cases, you must either restore the file, name them as the
checkpoint file expects, or continue with ` `{.docutils .literal
.notranslate}[` -noappend `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . If your
original run used ` `{.docutils .literal
.notranslate}[` -deffnm `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , and you want
appending, then your continuations must also use ` `{.docutils .literal
.notranslate}[` -deffnm `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} .
:::

::: {#backing-up-your-files .section}
## Backing up your files

You should arrange to back up your simulation files frequently. Network
file systems on clusters can be configured in more or less conservative
ways, and this can lead to be told that a checkpoint file has been
written to disk when actually it is still in memory somewhere and
vulnerable to a power failure or disk that fills or fails in the
meantime. The UNIX tool rsync can be a useful way to periodically copy
your simulation output to a remote storage location, which works safely
even while the simulation is underway. Keeping a copy of the final
checkpoint file from each part of a job submitted to a cluster can be
useful if a file system is unreliable.
:::

::: {#extending-a-tpr-file .section}
## Extending a .tpr file

If the simulation described by file has completed and should be
extended, use the tool to extend the run, e.g.

::: {.highlight-default .notranslate}
::: highlight
    gmx convert-tpr -s previous.tpr -extend timetoextendby -o next.tpr
    gmx mdrun -s next.tpr -cpi state.cpt
:::
:::

The time can also be extended using the ` `{.docutils .literal
.notranslate}[` -until `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` -nsteps `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} options. Note
that the original file may have generated velocities, but that is a
one-time operation within that is never performed again by any other
tool.
:::

::: {#changing-mdp-options-for-a-restart .section}
## Changing mdp options for a restart

If you wish to make changes to your simulations settings other than
length, then you should do so in the file or topology, and then call

::: {.highlight-default .notranslate}
::: highlight
    gmx grompp -f possibly-changed.mdp -p possibly-changed.top -c original.gro -t state.cpt -o new.tpr
    gmx mdrun -s new.tpr -cpi state.cpt
:::
:::

to instruct to copy the full-precision coordinates and velocities in the
checkpoint file into the new file. You should consider your choices for
, , and . You should generally not regenerate velocities with , and
generally select so that constraints are not re-applied before the first
integration step.
:::

::: {#restarts-without-checkpoint-files .section}
## Restarts without checkpoint files

It used to be possible to continue simulations without the checkpoint
files. As this approach could be unreliable or lead to unphysical
results, only restarts from checkpoints are permitted now.
:::

::: {#are-continuations-exact .section}
## Are continuations exact?

If you had a computer with unlimited precision, or if you integrated the
time-discretized equations of motion by hand, exact continuation would
lead to identical results. But since practical computers have limited
precision and MD is chaotic, trajectories will diverge very rapidly even
if one bit is different. Such trajectories will all be equally valid,
but eventually very different. Continuation using a checkpoint file,
using the same code compiled with the same compiler and running on the
same computer architecture using the same number of processors without
GPUs (see next section) would lead to binary identical results. However,
by default the actual work load will be balanced across the hardware
according to the observed execution times. Such trajectories are in
principle not reproducible, and in particular a run that took place in
more than one part will not be identical with an equivalent run in one
part - but neither of them is better in any sense.
:::

::: {#reproducibility .section}
## Reproducibility

The following factors affect the reproducibility of a simulation, and
thus its output:

-   Precision (mixed / double) with double giving â€œbetterâ€?
    reproducibility.

-   Number of cores, due to different order in which forces are
    accumulated. For instance (a+b)+c is not necessarily binary
    identical to a+(b+c) in floating-point arithmetic.

-   Type of processors. Even within the same processor family there can
    be slight differences.

-   Optimization level when compiling.

-   Optimizations at run time: e.g. the FFTW library that is typically
    used for fast Fourier transforms determines at startup which version
    of their algorithms is fastest, and uses that for the remainder of
    the calculations. Since the speed estimate is not deterministic, the
    results may vary from run to run.

-   Random numbers used for instance as a seed for generating velocities
    (in GROMACS at the preprocessing stage).

-   Uninitialized variables in the code (but there shouldnâ€™t be any)

-   Dynamic linking to different versions of shared libraries (e.g. for
    FFTs)

-   Dynamic load balancing, since particles are redistributed to
    processors based on elapsed wallclock time, which will lead to
    (a+b)+c != a+(b+c) issues as above

-   Number of PME-only ranks (for parallel PME simulations)

-   MPI reductions typically do not guarantee the order of the
    operations, and so the absence of associativity for floating-point
    arithmetic means the result of a reduction depends on the order
    actually chosen

-   On GPUs, the reduction of e.g. non-bonded forces has a
    non-deterministic summation order, so any fast implementation is
    non-reproducible by design.

The important question is whether it is a problem if simulations are not
completely reproducible. The answer is yes and no. Reproducibility is a
cornerstone of science in general, and hence it is important. The tells
us that in the case of infinitely long simulations, all observables
converge to their equilibrium values. Molecular simulations in GROMACS
adhere to this theorem, and hence, for instance, the energy of your
system will converge to a finite value, the diffusion constant of your
water molecules will converge to a finite value, and so on. That means
all the important observables, which are the values you would like to
get out of your simulation, are reproducible. Each individual trajectory
is not reproducible, however.

However, there are a few cases where it would be useful if trajectories
were reproducible, too. These include developers doing debugging, and
searching for a rare event in a trajectory when, if it occurs, you want
to have manually saved your checkpoint file so you can restart the
simulation under different conditions, e.g. writing output much more
frequently.

In order to obtain this reproducible trajectory, it is important to look
over the list above and eliminate the factors that could affect it.
Further, using

::: {.highlight-default .notranslate}
::: highlight
    gmx mdrun -reprod
:::
:::

will eliminate all sources of non-reproducibility that it can, i.e. same
executable + same hardware + same shared libraries + same run input
file + same command line parameters will lead to reproducible results.
:::
:::
::: {#molecular-dynamics-parameters-mdp-options .section}
# Molecular dynamics parameters (.mdp options)

::: {#general-information .section}
[ ]{#mdp-general}

## General information

Default values are given in parentheses, or listed first among choices.
The first option in the list is always the default option. Units are
given in square brackets. The difference between a dash and an
underscore is ignored.

A is available. This should be appropriate to start a normal simulation.
Edit it to suit your specific needs and desires.

::: {#preprocessing .section}
### Preprocessing

[ [ include ]{.pre} ]{.sig-name .descname}

:   directories to include in your topology. Format: ` `{.docutils
    .literal .notranslate}[` -I/home/john/mylib `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` -I../otherlib `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate}

```{=html}
<!-- -->
```

[ [ define ]{.pre} ]{.sig-name .descname}

:   defines to pass to the preprocessor, default is no defines. You can
    use any defines to control options in your customized topology
    files. Options that act on existing file mechanisms include

    > <div>
    >
    > ` `{.docutils .literal .notranslate}[` -DFLEXIBLE `{.docutils
    > .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}
    > will use flexible water instead of rigid water into your topology,
    > this can be useful for normal mode analysis.
    >
    > ` `{.docutils .literal .notranslate}[` -DPOSRES `{.docutils
    > .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}
    > will trigger the inclusion of ` `{.docutils .literal
    > .notranslate}[` posre.itp `{.docutils .literal
    > .notranslate}]{.pre}` `{.docutils .literal .notranslate} into your
    > topology, used for implementing position restraints.
    >
    > </div>
:::

::: {#run-control .section}
### Run control

[ [ integrator ]{.pre} ]{.sig-name .descname}

:   (Despite the name, this list includes algorithms that are not
    actually integrators over time. and all entries following it are in
    this category)

    [ [ md ]{.pre} ]{.sig-name .descname}

    :   A leap-frog algorithm for integrating Newtonâ€™s equations of
        motion.

    [ [ md-vv ]{.pre} ]{.sig-name .descname}

    :   A velocity Verlet algorithm for integrating Newtonâ€™s equations
        of motion. For constant NVE simulations started from
        corresponding points in the same trajectory, the trajectories
        are analytically, but not binary, identical to the leap-frog
        integrator. The kinetic energy, which is determined from the
        whole step velocities and is therefore slightly too high. The
        advantage of this integrator is more accurate, reversible
        Nose-Hoover and Parrinello-Rahman coupling integration based on
        Trotter expansion, as well as (slightly too small) full step
        velocity output. This all comes at the cost off extra
        computation, especially with constraints and extra communication
        in parallel. Note that for nearly all production simulations the
        integrator is accurate enough.

    [ [ md-vv-avek ]{.pre} ]{.sig-name .descname}

    :   A velocity Verlet algorithm identical to , except that the
        kinetic energy is determined as the average of the two half step
        kinetic energies as in the integrator, and this thus more
        accurate. With Nose-Hoover and/or Parrinello-Rahman coupling
        this comes with a slight increase in computational cost.

    [ [ sd ]{.pre} ]{.sig-name .descname}

    :   An accurate and efficient leap-frog stochastic dynamics
        integrator. With constraints, coordinates needs to be
        constrained twice per integration step. Depending on the
        computational cost of the force calculation, this can take a
        significant part of the simulation time. The temperature for one
        or more groups of atoms ( ) is set with , the inverse friction
        constant for each group is set with . The parameters and are
        ignored. The random generator is initialized with . When used as
        a thermostat, an appropriate value for is 2 ps, since this
        results in a friction that is lower than the internal friction
        of water, while it is high enough to remove excess heat NOTE:
        temperature deviations decay twice as fast as with a Berendsen
        thermostat with the same .

    [ [ bd ]{.pre} ]{.sig-name .descname}

    :   An Euler integrator for Brownian or position Langevin dynamics,
        the velocity is the force divided by a friction coefficient ( )
        plus random thermal noise ( ). When is 0, the friction
        coefficient for each particle is calculated as mass/ , as for
        the integrator . The random generator is initialized with .

    [ [ steep ]{.pre} ]{.sig-name .descname}

    :   A steepest descent algorithm for energy minimization. The
        maximum step size is , the tolerance is .

    [ [ cg ]{.pre} ]{.sig-name .descname}

    :   A conjugate gradient algorithm for energy minimization, the
        tolerance is . CG is more efficient when a steepest descent step
        is done every once in a while, this is determined by . For a
        minimization prior to a normal mode analysis, which requires a
        very high accuracy, GROMACS should be compiled in double
        precision.

    [ [ l-bfgs ]{.pre} ]{.sig-name .descname}

    :   A quasi-Newtonian algorithm for energy minimization according to
        the low-memory Broyden-Fletcher-Goldfarb-Shanno approach. In
        practice this seems to converge faster than Conjugate Gradients,
        but due to the correction steps necessary it is not (yet)
        parallelized.

    [ [ nm ]{.pre} ]{.sig-name .descname}

    :   Normal mode analysis is performed on the structure in the file.
        GROMACS should be compiled in double precision.

    [ [ tpi ]{.pre} ]{.sig-name .descname}

    :   Test particle insertion. The last molecule in the topology is
        the test particle. A trajectory must be provided to
        ` `{.docutils .literal .notranslate}[` mdrun `{.docutils
        .literal .notranslate}]{.pre}` `{.docutils .literal
        .notranslate}[` -rerun `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal .notranslate} . This
        trajectory should not contain the molecule to be inserted.
        Insertions are performed times in each frame at random locations
        and with random orientiations of the molecule. When is larger
        than one, insertions are performed in a sphere with radius
        around a the same random location using the same pair list.
        Since pair list construction is expensive, one can perform
        several extra insertions with the same list almost for free. The
        random seed is set with . The temperature for the Boltzmann
        weighting is set with , this should match the temperature of the
        simulation of the original trajectory. Dispersion correction is
        implemented correctly for TPI. All relevant quantities are
        written to the file specified with ` `{.docutils .literal
        .notranslate}[` mdrun `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal
        .notranslate}[` -tpi `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal .notranslate} . The
        distribution of insertion energies is written to the file
        specified with ` `{.docutils .literal
        .notranslate}[` mdrun `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal
        .notranslate}[` -tpid `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal .notranslate} . No
        trajectory or energy file is written. Parallel TPI gives
        identical results to single-node TPI. For charged molecules,
        using PME with a fine grid is most accurate and also efficient,
        since the potential in the system only needs to be calculated
        once per frame.

    [ [ tpic ]{.pre} ]{.sig-name .descname}

    :   Test particle insertion into a predefined cavity location. The
        procedure is the same as for , except that one coordinate extra
        is read from the trajectory, which is used as the insertion
        location. The molecule to be inserted should be centered at
        0,0,0. GROMACS does not do this for you, since for different
        situations a different way of centering might be optimal. Also
        sets the radius for the sphere around this location. Neighbor
        searching is done only once per frame, is not used. Parallel
        gives identical results to single-rank .

    [ [ mimic ]{.pre} ]{.sig-name .descname}

    :   Enable MiMiC QM/MM coupling to run hybrid molecular dynamics.
        Keey in mind that its required to launch CPMD compiled with
        MiMiC as well. In this mode all options regarding integration
        (T-coupling, P-coupling, timestep and number of steps) are
        ignored as CPMD will do the integration instead. Options related
        to forces computation (cutoffs, PME parameters, etc.) are
        working as usual. Atom selection to define QM atoms is read from

```{=html}
<!-- -->
```

[ [ tinit ]{.pre} ]{.sig-name .descname}

:   \(0\) \[ps\] starting time for your run (only makes sense for
    time-based integrators)

```{=html}
<!-- -->
```

[ [ dt ]{.pre} ]{.sig-name .descname}

:   (0.001) \[ps\] time step for integration (only makes sense for
    time-based integrators)

```{=html}
<!-- -->
```

[ [ nsteps ]{.pre} ]{.sig-name .descname}

:   \(0\) maximum number of steps to integrate or minimize, -1 is no
    maximum

```{=html}
<!-- -->
```

[ [ init-step ]{.pre} ]{.sig-name .descname}

:   \(0\) The starting step. The time at step i in a run is calculated
    as: t = + \* ( + i). The free-energy lambda is calculated as: lambda
    = + \* ( + i). Also non-equilibrium MD parameters can depend on the
    step number. Thus for exact restarts or redoing part of a run it
    might be necessary to set to the step number of the restart frame.
    does this automatically.

```{=html}
<!-- -->
```

[ [ simulation-part ]{.pre} ]{.sig-name .descname}

:   \(0\) A simulation can consist of multiple parts, each of which has
    a part number. This option specifies what that number will be, which
    helps keep track of parts that are logically the same simulation.
    This option is generally useful to set only when coping with a
    crashed simulation where files were lost.

```{=html}
<!-- -->
```

[ [ mts ]{.pre} ]{.sig-name .descname}

:   

    [ [ no ]{.pre} ]{.sig-name .descname}

    :   Evaluate all forces at every integration step.

    [ [ yes ]{.pre} ]{.sig-name .descname}

    :   Use a multiple timing-stepping integrator to evaluate some
        forces, as specified by every integration steps. All other
        forces are evaluated at every step. MTS is currently only
        supported with .

```{=html}
<!-- -->
```

[ [ mts-levels ]{.pre} ]{.sig-name .descname}

:   \(2\) The number of levels for the multiple time-stepping scheme.
    Currently only 2 is supported.

```{=html}
<!-- -->
```

[ [ mts-level2-forces ]{.pre} ]{.sig-name .descname}

:   (longrange-nonbonded) A list of one or more force groups that will
    be evaluated only every steps. Supported entries are: ` `{.docutils
    .literal .notranslate}[` longrange-nonbonded `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} ,
    ` `{.docutils .literal .notranslate}[` nonbonded `{.docutils
    .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} ,
    ` `{.docutils .literal .notranslate}[` pair `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} ,
    ` `{.docutils .literal .notranslate}[` dihedral `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} ,
    ` `{.docutils .literal .notranslate}[` angle `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} ,
    ` `{.docutils .literal .notranslate}[` pull `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} and
    ` `{.docutils .literal .notranslate}[` awh `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} . With
    ` `{.docutils .literal .notranslate}[` pair `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} the listed
    pair forces (such as 1-4) are selected. With ` `{.docutils .literal
    .notranslate}[` dihedral `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} all
    dihedrals are selected, including cmap. All other forces, including
    all restraints, are evaluated and integrated every step. When PME or
    Ewald is used for electrostatics and/or LJ interactions,
    ` `{.docutils .literal
    .notranslate}[` longrange-nonbonded `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} can not be
    omitted here.

```{=html}
<!-- -->
```

[ [ mts-level2-factor ]{.pre} ]{.sig-name .descname}

:   \(2\) \[steps\] Interval for computing the forces in level 2 of the
    multiple time-stepping scheme

```{=html}
<!-- -->
```

[ [ mass-repartitioning-factor ]{.pre} ]{.sig-name .descname}

:   \(1\) \[\] Scales the masses of the lightest atoms in the system by
    this factor to the mass mMin. All atoms with a mass lower than mMin
    also have their mass set to that mMin. The mass change is subtracted
    from the mass of the atom the light atom is bound to. If there is no
    bound atom a warning is generated. If there is more than one atom
    bound an error is generated. If the mass of the bound atom would
    become lower than mMin an error is generated. For typical atomistic
    systems only the masses of hydrogens are scaled. With h-bonds
    constrained a factor of 3 will usually enable a time step of 4 fs.

```{=html}
<!-- -->
```

[ [ comm-mode ]{.pre} ]{.sig-name .descname}

:   

    [ [ Linear ]{.pre} ]{.sig-name .descname}

    :   Remove center of mass translational velocity

    [ [ Angular ]{.pre} ]{.sig-name .descname}

    :   Remove center of mass translational and rotational velocity

    [ [ Linear-acceleration-correction ]{.pre} ]{.sig-name .descname}

    :   Remove center of mass translational velocity. Correct the center
        of mass position assuming linear acceleration over steps. This
        is useful for cases where an acceleration is expected on the
        center of mass which is nearly constant over steps. This can
        occur for example when pulling on a group using an absolute
        reference.

    [ [ None ]{.pre} ]{.sig-name .descname}

    :   No restriction on the center of mass motion

```{=html}
<!-- -->
```

[ [ nstcomm ]{.pre} ]{.sig-name .descname}

:   \(100\) \[steps\] frequency for center of mass motion removal

```{=html}
<!-- -->
```

[ [ comm-grps ]{.pre} ]{.sig-name .descname}

:   group(s) for center of mass motion removal, default is the whole
    system
:::

::: {#langevin-dynamics .section}
### Langevin dynamics

[ [ bd-fric ]{.pre} ]{.sig-name .descname}

:   \(0\) \[amu ps ^-1^ \] Brownian dynamics friction coefficient. When
    is 0, the friction coefficient for each particle is calculated as
    mass/ .

```{=html}
<!-- -->
```

[ [ ld-seed ]{.pre} ]{.sig-name .descname}

:   (-1) \[integer\] used to initialize random generator for thermal
    noise for stochastic and Brownian dynamics. When is set to -1, a
    pseudo random seed is used. When running BD or SD on multiple
    processors, each processor uses a seed equal to plus the processor
    number.
:::

::: {#energy-minimization .section}
### Energy minimization

[ [ emtol ]{.pre} ]{.sig-name .descname}

:   (10.0) \[kJ mol ^-1^ nm ^-1^ \] the minimization is converged when
    the maximum force is smaller than this value

```{=html}
<!-- -->
```

[ [ emstep ]{.pre} ]{.sig-name .descname}

:   (0.01) \[nm\] initial step-size

```{=html}
<!-- -->
```

[ [ nstcgsteep ]{.pre} ]{.sig-name .descname}

:   \(1000\) \[steps\] frequency of performing 1 steepest descent step
    while doing conjugate gradient energy minimization.

```{=html}
<!-- -->
```

[ [ nbfgscorr ]{.pre} ]{.sig-name .descname}

:   \(10\) Number of correction steps to use for L-BFGS minimization. A
    higher number is (at least theoretically) more accurate, but slower.
:::

::: {#shell-molecular-dynamics .section}
### Shell Molecular Dynamics

When shells or flexible constraints are present in the system the
positions of the shells and the lengths of the flexible constraints are
optimized at every time step until either the RMS force on the shells
and constraints is less than , or a maximum number of iterations has
been reached. Minimization is converged when the maximum force is
smaller than . For shell MD this value should be 1.0 at most.

[ [ niter ]{.pre} ]{.sig-name .descname}

:   \(20\) maximum number of iterations for optimizing the shell
    positions and the flexible constraints.

```{=html}
<!-- -->
```

[ [ fcstep ]{.pre} ]{.sig-name .descname}

:   \(0\) \[ps ^2^ \] the step size for optimizing the flexible
    constraints. Should be chosen as mu/(d2V/dq2) where mu is the
    reduced mass of two particles in a flexible constraint and d2V/dq2
    is the second derivative of the potential in the constraint
    direction. Hopefully this number does not differ too much between
    the flexible constraints, as the number of iterations and thus the
    runtime is very sensitive to fcstep. Try several values!
:::

::: {#test-particle-insertion .section}
### Test particle insertion

[ [ rtpi ]{.pre} ]{.sig-name .descname}

:   (0.05) \[nm\] the test particle insertion radius, see integrators
    and
:::

::: {#output-control .section}
### Output control

[ [ nstxout ]{.pre} ]{.sig-name .descname}

:   \(0\) \[steps\] number of steps that elapse between writing
    coordinates to the output trajectory file ( ), the last coordinates
    are always written unless 0, which means coordinates are not written
    into the trajectory file.

```{=html}
<!-- -->
```

[ [ nstvout ]{.pre} ]{.sig-name .descname}

:   \(0\) \[steps\] number of steps that elapse between writing
    velocities to the output trajectory file ( ), the last velocities
    are always written unless 0, which means velocities are not written
    into the trajectory file.

```{=html}
<!-- -->
```

[ [ nstfout ]{.pre} ]{.sig-name .descname}

:   \(0\) \[steps\] number of steps that elapse between writing forces
    to the output trajectory file ( ), the last forces are always
    written, unless 0, which means forces are not written into the
    trajectory file.

```{=html}
<!-- -->
```

[ [ nstlog ]{.pre} ]{.sig-name .descname}

:   \(1000\) \[steps\] number of steps that elapse between writing
    energies to the log file, the last energies are always written.

```{=html}
<!-- -->
```

[ [ nstcalcenergy ]{.pre} ]{.sig-name .descname}

:   \(100\) number of steps that elapse between calculating the
    energies, 0 is never. This option is only relevant with dynamics.
    This option affects the performance in parallel simulations, because
    calculating energies requires global communication between all
    processes which can become a bottleneck at high parallelization.

```{=html}
<!-- -->
```

[ [ nstenergy ]{.pre} ]{.sig-name .descname}

:   \(1000\) \[steps\] number of steps that elapse between writing
    energies to energy file, the last energies are always written,
    should be a multiple of . Note that the exact sums and fluctuations
    over all MD steps modulo are stored in the energy file, so can
    report exact energy averages and fluctuations also when \> 1

```{=html}
<!-- -->
```

[ [ nstxout-compressed ]{.pre} ]{.sig-name .descname}

:   \(0\) \[steps\] number of steps that elapse between writing position
    coordinates using lossy compression ( file), 0 for not writing
    compressed coordinates output.

```{=html}
<!-- -->
```

[ [ compressed-x-precision ]{.pre} ]{.sig-name .descname}

:   \(1000\) \[real\] precision with which to write to the compressed
    trajectory file

```{=html}
<!-- -->
```

[ [ compressed-x-grps ]{.pre} ]{.sig-name .descname}

:   group(s) to write to the compressed trajectory file, by default the
    whole system is written (if \> 0)

```{=html}
<!-- -->
```

[ [ energygrps ]{.pre} ]{.sig-name .descname}

:   group(s) for which to write to write short-ranged non-bonded
    potential energies to the energy file (not supported on GPUs)
:::

::: {#neighbor-searching .section}
### Neighbor searching

[ [ cutoff-scheme ]{.pre} ]{.sig-name .descname}

:   

    [ [ Verlet ]{.pre} ]{.sig-name .descname}

    :   Generate a pair list with buffering. The buffer size is
        automatically set based on , unless this is set to -1, in which
        case will be used.

    [ [ group ]{.pre} ]{.sig-name .descname}

    :   Generate a pair list for groups of atoms, corresponding to the
        charge groups in the topology. This option is no longer
        supported.

```{=html}
<!-- -->
```

[ [ nstlist ]{.pre} ]{.sig-name .descname}

:   10. \[steps\]

    [ [ \>0 ]{.pre} ]{.sig-name .descname}

    :   Frequency to update the neighbor list. When dynamics and set, is
        actually a minimum value and might increase it, unless it is set
        to 1. With parallel simulations and/or non-bonded force
        calculation on the GPU, a value of 20 or 40 often gives the best
        performance. With energy minimization this parameter is not used
        as the pair list is updated when at least one atom has moved by
        more than half the pair list buffer size.

    [ [ 0 ]{.pre} ]{.sig-name .descname}

    :   The neighbor list is only constructed once and never updated.
        This is mainly useful for vacuum simulations in which all
        particles see each other. But vacuum simulations are
        (temporarily) not supported.

    [ [ \<0 ]{.pre} ]{.sig-name .descname}

    :   Unused.

```{=html}
<!-- -->
```

[ [ pbc ]{.pre} ]{.sig-name .descname}

:   

    [ [ xyz ]{.pre} ]{.sig-name .descname}

    :   Use periodic boundary conditions in all directions.

    [ [ no ]{.pre} ]{.sig-name .descname}

    :   Use no periodic boundary conditions, ignore the box. To simulate
        without cut-offs, set all cut-offs and to 0. For best
        performance without cut-offs on a single MPI rank, set to zero.

    [ [ xy ]{.pre} ]{.sig-name .descname}

    :   Use periodic boundary conditions in x and y directions only.
        This can be used in combination with . Without walls or with
        only one wall the system size is infinite in the z direction.
        Therefore pressure coupling or Ewald summation methods can not
        be used. These disadvantages do not apply when two walls are
        used.

```{=html}
<!-- -->
```

[ [ periodic-molecules ]{.pre} ]{.sig-name .descname}

:   

    [ [ no ]{.pre} ]{.sig-name .descname}

    :   molecules are finite, fast molecular PBC can be used

    [ [ yes ]{.pre} ]{.sig-name .descname}

    :   for systems with molecules that couple to themselves through the
        periodic boundary conditions, this requires a slower PBC
        algorithm and molecules are not made whole in the output

```{=html}
<!-- -->
```

[ [ verlet-buffer-tolerance ]{.pre} ]{.sig-name .descname}

:   (0.005) \[kJ mol ^-1^ ps ^-1^ \]

    Used when performing a simulation with dynamics. This sets the
    maximum allowed error for pair interactions per particle caused by
    the Verlet buffer, which indirectly sets . As both and the Verlet
    buffer size are fixed (for performance reasons), particle pairs not
    in the pair list can occasionally get within the cut-off distance
    during -1 steps. This causes very small jumps in the energy. In a
    constant-temperature ensemble, these very small energy jumps can be
    estimated for a given cut-off and . The estimate assumes a
    homogeneous particle distribution, hence the errors might be
    slightly underestimated for multi-phase systems. (See the for
    details). For longer pair-list life-time ( -1) \* the buffer is
    overestimated, because the interactions between particles are
    ignored. Combined with cancellation of errors, the actual drift of
    the total energy is usually one to two orders of magnitude smaller.
    Note that the generated buffer size takes into account that the
    GROMACS pair-list setup leads to a reduction in the drift by a
    factor 10, compared to a simple particle-pair based list. Without
    dynamics (energy minimization etc.), the buffer is 5% of the
    cut-off. For NVE simulations the initial temperature is used, unless
    this is zero, in which case a buffer of 10% is used. For NVE
    simulations the tolerance usually needs to be lowered to achieve
    proper energy conservation on the nanosecond time scale. To override
    the automated buffer setting, use =-1 and set manually.

```{=html}
<!-- -->
```

[ [ verlet-buffer-pressure-tolerance ]{.pre} ]{.sig-name .descname}

:   (0.5) \[bar\]

    Used when performing a simulation with dynamics and only active when
    is positive. This sets the maximum tolerated error in the average
    pressure due to missing Lennard-Jones interactions of particle pairs
    that are not in the pair list, but come within range as the pair
    list ages. As for the drift tolerance, the (over)estimate of the
    pressure error is tight at short times. At longer time it turns into
    a significant overestimate, because interactions limit the
    displacement of particles. Note that the default tolerance of 0.5
    bar corresponds to a maximum relative deviation of the density of
    liquid water of 2e-5.

```{=html}
<!-- -->
```

[ [ rlist ]{.pre} ]{.sig-name .descname}

:   \(1\) \[nm\] Cut-off distance for the short-range neighbor list.
    With dynamics, this is by default set by the and options and the
    value of is ignored. Without dynamics, this is by default set to the
    maximum cut-off plus 5% buffer, except for test particle insertion,
    where the buffer is managed exactly and automatically. For NVE
    simulations, where the automated setting is not possible, the
    advised procedure is to run with an NVT setup with the expected
    temperature and copy the resulting value of to the NVE setup.
:::

::: {#electrostatics .section}
### Electrostatics

[ [ coulombtype ]{.pre} ]{.sig-name .descname}

:   

    [ [ Cut-off ]{.pre} ]{.sig-name .descname}

    :   Plain cut-off with pair list radius and Coulomb cut-off , where
        \>= .

    [ [ Ewald ]{.pre} ]{.sig-name .descname}

    :   Classical Ewald sum electrostatics. The real-space cut-off
        should be equal to . Use *e.g.* =0.9, =0.9. The highest
        magnitude of wave vectors used in reciprocal space is controlled
        by . The relative accuracy of direct/reciprocal space is
        controlled by .

        NOTE: Ewald scales as O(N ^3/2^ ) and is thus extremely slow for
        large systems. It is included mainly for reference - in most
        cases PME will perform much better.

    [ [ PME ]{.pre} ]{.sig-name .descname}

    :   Fast smooth Particle-Mesh Ewald (SPME) electrostatics. Direct
        space is similar to the Ewald sum, while the reciprocal part is
        performed with FFTs. Grid dimensions are controlled with and the
        interpolation order with . With a grid spacing of 0.1 nm and
        cubic interpolation the electrostatic forces have an accuracy of
        2-3\*10 ^-4^ . Since the error from the vdw-cutoff is larger
        than this you might try 0.15 nm. When running in parallel the
        interpolation parallelizes better than the FFT, so try
        decreasing grid dimensions while increasing interpolation.

    [ [ P3M-AD ]{.pre} ]{.sig-name .descname}

    :   Particle-Particle Particle-Mesh algorithm with analytical
        derivative for for long range electrostatic interactions. The
        method and code is identical to SPME, except that the influence
        function is optimized for the grid. This gives a slight increase
        in accuracy.

    [ [ Reaction-Field ]{.pre} ]{.sig-name .descname}

    :   Reaction field electrostatics with Coulomb cut-off , where \>= .
        The dielectric constant beyond the cut-off is . The dielectric
        constant can be set to infinity by setting =0.

    [ [ User ]{.pre} ]{.sig-name .descname}

    :   Currently unsupported. will now expect to find a file
        ` `{.docutils .literal .notranslate}[` table.xvg `{.docutils
        .literal .notranslate}]{.pre}` `{.docutils .literal
        .notranslate} with user-defined potential functions for
        repulsion, dispersion and Coulomb. When pair interactions are
        present, also expects to find a file ` `{.docutils .literal
        .notranslate}[` tablep.xvg `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal .notranslate} for the
        pair interactions. When the same interactions should be used for
        non-bonded and pair interactions the user can specify the same
        file name for both table files. These files should contain 7
        columns: the ` `{.docutils .literal
        .notranslate}[` x `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal .notranslate} value,
        ` `{.docutils .literal .notranslate}[` f(x) `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal .notranslate} ,
        ` `{.docutils .literal .notranslate}[` -f'(x) `{.docutils
        .literal .notranslate}]{.pre}` `{.docutils .literal
        .notranslate} , ` `{.docutils .literal
        .notranslate}[` g(x) `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal .notranslate} ,
        ` `{.docutils .literal .notranslate}[` -g'(x) `{.docutils
        .literal .notranslate}]{.pre}` `{.docutils .literal
        .notranslate} , ` `{.docutils .literal
        .notranslate}[` h(x) `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal .notranslate} ,
        ` `{.docutils .literal .notranslate}[` -h'(x) `{.docutils
        .literal .notranslate}]{.pre}` `{.docutils .literal
        .notranslate} , where ` `{.docutils .literal
        .notranslate}[` f(x) `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal .notranslate} is the
        Coulomb function, ` `{.docutils .literal
        .notranslate}[` g(x) `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal .notranslate} the
        dispersion function and ` `{.docutils .literal
        .notranslate}[` h(x) `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal .notranslate} the
        repulsion function. When is not set to User the values for
        ` `{.docutils .literal .notranslate}[` g `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal .notranslate} ,
        ` `{.docutils .literal .notranslate}[` -g' `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal .notranslate} ,
        ` `{.docutils .literal .notranslate}[` h `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal .notranslate} and
        ` `{.docutils .literal .notranslate}[` -h' `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal .notranslate} are
        ignored. For the non-bonded interactions ` `{.docutils .literal
        .notranslate}[` x `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal .notranslate} values
        should run from 0 to the largest cut-off distance + and should
        be uniformly spaced. For the pair interactions the table length
        in the file will be used. The optimal spacing, which is used for
        non-user tables, is ` `{.docutils .literal
        .notranslate}[` 0.002 `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal
        .notranslate}[` nm `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal .notranslate} when
        you run in mixed precision or ` `{.docutils .literal
        .notranslate}[` 0.0005 `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal
        .notranslate}[` nm `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal .notranslate} when
        you run in double precision. The function value at ` `{.docutils
        .literal .notranslate}[` x=0 `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal .notranslate} is not
        important. More information is in the printed manual.

    [ [ PME-Switch ]{.pre} ]{.sig-name .descname}

    :   Currently unsupported. A combination of PME and a switch
        function for the direct-space part (see above). is allowed to be
        smaller than .

    [ [ PME-User ]{.pre} ]{.sig-name .descname}

    :   Currently unsupported. A combination of PME and user tables (see
        above). is allowed to be smaller than . The PME mesh
        contribution is subtracted from the user table by . Because of
        this subtraction the user tables should contain about 10 decimal
        places.

    [ [ PME-User-Switch ]{.pre} ]{.sig-name .descname}

    :   Currently unsupported. A combination of PME-User and a switching
        function (see above). The switching function is applied to final
        particle-particle interaction, *i.e.* both to the user supplied
        function and the PME Mesh correction part.

```{=html}
<!-- -->
```

[ [ coulomb-modifier ]{.pre} ]{.sig-name .descname}

:   

    [ [ Potential-shift ]{.pre} ]{.sig-name .descname}

    :   Shift the Coulomb potential by a constant such that it is zero
        at the cut-off. This makes the potential the integral of the
        force. Note that this does not affect the forces or the
        sampling.

    [ [ None ]{.pre} ]{.sig-name .descname}

    :   Use an unmodified Coulomb potential. This can be useful when
        comparing energies with those computed with other software.

```{=html}
<!-- -->
```

[ [ rcoulomb-switch ]{.pre} ]{.sig-name .descname}

:   \(0\) \[nm\] where to start switching the Coulomb potential, only
    relevant when force or potential switching is used

```{=html}
<!-- -->
```

[ [ rcoulomb ]{.pre} ]{.sig-name .descname}

:   \(1\) \[nm\] The distance for the Coulomb cut-off. Note that with
    PME this value can be increased by the PME tuning in along with the
    PME grid spacing.

```{=html}
<!-- -->
```

[ [ epsilon-r ]{.pre} ]{.sig-name .descname}

:   \(1\) The relative dielectric constant. A value of 0 means infinity.

```{=html}
<!-- -->
```

[ [ epsilon-rf ]{.pre} ]{.sig-name .descname}

:   \(0\) The relative dielectric constant of the reaction field. This
    is only used with reaction-field electrostatics. A value of 0 means
    infinity.
:::

::: {#van-der-waals .section}
### Van der Waals

[ [ vdwtype ]{.pre} ]{.sig-name .descname}

:   

    [ [ Cut-off ]{.pre} ]{.sig-name .descname}

    :   Plain cut-off with pair list radius and VdW cut-off , where \>=
        .

    [ [ PME ]{.pre} ]{.sig-name .descname}

    :   Fast smooth Particle-mesh Ewald (SPME) for VdW interactions. The
        grid dimensions are controlled with in the same way as for
        electrostatics, and the interpolation order is controlled with .
        The relative accuracy of direct/reciprocal space is controlled
        by , and the specific combination rules that are to be used by
        the reciprocal routine are set using .

    [ [ Shift ]{.pre} ]{.sig-name .descname}

    :   This functionality is deprecated and replaced by using with .
        The LJ (not Buckingham) potential is decreased over the whole
        range and the forces decay smoothly to zero between and .

    [ [ Switch ]{.pre} ]{.sig-name .descname}

    :   This functionality is deprecated and replaced by using with .
        The LJ (not Buckingham) potential is normal out to , after which
        it is switched off to reach zero at . Both the potential and
        force functions are continuously smooth, but be aware that all
        switch functions will give rise to a bulge (increase) in the
        force (since we are switching the potential).

    [ [ User ]{.pre} ]{.sig-name .descname}

    :   Currently unsupported. See user for . The function value at zero
        is not important. When you want to use LJ correction, make sure
        that corresponds to the cut-off in the user-defined function.
        When is not set to User the values for the ` `{.docutils
        .literal .notranslate}[` f `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal .notranslate} and
        ` `{.docutils .literal .notranslate}[` -f' `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal .notranslate} columns
        are ignored.

```{=html}
<!-- -->
```

[ [ vdw-modifier ]{.pre} ]{.sig-name .descname}

:   

    [ [ Potential-shift ]{.pre} ]{.sig-name .descname}

    :   Shift the Van der Waals potential by a constant such that it is
        zero at the cut-off. This makes the potential the integral of
        the force. Note that this does not affect the forces or the
        sampling.

    [ [ None ]{.pre} ]{.sig-name .descname}

    :   Use an unmodified Van der Waals potential. This can be useful
        when comparing energies with those computed with other software.

    [ [ Force-switch ]{.pre} ]{.sig-name .descname}

    :   Smoothly switches the forces to zero between and . This shifts
        the potential shift over the whole range and switches it to zero
        at the cut-off. Note that this is more expensive to calculate
        than a plain cut-off and it is not required for energy
        conservation, since Potential-shift conserves energy just as
        well.

    [ [ Potential-switch ]{.pre} ]{.sig-name .descname}

    :   Smoothly switches the potential to zero between and . Note that
        this introduces articifically large forces in the switching
        region and is much more expensive to calculate. This option
        should only be used if the force field you are using requires
        this.

```{=html}
<!-- -->
```

[ [ rvdw-switch ]{.pre} ]{.sig-name .descname}

:   \(0\) \[nm\] where to start switching the LJ force and possibly the
    potential, only relevant when force or potential switching is used

```{=html}
<!-- -->
```

[ [ rvdw ]{.pre} ]{.sig-name .descname}

:   \(1\) \[nm\] distance for the LJ or Buckingham cut-off

```{=html}
<!-- -->
```

[ [ DispCorr ]{.pre} ]{.sig-name .descname}

:   

    [ [ no ]{.pre} ]{.sig-name .descname}

    :   donâ€™t apply any correction

    [ [ EnerPres ]{.pre} ]{.sig-name .descname}

    :   apply long range dispersion corrections for Energy and Pressure

    [ [ Ener ]{.pre} ]{.sig-name .descname}

    :   apply long range dispersion corrections for Energy only
:::

::: {#tables .section}
### Tables

[ [ table-extension ]{.pre} ]{.sig-name .descname}

:   \(1\) \[nm\] Extension of the non-bonded potential lookup tables
    beyond the largest cut-off distance. With actual non-bonded
    interactions the tables are never accessed beyond the cut-off. But a
    longer table length might be needed for the 1-4 interactions, which
    are always tabulated irrespective of the use of tables for the
    non-bonded interactions.

```{=html}
<!-- -->
```

[ [ energygrp-table ]{.pre} ]{.sig-name .descname}

:   Currently unsupported. When user tables are used for electrostatics
    and/or VdW, here one can give pairs of energy groups for which
    separate user tables should be used. The two energy groups will be
    appended to the table file name, in order of their definition in ,
    separated by underscores. For example, if ` `{.docutils .literal
    .notranslate}[` energygrps `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` = `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` Na `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` Cl `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` Sol `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} and
    ` `{.docutils .literal .notranslate}[` energygrp-table `{.docutils
    .literal .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` = `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` Na `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` Na `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` Na `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` Cl `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} , will read
    ` `{.docutils .literal .notranslate}[` table_Na_Na.xvg `{.docutils
    .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}
    and ` `{.docutils .literal
    .notranslate}[` table_Na_Cl.xvg `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} in addition
    to the normal ` `{.docutils .literal
    .notranslate}[` table.xvg `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} which will
    be used for all other energy group pairs.
:::

::: {#ewald .section}
### Ewald

[ [ fourierspacing ]{.pre} ]{.sig-name .descname}

:   (0.12) \[nm\] For ordinary Ewald, the ratio of the box dimensions
    and the spacing determines a lower bound for the number of wave
    vectors to use in each (signed) direction. For PME and P3M, that
    ratio determines a lower bound for the number of Fourier-space grid
    points that will be used along that axis. In all cases, the number
    for each direction can be overridden by entering a non-zero value
    for that direction. For optimizing the relative load of the
    particle-particle interactions and the mesh part of PME, it is
    useful to know that the accuracy of the electrostatics remains
    nearly constant when the Coulomb cut-off and the PME grid spacing
    are scaled by the same factor. Note that this spacing can be scaled
    up along with by the PME tuning in .

```{=html}
<!-- -->
```

[ [ fourier-nx ]{.pre} ]{.sig-name .descname}

:   

```{=html}
<!-- -->
```

[ [ fourier-ny ]{.pre} ]{.sig-name .descname}

:   

```{=html}
<!-- -->
```

[ [ fourier-nz ]{.pre} ]{.sig-name .descname}

:   \(0\) Highest magnitude of wave vectors in reciprocal space when
    using Ewald. Grid size when using PME or P3M. These values override
    per direction. The best choice is powers of 2, 3, 5 and 7. Avoid
    large primes. Note that these grid sizes can be reduced along with
    scaling up by the PME tuning in .

```{=html}
<!-- -->
```

[ [ pme-order ]{.pre} ]{.sig-name .descname}

:   \(4\) The number of grid points along a dimension to which a charge
    is mapped. The actual order of the PME interpolation is one less,
    e.g. the default of 4 gives cubic interpolation. Supported values
    are 3 to 12 (max 8 for P3M-AD). When running in parallel, it can be
    worth to switch to 5 and simultaneously increase the grid spacing.
    Note that on the CPU only values 4 and 5 have SIMD acceleration and
    GPUs only support the value 4.

```{=html}
<!-- -->
```

[ [ ewald-rtol ]{.pre} ]{.sig-name .descname}

:   (10 ^-5^ ) The relative strength of the Ewald-shifted direct
    potential at is given by . Decreasing this will give a more accurate
    direct sum, but then you need more wave vectors for the reciprocal
    sum.

```{=html}
<!-- -->
```

[ [ ewald-rtol-lj ]{.pre} ]{.sig-name .descname}

:   (10 ^-3^ ) When doing PME for VdW-interactions, is used to control
    the relative strength of the dispersion potential at in the same way
    as controls the electrostatic potential.

```{=html}
<!-- -->
```

[ [ lj-pme-comb-rule ]{.pre} ]{.sig-name .descname}

:   (Geometric) The combination rules used to combine VdW-parameters in
    the reciprocal part of LJ-PME. Geometric rules are much faster than
    Lorentz-Berthelot and usually the recommended choice, even when the
    rest of the force field uses the Lorentz-Berthelot rules.

    [ [ Geometric ]{.pre} ]{.sig-name .descname}

    :   Apply geometric combination rules

    [ [ Lorentz-Berthelot ]{.pre} ]{.sig-name .descname}

    :   Apply Lorentz-Berthelot combination rules

```{=html}
<!-- -->
```

[ [ ewald-geometry ]{.pre} ]{.sig-name .descname}

:   

    [ [ 3d ]{.pre} ]{.sig-name .descname}

    :   The Ewald sum is performed in all three dimensions.

    [ [ 3dc ]{.pre} ]{.sig-name .descname}

    :   The reciprocal sum is still performed in 3D, but a force and
        potential correction applied in the ` `{.docutils .literal
        .notranslate}[` z `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal .notranslate}
        dimension to produce a pseudo-2D summation. If your system has a
        slab geometry in the ` `{.docutils .literal
        .notranslate}[` x-y `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal .notranslate} plane
        you can try to increase the ` `{.docutils .literal
        .notranslate}[` z `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal .notranslate}
        -dimension of the box (a box height of 3 times the slab height
        is usually ok) and use this option.

```{=html}
<!-- -->
```

[ [ epsilon-surface ]{.pre} ]{.sig-name .descname}

:   \(0\) This controls the dipole correction to the Ewald summation in
    3D. The default value of zero means it is turned off. Turn it on by
    setting it to the value of the relative permittivity of the
    imaginary surface around your infinite system. Be careful - you
    shouldnâ€™t use this if you have free mobile charges in your system.
    This value does not affect the slab 3DC variant of the long range
    corrections.
:::

::: {#temperature-coupling .section}
### Temperature coupling

[ [ ensemble-temperature-setting ]{.pre} ]{.sig-name .descname}

:   

    [ [ auto ]{.pre} ]{.sig-name .descname}

    :   With this setting will determine which of the next three
        settings is available and choose the appropriate one. When all
        atoms are coupled to a temperature bath with the same
        temperature, a constant ensemble temperature is chosen and the
        value is taken from the temperature bath.

    [ [ constant ]{.pre} ]{.sig-name .descname}

    :   The system has a constant ensemble temperature given by . A
        constant ensemble temperature is required for certain sampling
        algorithms such as AWH.

    [ [ variable ]{.pre} ]{.sig-name .descname}

    :   The system has a variable ensemble temperature due to simulated
        annealing or simulated tempering. The system ensemble
        temperature is set dynamically during the simulation.

    [ [ not-available ]{.pre} ]{.sig-name .descname}

    :   The system has no ensemble temperature.

```{=html}
<!-- -->
```

[ [ ensemble-temperature ]{.pre} ]{.sig-name .descname}

:   (-1) \[K\]

    The ensemble temperature for the system. The input value is only
    used with ` `{.xref .std .std-mdp .docutils .literal
    .notranslate}[` ensemble-temperature-setting=constant `{.xref .std
    .std-mdp .docutils .literal .notranslate}]{.pre}` `{.xref .std
    .std-mdp .docutils .literal .notranslate} . By default the ensemble
    temperature is copied from the temperature of the thermal bath (when
    used).

```{=html}
<!-- -->
```

[ [ tcoupl ]{.pre} ]{.sig-name .descname}

:   

    [ [ no ]{.pre} ]{.sig-name .descname}

    :   No temperature coupling.

    [ [ berendsen ]{.pre} ]{.sig-name .descname}

    :   Temperature coupling with a Berendsen thermostat to a bath with
        temperature , with time constant . Several groups can be coupled
        separately, these are specified in the field separated by
        spaces. This is a historical thermostat needed to be able to
        reproduce previous simulations, but we strongly recommend not to
        use it for new production runs. Consult the manual for details.

    [ [ nose-hoover ]{.pre} ]{.sig-name .descname}

    :   Temperature coupling using a Nose-Hoover extended ensemble. The
        reference temperature and coupling groups are selected as above,
        but in this case controls the period of the temperature
        fluctuations at equilibrium, which is slightly different from a
        relaxation time. For NVT simulations the conserved energy
        quantity is written to the energy and log files.

    [ [ andersen ]{.pre} ]{.sig-name .descname}

    :   Temperature coupling by randomizing a fraction of the particle
        velocities at each timestep. Reference temperature and coupling
        groups are selected as above. is the average time between
        randomization of each molecule. Inhibits particle dynamics
        somewhat, but little or no ergodicity issues. Currently only
        implemented with velocity Verlet, and not implemented with
        constraints.

    [ [ andersen-massive ]{.pre} ]{.sig-name .descname}

    :   Temperature coupling by randomizing velocities of all particles
        at infrequent timesteps. Reference temperature and coupling
        groups are selected as above. is the time between randomization
        of all molecules. Inhibits particle dynamics somewhat, but
        little or no ergodicity issues. Currently only implemented with
        velocity Verlet.

    [ [ v-rescale ]{.pre} ]{.sig-name .descname}

    :   Temperature coupling using velocity rescaling with a stochastic
        term (JCP 126, 014101). This thermostat is similar to Berendsen
        coupling, with the same scaling using , but the stochastic term
        ensures that a proper canonical ensemble is generated. The
        random seed is set with . This thermostat works correctly even
        for =0. For NVT simulations the conserved energy quantity is
        written to the energy and log file.

```{=html}
<!-- -->
```

[ [ nsttcouple ]{.pre} ]{.sig-name .descname}

:   (-1) The frequency for coupling the temperature. The default value
    of -1 sets equal to 100, or fewer steps if required for accurate
    integration (5 steps per tau for first order coupling, 20 steps per
    tau for second order coupling). Note that the default value is large
    in order to reduce the overhead of the additional computation and
    communication required for obtaining the kinetic energy. For
    velocity Verlet integrators is set to 1.

```{=html}
<!-- -->
```

[ [ nh-chain-length ]{.pre} ]{.sig-name .descname}

:   \(10\) The number of chained Nose-Hoover thermostats for velocity
    Verlet integrators, the leap-frog integrator only supports 1. Data
    for the NH chain variables is not printed to the file by default,
    but can be turned on with the option.

```{=html}
<!-- -->
```

[ [ print-nose-hoover-chain-variables ]{.pre} ]{.sig-name .descname}

:   

    [ [ no ]{.pre} ]{.sig-name .descname}

    :   Do not store Nose-Hoover chain variables in the energy file.

    [ [ yes ]{.pre} ]{.sig-name .descname}

    :   Store all positions and velocities of the Nose-Hoover chain in
        the energy file.

```{=html}
<!-- -->
```

[ [ tc-grps ]{.pre} ]{.sig-name .descname}

:   groups to couple to separate temperature baths

```{=html}
<!-- -->
```

[ [ tau-t ]{.pre} ]{.sig-name .descname}

:   \[ps\] time constant for coupling (one for each group in ), -1 means
    no temperature coupling

```{=html}
<!-- -->
```

[ [ ref-t ]{.pre} ]{.sig-name .descname}

:   \[K\] reference temperature for coupling (one for each group in )
:::

::: {#pressure-coupling .section}
### Pressure coupling

[ [ pcoupl ]{.pre} ]{.sig-name .descname}

:   

    [ [ no ]{.pre} ]{.sig-name .descname}

    :   No pressure coupling. This means a fixed box size.

    [ [ Berendsen ]{.pre} ]{.sig-name .descname}

    :   Exponential relaxation pressure coupling with time constant .
        The box is scaled every steps. This barostat does not yield a
        correct thermodynamic ensemble; it is only included to be able
        to reproduce previous runs, and we strongly recommend against
        using it for new simulations. See the manual for details.

    [ [ C-rescale ]{.pre} ]{.sig-name .descname}

    :   Exponential relaxation pressure coupling with time constant ,
        including a stochastic term to enforce correct volume
        fluctuations. The box is scaled every steps. It can be used for
        both equilibration and production.

    [ [ Parrinello-Rahman ]{.pre} ]{.sig-name .descname}

    :   Extended-ensemble pressure coupling where the box vectors are
        subject to an equation of motion. The equation of motion for the
        atoms is coupled to this. No instantaneous scaling takes place.
        As for Nose-Hoover temperature coupling the time constant is the
        period of pressure fluctuations at equilibrium. This is a good
        method when you want to apply pressure scaling during data
        collection, but beware that you can get very large oscillations
        if you are starting from a different pressure. For simulations
        where the exact fluctations of the NPT ensemble are important,
        or if the pressure coupling time is very short it may not be
        appropriate, as the previous time step pressure is used in some
        steps of the GROMACS implementation for the current time step
        pressure.

    [ [ MTTK ]{.pre} ]{.sig-name .descname}

    :   Martyna-Tuckerman-Tobias-Klein implementation, only useable with
        or , very similar to Parrinello-Rahman. As for Nose-Hoover
        temperature coupling the time constant is the period of pressure
        fluctuations at equilibrium. This is probably a better method
        when you want to apply pressure scaling during data collection,
        but beware that you can get very large oscillations if you are
        starting from a different pressure. This requires a constant
        ensemble temperature for the system. Currently it only supports
        isotropic scaling, and only works without constraints.

```{=html}
<!-- -->
```

[ [ pcoupltype ]{.pre} ]{.sig-name .descname}

:   Specifies the kind of isotropy of the pressure coupling used. Each
    kind takes one or more values for and . Only a single value is
    permitted for .

    [ [ isotropic ]{.pre} ]{.sig-name .descname}

    :   Isotropic pressure coupling with time constant . One value each
        for and is required.

    [ [ semiisotropic ]{.pre} ]{.sig-name .descname}

    :   Pressure coupling which is isotropic in the ` `{.docutils
        .literal .notranslate}[` x `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal .notranslate} and
        ` `{.docutils .literal .notranslate}[` y `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal .notranslate}
        direction, but different in the ` `{.docutils .literal
        .notranslate}[` z `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal .notranslate}
        direction. This can be useful for membrane simulations. Two
        values each for and are required, for ` `{.docutils .literal
        .notranslate}[` x/y `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal .notranslate} and
        ` `{.docutils .literal .notranslate}[` z `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal .notranslate}
        directions respectively.

    [ [ anisotropic ]{.pre} ]{.sig-name .descname}

    :   Same as before, but 6 values are needed for ` `{.docutils
        .literal .notranslate}[` xx `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal .notranslate} ,
        ` `{.docutils .literal .notranslate}[` yy `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal .notranslate} ,
        ` `{.docutils .literal .notranslate}[` zz `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal .notranslate} ,
        ` `{.docutils .literal .notranslate}[` xy/yx `{.docutils
        .literal .notranslate}]{.pre}` `{.docutils .literal
        .notranslate} , ` `{.docutils .literal
        .notranslate}[` xz/zx `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal .notranslate} and
        ` `{.docutils .literal .notranslate}[` yz/zy `{.docutils
        .literal .notranslate}]{.pre}` `{.docutils .literal
        .notranslate} components, respectively. When the off-diagonal
        compressibilities are set to zero, a rectangular box will stay
        rectangular. Beware that anisotropic scaling can lead to extreme
        deformation of the simulation box.

    [ [ surface-tension ]{.pre} ]{.sig-name .descname}

    :   Surface tension coupling for surfaces parallel to the xy-plane.
        Uses normal pressure coupling for the ` `{.docutils .literal
        .notranslate}[` z `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal .notranslate}
        -direction, while the surface tension is coupled to the
        ` `{.docutils .literal .notranslate}[` x/y `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal .notranslate}
        dimensions of the box. The first value is the reference surface
        tension times the number of surfaces ` `{.docutils .literal
        .notranslate}[` bar `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal
        .notranslate}[` nm `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal .notranslate} , the
        second value is the reference ` `{.docutils .literal
        .notranslate}[` z `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal .notranslate}
        -pressure ` `{.docutils .literal .notranslate}[` bar `{.docutils
        .literal .notranslate}]{.pre}` `{.docutils .literal
        .notranslate} . The two values are the compressibility in the
        ` `{.docutils .literal .notranslate}[` x/y `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal .notranslate} and
        ` `{.docutils .literal .notranslate}[` z `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal .notranslate}
        direction respectively. The value for the ` `{.docutils .literal
        .notranslate}[` z `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal .notranslate}
        -compressibility should be reasonably accurate since it
        influences the convergence of the surface-tension, it can also
        be set to zero to have a box with constant height.

```{=html}
<!-- -->
```

[ [ nstpcouple ]{.pre} ]{.sig-name .descname}

:   (-1) The frequency for coupling the pressure. The default value of
    -1 sets equal to 100, or fewer steps if required for accurate
    integration (5 steps per tau for first order coupling, 20 steps per
    tau for second order coupling). Note that the default value is large
    in order to reduce the overhead of the additional computation and
    communication required for obtaining the virial and kinetic energy.
    For velocity Verlet integrators is set to 1.

```{=html}
<!-- -->
```

[ [ tau-p ]{.pre} ]{.sig-name .descname}

:   \(5\) \[ps\] The time constant for pressure coupling (one value for
    all directions).

```{=html}
<!-- -->
```

[ [ compressibility ]{.pre} ]{.sig-name .descname}

:   \[bar ^-1^ \] The compressibility (NOTE: this is now really in bar
    ^-1^ ) For water at 1 atm and 300 K the compressibility is 4.5e-5
    bar ^-1^ . The number of required values is implied by .

```{=html}
<!-- -->
```

[ [ ref-p ]{.pre} ]{.sig-name .descname}

:   \[bar\] The reference pressure for coupling. The number of required
    values is implied by .

```{=html}
<!-- -->
```

[ [ refcoord-scaling ]{.pre} ]{.sig-name .descname}

:   

    [ [ no ]{.pre} ]{.sig-name .descname}

    :   The reference coordinates for position restraints are not
        modified. Note that with this option the virial and pressure
        might be ill defined, see for more details.

    [ [ all ]{.pre} ]{.sig-name .descname}

    :   The reference coordinates are scaled with the scaling matrix of
        the pressure coupling.

    [ [ com ]{.pre} ]{.sig-name .descname}

    :   Scale the center of mass of the reference coordinates with the
        scaling matrix of the pressure coupling. The vectors of each
        reference coordinate to the center of mass are not scaled. Only
        one COM is used, even when there are multiple molecules with
        position restraints. For calculating the COM of the reference
        coordinates in the starting configuration, periodic boundary
        conditions are not taken into account. Note that with this
        option the virial and pressure might be ill defined, see for
        more details.
:::

::: {#simulated-annealing .section}
### Simulated annealing

Simulated annealing is controlled separately for each temperature group
in GROMACS. The reference temperature is a piecewise linear function,
but you can use an arbitrary number of points for each group, and choose
either a single sequence or a periodic behaviour for each group. The
actual annealing is performed by dynamically changing the reference
temperature used in the thermostat algorithm selected, so remember that
the system will usually not instantaneously reach the reference
temperature!

[ [ annealing ]{.pre} ]{.sig-name .descname}

:   Type of annealing for each temperature group

    [ [ no ]{.pre} ]{.sig-name .descname}

    :   No simulated annealing - just couple to reference temperature
        value.

    [ [ single ]{.pre} ]{.sig-name .descname}

    :   A single sequence of annealing points. If your simulation is
        longer than the time of the last point, the temperature will be
        coupled to this constant value after the annealing sequence has
        reached the last time point.

    [ [ periodic ]{.pre} ]{.sig-name .descname}

    :   The annealing will start over at the first reference point once
        the last reference time is reached. This is repeated until the
        simulation ends.

```{=html}
<!-- -->
```

[ [ annealing-npoints ]{.pre} ]{.sig-name .descname}

:   A list with the number of annealing reference/control points used
    for each temperature group. Use 0 for groups that are not annealed.
    The number of entries should equal the number of temperature groups.

```{=html}
<!-- -->
```

[ [ annealing-time ]{.pre} ]{.sig-name .descname}

:   List of times at the annealing reference/control points for each
    group. If you are using periodic annealing, the times will be used
    modulo the last value, *i.e.* if the values are 0, 5, 10, and 15,
    the coupling will restart at the 0ps value after 15ps, 30ps, 45ps,
    etc. The number of entries should equal the sum of the numbers given
    in .

```{=html}
<!-- -->
```

[ [ annealing-temp ]{.pre} ]{.sig-name .descname}

:   List of temperatures at the annealing reference/control points for
    each group. The number of entries should equal the sum of the
    numbers given in .

Confused? OK, letâ€™s use an example. Assume you have two temperature
groups, set the group selections to ` `{.docutils .literal
.notranslate}[` annealing `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate}[` = `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` single `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` periodic `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , the number of
points of each group to ` `{.docutils .literal
.notranslate}[` annealing-npoints `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate}[` = `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` 3 `{.docutils .literal .notranslate}]{.pre}` `{.docutils
.literal .notranslate}[` 4 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , the times to
` `{.docutils .literal .notranslate}[` annealing-time `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` = `{.docutils .literal .notranslate}]{.pre}` `{.docutils
.literal .notranslate}[` 0 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate}[` 3 `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` 6 `{.docutils .literal .notranslate}]{.pre}` `{.docutils
.literal .notranslate}[` 0 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate}[` 2 `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` 4 `{.docutils .literal .notranslate}]{.pre}` `{.docutils
.literal .notranslate}[` 6 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and finally
temperatures to ` `{.docutils .literal
.notranslate}[` annealing-temp `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate}[` = `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` 298 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` 280 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` 270 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` 298 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` 320 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` 320 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` 298 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . The first
group will be coupled to 298K at 0ps, but the reference temperature will
drop linearly to reach 280K at 3ps, and then linearly between 280K and
270K from 3ps to 6ps. After this is stays constant, at 270K. The second
group is coupled to 298K at 0ps, it increases linearly to 320K at 2ps,
where it stays constant until 4ps. Between 4ps and 6ps it decreases to
298K, and then it starts over with the same pattern again, *i.e.* rising
linearly from 298K to 320K between 6ps and 8ps. Check the summary
printed by if you are unsure!
:::

::: {#velocity-generation .section}
### Velocity generation

[ [ gen-vel ]{.pre} ]{.sig-name .descname}

:   

    [ [ no ]{.pre} ]{.sig-name .descname}

    :   Do not generate velocities. The velocities are set to zero when
        there are no velocities in the input structure file.

    [ [ yes ]{.pre} ]{.sig-name .descname}

    :   Generate velocities in according to a Maxwell distribution at
        temperature , with random seed . This is only meaningful with .

```{=html}
<!-- -->
```

[ [ gen-temp ]{.pre} ]{.sig-name .descname}

:   \(300\) \[K\] temperature for Maxwell distribution

```{=html}
<!-- -->
```

[ [ gen-seed ]{.pre} ]{.sig-name .descname}

:   (-1) \[integer\] used to initialize random generator for random
    velocities, when is set to -1, a pseudo random seed is used.
:::

::: {#bonds .section}
### Bonds

[ [ constraints ]{.pre} ]{.sig-name .descname}

:   Controls which bonds in the topology will be converted to rigid
    holonomic constraints. Note that typical rigid water models do not
    have bonds, but rather a specialized ` `{.docutils .literal
    .notranslate}[` [settles] `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} directive,
    so are not affected by this keyword.

    [ [ none ]{.pre} ]{.sig-name .descname}

    :   No bonds converted to constraints.

    [ [ h-bonds ]{.pre} ]{.sig-name .descname}

    :   Convert the bonds with H-atoms to constraints.

    [ [ all-bonds ]{.pre} ]{.sig-name .descname}

    :   Convert all bonds to constraints.

    [ [ h-angles ]{.pre} ]{.sig-name .descname}

    :   Convert all bonds to constraints and convert the angles that
        involve H-atoms to bond-constraints.

    [ [ all-angles ]{.pre} ]{.sig-name .descname}

    :   Convert all bonds to constraints and all angles to
        bond-constraints.

```{=html}
<!-- -->
```

[ [ constraint-algorithm ]{.pre} ]{.sig-name .descname}

:   Chooses which solver satisfies any non-SETTLE holonomic constraints.

    [ [ LINCS ]{.pre} ]{.sig-name .descname}

    :   LINear Constraint Solver. With domain decomposition the parallel
        version P-LINCS is used. The accuracy in set with , which sets
        the number of matrices in the expansion for the matrix
        inversion. After the matrix inversion correction the algorithm
        does an iterative correction to compensate for lengthening due
        to rotation. The number of such iterations can be controlled
        with . The root mean square relative constraint deviation is
        printed to the log file every steps. If a bond rotates more than
        in one step, a warning will be printed both to the log file and
        to ` `{.docutils .literal .notranslate}[` stderr `{.docutils
        .literal .notranslate}]{.pre}` `{.docutils .literal
        .notranslate} . LINCS should not be used with coupled angle
        constraints.

    [ [ SHAKE ]{.pre} ]{.sig-name .descname}

    :   SHAKE is slightly slower and less stable than LINCS, but does
        work with angle constraints. The relative tolerance is set with
        , 0.0001 is a good value for â€œnormalâ€? MD. SHAKE does not
        support constraints between atoms on different decomposition
        domains, so it can only be used with domain decomposition when
        so-called update-groups are used, which is usally the case when
        only bonds involving hydrogens are constrained. SHAKE can not be
        used with energy minimization.

```{=html}
<!-- -->
```

[ [ continuation ]{.pre} ]{.sig-name .descname}

:   This option was formerly known as ` `{.docutils .literal
    .notranslate}[` unconstrained-start `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} .

    [ [ no ]{.pre} ]{.sig-name .descname}

    :   apply constraints to the start configuration and reset shells

    [ [ yes ]{.pre} ]{.sig-name .descname}

    :   do not apply constraints to the start configuration and do not
        reset shells, useful for exact coninuation and reruns

```{=html}
<!-- -->
```

[ [ shake-tol ]{.pre} ]{.sig-name .descname}

:   (0.0001) relative tolerance for SHAKE

```{=html}
<!-- -->
```

[ [ lincs-order ]{.pre} ]{.sig-name .descname}

:   \(4\) Highest order in the expansion of the constraint coupling
    matrix. When constraints form triangles, an additional expansion of
    the same order is applied on top of the normal expansion only for
    the couplings within such triangles. For â€œnormalâ€? MD simulations
    an order of 4 usually suffices, 6 is needed for large time-steps
    with virtual sites or BD. For accurate energy minimization in double
    precision an order of 8 or more might be required. Note that in
    single precision an order higher than 6 will often lead to worse
    accuracy due to amplification of rounding errors. With domain
    decomposition, the cell size is limited by the distance spanned by
    +1 constraints. When one wants to scale further than this limit, one
    can decrease and increase , since the accuracy does not deteriorate
    when (1+ )\* remains constant.

```{=html}
<!-- -->
```

[ [ lincs-iter ]{.pre} ]{.sig-name .descname}

:   \(1\) Number of iterations to correct for rotational lengthening in
    LINCS. For normal runs a single step is sufficient, but for NVE runs
    where you want to conserve energy accurately or for accurate energy
    minimization in double precision you might want to increase it to 2.
    Note that in single precision using more than 1 iteration will often
    lead to worse accuracy due to amplification of rounding errors.

```{=html}
<!-- -->
```

[ [ lincs-warnangle ]{.pre} ]{.sig-name .descname}

:   \(30\) \[deg\] maximum angle that a bond can rotate before LINCS
    will complain

```{=html}
<!-- -->
```

[ [ morse ]{.pre} ]{.sig-name .descname}

:   

    [ [ no ]{.pre} ]{.sig-name .descname}

    :   bonds are represented by a harmonic potential

    [ [ yes ]{.pre} ]{.sig-name .descname}

    :   bonds are represented by a Morse potential
:::

::: {#energy-group-exclusions .section}
### Energy group exclusions

[ [ energygrp-excl ]{.pre} ]{.sig-name .descname}

:   Pairs of energy groups for which all non-bonded interactions are
    excluded. An example: if you have two energy groups ` `{.docutils
    .literal .notranslate}[` Protein `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} and
    ` `{.docutils .literal .notranslate}[` SOL `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} ,
    specifying ` `{.docutils .literal
    .notranslate}[` energygrp-excl `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` = `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` Protein `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` Protein `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` SOL `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` SOL `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} would give
    only the non-bonded interactions between the protein and the
    solvent. This is especially useful for speeding up energy
    calculations with ` `{.docutils .literal
    .notranslate}[` mdrun `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` -rerun `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} and for
    excluding interactions within frozen groups.
:::

::: {#walls .section}
### Walls

[ [ nwall ]{.pre} ]{.sig-name .descname}

:   \(0\) When set to 1 there is a wall at ` `{.docutils .literal
    .notranslate}[` z=0 `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} , when set
    to 2 there is also a wall at ` `{.docutils .literal
    .notranslate}[` z=z-box `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} . Walls can
    only be used with ` `{.docutils .literal
    .notranslate}[` =xy `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} . When set
    to 2, pressure coupling and Ewald summation can be used (it is
    usually best to use semiisotropic pressure coupling with the
    ` `{.docutils .literal .notranslate}[` x/y `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate}
    compressibility set to 0, as otherwise the surface area will
    change). Walls interact wit the rest of the system through an
    optional . Energy groups ` `{.docutils .literal
    .notranslate}[` wall0 `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} and
    ` `{.docutils .literal .notranslate}[` wall1 `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} (for =2)
    are added automatically to monitor the interaction of energy groups
    with each wall. The center of mass motion removal will be turned off
    in the ` `{.docutils .literal .notranslate}[` z `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} -direction.

```{=html}
<!-- -->
```

[ [ wall-atomtype ]{.pre} ]{.sig-name .descname}

:   the atom type name in the force field for each wall. By (for
    example) defining a special wall atom type in the topology with its
    own combination rules, this allows for independent tuning of the
    interaction of each atomtype with the walls.

```{=html}
<!-- -->
```

[ [ wall-type ]{.pre} ]{.sig-name .descname}

:   

    [ [ 9-3 ]{.pre} ]{.sig-name .descname}

    :   LJ integrated over the volume behind the wall: 9-3 potential

    [ [ 10-4 ]{.pre} ]{.sig-name .descname}

    :   LJ integrated over the wall surface: 10-4 potential

    [ [ 12-6 ]{.pre} ]{.sig-name .descname}

    :   direct LJ potential with the ` `{.docutils .literal
        .notranslate}[` z `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal .notranslate}
        distance from the wall

```{=html}
<!-- -->
```

[ [ table ]{.pre} ]{.sig-name .descname}

:   user defined potentials indexed with the ` `{.docutils .literal
    .notranslate}[` z `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} distance
    from the wall, the tables are read analogously to the option, where
    the first name is for a â€œnormalâ€? energy group and the second
    name is ` `{.docutils .literal .notranslate}[` wall0 `{.docutils
    .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} or
    ` `{.docutils .literal .notranslate}[` wall1 `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} , only the
    dispersion and repulsion columns are used

```{=html}
<!-- -->
```

[ [ wall-r-linpot ]{.pre} ]{.sig-name .descname}

:   (-1) \[nm\] Below this distance from the wall the potential is
    continued linearly and thus the force is constant. Setting this
    option to a postive value is especially useful for equilibration
    when some atoms are beyond a wall. When the value is \<=0 (\<0 for
    =table), a fatal error is generated when atoms are beyond a wall.

```{=html}
<!-- -->
```

[ [ wall-density ]{.pre} ]{.sig-name .descname}

:   \[nm ^-3^ \] / \[nm ^-2^ \] the number density of the atoms for each
    wall for wall types 9-3 and 10-4

```{=html}
<!-- -->
```

[ [ wall-ewald-zfac ]{.pre} ]{.sig-name .descname}

:   \(3\) The scaling factor for the third box vector for Ewald
    summation only, the minimum is 2. Ewald summation can only be used
    with =2, where one should use ` `{.docutils .literal
    .notranslate}[` =3dc `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} . The empty
    layer in the box serves to decrease the unphysical Coulomb
    interaction between periodic images.
:::

::: {#com-pulling .section}
### COM pulling

Sets whether pulling on collective variables is active. Note that where
pulling coordinates are applicable, there can be more than one (set with
) and multiple related variables will exist accordingly. Documentation
references to things like should be understood to apply to to the
applicable pulling coordinate, eg. the second pull coordinate is
described by pull-coord2-vec, pull-coord2-k, and so on.

[ [ pull ]{.pre} ]{.sig-name .descname}

:   

    [ [ no ]{.pre} ]{.sig-name .descname}

    :   No center of mass pulling. All the following pull options will
        be ignored (and if present in the file, they unfortunately
        generate warnings)

    [ [ yes ]{.pre} ]{.sig-name .descname}

    :   Center of mass pulling will be applied on 1 or more groups using
        1 or more pull coordinates.

```{=html}
<!-- -->
```

[ [ pull-cylinder-r ]{.pre} ]{.sig-name .descname}

:   (1.5) \[nm\] the radius of the cylinder for

```{=html}
<!-- -->
```

[ [ pull-constr-tol ]{.pre} ]{.sig-name .descname}

:   (10 ^-6^ ) the relative constraint tolerance for constraint pulling

```{=html}
<!-- -->
```

[ [ pull-print-com ]{.pre} ]{.sig-name .descname}

:   

    [ [ no ]{.pre} ]{.sig-name .descname}

    :   do not print the COM for any group

    [ [ yes ]{.pre} ]{.sig-name .descname}

    :   print the COM of all groups for all pull coordinates

```{=html}
<!-- -->
```

[ [ pull-print-ref-value ]{.pre} ]{.sig-name .descname}

:   

    [ [ no ]{.pre} ]{.sig-name .descname}

    :   do not print the reference value for each pull coordinate

    [ [ yes ]{.pre} ]{.sig-name .descname}

    :   print the reference value for each pull coordinate

```{=html}
<!-- -->
```

[ [ pull-print-components ]{.pre} ]{.sig-name .descname}

:   

    [ [ no ]{.pre} ]{.sig-name .descname}

    :   only print the distance for each pull coordinate

    [ [ yes ]{.pre} ]{.sig-name .descname}

    :   print the distance and Cartesian components selected in

```{=html}
<!-- -->
```

[ [ pull-nstxout ]{.pre} ]{.sig-name .descname}

:   \(50\) frequency for writing out the COMs of all the pull group (0
    is never)

```{=html}
<!-- -->
```

[ [ pull-nstfout ]{.pre} ]{.sig-name .descname}

:   \(50\) frequency for writing out the force of all the pulled group
    (0 is never)

```{=html}
<!-- -->
```

[ [ pull-pbc-ref-prev-step-com ]{.pre} ]{.sig-name .descname}

:   

    [ [ no ]{.pre} ]{.sig-name .descname}

    :   Use the reference atom ( ) for the treatment of periodic
        boundary conditions.

    [ [ yes ]{.pre} ]{.sig-name .descname}

    :   Use the COM of the previous step as reference for the treatment
        of periodic boundary conditions. The reference is initialized
        using the reference atom ( ), which should be located centrally
        in the group. Using the COM from the previous step can be useful
        if one or more pull groups are large.

```{=html}
<!-- -->
```

[ [ pull-xout-average ]{.pre} ]{.sig-name .descname}

:   

    [ [ no ]{.pre} ]{.sig-name .descname}

    :   Write the instantaneous coordinates for all the pulled groups.

    [ [ yes ]{.pre} ]{.sig-name .descname}

    :   Write the average coordinates (since last output) for all the
        pulled groups. N.b., some analysis tools might expect
        instantaneous pull output.

```{=html}
<!-- -->
```

[ [ pull-fout-average ]{.pre} ]{.sig-name .descname}

:   

    [ [ no ]{.pre} ]{.sig-name .descname}

    :   Write the instantaneous force for all the pulled groups.

    [ [ yes ]{.pre} ]{.sig-name .descname}

    :   Write the average force (since last output) for all the pulled
        groups. N.b., some analysis tools might expect instantaneous
        pull output.

```{=html}
<!-- -->
```

[ [ pull-ngroups ]{.pre} ]{.sig-name .descname}

:   \(1\) The number of pull groups, not including the absolute
    reference group, when used. Pull groups can be reused in multiple
    pull coordinates. Below only the pull options for group 1 are given,
    further groups simply increase the group index number.

```{=html}
<!-- -->
```

[ [ pull-ncoords ]{.pre} ]{.sig-name .descname}

:   \(1\) The number of pull coordinates. Below only the pull options
    for coordinate 1 are given, further coordinates simply increase the
    coordinate index number.

```{=html}
<!-- -->
```

[ [ pull-group1-name ]{.pre} ]{.sig-name .descname}

:   The name of the pull group, is looked up in the index file or in the
    default groups to obtain the atoms involved.

```{=html}
<!-- -->
```

[ [ pull-group1-weights ]{.pre} ]{.sig-name .descname}

:   Optional relative weights which are multiplied with the masses of
    the atoms to give the total weight for the COM. The number should be
    0, meaning all 1, or the number of atoms in the pull group.

```{=html}
<!-- -->
```

[ [ pull-group1-pbcatom ]{.pre} ]{.sig-name .descname}

:   \(0\) The reference atom for the treatment of periodic boundary
    conditions inside the group (this has no effect on the treatment of
    the pbc between groups). This option is only important when the
    diameter of the pull group is larger than half the shortest box
    vector. For determining the COM, all atoms in the group are put at
    their periodic image which is closest to . A value of 0 means that
    the middle atom (number wise) is used, which is only safe for small
    groups. checks that the maximum distance from the reference atom
    (specifically chosen, or not) to the other atoms in the group is not
    too large. This parameter is not used with cylinder. A value of -1
    turns on cosine weighting, which is useful for a group of molecules
    in a periodic system, *e.g.* a water slab (see Engin et al. J. Chem.
    Phys. B 2010).

```{=html}
<!-- -->
```

[ [ pull-coord1-type ]{.pre} ]{.sig-name .descname}

:   

    [ [ umbrella ]{.pre} ]{.sig-name .descname}

    :   Center of mass pulling using an umbrella potential between the
        reference group and one or more groups.

    [ [ constraint ]{.pre} ]{.sig-name .descname}

    :   Center of mass pulling using a constraint between the reference
        group and one or more groups. The setup is identical to the
        option umbrella, except for the fact that a rigid constraint is
        applied instead of a harmonic potential. Note that this type is
        not supported in combination with multiple time stepping.

    [ [ constant-force ]{.pre} ]{.sig-name .descname}

    :   Center of mass pulling using a linear potential and therefore a
        constant force. For this option there is no reference position
        and therefore the parameters and are not used.

    [ [ flat-bottom ]{.pre} ]{.sig-name .descname}

    :   At distances above a harmonic potential is applied, otherwise no
        potential is applied.

    [ [ flat-bottom-high ]{.pre} ]{.sig-name .descname}

    :   At distances below a harmonic potential is applied, otherwise no
        potential is applied.

    [ [ external-potential ]{.pre} ]{.sig-name .descname}

    :   An external potential that needs to be provided by another
        module.

```{=html}
<!-- -->
```

[ [ pull-coord1-potential-provider ]{.pre} ]{.sig-name .descname}

:   The name of the external module that provides the potential for the
    case where is external-potential.

```{=html}
<!-- -->
```

[ [ pull-coord1-geometry ]{.pre} ]{.sig-name .descname}

:   

    [ [ distance ]{.pre} ]{.sig-name .descname}

    :   Pull along the vector connecting the two groups. Components can
        be selected with .

    [ [ direction ]{.pre} ]{.sig-name .descname}

    :   Pull in the direction of .

    [ [ direction-periodic ]{.pre} ]{.sig-name .descname}

    :   As , but does not apply periodic box vector corrections to keep
        the distance within half the box length. This is (only) useful
        for pushing groups apart by more than half the box length by
        continuously changing the reference location using a pull rate.
        With this geometry the box should not be dynamic ( *e.g.* no
        pressure scaling) in the pull dimensions and the pull force is
        not added to the virial.

    [ [ direction-relative ]{.pre} ]{.sig-name .descname}

    :   As , but the pull vector is the vector that points from the COM
        of a third to the COM of a fourth pull group. This means that 4
        groups need to be supplied in . Note that the pull force will
        give rise to a torque on the pull vector, which is turn leads to
        forces perpendicular to the pull vector on the two groups
        defining the vector. If you want a pull group to move between
        the two groups defining the vector, simply use the union of
        these two groups as the reference group.

    [ [ cylinder ]{.pre} ]{.sig-name .descname}

    :   Designed for pulling with respect to a layer where the reference
        COM is given by a local cylindrical part of the reference group.
        The pulling is in the direction of . From the first of the two
        groups in a cylinder is selected around the axis going through
        the COM of the second group with direction with radius . Weights
        of the atoms decrease continously to zero as the radial distance
        goes from 0 to (mass weighting is also used). The radial
        dependence gives rise to radial forces on both pull groups. Note
        that the radius should be smaller than half the box size. For
        tilted cylinders they should be even smaller than half the box
        size since the distance of an atom in the reference group from
        the COM of the pull group has both a radial and an axial
        component. This geometry is not supported with constraint
        pulling.

    [ [ angle ]{.pre} ]{.sig-name .descname}

    :   Pull along an angle defined by four groups. The angle is defined
        as the angle between two vectors: the vector connecting the COM
        of the first group to the COM of the second group and the vector
        connecting the COM of the third group to the COM of the fourth
        group.

    [ [ angle-axis ]{.pre} ]{.sig-name .descname}

    :   As but the second vector is given by . Thus, only the two groups
        that define the first vector need to be given.

    [ [ dihedral ]{.pre} ]{.sig-name .descname}

    :   Pull along a dihedral angle defined by six groups. These
        pairwise define three vectors: the vector connecting the COM of
        group 1 to the COM of group 2, the COM of group 3 to the COM of
        group 4, and the COM of group 5 to the COM group 6. The dihedral
        angle is then defined as the angle between two planes: the plane
        spanned by the the two first vectors and the plane spanned the
        two last vectors.

    [ [ transformation ]{.pre} ]{.sig-name .descname}

    :   Transforms other pull coordinates using a mathematical
        expression defined by . Pull coordinates of lower indices, and
        time, can be used as variables to this pull coordinate. Thus,
        pull transformation coordinates should have a higher pull
        coordinate index than all pull coordinates they transform.

```{=html}
<!-- -->
```

[ [ pull-coord1-expression ]{.pre} ]{.sig-name .descname}

:   Mathematical expression to transform pull coordinates of lower
    indices to a new one. The pull coordinates are referred to as
    variables in the equation so that pull-coord1â€™s value becomes
    â€˜x1â€™, pull-coord2 value becomes â€˜x2â€™ etc. Time can also be
    used a variable, becoming â€˜tâ€™. Note that angular coordinates use
    units of radians in the expression. The mathematical expression are
    evaluated using muParser. Only relevant if is set to ` `{.xref .std
    .std-mdp-value .docutils .literal
    .notranslate}[` transformation `{.xref .std .std-mdp-value .docutils
    .literal .notranslate}]{.pre}` `{.xref .std .std-mdp-value .docutils
    .literal .notranslate} .

```{=html}
<!-- -->
```

[ [ pull-coord1-dx ]{.pre} ]{.sig-name .descname}

:   (1e-9) Size of finite difference to use in numerical derivation of
    the pull coordinate with respect to other pull coordinates. The
    current implementation uses a simple first order finite difference
    method to perform derivation so that fâ€™(x) = (f(x+dx)-f(x))/dx
    Only relevant if is set to ` `{.xref .std .std-mdp-value .docutils
    .literal .notranslate}[` transformation `{.xref .std .std-mdp-value
    .docutils .literal .notranslate}]{.pre}` `{.xref .std .std-mdp-value
    .docutils .literal .notranslate} .

```{=html}
<!-- -->
```

[ [ pull-coord1-groups ]{.pre} ]{.sig-name .descname}

:   The group indices on which this pull coordinate will operate. The
    number of group indices required is geometry dependent. The first
    index can be 0, in which case an absolute reference of is used. With
    an absolute reference the system is no longer translation invariant
    and one should think about what to do with the center of mass
    motion.

```{=html}
<!-- -->
```

[ [ pull-coord1-dim ]{.pre} ]{.sig-name .descname}

:   (Y Y Y) Selects the dimensions that this pull coordinate acts on and
    that are printed to the output files when = . With = , only
    Cartesian components set to Y contribute to the distance. Thus
    setting this to Y Y N results in a distance in the x/y plane. With
    other geometries all dimensions with non-zero entries in should be
    set to Y, the values for other dimensions only affect the output.

```{=html}
<!-- -->
```

[ [ pull-coord1-origin ]{.pre} ]{.sig-name .descname}

:   (0.0 0.0 0.0) The pull reference position for use with an absolute
    reference.

```{=html}
<!-- -->
```

[ [ pull-coord1-vec ]{.pre} ]{.sig-name .descname}

:   (0.0 0.0 0.0) The pull direction. normalizes the vector.

```{=html}
<!-- -->
```

[ [ pull-coord1-start ]{.pre} ]{.sig-name .descname}

:   

    [ [ no ]{.pre} ]{.sig-name .descname}

    :   do not modify

    [ [ yes ]{.pre} ]{.sig-name .descname}

    :   add the COM distance of the starting conformation to

```{=html}
<!-- -->
```

[ [ pull-coord1-init ]{.pre} ]{.sig-name .descname}

:   (0.0) \[nm\] or \[deg\] The reference distance or reference angle at
    t=0.

```{=html}
<!-- -->
```

[ [ pull-coord1-rate ]{.pre} ]{.sig-name .descname}

:   \(0\) \[nm/ps\] or \[deg/ps\] The rate of change of the reference
    position or reference angle.

```{=html}
<!-- -->
```

[ [ pull-coord1-k ]{.pre} ]{.sig-name .descname}

:   \(0\) \[kJ mol ^-1^ nm ^-2^ \] or \[kJ mol ^-1^ nm ^-1^ \] or \[kJ
    mol ^-1^ rad ^-2^ \] or \[kJ mol ^-1^ rad ^-1^ \] The force
    constant. For umbrella pulling this is the harmonic force constant
    in kJ mol ^-1^ nm ^-2^ (or kJ mol ^-1^ rad ^-2^ for angles). For
    constant force pulling this is the force constant of the linear
    potential, and thus the negative (!) of the constant force in kJ mol
    ^-1^ nm ^-1^ (or kJ mol ^-1^ rad ^-1^ for angles). Note that for
    angles the force constant is expressed in terms of radians (while
    and are expressed in degrees).

```{=html}
<!-- -->
```

[ [ pull-coord1-kB ]{.pre} ]{.sig-name .descname}

:   (pull-k1) \[kJ mol ^-1^ nm ^-2^ \] or \[kJ mol ^-1^ nm ^-1^ \] or
    \[kJ mol ^-1^ rad ^-2^ \] or \[kJ mol ^-1^ rad ^-1^ \] As , but for
    state B. This is only used when is turned on. The force constant is
    then (1 - lambda) \* + lambda \* .
:::

::: {#awh-adaptive-biasing .section}
### AWH adaptive biasing

[ [ awh ]{.pre} ]{.sig-name .descname}

:   

    [ [ no ]{.pre} ]{.sig-name .descname}

    :   No biasing.

    [ [ yes ]{.pre} ]{.sig-name .descname}

    :   Adaptively bias a reaction coordinate using the AWH method and
        estimate the corresponding PMF. This requires a constant
        ensemble temperature to be available. The PMF and other AWH data
        are written to energy file at an interval set by and can be
        extracted with the ` `{.docutils .literal
        .notranslate}[` gmx `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal
        .notranslate}[` awh `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal .notranslate} tool.
        The AWH coordinate can be multidimensional and is defined by
        mapping each dimension to a pull coordinate index. This is only
        allowed if and = ` `{.docutils .literal
        .notranslate}[` awh `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal .notranslate} for the
        concerned pull coordinate indices. Pull geometry
        â€˜direction-periodicâ€™ and transformation coordinates that
        depend on time are not supported by AWH.

```{=html}
<!-- -->
```

[ [ awh-potential ]{.pre} ]{.sig-name .descname}

:   

    [ [ convolved ]{.pre} ]{.sig-name .descname}

    :   The applied biasing potential is the convolution of the bias
        function and a set of harmonic umbrella potentials (see below).
        This results in a smooth potential function and force. The
        resolution of the potential is set by the force constant of each
        umbrella, see . This option is not compatible with using the
        free energy lambda state as an AWH reaction coordinate.

    [ [ umbrella ]{.pre} ]{.sig-name .descname}

    :   The potential bias is applied by controlling the position of an
        harmonic potential using Monte-Carlo sampling. The force
        constant is set with . The umbrella location is sampled using
        Monte-Carlo every steps. This is option is required when using
        the free energy lambda state as an AWH reaction coordinate.
        Apart from that, this option is mainly for comparison and
        testing purposes as there are no advantages to using an
        umbrella.

```{=html}
<!-- -->
```

[ [ awh-share-multisim ]{.pre} ]{.sig-name .descname}

:   

    [ [ no ]{.pre} ]{.sig-name .descname}

    :   AWH will not share biases across simulations started with option
        ` `{.docutils .literal .notranslate}[` -multidir `{.docutils
        .literal .notranslate}]{.pre}` `{.docutils .literal
        .notranslate} . The biases will be independent.

    [ [ yes ]{.pre} ]{.sig-name .descname}

    :   With and option ` `{.docutils .literal
        .notranslate}[` -multidir `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal .notranslate} the
        bias and PMF estimates for biases with \>0 will be shared across
        simulations with the biases with the same value. The simulations
        should have the same AWH settings for sharing to make sense.
        will check whether the simulations are technically compatible
        for sharing, but the user should check that bias sharing
        physically makes sense.

```{=html}
<!-- -->
```

[ [ awh-seed ]{.pre} ]{.sig-name .descname}

:   (-1) Random seed for Monte-Carlo sampling the umbrella position,
    where -1 indicates to generate a seed. Only used with .

```{=html}
<!-- -->
```

[ [ awh-nstout ]{.pre} ]{.sig-name .descname}

:   \(100000\) Number of steps between printing AWH data to the energy
    file, should be a multiple of .

```{=html}
<!-- -->
```

[ [ awh-nstsample ]{.pre} ]{.sig-name .descname}

:   \(10\) Number of steps between sampling of the coordinate value.
    This sampling is the basis for updating the bias and estimating the
    PMF and other AWH observables.

```{=html}
<!-- -->
```

[ [ awh-nsamples-update ]{.pre} ]{.sig-name .descname}

:   \(10\) The number of coordinate samples used for each AWH update.
    The update interval in steps is times this value.

```{=html}
<!-- -->
```

[ [ awh-nbias ]{.pre} ]{.sig-name .descname}

:   \(1\) The number of biases, each acting on its own coordinate. The
    following options should be specified for each bias although below
    only the options for bias number 1 is shown. Options for other bias
    indices are obtained by replacing â€˜1â€™ by the bias index.

```{=html}
<!-- -->
```

[ [ awh1-error-init ]{.pre} ]{.sig-name .descname}

:   (10.0) \[kJ mol ^-1^ \] Estimated initial average error of the PMF
    for this bias. This value together with an estimate of the crossing
    time, based on the length of the sampling interval and the given
    diffusion constant(s) , determine the initial biasing rate. With
    multiple dimensions, the longest crossing time is used. The error is
    obviously not known *a priori* . Only a rough estimate of is needed
    however. As a general guideline, leave to its default value when
    starting a new simulation. On the other hand, when there is *a
    priori* knowledge of the PMF (e.g. when an initial PMF estimate is
    provided, see the option) then should reflect that knowledge.

```{=html}
<!-- -->
```

[ [ awh1-growth ]{.pre} ]{.sig-name .descname}

:   

    [ [ exp-linear ]{.pre} ]{.sig-name .descname}

    :   

    Each bias keeps a reference weight histogram for the coordinate
    samples. Its size sets the magnitude of the bias function and free
    energy estimate updates (few samples corresponds to large updates
    and vice versa). Thus, its growth rate sets the maximum convergence
    rate. By default, there is an initial stage in which the histogram
    grows close to exponentially (but slower than the sampling rate). In
    the final stage that follows, the growth rate is linear and equal to
    the sampling rate (set by ). The initial stage is typically
    necessary for efficient convergence when starting a new simulation
    where high free energy barriers have not yet been flattened by the
    bias.

    [ [ linear ]{.pre} ]{.sig-name .descname}

    :   

    As but skip the initial stage. This may be useful if there is *a
    priori* knowledge (see ) which eliminates the need for an initial
    stage. This is also the setting compatible with .

```{=html}
<!-- -->
```

[ [ awh1-growth-factor ]{.pre} ]{.sig-name .descname}

:   \(2\) \[\] The growth factor [ \\(\\gamma\\) ]{.math .notranslate
    .nohighlight} during the exponential phase with . Should be larger
    than 1.

```{=html}
<!-- -->
```

[ [ awh1-equilibrate-histogram ]{.pre} ]{.sig-name .descname}

:   

    [ [ no ]{.pre} ]{.sig-name .descname}

    :   Do not equilibrate histogram.

    [ [ yes ]{.pre} ]{.sig-name .descname}

    :   Before entering the initial stage (see ), make sure the
        histogram of sampled weights is following the target
        distribution closely enough (specifically, at least 80% of the
        target region needs to have a local relative error of less than
        20%). This option would typically only be used when \> 0 and the
        initial configurations poorly represent the target distribution.

```{=html}
<!-- -->
```

[ [ awh1-target ]{.pre} ]{.sig-name .descname}

:   

    [ [ constant ]{.pre} ]{.sig-name .descname}

    :   The bias is tuned towards a constant (uniform) coordinate
        distribution in the defined sampling interval (defined by \[ ,
        \]).

    [ [ cutoff ]{.pre} ]{.sig-name .descname}

    :   Similar to , but the target distribution is proportional to
        1/(1 + exp(F - )), where F is the free energy relative to the
        estimated global minimum. This provides a smooth switch of a
        flat target distribution in regions with free energy lower than
        the cut-off to a Boltzmann distribution in regions with free
        energy higher than the cut-off.

    [ [ boltzmann ]{.pre} ]{.sig-name .descname}

    :   The target distribution is a Boltzmann distribtution with a
        scaled beta (inverse temperature) factor given by . *E.g.* , a
        value of 0.1 would give the same coordinate distribution as
        sampling with a simulation temperature scaled by 10.

    [ [ local-boltzmann ]{.pre} ]{.sig-name .descname}

    :   Same target distribution and use of but the convergence towards
        the target distribution is inherently local *i.e.* , the rate of
        change of the bias only depends on the local sampling. This
        local convergence property is only compatible with , since for
        histograms are globally rescaled in the initial stage.

```{=html}
<!-- -->
```

[ [ awh1-target-beta-scaling ]{.pre} ]{.sig-name .descname}

:   \(0\) For and it is the unitless beta scaling factor taking values
    in (0,1).

```{=html}
<!-- -->
```

[ [ awh1-target-cutoff ]{.pre} ]{.sig-name .descname}

:   \(0\) \[kJ mol ^-1^ \] For this is the cutoff, should be \> 0.

```{=html}
<!-- -->
```

[ [ awh1-user-data ]{.pre} ]{.sig-name .descname}

:   

    [ [ no ]{.pre} ]{.sig-name .descname}

    :   Initialize the PMF and target distribution with default values.

    [ [ yes ]{.pre} ]{.sig-name .descname}

    :   Initialize the PMF and target distribution with user provided
        data. For = 1, will expect a file ` `{.docutils .literal
        .notranslate}[` awhinit.xvg `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal .notranslate} to be
        present in the run directory. For multiple biases, expects files
        ` `{.docutils .literal .notranslate}[` awhinit1.xvg `{.docutils
        .literal .notranslate}]{.pre}` `{.docutils .literal
        .notranslate} , ` `{.docutils .literal
        .notranslate}[` awhinit2.xvg `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal .notranslate} , etc.
        The file name can be changed with the ` `{.docutils .literal
        .notranslate}[` -awh `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal .notranslate} option.
        The first columns of each input file should contain the
        coordinate values, such that each row defines a point in
        coordinate space. Column + 1 should contain the PMF value (in
        kT) for each point. The target distribution column can either
        follow the PMF (column + 2) or be in the same column as written
        by .

```{=html}
<!-- -->
```

[ [ awh1-share-group ]{.pre} ]{.sig-name .descname}

:   

    [ [ 0 ]{.pre} ]{.sig-name .descname}

    :   Do not share the bias.

    [ [ positive ]{.pre} ]{.sig-name .descname}

    :   Share the bias and PMF estimates between simulations. This
        currently only works between biases with the same index. Note
        that currently sharing within a single simulation is not
        supported. The bias will be shared across simulations that
        specify the same value for . To enable this, use and the option
        ` `{.docutils .literal .notranslate}[` -multidir `{.docutils
        .literal .notranslate}]{.pre}` `{.docutils .literal
        .notranslate} . Sharing may increase convergence initially,
        although the starting configurations can be critical, especially
        when sharing between many biases.

```{=html}
<!-- -->
```

[ [ awh1-target-metric-scaling ]{.pre} ]{.sig-name .descname}

:   

    [ [ no ]{.pre} ]{.sig-name .descname}

    :   Do not scale the target distribution based on the AWH friction
        metric.

    [ [ yes ]{.pre} ]{.sig-name .descname}

    :   Scale the target distribution based on the AWH friction metric.
        Regions with high friction (long autocorrelation times) will be
        sampled more. The diffusion metric is the inverse of the
        friction metric. This scaling can be used with any type and is
        applied after user provided target distribution modifications (
        ), if any. If , the target distribution scaling starts after
        leaving the initial phase.

```{=html}
<!-- -->
```

[ [ awh1-target-metric-scaling-limit ]{.pre} ]{.sig-name .descname}

:   \(10\) The upper limit of scaling, relative to the average, when
    ` `{.xref .std .std-mdp-value .docutils .literal
    .notranslate}[` awh1-target-metric-scaling `{.xref .std
    .std-mdp-value .docutils .literal .notranslate}]{.pre}` `{.xref .std
    .std-mdp-value .docutils .literal .notranslate} is enabled. The
    lower limit will be the inverse of this value. This upper limit
    should be \> 1.

```{=html}
<!-- -->
```

[ [ awh1-ndim ]{.pre} ]{.sig-name .descname}

:   \(1\) \[integer\] Number of dimensions of the coordinate, each
    dimension maps to 1 pull coordinate. The following options should be
    specified for each such dimension. Below only the options for
    dimension number 1 is shown. Options for other dimension indices are
    obtained by replacing â€˜1â€™ by the dimension index.

```{=html}
<!-- -->
```

[ [ awh1-dim1-coord-provider ]{.pre} ]{.sig-name .descname}

:   

    [ [ pull ]{.pre} ]{.sig-name .descname}

    :   The pull module is providing the reaction coordinate for this
        dimension. With multiple time-stepping, AWH and pull should be
        in the same MTS level.

    [ [ fep-lambda ]{.pre} ]{.sig-name .descname}

    :   The free energy lambda state is the reaction coordinate for this
        dimension. The lambda states to use are specified by , , etc.
        This is not compatible with delta-lambda. It also requires
        calc-lambda-neighbors to be -1. With multiple time-stepping, AWH
        should be in the slow level. This option requires .

```{=html}
<!-- -->
```

[ [ awh1-dim1-coord-index ]{.pre} ]{.sig-name .descname}

:   \(1\) Index of the pull coordinate defining this coordinate
    dimension.

```{=html}
<!-- -->
```

[ [ awh1-dim1-force-constant ]{.pre} ]{.sig-name .descname}

:   \(0\) \[kJ mol ^-1^ nm ^-2^ \] or \[kJ mol ^-1^ rad ^-2^ \] Force
    constant for the (convolved) umbrella potential(s) along this
    coordinate dimension.

```{=html}
<!-- -->
```

[ [ awh1-dim1-start ]{.pre} ]{.sig-name .descname}

:   (0.0) \[nm\] or \[deg\] Start value of the sampling interval along
    this dimension. The range of allowed values depends on the relevant
    pull geometry (see ). For dihedral geometries greater than is
    allowed. The interval will then wrap around from +period/2 to
    -period/2. For the direction geometry, the dimension is made
    periodic when the direction is along a box vector and covers more
    than 95% of the box length. Note that one should not apply pressure
    coupling along a periodic dimension.

```{=html}
<!-- -->
```

[ [ awh1-dim1-end ]{.pre} ]{.sig-name .descname}

:   (0.0) \[nm\] or \[deg\] End value defining the sampling interval
    together with .

```{=html}
<!-- -->
```

[ [ awh1-dim1-diffusion ]{.pre} ]{.sig-name .descname}

:   (10 ^-5^ ) \[nm ^2^ /ps\], \[rad ^2^ /ps\] or \[ps ^-1^ \] Estimated
    diffusion constant for this coordinate dimension determining the
    initial biasing rate. This needs only be a rough estimate and should
    not critically affect the results unless it is set to something very
    low, leading to slow convergence, or very high, forcing the system
    far from equilibrium. Not setting this value explicitly generates a
    warning.

```{=html}
<!-- -->
```

[ [ awh1-dim1-cover-diameter ]{.pre} ]{.sig-name .descname}

:   (0.0) \[nm\] or \[deg\] Diameter that needs to be sampled by a
    single simulation around a coordinate value before the point is
    considered covered in the initial stage (see ). A value \> 0 ensures
    that for each covering there is a continuous transition of this
    diameter across each coordinate value. This is trivially true for
    independent simulations but not for for multiple bias-sharing
    simulations ( \>0). For a diameter = 0, covering occurs as soon as
    the simulations have sampled the whole interval, which for many
    sharing simulations does not guarantee transitions across free
    energy barriers. On the other hand, when the diameter \>= the
    sampling interval length, covering occurs when a single simulation
    has independently sampled the whole interval.
:::

::: {#enforced-rotation .section}
### Enforced rotation

These parameters can be used enforce the rotation of a group of atoms,
e.g. a protein subunit. The describes in detail 13 different potentials
that can be used to achieve such a rotation.

[ [ rotation ]{.pre} ]{.sig-name .descname}

:   

    [ [ no ]{.pre} ]{.sig-name .descname}

    :   No enforced rotation will be applied. All enforced rotation
        options will be ignored (and if present in the file, they
        unfortunately generate warnings).

    [ [ yes ]{.pre} ]{.sig-name .descname}

    :   Apply the rotation potential specified by to the group of atoms
        given under the option.

```{=html}
<!-- -->
```

[ [ rot-ngroups ]{.pre} ]{.sig-name .descname}

:   \(1\) Number of rotation groups.

```{=html}
<!-- -->
```

[ [ rot-group0 ]{.pre} ]{.sig-name .descname}

:   Name of rotation group 0 in the index file.

```{=html}
<!-- -->
```

[ [ rot-type0 ]{.pre} ]{.sig-name .descname}

:   (iso) Type of rotation potential that is applied to rotation
    group 0. Can be of of the following: ` `{.docutils .literal
    .notranslate}[` iso `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} ,
    ` `{.docutils .literal .notranslate}[` iso-pf `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} ,
    ` `{.docutils .literal .notranslate}[` pm `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} ,
    ` `{.docutils .literal .notranslate}[` pm-pf `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} ,
    ` `{.docutils .literal .notranslate}[` rm `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} ,
    ` `{.docutils .literal .notranslate}[` rm-pf `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} ,
    ` `{.docutils .literal .notranslate}[` rm2 `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} ,
    ` `{.docutils .literal .notranslate}[` rm2-pf `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} ,
    ` `{.docutils .literal .notranslate}[` flex `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} ,
    ` `{.docutils .literal .notranslate}[` flex-t `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} ,
    ` `{.docutils .literal .notranslate}[` flex2 `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} , or
    ` `{.docutils .literal .notranslate}[` flex2-t `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} .

```{=html}
<!-- -->
```

[ [ rot-massw0 ]{.pre} ]{.sig-name .descname}

:   (no) Use mass weighted rotation group positions.

```{=html}
<!-- -->
```

[ [ rot-vec0 ]{.pre} ]{.sig-name .descname}

:   (1.0 0.0 0.0) Rotation vector, will get normalized.

```{=html}
<!-- -->
```

[ [ rot-pivot0 ]{.pre} ]{.sig-name .descname}

:   (0.0 0.0 0.0) \[nm\] Pivot point for the potentials ` `{.docutils
    .literal .notranslate}[` iso `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} ,
    ` `{.docutils .literal .notranslate}[` pm `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} ,
    ` `{.docutils .literal .notranslate}[` rm `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} , and
    ` `{.docutils .literal .notranslate}[` rm2 `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} .

```{=html}
<!-- -->
```

[ [ rot-rate0 ]{.pre} ]{.sig-name .descname}

:   \(0\) \[degree ps ^-1^ \] Reference rotation rate of group 0.

```{=html}
<!-- -->
```

[ [ rot-k0 ]{.pre} ]{.sig-name .descname}

:   \(0\) \[kJ mol ^-1^ nm ^-2^ \] Force constant for group 0.

```{=html}
<!-- -->
```

[ [ rot-slab-dist0 ]{.pre} ]{.sig-name .descname}

:   (1.5) \[nm\] Slab distance, if a flexible axis rotation type was
    chosen.

```{=html}
<!-- -->
```

[ [ rot-min-gauss0 ]{.pre} ]{.sig-name .descname}

:   (0.001) Minimum value (cutoff) of Gaussian function for the force to
    be evaluated (for the flexible axis potentials).

```{=html}
<!-- -->
```

[ [ rot-eps0 ]{.pre} ]{.sig-name .descname}

:   (0.0001) \[nm ^2^ \] Value of additive constant epsilon for
    ` `{.docutils .literal .notranslate}[` rm2* `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} and
    ` `{.docutils .literal .notranslate}[` flex2* `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} potentials.

```{=html}
<!-- -->
```

[ [ rot-fit-method0 ]{.pre} ]{.sig-name .descname}

:   (rmsd) Fitting method when determining the actual angle of a
    rotation group (can be one of ` `{.docutils .literal
    .notranslate}[` rmsd `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} ,
    ` `{.docutils .literal .notranslate}[` norm `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} , or
    ` `{.docutils .literal .notranslate}[` potential `{.docutils
    .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} ).

```{=html}
<!-- -->
```

[ [ rot-potfit-nsteps0 ]{.pre} ]{.sig-name .descname}

:   \(21\) For fit type ` `{.docutils .literal
    .notranslate}[` potential `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} , the
    number of angular positions around the reference angle for which the
    rotation potential is evaluated.

```{=html}
<!-- -->
```

[ [ rot-potfit-step0 ]{.pre} ]{.sig-name .descname}

:   (0.25) For fit type ` `{.docutils .literal
    .notranslate}[` potential `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} , the
    distance in degrees between two angular positions.

```{=html}
<!-- -->
```

[ [ rot-nstrout ]{.pre} ]{.sig-name .descname}

:   \(100\) Output frequency (in steps) for the angle of the rotation
    group, as well as for the torque and the rotation potential energy.

```{=html}
<!-- -->
```

[ [ rot-nstsout ]{.pre} ]{.sig-name .descname}

:   \(1000\) Output frequency for per-slab data of the flexible axis
    potentials, i.e. angles, torques and slab centers.
:::

::: {#nmr-refinement .section}
### NMR refinement

[ [ disre ]{.pre} ]{.sig-name .descname}

:   

    [ [ no ]{.pre} ]{.sig-name .descname}

    :   ignore distance restraint information in topology file

    [ [ simple ]{.pre} ]{.sig-name .descname}

    :   simple (per-molecule) distance restraints.

    [ [ ensemble ]{.pre} ]{.sig-name .descname}

    :   distance restraints over an ensemble of molecules in one
        simulation box. Normally, one would perform ensemble averaging
        over multiple simulations, using ` `{.docutils .literal
        .notranslate}[` mdrun `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal
        .notranslate}[` -multidir `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal .notranslate} . The
        environment variable ` `{.docutils .literal
        .notranslate}[` GMX_DISRE_ENSEMBLE_SIZE `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal .notranslate} sets
        the number of systems within each ensemble (usually equal to the
        number of directories supplied to ` `{.docutils .literal
        .notranslate}[` mdrun `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal
        .notranslate}[` -multidir `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal .notranslate} ).

```{=html}
<!-- -->
```

[ [ disre-weighting ]{.pre} ]{.sig-name .descname}

:   

    [ [ equal ]{.pre} ]{.sig-name .descname}

    :   divide the restraint force equally over all atom pairs in the
        restraint

    [ [ conservative ]{.pre} ]{.sig-name .descname}

    :   the forces are the derivative of the restraint potential, this
        results in an weighting of the atom pairs to the reciprocal
        seventh power of the displacement. The forces are conservative
        when is zero.

```{=html}
<!-- -->
```

[ [ disre-mixed ]{.pre} ]{.sig-name .descname}

:   

    [ [ no ]{.pre} ]{.sig-name .descname}

    :   the violation used in the calculation of the restraint force is
        the time-averaged violation

    [ [ yes ]{.pre} ]{.sig-name .descname}

    :   the violation used in the calculation of the restraint force is
        the square root of the product of the time-averaged violation
        and the instantaneous violation

```{=html}
<!-- -->
```

[ [ disre-fc ]{.pre} ]{.sig-name .descname}

:   \(1000\) \[kJ mol ^-1^ nm ^-2^ \] force constant for distance
    restraints, which is multiplied by a (possibly) different factor for
    each restraint given in the ` `{.docutils .literal
    .notranslate}[` fac `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} column of
    the interaction in the topology file.

```{=html}
<!-- -->
```

[ [ disre-tau ]{.pre} ]{.sig-name .descname}

:   \(0\) \[ps\] time constant for distance restraints running average.
    A value of zero turns off time averaging.

```{=html}
<!-- -->
```

[ [ nstdisreout ]{.pre} ]{.sig-name .descname}

:   \(100\) \[steps\] period between steps when the running
    time-averaged and instantaneous distances of all atom pairs involved
    in restraints are written to the energy file (can make the energy
    file very large)

```{=html}
<!-- -->
```

[ [ orire ]{.pre} ]{.sig-name .descname}

:   

    [ [ no ]{.pre} ]{.sig-name .descname}

    :   ignore orientation restraint information in topology file

    [ [ yes ]{.pre} ]{.sig-name .descname}

    :   use orientation restraints, ensemble averaging can be performed
        with ` `{.docutils .literal .notranslate}[` mdrun `{.docutils
        .literal .notranslate}]{.pre}` `{.docutils .literal
        .notranslate}[` -multidir `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal .notranslate}

```{=html}
<!-- -->
```

[ [ orire-fc ]{.pre} ]{.sig-name .descname}

:   \(0\) \[kJ mol ^-1^ \] force constant for orientation restraints,
    which is multiplied by a (possibly) different weight factor for each
    restraint, can be set to zero to obtain the orientations from a free
    simulation

```{=html}
<!-- -->
```

[ [ orire-tau ]{.pre} ]{.sig-name .descname}

:   \(0\) \[ps\] time constant for orientation restraints running
    average. A value of zero turns off time averaging.

```{=html}
<!-- -->
```

[ [ orire-fitgrp ]{.pre} ]{.sig-name .descname}

:   fit group for orientation restraining. This group of atoms is used
    to determine the rotation **R** of the system with respect to the
    reference orientation. The reference orientation is the starting
    conformation of the first subsystem. For a protein, backbone is a
    reasonable choice

```{=html}
<!-- -->
```

[ [ nstorireout ]{.pre} ]{.sig-name .descname}

:   \(100\) \[steps\] period between steps when the running
    time-averaged and instantaneous orientations for all restraints, and
    the molecular order tensor are written to the energy file (can make
    the energy file very large)
:::

::: {#free-energy-calculations .section}
### Free energy calculations

[ [ free-energy ]{.pre} ]{.sig-name .descname}

:   

    [ [ no ]{.pre} ]{.sig-name .descname}

    :   Only use topology A.

    [ [ yes ]{.pre} ]{.sig-name .descname}

    :   Interpolate between topology A (lambda=0) to topology B
        (lambda=1) and write the derivative of the Hamiltonian with
        respect to lambda (as specified with ), or the Hamiltonian
        differences with respect to other lambda values (as specified
        with foreign lambda) to the energy file and/or to ` `{.docutils
        .literal .notranslate}[` dhdl.xvg `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal .notranslate} , where
        they can be processed by, for example . The potentials,
        bond-lengths and angles are interpolated linearly as described
        in the manual. When is larger than zero, soft-core potentials
        are used for the LJ and Coulomb interactions.

```{=html}
<!-- -->
```

[ [ expanded ]{.pre} ]{.sig-name .descname}

:   Turns on expanded ensemble simulation, where the alchemical state
    becomes a dynamic variable, allowing jumping between different
    Hamiltonians. See the expanded ensemble options for controlling how
    expanded ensemble simulations are performed. The different
    Hamiltonians used in expanded ensemble simulations are defined by
    the other free energy options.

```{=html}
<!-- -->
```

[ [ init-lambda ]{.pre} ]{.sig-name .descname}

:   (-1) starting value for lambda (float). Generally, this should only
    be used with slow growth ( *i.e.* nonzero ). In other cases, should
    be specified instead. If a lambda vector is given, is used to
    interpolate the vector instead of setting lambda directly. Must be
    greater than or equal to 0.

```{=html}
<!-- -->
```

[ [ delta-lambda ]{.pre} ]{.sig-name .descname}

:   \(0\) increment per time step for lambda

```{=html}
<!-- -->
```

[ [ init-lambda-state ]{.pre} ]{.sig-name .descname}

:   (-1) starting value for the lambda state (integer). Specifies which
    columm of the lambda vector ( , , , , , , ) should be used. This is
    a zero-based index: 0 means the first column, and so on.

```{=html}
<!-- -->
```

[ [ fep-lambdas ]{.pre} ]{.sig-name .descname}

:   \[array\] Zero, one or more lambda values for which Delta H values
    will be determined and written to dhdl.xvg every steps. Values must
    be greater than or equal to 0; values greater than 1 are allowed but
    should be used carefully. Free energy differences between different
    lambda values can then be determined with . is different from the
    other -lambdas keywords because all components of the lambda vector
    that are not specified will use (including and therefore the pull
    code restraints).

```{=html}
<!-- -->
```

[ [ coul-lambdas ]{.pre} ]{.sig-name .descname}

:   \[array\] Zero, one or more lambda values for which Delta H values
    will be determined and written to dhdl.xvg every steps. Values must
    be greater than or equal to 0; values greater than 1 are allowed but
    should be used carefully. If soft-core potentials are used, values
    must be between 0 and 1. Only the electrostatic interactions are
    controlled with this component of the lambda vector (and only if the
    lambda=0 and lambda=1 states have differing electrostatic
    interactions).

```{=html}
<!-- -->
```

[ [ vdw-lambdas ]{.pre} ]{.sig-name .descname}

:   \[array\] Zero, one or more lambda values for which Delta H values
    will be determined and written to dhdl.xvg every steps. Values must
    be greater than or equal to 0; values greater than 1 are allowed but
    should be used carefully. If soft-core potentials are used, values
    must be between 0 and 1. Only the van der Waals interactions are
    controlled with this component of the lambda vector.

```{=html}
<!-- -->
```

[ [ bonded-lambdas ]{.pre} ]{.sig-name .descname}

:   \[array\] Zero, one or more lambda values for which Delta H values
    will be determined and written to dhdl.xvg every steps. Values must
    be greater than or equal to 0; values greater than 1 are allowed but
    should be used carefully. Only the bonded interactions are
    controlled with this component of the lambda vector.

```{=html}
<!-- -->
```

[ [ restraint-lambdas ]{.pre} ]{.sig-name .descname}

:   \[array\] Zero, one or more lambda values for which Delta H values
    will be determined and written to dhdl.xvg every steps. Values must
    be greater than or equal to 0; values greater than 1 are allowed but
    should be used carefully. Only the restraint interactions: dihedral
    restraints, and the pull code restraints are controlled with this
    component of the lambda vector.

```{=html}
<!-- -->
```

[ [ mass-lambdas ]{.pre} ]{.sig-name .descname}

:   \[array\] Zero, one or more lambda values for which Delta H values
    will be determined and written to dhdl.xvg every steps. Values must
    be greater than or equal to 0; values greater than 1 are allowed but
    should be used carefully. Only the particle masses are controlled
    with this component of the lambda vector.

```{=html}
<!-- -->
```

[ [ temperature-lambdas ]{.pre} ]{.sig-name .descname}

:   \[array\] Zero, one or more lambda values for which Delta H values
    will be determined and written to dhdl.xvg every steps. Values must
    be greater than or equal to 0; values greater than 1 are allowed but
    should be used carefully. Only the temperatures are controlled with
    this component of the lambda vector. Note that these lambdas should
    not be used for replica exchange, only for simulated tempering.

```{=html}
<!-- -->
```

[ [ calc-lambda-neighbors ]{.pre} ]{.sig-name .descname}

:   \(1\) Controls the number of lambda values for which Delta H values
    will be calculated and written out, if has been set. A positive
    value will limit the number of lambda points calculated to only the
    nth neighbors of : for example, if is 5 and this parameter has a
    value of 2, energies for lambda points 3-7 will be calculated and
    writen out. A value of -1 means all lambda points will be written
    out. For normal BAR such as with , a value of 1 is sufficient, while
    for MBAR -1 should be used.

```{=html}
<!-- -->
```

[ [ sc-function ]{.pre} ]{.sig-name .descname}

:   (beutler)

    [ [ beutler ]{.pre} ]{.sig-name .descname}

    :   

    Beutler *et al.* soft-core function

    [ [ gapsys ]{.pre} ]{.sig-name .descname}

    :   

    Gapsys *et al.* soft-core function

```{=html}
<!-- -->
```

[ [ sc-alpha ]{.pre} ]{.sig-name .descname}

:   \(0\) for the soft-core alpha parameter, a value of 0 results in
    linear interpolation of the LJ and Coulomb interactions. Used only
    with

```{=html}
<!-- -->
```

[ [ sc-r-power ]{.pre} ]{.sig-name .descname}

:   \(6\) power 6 for the radial term in the soft-core equation. Used
    only with

```{=html}
<!-- -->
```

[ [ sc-coul ]{.pre} ]{.sig-name .descname}

:   (no) Whether to apply the soft-core free energy interaction
    transformation to the Columbic interaction of a molecule. Default is
    no, as it is generally more efficient to turn off the Coulomic
    interactions linearly before turning off the van der Waals
    interactions. Note that it is only taken into account when lambda
    states are used, not with / , and you can still turn off soft-core
    interactions by setting to 0. Used only with

```{=html}
<!-- -->
```

[ [ sc-power ]{.pre} ]{.sig-name .descname}

:   \(1\) the power for lambda in the soft-core function, only the
    values 1 and 2 are supported. Used only with

```{=html}
<!-- -->
```

[ [ sc-sigma ]{.pre} ]{.sig-name .descname}

:   (0.3) \[nm\] for the soft-core sigma for particles which have a C6
    or C12 parameter equal to zero or a sigma smaller than . Used only
    with

```{=html}
<!-- -->
```

[ [ sc-gapsys-scale-linpoint-lj ]{.pre} ]{.sig-name .descname}

:   (0.85) for it is the unitless alphaLJ parameter. It controls the
    softness of the van der Waals interactions by scaling the point for
    linearizing the vdw force. Setting it to 0 will result in the
    standard hard-core van der Waals interactions. Used only with

```{=html}
<!-- -->
```

[ [ sc-gapsys-scale-linpoint-q ]{.pre} ]{.sig-name .descname}

:   (0.3) \[nm/e\^2\] For the alphaQ parameter with the unit of
    \[nm/e\^2\] and default value of 0.3. It controls the softness of
    the Coulombic interactions. Setting it to 0 will result in the
    standard hard-core Coulombic interactions. Used only with

```{=html}
<!-- -->
```

[ [ sc-gapsys-sigma-lj ]{.pre} ]{.sig-name .descname}

:   (0.3) \[nm\] for the soft-core sigma for particles which have a C6
    or C12 parameter equal to zero. Used only with

```{=html}
<!-- -->
```

[ [ couple-moltype ]{.pre} ]{.sig-name .descname}

:   Here one can supply a molecule type (as defined in the topology) for
    calculating solvation or coupling free energies. There is a special
    option ` `{.docutils .literal .notranslate}[` system `{.docutils
    .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}
    that couples all molecule types in the system. This can be useful
    for equilibrating a system starting from (nearly) random
    coordinates. has to be turned on. The Van der Waals interactions
    and/or charges in this molecule type can be turned on or off between
    lambda=0 and lambda=1, depending on the settings of and . If you
    want to decouple one of several copies of a molecule, you need to
    copy and rename the molecule definition in the topology.

```{=html}
<!-- -->
```

[ [ couple-lambda0 ]{.pre} ]{.sig-name .descname}

:   

    [ [ vdw-q ]{.pre} ]{.sig-name .descname}

    :   all interactions are on at lambda=0

    [ [ vdw ]{.pre} ]{.sig-name .descname}

    :   the charges are zero (no Coulomb interactions) at lambda=0

    [ [ q ]{.pre} ]{.sig-name .descname}

    :   the Van der Waals interactions are turned at lambda=0; soft-core
        interactions will be required to avoid singularities

    [ [ none ]{.pre} ]{.sig-name .descname}

    :   the Van der Waals interactions are turned off and the charges
        are zero at lambda=0; soft-core interactions will be required to
        avoid singularities.

```{=html}
<!-- -->
```

[ [ couple-lambda1 ]{.pre} ]{.sig-name .descname}

:   analogous to , but for lambda=1

```{=html}
<!-- -->
```

[ [ couple-intramol ]{.pre} ]{.sig-name .descname}

:   

    [ [ no ]{.pre} ]{.sig-name .descname}

    :   All intra-molecular non-bonded interactions for moleculetype are
        replaced by exclusions and explicit pair interactions. In this
        manner the decoupled state of the molecule corresponds to the
        proper vacuum state without periodicity effects.

    [ [ yes ]{.pre} ]{.sig-name .descname}

    :   The intra-molecular Van der Waals and Coulomb interactions are
        also turned on/off. This can be useful for partitioning
        free-energies of relatively large molecules, where the
        intra-molecular non-bonded interactions might lead to
        kinetically trapped vacuum conformations. The 1-4 pair
        interactions are not turned off.

```{=html}
<!-- -->
```

[ [ nstdhdl ]{.pre} ]{.sig-name .descname}

:   \(100\) the frequency for writing dH/dlambda and possibly Delta H to
    dhdl.xvg, 0 means no ouput, should be a multiple of .

```{=html}
<!-- -->
```

[ [ dhdl-derivatives ]{.pre} ]{.sig-name .descname}

:   (yes)

    If yes (the default), the derivatives of the Hamiltonian with
    respect to lambda at each step are written out. These values are
    needed for interpolation of linear energy differences with (although
    the same can also be achieved with the right foreign lambda setting,
    that may not be as flexible), or with thermodynamic integration

```{=html}
<!-- -->
```

[ [ dhdl-print-energy ]{.pre} ]{.sig-name .descname}

:   (no)

    Include either the total or the potential energy in the dhdl file.
    Options are â€˜noâ€™, â€˜potentialâ€™, or â€˜totalâ€™. This
    information is needed for later free energy analysis if the states
    of interest are at different temperatures. If all states are at the
    same temperature, this information is not needed. â€˜potentialâ€™ is
    useful in case one is using ` `{.docutils .literal
    .notranslate}[` mdrun `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` -rerun `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} to generate
    the ` `{.docutils .literal .notranslate}[` dhdl.xvg `{.docutils
    .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}
    file. When rerunning from an existing trajectory, the kinetic energy
    will often not be correct, and thus one must compute the residual
    free energy from the potential alone, with the kinetic energy
    component computed analytically.

```{=html}
<!-- -->
```

[ [ separate-dhdl-file ]{.pre} ]{.sig-name .descname}

:   

    [ [ yes ]{.pre} ]{.sig-name .descname}

    :   The free energy values that are calculated (as specified with
        the foreign lambda and settings) are written out to a separate
        file, with the default name ` `{.docutils .literal
        .notranslate}[` dhdl.xvg `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal .notranslate} . This
        file can be used directly with .

    [ [ no ]{.pre} ]{.sig-name .descname}

    :   The free energy values are written out to the energy output file
        ( ` `{.docutils .literal .notranslate}[` ener.edr `{.docutils
        .literal .notranslate}]{.pre}` `{.docutils .literal
        .notranslate} , in accumulated blocks at every steps), where
        they can be extracted with or used directly with .

```{=html}
<!-- -->
```

[ [ dh-hist-size ]{.pre} ]{.sig-name .descname}

:   \(0\) If nonzero, specifies the size of the histogram into which the
    Delta H values (specified with foreign lambda) and the derivative
    dH/dl values are binned, and written to ener.edr. This can be used
    to save disk space while calculating free energy differences. One
    histogram gets written for each foreign lambda and two for the
    dH/dl, at every step. Be aware that incorrect histogram settings
    (too small size or too wide bins) can introduce errors. Do not use
    histograms unless youâ€™re certain you need it.

```{=html}
<!-- -->
```

[ [ dh-hist-spacing ]{.pre} ]{.sig-name .descname}

:   (0.1) Specifies the bin width of the histograms, in energy units.
    Used in conjunction with . This size limits the accuracy with which
    free energies can be calculated. Do not use histograms unless
    youâ€™re certain you need it.
:::

::: {#expanded-ensemble-calculations .section}
### Expanded Ensemble calculations

[ [ nstexpanded ]{.pre} ]{.sig-name .descname}

:   The number of integration steps beween attempted moves changing the
    system Hamiltonian in expanded ensemble simulations. Must be a
    multiple of , but can be greater or less than .

```{=html}
<!-- -->
```

[ [ lmc-stats ]{.pre} ]{.sig-name .descname}

:   

    [ [ no ]{.pre} ]{.sig-name .descname}

    :   No Monte Carlo in state space is performed.

    [ [ metropolis-transition ]{.pre} ]{.sig-name .descname}

    :   Uses the Metropolis weights to update the expanded ensemble
        weight of each state. Min{1,exp(-(beta_new u_new - beta_old
        u_old)}

    [ [ barker-transition ]{.pre} ]{.sig-name .descname}

    :   Uses the Barker transition critera to update the expanded
        ensemble weight of each state i, defined by exp(-beta_new
        u_new)/(exp(-beta_new u_new)+exp(-beta_old u_old))

    [ [ wang-landau ]{.pre} ]{.sig-name .descname}

    :   Uses the Wang-Landau algorithm (in state space, not energy
        space) to update the expanded ensemble weights.

    [ [ min-variance ]{.pre} ]{.sig-name .descname}

    :   Uses the minimum variance updating method of Escobedo et al. to
        update the expanded ensemble weights. Weights will not be the
        free energies, but will rather emphasize states that need more
        sampling to give even uncertainty.

```{=html}
<!-- -->
```

[ [ lmc-mc-move ]{.pre} ]{.sig-name .descname}

:   

    [ [ no ]{.pre} ]{.sig-name .descname}

    :   No Monte Carlo in state space is performed.

    [ [ metropolis-transition ]{.pre} ]{.sig-name .descname}

    :   Randomly chooses a new state up or down, then uses the
        Metropolis critera to decide whether to accept or reject:
        Min{1,exp(-(beta_new u_new - beta_old u_old)}

    [ [ barker-transition ]{.pre} ]{.sig-name .descname}

    :   Randomly chooses a new state up or down, then uses the Barker
        transition critera to decide whether to accept or reject:
        exp(-beta_new u_new)/(exp(-beta_new u_new)+exp(-beta_old u_old))

    [ [ gibbs ]{.pre} ]{.sig-name .descname}

    :   Uses the conditional weights of the state given the coordinate
        (exp(-beta_i u_i) / sum_k exp(beta_i u_i) to decide which state
        to move to.

    [ [ metropolized-gibbs ]{.pre} ]{.sig-name .descname}

    :   Uses the conditional weights of the state given the coordinate
        (exp(-beta_i u_i) / sum_k exp(beta_i u_i) to decide which state
        to move to, EXCLUDING the current state, then uses a rejection
        step to ensure detailed balance. Always more efficient that
        Gibbs, though only marginally so in many situations, such as
        when only the nearest neighbors have decent phase space overlap.

```{=html}
<!-- -->
```

[ [ lmc-seed ]{.pre} ]{.sig-name .descname}

:   (-1) random seed to use for Monte Carlo moves in state space. When
    is set to -1, a pseudo random seed is us

```{=html}
<!-- -->
```

[ [ mc-temperature ]{.pre} ]{.sig-name .descname}

:   Temperature used for acceptance/rejection for Monte Carlo moves. If
    not specified, the temperature of the simulation specified in the
    first group of is used.

```{=html}
<!-- -->
```

[ [ wl-ratio ]{.pre} ]{.sig-name .descname}

:   (0.8) The cutoff for the histogram of state occupancies to be reset,
    and the free energy incrementor to be changed from delta to delta \*
    . If we define the Nratio = (number of samples at each histogram) /
    (average number of samples at each histogram). of 0.8 means that
    means that the histogram is only considered flat if all Nratio \>
    0.8 AND simultaneously all 1/Nratio \> 0.8.

```{=html}
<!-- -->
```

[ [ wl-scale ]{.pre} ]{.sig-name .descname}

:   (0.8) Each time the histogram is considered flat, then the current
    value of the Wang-Landau incrementor for the free energies is
    multiplied by . Value must be between 0 and 1.

```{=html}
<!-- -->
```

[ [ init-wl-delta ]{.pre} ]{.sig-name .descname}

:   (1.0) The initial value of the Wang-Landau incrementor in kT. Some
    value near 1 kT is usually most efficient, though sometimes a value
    of 2-3 in units of kT works better if the free energy differences
    are large.

```{=html}
<!-- -->
```

[ [ wl-oneovert ]{.pre} ]{.sig-name .descname}

:   (no) Set Wang-Landau incrementor to scale with 1/(simulation time)
    in the large sample limit. There is significant evidence that the
    standard Wang-Landau algorithms in state space presented here result
    in free energies getting â€˜burned inâ€™ to incorrect values that
    depend on the initial state. when is true, then when the incrementor
    becomes less than 1/N, where N is the mumber of samples collected
    (and thus proportional to the data collection time, hence â€˜1 over
    tâ€™), then the Wang-Lambda incrementor is set to 1/N, decreasing
    every step. Once this occurs, is ignored, but the weights will still
    stop updating when the equilibration criteria set in is achieved.

```{=html}
<!-- -->
```

[ [ lmc-repeats ]{.pre} ]{.sig-name .descname}

:   \(1\) Controls the number of times that each Monte Carlo swap type
    is performed each iteration. In the limit of large numbers of Monte
    Carlo repeats, then all methods converge to Gibbs sampling. The
    value will generally not need to be different from 1.

```{=html}
<!-- -->
```

[ [ lmc-gibbsdelta ]{.pre} ]{.sig-name .descname}

:   (-1) Limit Gibbs sampling to selected numbers of neighboring states.
    For Gibbs sampling, it is sometimes inefficient to perform Gibbs
    sampling over all of the states that are defined. A positive value
    of means that only states plus or minus are considered in exchanges
    up and down. A value of -1 means that all states are considered. For
    less than 100 states, it is probably not that expensive to include
    all states.

```{=html}
<!-- -->
```

[ [ lmc-forced-nstart ]{.pre} ]{.sig-name .descname}

:   \(0\) Force initial state space sampling to generate weights. In
    order to come up with reasonable initial weights, this setting
    allows the simulation to drive from the initial to the final lambda
    state, with steps at each state before moving on to the next lambda
    state. If is sufficiently long (thousands of steps, perhaps), then
    the weights will be close to correct. However, in most cases, it is
    probably better to simply run the standard weight equilibration
    algorithms.

```{=html}
<!-- -->
```

[ [ nst-transition-matrix ]{.pre} ]{.sig-name .descname}

:   (-1) Frequency of outputting the expanded ensemble transition
    matrix. A negative number means it will only be printed at the end
    of the simulation.

```{=html}
<!-- -->
```

[ [ symmetrized-transition-matrix ]{.pre} ]{.sig-name .descname}

:   (no) Whether to symmetrize the empirical transition matrix. In the
    infinite limit the matrix will be symmetric, but will diverge with
    statistical noise for short timescales. Forced symmetrization, by
    using the matrix T_sym = 1/2 (T + transpose(T)), removes problems
    like the existence of (small magnitude) negative eigenvalues.

```{=html}
<!-- -->
```

[ [ mininum-var-min ]{.pre} ]{.sig-name .descname}

:   \(100\) The min-variance strategy (option of is only valid for
    larger number of samples, and can get stuck if too few samples are
    used at each state. is the minimum number of samples that each state
    that are allowed before the min-variance strategy is activated if
    selected.

```{=html}
<!-- -->
```

[ [ init-lambda-weights ]{.pre} ]{.sig-name .descname}

:   The initial weights (free energies) used for the expanded ensemble
    states. Default is a vector of zero weights. format is similar to
    the lambda vector settings in , except the weights can be any
    floating point number. Units are kT. Its length must match the
    lambda vector lengths.

```{=html}
<!-- -->
```

[ [ lmc-weights-equil ]{.pre} ]{.sig-name .descname}

:   

    [ [ no ]{.pre} ]{.sig-name .descname}

    :   Expanded ensemble weights continue to be updated throughout the
        simulation.

    [ [ yes ]{.pre} ]{.sig-name .descname}

    :   The input expanded ensemble weights are treated as equilibrated,
        and are not updated throughout the simulation.

    [ [ wl-delta ]{.pre} ]{.sig-name .descname}

    :   Expanded ensemble weight updating is stopped when the
        Wang-Landau incrementor falls below this value.

    [ [ number-all-lambda ]{.pre} ]{.sig-name .descname}

    :   Expanded ensemble weight updating is stopped when the number of
        samples at all of the lambda states is greater than this value.

    [ [ number-steps ]{.pre} ]{.sig-name .descname}

    :   Expanded ensemble weight updating is stopped when the number of
        steps is greater than the level specified by this value.

    [ [ number-samples ]{.pre} ]{.sig-name .descname}

    :   Expanded ensemble weight updating is stopped when the number of
        total samples across all lambda states is greater than the level
        specified by this value.

    [ [ count-ratio ]{.pre} ]{.sig-name .descname}

    :   Expanded ensemble weight updating is stopped when the ratio of
        samples at the least sampled lambda state and most sampled
        lambda state greater than this value.

```{=html}
<!-- -->
```

[ [ simulated-tempering ]{.pre} ]{.sig-name .descname}

:   (no) Turn simulated tempering on or off. Simulated tempering is
    implemented as expanded ensemble sampling with different
    temperatures instead of different Hamiltonians.

```{=html}
<!-- -->
```

[ [ sim-temp-low ]{.pre} ]{.sig-name .descname}

:   \(300\) \[K\] Low temperature for simulated tempering.

```{=html}
<!-- -->
```

[ [ sim-temp-high ]{.pre} ]{.sig-name .descname}

:   \(300\) \[K\] High temperature for simulated tempering.

```{=html}
<!-- -->
```

[ [ simulated-tempering-scaling ]{.pre} ]{.sig-name .descname}

:   Controls the way that the temperatures at intermediate lambdas are
    calculated from the part of the lambda vector.

    [ [ linear ]{.pre} ]{.sig-name .descname}

    :   Linearly interpolates the temperatures using the values of ,
        *i.e.* if =300, =400, then lambda=0.5 correspond to a
        temperature of 350. A nonlinear set of temperatures can always
        be implemented with uneven spacing in lambda.

    [ [ geometric ]{.pre} ]{.sig-name .descname}

    :   Interpolates temperatures geometrically between and . The i:th
        state has temperature \* ( / ) raised to the power of
        (i/(ntemps-1)). This should give roughly equal exchange for
        constant heat capacity, though of course things simulations that
        involve protein folding have very high heat capacity peaks.

    [ [ exponential ]{.pre} ]{.sig-name .descname}

    :   Interpolates temperatures exponentially between and . The i:th
        state has temperature + ( - )\*((exp( (i))-1)/(exp(1.0)-i)).
:::

::: {#non-equilibrium-md .section}
### Non-equilibrium MD

[ [ acc-grps ]{.pre} ]{.sig-name .descname}

:   groups for constant acceleration ( *e.g.* ` `{.docutils .literal
    .notranslate}[` Protein `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` Sol `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} ) all atoms
    in groups Protein and Sol will experience constant acceleration as
    specified in the line. Note that the kinetic energy of the center of
    mass of accelarated groups contributes to the kinetic energy and
    temperature of the system. If this is not desired, make each
    accelerate group also a separate temperature coupling group.

```{=html}
<!-- -->
```

[ [ accelerate ]{.pre} ]{.sig-name .descname}

:   \(0\) \[nm ps ^-2^ \] acceleration for ; x, y and z for each group (
    *e.g.* ` `{.docutils .literal .notranslate}[` 0.1 `{.docutils
    .literal .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` 0.0 `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` 0.0 `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` -0.1 `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` 0.0 `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` 0.0 `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} means that
    first group has constant acceleration of 0.1 nm ps ^-2^ in X
    direction, second group the opposite).

```{=html}
<!-- -->
```

[ [ freezegrps ]{.pre} ]{.sig-name .descname}

:   Groups that are to be frozen ( *i.e.* their X, Y, and/or Z position
    will not be updated; *e.g.* ` `{.docutils .literal
    .notranslate}[` Lipid `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` SOL `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} ).
    specifies for which dimension(s) the freezing applies. To avoid
    spurious contributions to the virial and pressure due to large
    forces between completely frozen atoms you need to use energy group
    exclusions, this also saves computing time. Note that coordinates of
    frozen atoms are not scaled by pressure-coupling algorithms.

```{=html}
<!-- -->
```

[ [ freezedim ]{.pre} ]{.sig-name .descname}

:   dimensions for which groups in should be frozen, specify
    ` `{.docutils .literal .notranslate}[` Y `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} or
    ` `{.docutils .literal .notranslate}[` N `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} for X, Y
    and Z and for each group ( *e.g.* ` `{.docutils .literal
    .notranslate}[` Y `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` Y `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` N `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` N `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` N `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` N `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} means that
    particles in the first group can move only in Z direction. The
    particles in the second group can move in any direction).

```{=html}
<!-- -->
```

[ [ cos-acceleration ]{.pre} ]{.sig-name .descname}

:   \(0\) \[nm ps ^-2^ \] the amplitude of the acceleration profile for
    calculating the viscosity. The acceleration is in the X-direction
    and the magnitude is cos(2 pi z/boxheight). Two terms are added to
    the energy file: the amplitude of the velocity profile and
    1/viscosity.

```{=html}
<!-- -->
```

[ [ deform ]{.pre} ]{.sig-name .descname}

:   (0 0 0 0 0 0) \[nm ps ^-1^ \] The velocities of deformation for the
    box elements: a(x) b(y) c(z) b(x) c(x) c(y). Each step the box
    elements for which is non-zero are calculated as:
    box(ts)+(t-ts)\*deform, off-diagonal elements are corrected for
    periodicity. The time ts is set to t at the first step and at steps
    at which x and v are written to trajectory to ensure exact restarts.
    Deformation can be used together with semiisotropic or anisotropic
    pressure coupling when the appropriate compressibilities are set to
    zero. The diagonal elements can be used to strain a solid. The
    off-diagonal elements can be used to shear a solid or a liquid. Note
    that the atom positions are not affected directly by this option.
    Instead, the deform option only modifies the velocities of particles
    that are shifted by a periodic box vector such that their new
    velocities match the virtual velocity flow field corresponding to
    the box deformation. As the deform option never accelerates the
    remaining particles in the system, the matching velocity flow field
    should be set up at the beginning of the simulation to make the
    particles follow the deformation. This can be done with the option.
    The flow field is removed from the kinetic energy by so the actual
    temperature and pressure of the system are reported.

```{=html}
<!-- -->
```

[ [ deform-init-flow ]{.pre} ]{.sig-name .descname}

:   

    [ [ no ]{.pre} ]{.sig-name .descname}

    :   Do not modify the velocities. Only use this option when the
        velocities of the atoms in the initial configuration already
        obey the flow field.

    [ [ yes ]{.pre} ]{.sig-name .descname}

    :   When the option is active, add a velocity profile corresponding
        to the box deformation to the initial velocities. This is done
        after computing observables from the initial state such as the
        initial tempature.
:::

::: {#electric-fields .section}
### Electric fields

[ [ electric-field-x ]{.pre} ]{.sig-name .descname}

:   

```{=html}
<!-- -->
```

[ [ electric-field-y ]{.pre} ]{.sig-name .descname}

:   

```{=html}
<!-- -->
```

[ [ electric-field-z ]{.pre} ]{.sig-name .descname}

:   Here you can specify an electric field that optionally can be
    alternating and pulsed. The general expression for the field has the
    form of a gaussian laser pulse:

    ::: {.math-wrapper .docutils .container}
    ::: {.math .notranslate .nohighlight}
    \\\[E(t) = E_0
    \\exp\\left\[-\\frac{(t-t_0)\^2}{2\\sigma\^2}\\right\]\\cos\\left\[\\omega
    (t-t_0)\\right\]\\\]
    :::
    :::

    For example, the four parameters for direction x are set in the
    fields of (and similar for ` `{.docutils .literal
    .notranslate}[` electric-field-y `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} and
    ` `{.docutils .literal .notranslate}[` electric-field-z `{.docutils
    .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} )
    like

    ` `{.docutils .literal .notranslate}[` electric-field-x `{.docutils
    .literal .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` = `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` E0 `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` omega `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` t0 `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` sigma `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate}

    with units (respectively) V nm ^-1^ , ps ^-1^ , ps, ps.

    In the special case that ` `{.docutils .literal
    .notranslate}[` sigma `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` = `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` 0 `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} , the
    exponential term is omitted and only the cosine term is used. In
    this case, ` `{.docutils .literal .notranslate}[` t0 `{.docutils
    .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}
    must be set to 0. If also ` `{.docutils .literal
    .notranslate}[` omega `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` = `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` 0 `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} a static
    electric field is applied.

    Read more at and in ref.Â .
:::

::: {#mixed-quantum-classical-molecular-dynamics .section}
### Mixed quantum/classical molecular dynamics

[ [ QMMM-grps ]{.pre} ]{.sig-name .descname}

:   groups to be described at the QM level for MiMiC QM/MM

```{=html}
<!-- -->
```

[ [ QMMM ]{.pre} ]{.sig-name .descname}

:   

    [ [ no ]{.pre} ]{.sig-name .descname}

    :   QM/MM is no longer supported via these .mdp options. For MiMic,
        use no here.
:::

::: {#computational-electrophysiology .section}
### Computational Electrophysiology

Use these options to switch on and control ion/water position exchanges
in â€œComputational Electrophysiologyâ€? simulation setups. (See the for
details).

[ [ swapcoords ]{.pre} ]{.sig-name .descname}

:   

    [ [ no ]{.pre} ]{.sig-name .descname}

    :   Do not enable ion/water position exchanges.

    [ [ X ]{.pre} [ ; ]{.pre} [ Y ]{.pre} [ ; ]{.pre} [ Z ]{.pre} ]{.sig-name .descname}

    :   Allow for ion/water position exchanges along the chosen
        direction. In a typical setup with the membranes parallel to the
        x-y plane, ion/water pairs need to be exchanged in Z direction
        to sustain the requested ion concentrations in the compartments.

```{=html}
<!-- -->
```

[ [ swap-frequency ]{.pre} ]{.sig-name .descname}

:   \(1\) The swap attempt frequency, i.e. every how many time steps the
    ion counts per compartment are determined and exchanges made if
    necessary. Normally it is not necessary to check at every time step.
    For typical Computational Electrophysiology setups, a value of about
    100 is sufficient and yields a negligible performance impact.

```{=html}
<!-- -->
```

[ [ split-group0 ]{.pre} ]{.sig-name .descname}

:   Name of the index group of the membrane-embedded part of channel #0.
    The center of mass of these atoms defines one of the compartment
    boundaries and should be chosen such that it is near the center of
    the membrane.

```{=html}
<!-- -->
```

[ [ split-group1 ]{.pre} ]{.sig-name .descname}

:   Channel #1 defines the position of the other compartment boundary.

```{=html}
<!-- -->
```

[ [ massw-split0 ]{.pre} ]{.sig-name .descname}

:   (no) Defines whether or not mass-weighting is used to calculate the
    split group center.

    [ [ no ]{.pre} ]{.sig-name .descname}

    :   Use the geometrical center.

    [ [ yes ]{.pre} ]{.sig-name .descname}

    :   Use the center of mass.

```{=html}
<!-- -->
```

[ [ massw-split1 ]{.pre} ]{.sig-name .descname}

:   (no) As above, but for split-group #1.

```{=html}
<!-- -->
```

[ [ solvent-group ]{.pre} ]{.sig-name .descname}

:   Name of the index group of solvent molecules.

```{=html}
<!-- -->
```

[ [ coupl-steps ]{.pre} ]{.sig-name .descname}

:   \(10\) Average the number of ions per compartment over these many
    swap attempt steps. This can be used to prevent that ions near a
    compartment boundary (diffusing through a channel, e.g.) lead to
    unwanted back and forth swaps.

```{=html}
<!-- -->
```

[ [ iontypes ]{.pre} ]{.sig-name .descname}

:   \(1\) The number of different ion types to be controlled. These are
    during the simulation exchanged with solvent molecules to reach the
    desired reference numbers.

```{=html}
<!-- -->
```

[ [ iontype0-name ]{.pre} ]{.sig-name .descname}

:   Name of the first ion type.

```{=html}
<!-- -->
```

[ [ iontype0-in-A ]{.pre} ]{.sig-name .descname}

:   (-1) Requested (=reference) number of ions of type 0 in
    compartment A. The default value of -1 means: use the number of ions
    as found in time step 0 as reference value.

```{=html}
<!-- -->
```

[ [ iontype0-in-B ]{.pre} ]{.sig-name .descname}

:   (-1) Reference number of ions of type 0 for compartment B.

```{=html}
<!-- -->
```

[ [ bulk-offsetA ]{.pre} ]{.sig-name .descname}

:   (0.0) Offset of the first swap layer from the compartment A
    midplane. By default (i.e. bulk offset = 0.0), ion/water exchanges
    happen between layers at maximum distance (= bulk concentration) to
    the split group layers. However, an offset b (-1.0 \< b \< +1.0) can
    be specified to offset the bulk layer from the middle at 0.0 towards
    one of the compartment-partitioning layers (at +/- 1.0).

```{=html}
<!-- -->
```

[ [ bulk-offsetB ]{.pre} ]{.sig-name .descname}

:   (0.0) Offset of the other swap layer from the compartment B
    midplane.

```{=html}
<!-- -->
```

[ [ threshold ]{.pre} ]{.sig-name .descname}

:   \(1\) Only swap ions if threshold difference to requested count is
    reached.

```{=html}
<!-- -->
```

[ [ cyl0-r ]{.pre} ]{.sig-name .descname}

:   (2.0) \[nm\] Radius of the split cylinder #0. Two split cylinders
    (mimicking the channel pores) can optionally be defined relative to
    the center of the split group. With the help of these cylinders it
    can be counted which ions have passed which channel. The split
    cylinder definition has no impact on whether or not ion/water swaps
    are done.

```{=html}
<!-- -->
```

[ [ cyl0-up ]{.pre} ]{.sig-name .descname}

:   (1.0) \[nm\] Upper extension of the split cylinder #0.

```{=html}
<!-- -->
```

[ [ cyl0-down ]{.pre} ]{.sig-name .descname}

:   (1.0) \[nm\] Lower extension of the split cylinder #0.

```{=html}
<!-- -->
```

[ [ cyl1-r ]{.pre} ]{.sig-name .descname}

:   (2.0) \[nm\] Radius of the split cylinder #1.

```{=html}
<!-- -->
```

[ [ cyl1-up ]{.pre} ]{.sig-name .descname}

:   (1.0) \[nm\] Upper extension of the split cylinder #1.

```{=html}
<!-- -->
```

[ [ cyl1-down ]{.pre} ]{.sig-name .descname}

:   (1.0) \[nm\] Lower extension of the split cylinder #1.
:::

::: {#density-guided-simulations .section}
### Density-guided simulations

These options enable and control the calculation and application of
additional forces that are derived from three-dimensional densities,
e.g., from cryo electron-microscopy experiments. (See the for details)

[ [ density-guided-simulation-active ]{.pre} ]{.sig-name .descname}

:   (no) Activate density-guided simulations.

```{=html}
<!-- -->
```

[ [ density-guided-simulation-group ]{.pre} ]{.sig-name .descname}

:   (protein) The atoms that are subject to the forces from the
    density-guided simulation and contribute to the simulated density.

```{=html}
<!-- -->
```

[ [ density-guided-simulation-similarity-measure ]{.pre} ]{.sig-name .descname}

:   (inner-product) Similarity measure between the density that is
    calculated from the atom positions and the reference density.

    [ [ inner-product ]{.pre} ]{.sig-name .descname}

    :   Takes the sum of the product of reference density and simulated
        density voxel values.

    [ [ relative-entropy ]{.pre} ]{.sig-name .descname}

    :   Uses the negative relative entropy (or Kullback-Leibler
        divergence) between reference density and simulated density as
        similarity measure. Negative density values are ignored.

    [ [ cross-correlation ]{.pre} ]{.sig-name .descname}

    :   Uses the Pearson correlation coefficient between reference
        density and simulated density as similarity measure.

```{=html}
<!-- -->
```

[ [ density-guided-simulation-atom-spreading-weight ]{.pre} ]{.sig-name .descname}

:   (unity) Determines the multiplication factor for the Gaussian kernel
    when spreading atoms on the grid.

    [ [ unity ]{.pre} ]{.sig-name .descname}

    :   Every atom in the density fitting group is assigned the same
        unit factor.

    [ [ mass ]{.pre} ]{.sig-name .descname}

    :   Atoms contribute to the simulated density proportional to their
        mass.

    [ [ charge ]{.pre} ]{.sig-name .descname}

    :   Atoms contribute to the simulated density proportional to their
        charge.

```{=html}
<!-- -->
```

[ [ density-guided-simulation-force-constant ]{.pre} ]{.sig-name .descname}

:   (1e+09) \[kJ mol ^-1^ \] The scaling factor for density-guided
    simulation forces. May also be negative.

```{=html}
<!-- -->
```

[ [ density-guided-simulation-gaussian-transform-spreading-width ]{.pre} ]{.sig-name .descname}

:   (0.2) \[nm\] The Gaussian RMS width for the spread kernel for the
    simulated density.

```{=html}
<!-- -->
```

[ [ density-guided-simulation-gaussian-transform-spreading-range-in-multiples-of-width ]{.pre} ]{.sig-name .descname}

:   \(4\) The range after which the gaussian is cut off in multiples of
    the Gaussian RMS width described above.

```{=html}
<!-- -->
```

[ [ density-guided-simulation-reference-density-filename ]{.pre} ]{.sig-name .descname}

:   (reference.mrc) Reference density file name using an absolute path
    or a path relative to the to the folder from which is called.

```{=html}
<!-- -->
```

[ [ density-guided-simulation-nst ]{.pre} ]{.sig-name .descname}

:   \(1\) Interval in steps at which the density fitting forces are
    evaluated and applied. The forces are scaled by this number when
    applied (See the for details).

```{=html}
<!-- -->
```

[ [ density-guided-simulation-normalize-densities ]{.pre} ]{.sig-name .descname}

:   (true) Normalize the sum of density voxel values to one for the
    reference density as well as the simulated density.

```{=html}
<!-- -->
```

[ [ density-guided-simulation-adaptive-force-scaling ]{.pre} ]{.sig-name .descname}

:   (false) Adapt the force constant to ensure a steady increase in
    similarity between simulated and reference density.

    [ [ true ]{.pre} ]{.sig-name .descname}

    :   Use adaptive force scaling.

```{=html}
<!-- -->
```

[ [ density-guided-simulation-adaptive-force-scaling-time-constant ]{.pre} ]{.sig-name .descname}

:   \(4\) \[ps\] Couple force constant to increase in similarity with
    reference density with this time constant. Larger times result in
    looser coupling.

```{=html}
<!-- -->
```

[ [ density-guided-simulation-shift-vector ]{.pre} ]{.sig-name .descname}

:   (0,0,0) \[nm\] Add this vector to all atoms in the
    density-guided-simulation-group before calculating forces and
    energies for density-guided-simulations. Affects only the
    density-guided-simulation forces and energies. Corresponds to a
    shift of the input density in the opposite direction by (-1) \*
    density-guided-simulation-shift-vector.

```{=html}
<!-- -->
```

[ [ density-guided-simulation-transformation-matrix ]{.pre} ]{.sig-name .descname}

:   (1,0,0,0,1,0,0,0,1) Multiply all atoms with this matrix in the
    density-guided-simulation-group before calculating forces and
    energies for density-guided-simulations. Affects only the
    density-guided-simulation forces and energies. Corresponds to a
    transformation of the input density by the inverse of this matrix.
    The matrix is given in row-major order. This option allows, e.g.,
    rotation of the density-guided atom group around the z-axis by [
    \\(\\theta\\) ]{.math .notranslate .nohighlight} degrees by using
    the following input: [ \\((\\cos \\theta , -\\sin \\theta , 0 ,
    \\sin \\theta , \\cos \\theta , 0 , 0 , 0 , 1)\\) ]{.math
    .notranslate .nohighlight} .
:::

::: {#qm-mm-simulations-with-cp2k-interface .section}
### QM/MM simulations with CP2K Interface

These options enable and control the calculation and application of
additional QM/MM forces that are computed by the CP2K package if it is
linked into GROMACS. For further details about QM/MM interface
implementation follow .

[ [ qmmm-cp2k-active ]{.pre} ]{.sig-name .descname}

:   (false) Activate QM/MM simulations. Requires CP2K to be linked with
    GROMACS

```{=html}
<!-- -->
```

[ [ qmmm-cp2k-qmgroup ]{.pre} ]{.sig-name .descname}

:   (System) Index group with atoms that are treated with QM.

```{=html}
<!-- -->
```

[ [ qmmm-cp2k-qmmethod ]{.pre} ]{.sig-name .descname}

:   (PBE) Method used to describe the QM part of the system.

    [ [ PBE ]{.pre} ]{.sig-name .descname}

    :   DFT using PBE functional and DZVP-MOLOPT basis set.

    [ [ BLYP ]{.pre} ]{.sig-name .descname}

    :   DFT using BLYP functional and DZVP-MOLOPT basis set.

    [ [ INPUT ]{.pre} ]{.sig-name .descname}

    :   Provide an external input file for CP2K when running with the
        ` `{.docutils .literal .notranslate}[` -qmi `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal .notranslate}
        command-line option. External input files are subject to the
        limitations that are described in .

```{=html}
<!-- -->
```

[ [ qmmm-cp2k-qmcharge ]{.pre} ]{.sig-name .descname}

:   0.  Total charge of the QM part.

```{=html}
<!-- -->
```

[ [ qmmm-cp2k-qmmultiplicity ]{.pre} ]{.sig-name .descname}

:   1.  Multiplicity or spin-state of QM part. Default value 1 means
        singlet state.

```{=html}
<!-- -->
```

[ [ qmmm-cp2k-qmfilenames ]{.pre} ]{.sig-name .descname}

:   () Names of the CP2K files that will be generated during the
    simulation. When using the default, empty, value the name of the
    simulation input file will be used with an additional ` `{.docutils
    .literal .notranslate}[` _cp2k `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} suffix.
:::

::: {#collective-variables-colvars-module .section}
[ ]{#mdp-colvars}

### Collective variables (Colvars) module

These options enable and control the features provided by the collective
variables (Colvars) module ( ), a software library for enhanced sampling
methods in molecular simulations. The Colvars module is described in
ref.Â as well as other references that are reported in the log file when
the corresponding features are used. For further details about Colvars
interface implementation follow .

[ [ colvars-active ]{.pre} ]{.sig-name .descname}

:   (false) Activate Colvars computation in the current run. Requires
    that the Colvars library was compiled with GROMACS, which is the
    default in a typical installation.

```{=html}
<!-- -->
```

[ [ colvars-configfile ]{.pre} ]{.sig-name .descname}

:   Name of the Colvars configuration file, using options specific to
    Colvars that are documented at: . The file name can be either an
    absolute path, or a path relative to the working directory when is
    called.

```{=html}
<!-- -->
```

[ [ colvars-seed ]{.pre} ]{.sig-name .descname}

:   (-1) \[integer\] Seed used to initialize the random generator
    associated with certain stochastic methods implemented within
    Colvars. The default value of -1 generates a random seed.

The current implementation of the Colvars-GROMACS interface gathers the
relevant atomic coordinates on one MPI rank, where all collective
variables and their forces are computed. Take this fact into account
when choosing how many atoms to include in selections.
:::

::: {#user-defined-thingies .section}
### User defined thingies

[ [ user1-grps ]{.pre} ]{.sig-name .descname}

:   

```{=html}
<!-- -->
```

[ [ user2-grps ]{.pre} ]{.sig-name .descname}

:   

```{=html}
<!-- -->
```

[ [ userint1 ]{.pre} [ (0) ]{.pre} ]{.sig-name .descname}

:   

```{=html}
<!-- -->
```

[ [ userint2 ]{.pre} [ (0) ]{.pre} ]{.sig-name .descname}

:   

```{=html}
<!-- -->
```

[ [ userint3 ]{.pre} [ (0) ]{.pre} ]{.sig-name .descname}

:   

```{=html}
<!-- -->
```

[ [ userint4 ]{.pre} [ (0) ]{.pre} ]{.sig-name .descname}

:   

```{=html}
<!-- -->
```

[ [ userreal1 ]{.pre} [ (0) ]{.pre} ]{.sig-name .descname}

:   

```{=html}
<!-- -->
```

[ [ userreal2 ]{.pre} [ (0) ]{.pre} ]{.sig-name .descname}

:   

```{=html}
<!-- -->
```

[ [ userreal3 ]{.pre} [ (0) ]{.pre} ]{.sig-name .descname}

:   

```{=html}
<!-- -->
```

[ [ userreal4 ]{.pre} [ (0) ]{.pre} ]{.sig-name .descname}

:   These you can use if you modify code. You can pass integers and
    reals and groups to your subroutine. Check the inputrec definition
    in ` `{.docutils .literal
    .notranslate}[` src/gromacs/mdtypes/inputrec.h `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate}
:::

::: {#removed-features .section}
### Removed features

These features have been removed from GROMACS, but so that old and files
cannot be mistakenly misused, we still parse this option. and will issue
a fatal error if this is set.

[ [ adress ]{.pre} ]{.sig-name .descname}

:   (no)

```{=html}
<!-- -->
```

[ [ implicit-solvent ]{.pre} ]{.sig-name .descname}

:   (no)
:::
:::
:::
::: {#molecular-dynamics-simulation-suite .section}
# molecular dynamics simulation suite

::: {#synopsis .section}
## Synopsis

``` literal-block
gmx [-[no]h] [-[no]quiet] [-[no]version] [-[no]copyright] [-nice <int>]
    [-[no]backup]
```
:::

::: {#description .section}
## Description

GROMACS is a full-featured suite of programs to perform molecular
dynamics simulations, i.e., to simulate the behavior of systems with
hundreds to millions of particles using Newtonian equations of motion.
It is primarily used for research on proteins, lipids, and polymers, but
can be applied to a wide variety of chemical and biological research
questions.
:::

::: {#options .section}
## Options

Other options:

` `{.docutils .literal .notranslate}[` -[no]h `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Print help and quit

` `{.docutils .literal .notranslate}[` -[no]quiet `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Do not print common startup info or quotes

` `{.docutils .literal .notranslate}[` -[no]version `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Print extended version information and quit

` `{.docutils .literal .notranslate}[` -[no]copyright `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (no)

:   Print copyright information on startup

` `{.docutils .literal .notranslate}[` -nice `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} \<int\> (19)

:   Set the nicelevel (default depends on command)

` `{.docutils .literal .notranslate}[` -[no]backup `{.docutils .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} (yes)

:   Write backups if output files exist
:::

::: {#gmx-commands .section}
## gmx commands

The following commands are available. Please refer to their individual
man pages or ` `{.docutils .literal .notranslate}[` gmx `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` help `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` <command> `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} for further
details.

::: {#trajectory-analysis .section}
### Trajectory analysis

*gmx-gangle(1)*

:   Calculate angles

*gmx-convert-trj(1)*

:   Converts between different trajectory types

*gmx-distance(1)*

:   Calculate distances between pairs of positions

*gmx-dssp(1)*

:   Calculate protein secondary structure via DSSP algorithm

*gmx-extract-cluster(1)*

:   Allows extracting frames corresponding to clusters from trajectory

*gmx-freevolume(1)*

:   Calculate free volume

*gmx-hbond(1)*

:   Compute and analyze hydrogen bonds.

*gmx-msd(1)*

:   Compute mean squared displacements

*gmx-pairdist(1)*

:   Calculate pairwise distances between groups of positions

*gmx-rdf(1)*

:   Calculate radial distribution functions

*gmx-sasa(1)*

:   Compute solvent accessible surface area

*gmx-scattering(1)*

:   Calculate small angle scattering profiles for SANS or SAXS

*gmx-select(1)*

:   Print general information about selections

*gmx-trajectory(1)*

:   Print coordinates, velocities, and/or forces for selections

*gmx-gyrate(1)*

:   Calculate radius of gyration of a molecule
:::

::: {#generating-topologies-and-coordinates .section}
### Generating topologies and coordinates

*gmx-editconf(1)*

:   Edit the box and write subgroups

*gmx-x2top(1)*

:   Generate a primitive topology from coordinates

*gmx-solvate(1)*

:   Solvate a system

*gmx-insert-molecules(1)*

:   Insert molecules into existing vacancies

*gmx-genconf(1)*

:   Multiply a conformation in â€˜randomâ€™ orientations

*gmx-genion(1)*

:   Generate monoatomic ions on energetically favorable positions

*gmx-genrestr(1)*

:   Generate position restraints or distance restraints for index groups

*gmx-pdb2gmx(1)*

:   Convert coordinate files to topology and FF-compliant coordinate
    files
:::

::: {#running-a-simulation .section}
### Running a simulation

*gmx-grompp(1)*

:   Make a run input file

*gmx-mdrun(1)*

:   Perform a simulation, do a normal mode analysis or an energy
    minimization

*gmx-convert-tpr(1)*

:   Make a modified run-input file
:::

::: {#viewing-trajectories .section}
### Viewing trajectories

*gmx-nmtraj(1)*

:   Generate a virtual oscillating trajectory from an eigenvector
:::

::: {#processing-energies .section}
### Processing energies

*gmx-enemat(1)*

:   Extract an energy matrix from an energy file

*gmx-energy(1)*

:   Writes energies to xvg files and display averages

*gmx-mdrun(1)*

:   (Re)calculate energies for trajectory frames with -rerun
:::

::: {#converting-files .section}
### Converting files

*gmx-editconf(1)*

:   Convert and manipulates structure files

*gmx-eneconv(1)*

:   Convert energy files

*gmx-sigeps(1)*

:   Convert c6/12 or c6/cn combinations to and from sigma/epsilon

*gmx-trjcat(1)*

:   Concatenate trajectory files

*gmx-trjconv(1)*

:   Convert and manipulates trajectory files

*gmx-xpm2ps(1)*

:   Convert XPM (XPixelMap) matrices to postscript or XPM
:::

::: {#tools .section}
### Tools

*gmx-analyze(1)*

:   Analyze data sets

*gmx-awh(1)*

:   Extract data from an accelerated weight histogram (AWH) run

*gmx-filter(1)*

:   Frequency filter trajectories, useful for making smooth movies

*gmx-lie(1)*

:   Estimate free energy from linear combinations

*gmx-pme_error(1)*

:   Estimate the error of using PME with a given input file

*gmx-sham(1)*

:   Compute free energies or other histograms from histograms

*gmx-spatial(1)*

:   Calculate the spatial distribution function

*gmx-traj(1)*

:   Plot x, v, f, box, temperature and rotational energy from
    trajectories

*gmx-tune_pme(1)*

:   Time mdrun as a function of PME ranks to optimize settings

*gmx-wham(1)*

:   Perform weighted histogram analysis after umbrella sampling

*gmx-check(1)*

:   Check and compare files

*gmx-dump(1)*

:   Make binary files human readable

*gmx-make_ndx(1)*

:   Make index files

*gmx-mk_angndx(1)*

:   Generate index files for â€˜gmx angleâ€™

*gmx-trjorder(1)*

:   Order molecules according to their distance to a group

*gmx-xpm2ps(1)*

:   Convert XPM (XPixelMap) matrices to postscript or XPM

*gmx-report-methods(1)*

:   Write short summary about the simulation setup to a text file and/or
    to the standard output.
:::

::: {#distances-between-structures .section}
### Distances between structures

*gmx-cluster(1)*

:   Cluster structures

*gmx-confrms(1)*

:   Fit two structures and calculates the RMSD

*gmx-rms(1)*

:   Calculate RMSDs with a reference structure and RMSD matrices

*gmx-rmsf(1)*

:   Calculate atomic fluctuations
:::

::: {#distances-in-structures-over-time .section}
### Distances in structures over time

*gmx-mindist(1)*

:   Calculate the minimum distance between two groups

*gmx-mdmat(1)*

:   Calculate residue contact maps

*gmx-polystat(1)*

:   Calculate static properties of polymers

*gmx-rmsdist(1)*

:   Calculate atom pair distances averaged with power -2, -3 or -6
:::

::: {#mass-distribution-properties-over-time .section}
### Mass distribution properties over time

*gmx-gyrate-legacy(1)*

:   Calculate the radius of gyration

*gmx-polystat(1)*

:   Calculate static properties of polymers

*gmx-rdf(1)*

:   Calculate radial distribution functions

*gmx-rotacf(1)*

:   Calculate the rotational correlation function for molecules

*gmx-rotmat(1)*

:   Plot the rotation matrix for fitting to a reference structure

*gmx-sans-legacy(1)*

:   Compute small angle neutron scattering spectra

*gmx-saxs-legacy(1)*

:   Compute small angle X-ray scattering spectra

*gmx-traj(1)*

:   Plot x, v, f, box, temperature and rotational energy from
    trajectories

*gmx-vanhove(1)*

:   Compute Van Hove displacement and correlation functions
:::

::: {#analyzing-bonded-interactions .section}
### Analyzing bonded interactions

*gmx-angle(1)*

:   Calculate distributions and correlations for angles and dihedrals

*gmx-mk_angndx(1)*

:   Generate index files for â€˜gmx angleâ€™
:::

::: {#structural-properties .section}
### Structural properties

*gmx-bundle(1)*

:   Analyze bundles of axes, e.g., helices

*gmx-clustsize(1)*

:   Calculate size distributions of atomic clusters

*gmx-disre(1)*

:   Analyze distance restraints

*gmx-hbond-legacy(1)*

:   Compute and analyze hydrogen bonds

*gmx-order(1)*

:   Compute the order parameter per atom for carbon tails

*gmx-principal(1)*

:   Calculate principal axes of inertia for a group of atoms

*gmx-rdf(1)*

:   Calculate radial distribution functions

*gmx-saltbr(1)*

:   Compute salt bridges

*gmx-sorient(1)*

:   Analyze solvent orientation around solutes

*gmx-spol(1)*

:   Analyze solvent dipole orientation and polarization around solutes
:::

::: {#kinetic-properties .section}
### Kinetic properties

*gmx-bar(1)*

:   Calculate free energy difference estimates through Bennettâ€™s
    acceptance ratio

*gmx-current(1)*

:   Calculate dielectric constants and current autocorrelation function

*gmx-dos(1)*

:   Analyze density of states and properties based on that

*gmx-dyecoupl(1)*

:   Extract dye dynamics from trajectories

*gmx-principal(1)*

:   Calculate principal axes of inertia for a group of atoms

*gmx-tcaf(1)*

:   Calculate viscosities of liquids

*gmx-traj(1)*

:   Plot x, v, f, box, temperature and rotational energy from
    trajectories

*gmx-vanhove(1)*

:   Compute Van Hove displacement and correlation functions

*gmx-velacc(1)*

:   Calculate velocity autocorrelation functions
:::

::: {#electrostatic-properties .section}
### Electrostatic properties

*gmx-current(1)*

:   Calculate dielectric constants and current autocorrelation function

*gmx-dielectric(1)*

:   Calculate frequency dependent dielectric constants

*gmx-dipoles(1)*

:   Compute the total dipole plus fluctuations

*gmx-potential(1)*

:   Calculate the electrostatic potential across the box

*gmx-spol(1)*

:   Analyze solvent dipole orientation and polarization around solutes

*gmx-genion(1)*

:   Generate monoatomic ions on energetically favorable positions
:::

::: {#protein-specific-analysis .section}
### Protein-specific analysis

*gmx-chi(1)*

:   Calculate everything you want to know about chi and other dihedrals

*gmx-helix(1)*

:   Calculate basic properties of alpha helices

*gmx-helixorient(1)*

:   Calculate local pitch/bending/rotation/orientation inside helices

*gmx-rama(1)*

:   Compute Ramachandran plots

*gmx-wheel(1)*

:   Plot helical wheels
:::

::: {#interfaces .section}
### Interfaces

*gmx-bundle(1)*

:   Analyze bundles of axes, e.g., helices

*gmx-density(1)*

:   Calculate the density of the system

*gmx-densmap(1)*

:   Calculate 2D planar or axial-radial density maps

*gmx-densorder(1)*

:   Calculate surface fluctuations

*gmx-h2order(1)*

:   Compute the orientation of water molecules

*gmx-hydorder(1)*

:   Compute tetrahedrality parameters around a given atom

*gmx-order(1)*

:   Compute the order parameter per atom for carbon tails

*gmx-potential(1)*

:   Calculate the electrostatic potential across the box
:::

::: {#covariance-analysis .section}
### Covariance analysis

*gmx-anaeig(1)*

:   Analyze the eigenvectors

*gmx-covar(1)*

:   Calculate and diagonalize the covariance matrix

*gmx-make_edi(1)*

:   Generate input files for essential dynamics sampling
:::

::: {#normal-modes .section}
### Normal modes

*gmx-anaeig(1)*

:   Analyze the normal modes

*gmx-nmeig(1)*

:   Diagonalize the Hessian for normal mode analysis

*gmx-nmtraj(1)*

:   Generate a virtual oscillating trajectory from an eigenvector

*gmx-nmens(1)*

:   Generate an ensemble of structures from the normal modes

*gmx-grompp(1)*

:   Make a run input file

*gmx-mdrun(1)*

:   Find a potential energy minimum and calculate the Hessian
:::
:::
:::
::: {#policy-for-deprecating-gromacs-functionality .section}
[ ]{#deprecation-policy}

# Policy for deprecating GROMACS functionality

Occasionally functionality ceases being useful, is unable to be fixed or
maintained, or its user interface needs to be improved. The development
team does this sparingly. Broken functionality might be removed without
notice if nobody willing to fix it can be found. Working functionality
will be changed only after announcing in the previous major release the
intent to remove and/or change the form of such functionality. Thus
there is typically a year for users and external tool providers to
prepare for such changes, and contact the GROMACS developers to see how
they might be affected and how best to adapt.

There is a current list of anticipated changes and deprecated
functionality in the â€œMajor releaseâ€? .

When environment variables are deprecated, it is up to the user to make
sure that their scripts are updated accordingly for the new release. In
cases where it is sensible, the development team should do the effort to
keep the old environment variables working for one extra release cycle,
before fully removing them. The user should be informed about this
future deprecation with a warning. If keeping the old environment
variable is not possible or highly problematic, setting the removed
environment variable should be triggering a warning during one release
cycle.
:::
::: {#security-when-using-gromacs .section}
# Security when using GROMACS

We advise the users of GROMACS to be careful when using GROMACS with
files obtained from an unknown source (e.g. the Internet).

We cannot guarantee that the program wonâ€™t crash with serious errors
that could cause execution of code with the same privileges as GROMACS
and e.g. delete the contents of your home directory.

Files that the user has created themselves donâ€™t carry those risks,
but may still misbehave and crash or consume large amounts of resources
upon malformed input.

Run input files obtained from outside sources should be treated with the
same caution as an executable file from the same source.
:::
::: {#selection-syntax-and-usage .section}
# Selection syntax and usage

Selections are used to select atoms/molecules/residues for analysis. In
contrast to traditional index files, selections can be dynamic, i.e.,
select different atoms for different trajectory frames. The GROMACS
manual contains a short introductory section to selections in the
Analysis chapter, including suggestions on how to get familiar with
selections if you are new to the concept. The subtopics listed below
provide more details on the technical and syntactic aspects of
selections.

Each analysis tool requires a different number of selections and the
selections are interpreted differently. The general idea is still the
same: each selection evaluates to a set of positions, where a position
can be an atom position or center-of-mass or center-of-geometry of a set
of atoms. The tool then uses these positions for its analysis to allow
very flexible processing. Some analysis tools may have limitations on
the types of selections allowed.

::: {#specifying-selections-from-command-line .section}
## Specifying selections from command line

If no selections are provided on the command line, you are prompted to
type the selections interactively (a pipe can also be used to provide
the selections in this case for most tools). While this works well for
testing, it is easier to provide the selections from the command line if
they are complex or for scripting.

Each tool has different command-line arguments for specifying selections
(see the help for the individual tools). You can either pass a single
string containing all selections (separated by semicolons), or multiple
strings, each containing one selection. Note that you need to quote the
selections to protect them from the shell.

If you set a selection command-line argument, but do not provide any
selections, you are prompted to type the selections for that argument
interactively. This is useful if that selection argument is optional, in
which case it is not normally prompted for.

To provide selections from a file, use ` `{.docutils .literal
.notranslate}[` -sf `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` file.dat `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} in the place of
the selection for a selection argument (e.g., ` `{.docutils .literal
.notranslate}[` -select `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` -sf `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` file.dat `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ). In general,
the ` `{.docutils .literal .notranslate}[` -sf `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} argument reads
selections from the provided file and assigns them to selection
arguments that have been specified up to that point, but for which no
selections have been provided. As a special case, ` `{.docutils .literal
.notranslate}[` -sf `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} provided on its
own, without preceding selection arguments, assigns the selections to
all (yet unset) required selections (i.e., those that would be promted
interactively if no selections are provided on the command line).

To use groups from a traditional index file, use argument ` `{.docutils
.literal .notranslate}[` -n `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} to provide a
file. See the â€œsyntaxâ€? subtopic for how to use them. If this option
is not provided, default groups are generated. The default groups are
generated with the same logic as for non-selection tools.

Depending on the tool, two additional command-line arguments may be
available to control the behavior:

-   ` `{.docutils .literal .notranslate}[` -seltype `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} can be used
    to specify the default type of positions to calculate for each
    selection.

-   ` `{.docutils .literal .notranslate}[` -selrpos `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} can be used
    to specify the default type of positions used in selecting atoms by
    coordinates.

See the â€œpositionsâ€? subtopic for more information on these options.

Tools that take selections apply them to a structure/topology and/or a
trajectory file. If the tool takes both (typically as ` `{.docutils
.literal .notranslate}[` -s `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} for
structure/topology and ` `{.docutils .literal
.notranslate}[` -f `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} for
trajectory), then the trajectory file is only used for coordinate
information, and all other information, such as atom names and residue
information, is read from the structure/topology file. If the tool only
takes a structure file, or if only that input parameter is provided,
then also the coordinates are taken from that file. For example, to
select atoms from a ` `{.docutils .literal
.notranslate}[` .pdb `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} / ` `{.docutils
.literal .notranslate}[` .gro `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} file in a tool
that provides both options, pass it as ` `{.docutils .literal
.notranslate}[` -s `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} (only). There
is no warning if the trajectory file specifies, e.g., different atom
names than the structure file. Only the number of atoms is checked. Many
selection-enabled tools also provide an ` `{.docutils .literal
.notranslate}[` -fgroup `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} option to
specify the atom indices that are present in the trajectory for cases
where the trajectory only has a subset of atoms from the
topology/structure file.
:::

::: {#selection-syntax .section}
## Selection syntax

A set of selections consists of one or more selections, separated by
semicolons. Each selection defines a set of positions for the analysis.
Each selection can also be preceded by a string that gives a name for
the selection for use in, e.g., graph legends. If no name is provided,
the string used for the selection is used automatically as the name.

For interactive input, the syntax is slightly altered: line breaks can
also be used to separate selections. followed by a line break can be
used to continue a line if necessary. Notice that the above only applies
to real interactive input, not if you provide the selections, e.g., from
a pipe.

It is possible to use variables to store selection expressions. A
variable is defined with the following syntax:

::: {.highlight-default .notranslate}
::: highlight
    VARNAME = EXPR ;
:::
:::

where ` `{.docutils .literal .notranslate}[` EXPR `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} is any valid
selection expression. After this, ` `{.docutils .literal
.notranslate}[` VARNAME `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} can be used
anywhere where ` `{.docutils .literal .notranslate}[` EXPR `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} would
be valid.

Selections are composed of three main types of expressions, those that
define atoms ( ` `{.docutils .literal
.notranslate}[` ATOM_EXPR `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ), those that
define positions ( ` `{.docutils .literal
.notranslate}[` POS_EXPR `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ), and those
that evaluate to numeric values ( ` `{.docutils .literal
.notranslate}[` NUM_EXPR `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ). Each
selection should be a ` `{.docutils .literal
.notranslate}[` POS_EXPR `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} or a
` `{.docutils .literal .notranslate}[` ATOM_EXPR `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} (the latter is
automatically converted to positions). The basic rules are as follows:

-   An expression like ` `{.docutils .literal
    .notranslate}[` NUM_EXPR1 `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` < `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` NUM_EXPR2 `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} evaluates
    to an ` `{.docutils .literal .notranslate}[` ATOM_EXPR `{.docutils
    .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}
    that selects all the atoms for which the comparison is true.

-   Atom expressions can be combined with boolean operations such as
    ` `{.docutils .literal .notranslate}[` not `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` ATOM_EXPR `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} ,
    ` `{.docutils .literal .notranslate}[` ATOM_EXPR `{.docutils
    .literal .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` and `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` ATOM_EXPR `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} , or
    ` `{.docutils .literal .notranslate}[` ATOM_EXPR `{.docutils
    .literal .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` or `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` ATOM_EXPR `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} .
    Parentheses can be used to alter the evaluation order.

-   ` `{.docutils .literal .notranslate}[` ATOM_EXPR `{.docutils
    .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}
    expressions can be converted into ` `{.docutils .literal
    .notranslate}[` POS_EXPR `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} expressions
    in various ways, see the â€œpositionsâ€? subtopic for more details.

-   ` `{.docutils .literal .notranslate}[` POS_EXPR `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} can be
    converted into ` `{.docutils .literal
    .notranslate}[` NUM_EXPR `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} using
    syntax like â€œ ` `{.docutils .literal .notranslate}[` x `{.docutils
    .literal .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` of `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` POS_EXPR `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} â€?.
    Currently, this is only supported for single positions like in
    expression â€œ ` `{.docutils .literal .notranslate}[` x `{.docutils
    .literal .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` of `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` cog `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` of `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` ATOM_EXPR `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} â€?.

Some keywords select atoms based on string values such as the atom name.
For these keywords, it is possible to use wildcards ( ` `{.docutils
.literal .notranslate}[` name `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` "C*" `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ) or regular
expressions (e.g., ` `{.docutils .literal
.notranslate}[` resname `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` "R[AB]" `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ). The match
type is automatically guessed from the string: if it contains other
characters than letters, numbers, â€˜\*â€™, or â€˜?â€™, it is
interpreted as a regular expression. To force the matching to use
literal string matching, use ` `{.docutils .literal
.notranslate}[` name `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate}[` = `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` "C*" `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} to match a
literal C\*. To force other type of matching, use â€˜?â€™ or â€˜\~â€™ in
place of â€˜=â€™ to force wildcard or regular expression matching,
respectively.

Strings that contain non-alphanumeric characters should be enclosed in
double quotes as in the examples. For other strings, the quotes are
optional, but if the value conflicts with a reserved keyword, a syntax
error will occur. If your strings contain uppercase letters, this should
not happen.

Index groups provided with the ` `{.docutils .literal
.notranslate}[` -n `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} command-line
option or generated by default can be accessed with ` `{.docutils
.literal .notranslate}[` group `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` NR `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} or
` `{.docutils .literal .notranslate}[` group `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` NAME `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , where
` `{.docutils .literal .notranslate}[` NR `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} is a zero-based
index of the group and ` `{.docutils .literal
.notranslate}[` NAME `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} is part of the
name of the desired group. The keyword ` `{.docutils .literal
.notranslate}[` group `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} is optional if
the whole selection is provided from an index group. To see a list of
available groups in the interactive mode, press enter in the beginning
of a line.
:::

::: {#specifying-positions-in-selections .section}
## Specifying positions in selections

Possible ways of specifying positions in selections are:

1.  A constant position can be defined as ` `{.docutils .literal
    .notranslate}[` [XX, `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` YY, `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` ZZ] `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} , where
    ` `{.docutils .literal .notranslate}[` XX `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} ,
    ` `{.docutils .literal .notranslate}[` YY `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} and
    ` `{.docutils .literal .notranslate}[` ZZ `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} are real
    numbers.

2.  ` `{.docutils .literal .notranslate}[` com `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` of `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` ATOM_EXPR `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` [pbc] `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} or
    ` `{.docutils .literal .notranslate}[` cog `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` of `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` ATOM_EXPR `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` [pbc] `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} calculate
    the center of mass/geometry of ` `{.docutils .literal
    .notranslate}[` ATOM_EXPR `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} . If
    ` `{.docutils .literal .notranslate}[` pbc `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} is
    specified, the center is calculated iteratively to try to deal with
    cases where ` `{.docutils .literal
    .notranslate}[` ATOM_EXPR `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} wraps
    around periodic boundary conditions.

3.  ` `{.docutils .literal .notranslate}[` POSTYPE `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` of `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` ATOM_EXPR `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} calculates
    the specified positions for the atoms in ` `{.docutils .literal
    .notranslate}[` ATOM_EXPR `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} .
    ` `{.docutils .literal .notranslate}[` POSTYPE `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} can be
    ` `{.docutils .literal .notranslate}[` atom `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} ,
    ` `{.docutils .literal .notranslate}[` res_com `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} ,
    ` `{.docutils .literal .notranslate}[` res_cog `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} ,
    ` `{.docutils .literal .notranslate}[` mol_com `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} or
    ` `{.docutils .literal .notranslate}[` mol_cog `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} , with an
    optional prefix ` `{.docutils .literal
    .notranslate}[` whole_ `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate}
    ` `{.docutils .literal .notranslate}[` part_ `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} or
    ` `{.docutils .literal .notranslate}[` dyn_ `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} .
    ` `{.docutils .literal .notranslate}[` whole_ `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} calculates
    the centers for the whole residue/molecule, even if only part of it
    is selected. ` `{.docutils .literal
    .notranslate}[` part_ `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} prefix
    calculates the centers for the selected atoms, but uses always the
    same atoms for the same residue/molecule. The used atoms are
    determined from the largest group allowed by the selection.
    ` `{.docutils .literal .notranslate}[` dyn_ `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} calculates
    the centers strictly only for the selected atoms. If no prefix is
    specified, whole selections default to ` `{.docutils .literal
    .notranslate}[` part_ `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} and other
    places default to ` `{.docutils .literal
    .notranslate}[` whole_ `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} . The
    latter is often desirable to select the same molecules in different
    tools, while the first is a compromise between speed ( ` `{.docutils
    .literal .notranslate}[` dyn_ `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} positions
    can be slower to evaluate than ` `{.docutils .literal
    .notranslate}[` part_ `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} ) and
    intuitive behavior.

4.  ` `{.docutils .literal .notranslate}[` ATOM_EXPR `{.docutils
    .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} ,
    when given for whole selections, is handled as 3. above, using the
    position type from the command-line argument ` `{.docutils .literal
    .notranslate}[` -seltype `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} .

Selection keywords that select atoms based on their positions, such as
` `{.docutils .literal .notranslate}[` dist `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` from `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , use by
default the positions defined by the ` `{.docutils .literal
.notranslate}[` -selrpos `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} command-line
option. This can be overridden by prepending a ` `{.docutils .literal
.notranslate}[` POSTYPE `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} specifier to
the keyword. For example, ` `{.docutils .literal
.notranslate}[` res_com `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` dist `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` from `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` POS `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} evaluates the
residue center of mass distances. In the example, all atoms of a residue
are either selected or not, based on the single distance calculated.
:::

::: {#arithmetic-expressions-in-selections .section}
## Arithmetic expressions in selections

Basic arithmetic evaluation is supported for numeric expressions.
Supported operations are addition, subtraction, negation,
multiplication, division, and exponentiation (using \^). Result of a
division by zero or other illegal operations is undefined.
:::

::: {#selection-keywords .section}
## Selection keywords

The following selection keywords are currently available. For keywords
marked with a plus, additional help is available through a subtopic
KEYWORD, where KEYWORD is the name of the keyword.

-   Keywords that select atoms by an integer property:

    ::: {.highlight-default .notranslate}
    ::: highlight
        atomnr
        mol (synonym for molindex)
        molecule (synonym for molindex)
        molindex
        resid (synonym for resnr)
        residue (synonym for resindex)
        resindex
        resnr
    :::
    :::

    (use in expressions or like â€œatomnr 1 to 5 7 9â€?)

-   Keywords that select atoms by a numeric property:

    ::: {.highlight-default .notranslate}
    ::: highlight
        beta (synonym for betafactor)
        betafactor
        charge
        distance from POS [cutoff REAL]
        distance from POS [cutoff REAL]
        mass
        mindistance from POS_EXPR [cutoff REAL]
        mindistance from POS_EXPR [cutoff REAL]
        occupancy
        x
        y
        z
    :::
    :::

    (use in expressions or like â€œoccupancy 0.5 to 1â€?)

-   Keywords that select atoms by a string property:

    ::: {.highlight-default .notranslate}
    ::: highlight
        altloc
        atomname
        atomtype
        chain
        insertcode
        name (synonym for atomname)
        pdbatomname
        pdbname (synonym for pdbatomname)
        resname
        type (synonym for atomtype)
    :::
    :::

    (use like â€œname PATTERN \[PATTERN\] â€¦â€?)

-   Additional keywords that directly select atoms:

    ::: {.highlight-default .notranslate}
    ::: highlight
        all
        insolidangle center POS span POS_EXPR [cutoff REAL]
        none
        same KEYWORD as ATOM_EXPR
        within REAL of POS_EXPR
    :::
    :::

-   Keywords that directly evaluate to positions:

    ::: {.highlight-default .notranslate}
    ::: highlight
        cog of ATOM_EXPR [pbc]
        com of ATOM_EXPR [pbc]
    :::
    :::

    (see also â€œpositionsâ€? subtopic)

-   Additional keywords:

    ::: {.highlight-default .notranslate}
    ::: highlight
        merge POSEXPR
        POSEXPR permute P1 ... PN
        plus POSEXPR
    :::
    :::

::: {#selecting-atoms-by-name-atomname-name-pdbatomname-pdbname .section}
### Selecting atoms by name - atomname, name, pdbatomname, pdbname

::: {.highlight-default .notranslate}
::: highlight
    name
    pdbname
    atomname
    pdbatomname
:::
:::

These keywords select atoms by name. ` `{.docutils .literal
.notranslate}[` name `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} selects atoms
using the GROMACS atom naming convention. For input formats other than
PDB, the atom names are matched exactly as they appear in the input
file. For PDB files, 4 character atom names that start with a digit are
matched after moving the digit to the end (e.g., to match 3HG2 from a
PDB file, use ` `{.docutils .literal .notranslate}[` name `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` HG23 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ).
` `{.docutils .literal .notranslate}[` pdbname `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} can only be
used with a PDB input file, and selects atoms based on the exact name
given in the input file, without the transformation described above.

` `{.docutils .literal .notranslate}[` atomname `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` pdbatomname `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} are synonyms
for the above two keywords.
:::

::: {#selecting-based-on-distance-dist-distance-mindist-mindistance-within .section}
### Selecting based on distance - dist, distance, mindist, mindistance, within

::: {.highlight-default .notranslate}
::: highlight
    distance from POS [cutoff REAL]
    mindistance from POS_EXPR [cutoff REAL]
    within REAL of POS_EXPR
:::
:::

` `{.docutils .literal .notranslate}[` distance `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` mindistance `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} calculate the
distance from the given position(s), the only difference being in that
` `{.docutils .literal .notranslate}[` distance `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} only accepts a
single position, while any number of positions can be given for
` `{.docutils .literal .notranslate}[` mindistance `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , which then
calculates the distance to the closest position. ` `{.docutils .literal
.notranslate}[` within `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} directly
selects atoms that are within ` `{.docutils .literal
.notranslate}[` REAL `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} of
` `{.docutils .literal .notranslate}[` POS_EXPR `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} .

For the first two keywords, it is possible to specify a cutoff to speed
up the evaluation: all distances above the specified cutoff are returned
as equal to the cutoff.
:::

::: {#selecting-atoms-in-a-solid-angle-insolidangle .section}
### Selecting atoms in a solid angle - insolidangle

::: {.highlight-default .notranslate}
::: highlight
    insolidangle center POS span POS_EXPR [cutoff REAL]
:::
:::

This keyword selects atoms that are within ` `{.docutils .literal
.notranslate}[` REAL `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} degrees
(default=5) of any position in ` `{.docutils .literal
.notranslate}[` POS_EXPR `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} as seen from
` `{.docutils .literal .notranslate}[` POS `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} a position
expression that evaluates to a single position), i.e., atoms in the
solid angle spanned by the positions in ` `{.docutils .literal
.notranslate}[` POS_EXPR `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and centered at
` `{.docutils .literal .notranslate}[` POS `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} .

Technically, the solid angle is constructed as a union of small cones
whose tip is at ` `{.docutils .literal .notranslate}[` POS `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} and
the axis goes through a point in ` `{.docutils .literal
.notranslate}[` POS_EXPR `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . There is such
a cone for each position in ` `{.docutils .literal
.notranslate}[` POS_EXPR `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} , and point is
in the solid angle if it lies within any of these cones. The cutoff
determines the width of the cones.
:::

::: {#merging-selections-merge-plus .section}
### Merging selections - merge, plus

::: {.highlight-default .notranslate}
::: highlight
    POSEXPR merge POSEXPR [stride INT]
    POSEXPR merge POSEXPR [merge POSEXPR ...]
    POSEXPR plus POSEXPR [plus POSEXPR ...]
:::
:::

Basic selection keywords can only create selections where each atom
occurs at most once. The ` `{.docutils .literal
.notranslate}[` merge `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and
` `{.docutils .literal .notranslate}[` plus `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} selection
keywords can be used to work around this limitation. Both create a
selection that contains the positions from all the given position
expressions, even if they contain duplicates. The difference between the
two is that ` `{.docutils .literal .notranslate}[` merge `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}
expects two or more selections with the same number of positions, and
the output contains the input positions selected from each expression in
turn, i.e., the output is like A1 B1 A2 B2 and so on. It is also
possible to merge selections of unequal size as long as the size of the
first is a multiple of the second one. The ` `{.docutils .literal
.notranslate}[` stride `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} parameter can
be used to explicitly provide this multiplicity. ` `{.docutils .literal
.notranslate}[` plus `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} simply
concatenates the positions after each other, and can work also with
selections of different sizes. These keywords are valid only at the
selection level, not in any subexpressions.
:::

::: {#permuting-selections-permute .section}
### Permuting selections - permute

::: {.highlight-default .notranslate}
::: highlight
    permute P1 ... PN
:::
:::

By default, all selections are evaluated such that the atom indices are
returned in ascending order. This can be changed by appending
` `{.docutils .literal .notranslate}[` permute `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` P1 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` P2 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` ... `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` PN `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} to an
expression. The ` `{.docutils .literal .notranslate}[` Pi `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} should
form a permutation of the numbers 1 to N. This keyword permutes each
N-position block in the selection such that the iâ€™th position in the
block becomes Piâ€™th. Note that it is the positions that are permuted,
not individual atoms. A fatal error occurs if the size of the selection
is not a multiple of n. It is only possible to permute the whole
selection expression, not any subexpressions, i.e., the ` `{.docutils
.literal .notranslate}[` permute `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} keyword should
appear last in a selection.
:::

::: {#selecting-atoms-by-residue-number-resid-residue-resindex-resnr .section}
### Selecting atoms by residue number - resid, residue, resindex, resnr

::: {.highlight-default .notranslate}
::: highlight
    resnr
    resid
    resindex
    residue
:::
:::

` `{.docutils .literal .notranslate}[` resnr `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} selects atoms
using the residue numbering in the input file. ` `{.docutils .literal
.notranslate}[` resid `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} is synonym for
this keyword for VMD compatibility.

` `{.docutils .literal .notranslate}[` resindex `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate}[` N `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}
selects the ` `{.docutils .literal .notranslate}[` N `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} th
residue starting from the beginning of the input file. This is useful
for uniquely identifying residues if there are duplicate numbers in the
input file (e.g., in multiple chains). ` `{.docutils .literal
.notranslate}[` residue `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} is a synonym
for ` `{.docutils .literal .notranslate}[` resindex `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . This allows
` `{.docutils .literal .notranslate}[` same `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` residue `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` as `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} to work as
expected.
:::

::: {#extending-selections-same .section}
### Extending selections - same

::: {.highlight-default .notranslate}
::: highlight
    same KEYWORD as ATOM_EXPR
:::
:::

The keyword ` `{.docutils .literal .notranslate}[` same `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} can be
used to select all atoms for which the given ` `{.docutils .literal
.notranslate}[` KEYWORD `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} matches any of
the atoms in ` `{.docutils .literal
.notranslate}[` ATOM_EXPR `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . Keywords that
evaluate to integer or string values are supported.
:::
:::

::: {#selection-evaluation-and-optimization .section}
## Selection evaluation and optimization

Boolean evaluation proceeds from left to right and is short-circuiting
i.e., as soon as it is known whether an atom will be selected, the
remaining expressions are not evaluated at all. This can be used to
optimize the selections: you should write the most restrictive and/or
the most inexpensive expressions first in boolean expressions. The
relative ordering between dynamic and static expressions does not
matter: all static expressions are evaluated only once, before the first
frame, and the result becomes the leftmost expression.

Another point for optimization is in common subexpressions: they are not
automatically recognized, but can be manually optimized by the use of
variables. This can have a big impact on the performance of complex
selections, in particular if you define several index groups like this:

::: {.highlight-default .notranslate}
::: highlight
    rdist = distance from com of resnr 1 to 5;
    resname RES and rdist < 2;
    resname RES and rdist < 4;
    resname RES and rdist < 6;
:::
:::

Without the variable assignment, the distances would be evaluated three
times, although they are exactly the same within each selection.
Anything assigned into a variable becomes a common subexpression that is
evaluated only once during a frame. Currently, in some cases the use of
variables can actually lead to a small performance loss because of the
checks necessary to determine for which atoms the expression has already
been evaluated, but this should not be a major problem.
:::

::: {#selection-limitations .section}
## Selection limitations

-   Some analysis programs may require a special structure for the input
    selections (e.g., some options of ` `{.docutils .literal
    .notranslate}[` gmx `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` gangle `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} require the
    index group to be made of groups of three or four atoms). For such
    programs, it is up to the user to provide a proper selection
    expression that always returns such positions.

-   All selection keywords select atoms in increasing order, i.e., you
    can consider them as set operations that in the end return the atoms
    in sorted numerical order. For example, the following selections
    select the same atoms in the same order:

    ::: {.highlight-default .notranslate}
    ::: highlight
        resname RA RB RC
        resname RB RC RA
    :::
    :::

    ::: {.highlight-default .notranslate}
    ::: highlight
        atomnr 10 11 12 13
        atomnr 12 13 10 11
        atomnr 10 to 13
        atomnr 13 to 10
    :::
    :::

    If you need atoms/positions in a different order, you can:

    -   use external index groups (for some static selections),

    -   use the ` `{.docutils .literal
        .notranslate}[` permute `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal .notranslate} keyword
        to change the final order, or

    -   use the ` `{.docutils .literal .notranslate}[` merge `{.docutils
        .literal .notranslate}]{.pre}` `{.docutils .literal
        .notranslate} or ` `{.docutils .literal
        .notranslate}[` plus `{.docutils .literal
        .notranslate}]{.pre}` `{.docutils .literal .notranslate}
        keywords to compose the final selection from multiple distinct
        selections.

-   Due to technical reasons, having a negative value as the first value
    in expressions like

    ::: {.highlight-default .notranslate}
    ::: highlight
        charge -1 to -0.7
    :::
    :::

    result in a syntax error. A workaround is to write

    ::: {.highlight-default .notranslate}
    ::: highlight
        charge {-1 to -0.7}
    :::
    :::

    instead.

-   When ` `{.docutils .literal .notranslate}[` name `{.docutils
    .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}
    selection keyword is used together with PDB input files, the
    behavior may be unintuitive. When GROMACS reads in a PDB file, 4
    character atom names that start with a digit are transformed such
    that, e.g., 1HG2 becomes HG21, and the latter is what is matched by
    the ` `{.docutils .literal .notranslate}[` name `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} keyword.
    Use ` `{.docutils .literal .notranslate}[` pdbname `{.docutils
    .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} to
    match the atom name as it appears in the input PDB file.
:::

::: {#selection-examples .section}
## Selection examples

Below, examples of different types of selections are given.

-   Selection of all water oxygens:

    ::: {.highlight-default .notranslate}
    ::: highlight
        resname SOL and name OW
    :::
    :::

-   Centers of mass of residues 1 to 5 and 10:

    ::: {.highlight-default .notranslate}
    ::: highlight
        res_com of resnr 1 to 5 10
    :::
    :::

-   All atoms farther than 1 nm of a fixed position:

    ::: {.highlight-default .notranslate}
    ::: highlight
        not within 1 of [1.2, 3.1, 2.4]
    :::
    :::

-   All atoms of a residue LIG within 0.5 nm of a protein (with a custom
    name):

    ::: {.highlight-default .notranslate}
    ::: highlight
        "Close to protein" resname LIG and within 0.5 of group "Protein"
    :::
    :::

-   All protein residues that have at least one atom within 0.5 nm of a
    residue LIG:

    ::: {.highlight-default .notranslate}
    ::: highlight
        group "Protein" and same residue as within 0.5 of resname LIG
    :::
    :::

-   All RES residues whose COM is between 2 and 4 nm from the COM of all
    of them:

    ::: {.highlight-default .notranslate}
    ::: highlight
        rdist = res_com distance from com of resname RES
        resname RES and rdist >= 2 and rdist <= 4
    :::
    :::

-   Selection like with duplicate atoms like C1 C2 C2 C3 C3 C4 â€¦ C8
    C9:

    ::: {.highlight-default .notranslate}
    ::: highlight
        name "C[1-8]" merge name "C[2-9]"
    :::
    :::

    This can be used with ` `{.docutils .literal
    .notranslate}[` gmx `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` distance `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} to compute
    C1-C2, C2-C3 etc. distances.

-   Selection with atoms in order C2 C1:

    ::: {.highlight-default .notranslate}
    ::: highlight
        name C1 C2 permute 2 1
    :::
    :::

    This can be used with ` `{.docutils .literal
    .notranslate}[` gmx `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` gangle `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} to get
    C2-\>C1 vectors instead of C1-\>C2.

-   Selection with COMs of two index groups:

    ::: {.highlight-default .notranslate}
    ::: highlight
        com of group 1 plus com of group 2
    :::
    :::

    This can be used with ` `{.docutils .literal
    .notranslate}[` gmx `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` distance `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} to compute
    the distance between these two COMs.

-   Fixed vector along x (can be used as a reference with ` `{.docutils
    .literal .notranslate}[` gmx `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` gangle `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} ):

    ::: {.highlight-default .notranslate}
    ::: highlight
        [0, 0, 0] plus [1, 0, 0]
    :::
    :::

-   The following examples explain the difference between the various
    position types. This selection selects a position for each residue
    where any of the three atoms C\[123\] has ` `{.docutils .literal
    .notranslate}[` x `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` < `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` 2 `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} . The
    positions are computed as the COM of all three atoms. This is the
    default behavior if you just write ` `{.docutils .literal
    .notranslate}[` res_com `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` of `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} .

    ::: {.highlight-default .notranslate}
    ::: highlight
        part_res_com of name C1 C2 C3 and x < 2
    :::
    :::

    This selection does the same, but the positions are computed as COM
    positions of whole residues:

    ::: {.highlight-default .notranslate}
    ::: highlight
        whole_res_com of name C1 C2 C3 and x < 2
    :::
    :::

    Finally, this selection selects the same residues, but the positions
    are computed as COM of exactly those atoms atoms that match the
    ` `{.docutils .literal .notranslate}[` x `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` < `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` 2 `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} criterion:

    ::: {.highlight-default .notranslate}
    ::: highlight
        dyn_res_com of name C1 C2 C3 and x < 2
    :::
    :::

-   Without the ` `{.docutils .literal .notranslate}[` of `{.docutils
    .literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}
    keyword, the default behavior is different from above, but otherwise
    the rules are the same:

    ::: {.highlight-default .notranslate}
    ::: highlight
        name C1 C2 C3 and res_com x < 2
    :::
    :::

    works as if ` `{.docutils .literal
    .notranslate}[` whole_res_com `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} was
    specified, and selects the three atoms from residues whose COM
    satisfiex ` `{.docutils .literal .notranslate}[` x `{.docutils
    .literal .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` < `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` 2 `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} . Using

    ::: {.highlight-default .notranslate}
    ::: highlight
        name C1 C2 C3 and part_res_com x < 2
    :::
    :::

    instead selects residues based on the COM computed from the C\[123\]
    atoms.
:::
:::
::: {#system-preparation .section}
[ ]{#gmx-sysprep}

# System preparation

::: {.toctree-wrapper .compound}
:::

There are many ways to prepare a simulation system to run with GROMACS.
These often vary with the kind of scientific question being considered,
or the model physics involved. A protein-ligand atomistic free-energy
simulation might need a multi-state topology, while a coarse-grained
simulation might need to manage defaults that suit systems with higher
density.

::: {#steps-to-consider .section}
## Steps to consider

The following general guidance should help with planning successful
simulations. Some stages are optional for some kinds of simulations.

1.  Clearly identify the property or phenomena of interest to be studied
    by performing the simulation. Do not continue further until you are
    clear on this! Do not run your simulation and then seek to work out
    how to use it to test your hypothesis, because it may be unsuitable,
    or the required information was not saved.

2.  Select the appropriate tools to be able to perform the simulation
    and observe the property or phenomena of interest. It is important
    to read and familiarize yourself with publications by other
    researchers on similar systems. Choices of tools include:

    -   software with which to perform the simulation (consideration of
        force field may influence this decision)

    -   the force field, which describes how the particles within the
        system interact with each other. Select one that is appropriate
        for the system being studied and the property or phenomena of
        interest. This is a very important and non-trivial step!
        Consider now how you will analyze your simulation data to make
        your observations.

3.  Obtain or generate the initial coordinate file for each molecule to
    be placed within the system. Many different software packages are
    able to build molecular structures and assemble them into suitable
    configurations.

4.  Generate the raw starting structure for the system by placing the
    molecules within the coordinate file as appropriate. Molecules may
    be specifically placed or arranged randomly. Several non-GROMACS
    tools are useful here; within GROMACS , and solve frequent problems.

5.  Obtain or generate the topology file for the system, using (for
    example) , , (for CHARMM forcefield), , (for GROMOS96 53A6) or your
    favourite text editor in concert with of the GROMACS . For the AMBER
    force fields, or might be appropriate.

6.  Describe a simulation box (e.g. using ) whose size is appropriate
    for the eventual density you would like, fill it with solvent (e.g.
    using ), and add any counter-ions needed to neutralize the system
    (e.g. using and ). In these steps you may need to edit your topology
    file to stay current with your coordinate file.

7.  Run an energy minimization on the system (using and ). This is
    required to sort out any bad starting structures caused during
    generation of the system, which may cause the production simulation
    to crash. It may be necessary also to minimize your solute structure
    in vacuo before introducing solvent molecules (or your lipid bilayer
    or whatever else). You should consider using flexible water models
    and not using bond constraints or frozen groups. The use of position
    restraints and/or distance restraints should be evaluated carefully.

8.  Select the appropriate simulation parameters for the equilibration
    simulation (defined in file). You need to choose simulation
    parameters that are consistent with how force field was derived. You
    may need to simulate at NVT with position restraints on your solvent
    and/or solute to get the temperature almost right, then relax to NPT
    to fix the density (which should be done with Berendsen until after
    the density is stabilized, before a further switch to a barostat
    that produces the correct ensemble), then move further (if needed)
    to reach your production simulation ensemble (e.g. NVT, NVE). If you
    have problems here with the system , consider using the suggestions
    on that page, e.g. position restraints on solutes, or not using bond
    constraints, or using smaller integration timesteps, or several
    gentler heating stage(s).

9.  Run the equilibration simulation for sufficient time so that the
    system relaxes sufficiently in the target ensemble to allow the
    production run to be commenced (using and , then and ).

10. Select the appropriate simulation parameters for the production
    simulation (defined in file). In particular, be careful not to
    re-generate the velocities. You still need to be consistent with how
    the force field was derived and how to measure the property or
    phenomena of interest.
:::

::: {#tips-and-tricks .section}
## Tips and tricks

::: {#database-files .section}
### Database files

The ` `{.docutils .literal .notranslate}[` share/top `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate}
directory of a GROMACS installation contains numerous plain-text helper
files with the ` `{.docutils .literal .notranslate}[` .dat `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} file
extension. Some of the command-line tools (see ) refer to these, and
each tool documents which files it uses, and how they are used.

If you need to modify these files (e.g. to introduce new atom types with
VDW radii into ` `{.docutils .literal
.notranslate}[` vdwradii.dat `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ), you can copy
the file from your installation directory into your working directory,
and the GROMACS tools will automatically load the copy from your working
directory rather than the standard one. To suppress all the standard
definitions, use an empty file in the working directory.
:::
:::
:::
::: {#terminology .section}
# Terminology

::: {#pressure .section}
[ ]{#gmx-pressure}

## Pressure

The pressure in molecular dynamics can be computed from the kinetic
energy and the virial.

::: {#fluctuation .section}
### Fluctuation

Whether or not pressure coupling is used within a simulation, the
pressure value for the simulation box will oscillate significantly.
Instantaneous pressure is meaningless, and not well-defined. Over a
picosecond time scale it usually will not be a good indicator of the
true pressure. This variation is entirely normal due to the fact that
pressure is a macroscopic property and can only be measured properly as
time average, while it is being measured and/or adjusted with pressure
coupling on the microscopic scale. How much it varies and the speed at
which it does depends on the number of atoms in the system, the type of
pressure coupling used and the value of the coupling constants.
Fluctuations of the order of hundreds of bar are typical. For a box of
216 waters, fluctuations of 500-600 bar are standard. Since the
fluctuations go down with the square root of the number of particles, a
system of 21600 water molecules (100 times larger) will still have
pressure fluctuations of 50-60 bar.
:::
:::

::: {#periodic-boundary-conditions .section}
[ ]{#gmx-pbc}

## Periodic boundary conditions

Periodic boundary conditions (PBC) are used in molecular dynamics
simulations to avoid problems with boundary effects caused by finite
size, and make the system more like an infinite one, at the cost of
possible periodicity effects.

Beginners visualizing a trajectory sometimes think they are observing a
problem when

-   the molecule(s) does not stay in the centre of the box, or

-   it appears that (parts of) the molecule(s) diffuse out of the box,
    or

-   holes are created, or

-   broken molecules appear, or

-   their unit cell was a rhombic dodecahedron or cubic octahedron but
    it looks like a slanted cube after the simulation, or

-   crazy bonds all across the simulation cell appear.

This is not a problem or error that is occurring, it is what you should
expect.

The existence of PBC means that any atom that leaves a simulation box
by, say, the right-hand face, then enters the simulation box by the
left-hand face. In the example of a large protein, if you look at the
face of the simulation box that is opposite to the one from which the
protein is protruding, then a hole in the solvent will be visible. The
reason that the molecule(s) move from where they were initially located
within the box is (for the vast majority of simulations) they are free
to diffuse around. And so they do. They are not held in a magic location
of the box. The box is not centered around anything while performing the
simulation. Molecules are not made whole as a matter of course.
Moreover, any periodic cell shape can be expressed as a parallelepiped
(a.k.a. triclinic cell), and GROMACS does so internally regardless of
the initial shape of the box.

These visual issues can be fixed after the conclusion of the simulation
by judicious use of the optional inputs to to process the trajectory
files. Similarly, analyses such as RMSD of atomic positions can be
flawed when a reference structure is compared with a structure that
needs adjusting for periodicity effects, and the solution with follows
the same lines. Some complex cases needing more than one operation will
require more than one invocation of in order to work.

For further information, see the corresponding section in the .

::: {#suggested-workflow .section}
### Suggested workflow

Fixing periodicity effects with to suit visualization or analysis can be
tricky. Multiple invocations can be necessary. You may need to create
custom index groups (e.g. to keep your ligand with your protein)
Following the steps below in order (omitting those not required) should
help get a pleasant result. You will need to consult ` `{.docutils
.literal .notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` trjconv `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` -h `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} to find out the
details for each step. Thatâ€™s deliberate â€" there is no magic â€œdo
what I wantâ€? recipe. You have to decide what you want, first. :-)

1.  First make your molecules whole if you want them whole.

2.  Cluster your molecules/particles if you want them clustered.

3.  If you want jumps removed, extract the first frame from the
    trajectory to use as the reference, and then use ` `{.docutils
    .literal .notranslate}[` -pbc `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` nojump `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} with that
    first frame as reference.

4.  Center your system using some criterion. Doing so shifts the system,
    so donâ€™t use ` `{.docutils .literal
    .notranslate}[` -pbc `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` nojump `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} after this
    step.

5.  Perhaps put everything in some box with the other ` `{.docutils
    .literal .notranslate}[` -pbc `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} or
    ` `{.docutils .literal .notranslate}[` -ur `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} options.

6.  Fit the resulting trajectory to some (other) reference structure (if
    desired), and donâ€™t use any PBC related option afterwards.

With point three, the issue is that removes the jumps from the first
frame using the reference structure provided with -s. If the reference
structure (run input file) is not clustered/whole, using ` `{.docutils
.literal .notranslate}[` -pbc `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` nojump `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} will undo steps
1 and 2.
:::
:::

::: {#thermostats .section}
[ ]{#gmx-thermostats}

## Thermostats

Thermostats are designed to help a simulation sample from the correct
ensemble (i.e. NVT or NPT) by modulating the temperature of the system
in some fashion. First, we need to establish what we mean by
temperature. In simulations, the â€œinstantaneous (kinetic)
temperatureâ€? is usually computed from the kinetic energy of the system
using the equipartition theorem. In other words, the temperature is
computed from the systemâ€™s total kinetic energy.

So, whatâ€™s the goal of a thermostat? Actually, it turns out the goal
is not to keep the temperature constant, as that would mean fixing the
total kinetic energy, which would be silly and not the aim of NVT or
NPT. Rather, itâ€™s to ensure that the average temperature of a system
be correct.

To see why this is the case, imagine a glass of water sitting in a room.
Suppose you can look very closely at a few molecules in some small
region of the glass, and measure their kinetic energies. You would not
expect the kinetic energy of this small number of particles to remain
precisely constant; rather, youâ€™d expect fluctuations in the kinetic
energy due to the small number of particles. As you average over larger
and larger numbers of particles, the fluctuations in the average get
smaller and smaller, so finally by the time you look at the whole glass,
you say it has â€œconstant temperatureâ€?.

Molecular dynamics simulations are often fairly small compared to a
glass of water, so we have bigger fluctuations. So itâ€™s really more
appropriate here to think of the role of a thermostat as ensuring that
we have

1.  the correct average temperature, and

2.  the fluctuations of the correct size.

See the relevant section in the for details on how temperature coupling
is applied and the types currently available.

::: {#what-to-do .section}
[ ]{#gmx-thermostats-do}

### What to do

Some hints on practices that generally are a good idea:

-   Preferably, use a thermostat that samples the correct distribution
    of temperatures (for examples, see the corresponding manual
    section), in addition to giving you the correct average temperature.

-   At least: use a thermostat that gives you the correct average
    temperature, and apply it to components of your system for which
    they are justified (see the first bullet in ). In some cases, using
    ` `{.docutils .literal .notranslate}[` tc-grps `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` = `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` System `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} may lead to
    the â€œhot solvent/cold soluteâ€? problem described in the 3rd
    reference in .
:::

::: {#what-not-to-do .section}
[ ]{#gmx-thermostats-dont}

### What not to do

Some hints on practices that generally not a good idea to use:

-   Do not use separate thermostats for every component of your system.
    Some molecular dynamics thermostats only work well in the
    thermodynamic limit. A group must be of sufficient size to justify
    its own thermostat. If you use one thermostat for, say, a small
    molecule, another for protein, and another for water, you are likely
    introducing errors and artifacts that are hard to predict. In
    particular, do not couple ions in aqueous solvent in a separate
    group from that solvent. For a protein simulation, using
    ` `{.docutils .literal .notranslate}[` tc-grps `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` = `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` Protein `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` Non-Protein `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} is usually
    best.

-   Do not use thermostats that work well only in the limit of a large
    number of degrees of freedom for systems with few degrees of
    freedom. For example, do not use NosÃ©-Hoover or Berendsen
    thermostats for types of free energy calculations where you will
    have a component of the system with very few degrees of freedom in
    an end state (i.e. a noninteracting small molecule).
:::

::: {#further-reading .section}
### Further reading

1.  Cheng, A. & Merz, K. M. Application of the NosÃ©-Hoover chain
    algorithm to the study of protein dynamics. *J. Phys. Chem.* **100**
    (5), 1927â€"1937 ( ).

2.  Mor, A., Ziv, G. & Levy, Y. Simulations of proteins with
    inhomogeneous degrees of freedom: the effect of thermostats. *J.
    Comput. Chem.* **29** (12), 1992â€"1998 ( ).

3.  Lingenheil, M., Denschlag, R., Reichold, R. & Tavan, P. The
    â€œhot-solvent/cold-soluteâ€? problem revisited. *J. Chem. Theory
    Comput.* **4** (8), 1293â€"1306 ( ).
:::
:::

::: {#energy-conservation .section}
## Energy conservation

In principle, a molecular dynamics simulation should conserve the total
energy, the total momentum and (in a non-periodic system) the total
angular momentum. A number of algorithmic and numerical issues make that
this is not always the case:

-   Cut-off treatment and/or long-range electrostatics treatment (see
    Van Der Spoel, D. & van Maaren, P. J. The origin of layer structure
    artifacts in simulations of liquid water. *J. Chem. Theor. Comp.*
    **2** , 1â€"11 ( ).)

-   Treatment of pair lists,

-   Constraint algorithms (see e.g. Hess, B. P-LINCS: A parallel linear
    constraint solver for molecular simulation. *J. Chem. Theor. Comp.*
    **4** , 116â€"122 ( ).).

-   The integration timestep.

-   and .

-   Round-off error (in particular in single precision), for example
    subtracting large numbers (Lippert, R. A. et al. A common, avoidable
    source of error in molecular dynamics integrators. *J. Chem. Phys.*
    **126** , 046101 ( ).).

-   The choice of the integration algorithm (in GROMACS this is normally
    leap-frog).

-   Removal of center of mass motion: when doing this in more than one
    group the conservation of energy will be violated.
:::

::: {#average-structure .section}
## Average structure

Various GROMACS utilities can compute average structures. Presumably the
idea for this comes from something like an ensemble-average NMR
structure. In some cases, it makes sense to calculate an average
structure (as a step on the way to calculating root-mean-squared
fluctuations (RMSF), for example, one needs the average position of all
of the atoms).

However, itâ€™s important to remember that an average structure isnâ€™t
necessarily meaningful. By way of analogy, suppose I alternate holding a
ball in my left hand, then in my right hand. Whatâ€™s the average
position of the ball? Halfway in between â€" even though I always have
it either in my left hand or my right hand. Similarly, for structures,
averages will tend to be meaningless anytime there are separate
metastable conformational states. This can happen on a sidechain level,
or for some regions of backbone, or even whole helices or components of
the secondary structure.

Thus, if you derive an average structure from a molecular dynamics
simulation, and find artifacts like unphysical bond lengths, weird
structures, etc., this doesnâ€™t necessarily mean something is wrong. It
just shows the above: an average structure from a simulation is not
necessarily a physically meaningful structure.
:::

::: {#blowing-up .section}
[ ]{#id5}

## Blowing up

*Blowing up* is a highly technical term used to describe a common sort
of simulation failure. In brief, it describes a failure typically due to
an unacceptably large force that ends up resulting in a failure of the
integrator.

To give a bit more background, itâ€™s important to remember that
molecular dynamics numerically integrates Newtonâ€™s equations of motion
by taking small, discrete timesteps, and using these timesteps to
determine new velocities and positions from velocities, positions, and
forces at the previous timestep. If forces become too large at one
timestep, this can result in extremely large changes in
velocity/position when going to the next timestep. Typically, this will
result in a cascade of errors: one atom experiences a very large force
one timestep, and thus goes shooting across the system in an
uncontrolled way in the next timestep, overshooting its preferred
location or landing on top of another atom or something similar. This
then results in even larger forces the next timestep, more uncontrolled
motions, and so on. Ultimately, this will cause the simulation package
to crash in some way, since it canâ€™t cope with such situations. In
simulations with constraints, the first symptom of this will usually be
some LINCS or SHAKE warning or error â€" not because the constraints are
the source of the problem, but just because theyâ€™re the first thing to
crash. Similarly, in simulations with domain decomposition, you may see
messages about particles being more than a cell length out of the domain
decomposition cell of their charge group, which are symptomatic of your
underlying problem, and not the domain decomposition algorithm itself.
Likewise for warnings about tabulated or 1-4 interactions being outside
the distance supported by the table. This can happen on one computer
system while another resulted in a stable simulation because of the
impossibility of numerical reproducibility of these calculations on
different computer systems.

Possible causes include:

-   you didnâ€™t minimize well enough,

-   you have a bad starting structure, perhaps with steric clashes,

-   you are using too large a timestep (particularly given your choice
    of constraints),

-   you are doing particle insertion in free energy calculations without
    using soft core,

-   you are using inappropriate pressure coupling (e.g. when you are not
    in equilibrium, Berendsen can be best while relaxing the volume, but
    you will need to switch to a more accurate pressure-coupling
    algorithm later),

-   you are using inappropriate temperature coupling, perhaps on
    inappropriate groups, or

-   your position restraints are to coordinates too different from those
    present in the system, or

-   you have a single water molecule somewhere within the system that is
    isolated from the other water molecules, or

-   you are experiencing a bug in .

Because blowing up is due, typically, to forces that are too large for a
particular timestep size, there are a couple of basic solutions:

-   make sure the forces donâ€™t get that large, or

-   use a smaller timestep.

Better system preparation is a way to make sure that forces donâ€™t get
large, if the problems are occurring near the beginning of a simulation.
:::

::: {#diagnosing-an-unstable-system .section}
[ ]{#system-diagnosis}

## Diagnosing an unstable system

Troubleshooting a system that is blowing up can be challenging,
especially for an inexperienced user. Here are a few general tips that
one may find useful when addressing such a scenario:

1.  If the crash is happening relatively early (within a few steps), set
    ` `{.docutils .literal .notranslate}[` nstxout `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} (or
    ` `{.docutils .literal
    .notranslate}[` nstxout-compressed `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} ) to 1,
    capturing all possible frames. Watch the resulting trajectory to see
    which atoms/residues/molecules become unstable first.

2.  Simplify the problem to try to establish a cause:

    -   If you have a new box of solvent, try minimizing and simulating
        a single molecule to see if the instability is due to some
        inherent problem with the moleculeâ€™s topology or if instead
        there are clashes in your starting configuration.

    -   If you have a protein-ligand system, try simulating the protein
        alone in the desired solvent. If it is stable, simulate the
        ligand in vacuo to see if its topology gives stable
        configurations, energies, etc.

    -   Remove the use of fancy algorithms, particularly if you
        havenâ€™t equilibrated thoroughly first

3.  Monitor various components of the systemâ€™s energy using . If an
    intramolecular term is spiking, that may indicate improper bonded
    parameters, for example.

4.  Make sure you havenâ€™t been ignoring error messages (missing atoms
    when running , mismatching names when running , etc.) or using
    work-arounds (like using ` `{.docutils .literal
    .notranslate}[` gmx `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` grompp `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[` -maxwarn `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} when you
    shouldnâ€™t be) to make sure your topology is intact and being
    interpreted correctly.

5.  Make sure you are using appropriate settings in your file for the
    force field you have chosen and the type of system you have.
    Particularly important settings are treatment of cutoffs, proper
    neighbor searching interval ( ` `{.docutils .literal
    .notranslate}[` nstlist `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} ), and
    temperature coupling. Improper settings can lead to a breakdown in
    the model physics, even if the starting configuration of the system
    is reasonable.

When using no explict solvent, starting your equilibration with a
smaller time step than your production run can help energy equipartition
more stably.

There are several common situations in which instability frequently
arises, usually in the introduction of new species (ligands or other
molecules) into the system. To determine the source of the problem,
simplify the system (e.g. the case of a protein-ligand complex) in the
following way.

1.  Does the protein (in water) minimize adequately by itself? This is a
    test of the integrity of the coordinates and system preparation. If
    this fails, something probably went wrong when running (see below),
    or maybe placed an ion very close to the protein (it is random,
    after all).

2.  Does the ligand minimize in vacuo? This is a test of the topology.
    If it does not, check your parameterization of the ligand and any
    implementation of new parameters in force field files.

3.  (If previous item is successful) Does the ligand minimize in water,
    and/or does a short simulation of the ligand in water succeed?

Other sources of possible problems are in the biomolecule topology
itself.

1.  Did you use ` `{.docutils .literal
    .notranslate}[` -missing `{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal .notranslate} when
    running ? If so, donâ€™t. Reconstruct missing coordinates rather
    than ignoring them.

2.  Did you override long/short bond warnings by changing the lengths?
    If so, donâ€™t. You probably have missing atoms or some terrible
    input geometry.
:::

::: {#molecular-dynamics .section}
[ ]{#gmx-md}

## Molecular dynamics

Molecular dynamics (MD) is computer simulation with atoms and/or
molecules interacting using some basic laws of physics. The GROMACS
provides a good general introduction to this area, as well as specific
material for use with GROMACS. The first few chapters are mandatory
reading for anybody wishing to use GROMACS and not waste time.

-   Introduction to molecular modeling ( , )\] - theoretical framework,
    modeling levels, limitations and possibilities, systems and methods
    (Erik Lindahl).

::: {#books .section}
### Books

There are several text books around.

Good introductory books are:

-   A. Leach (2001) Molecular Modeling: Principles and Applications.

-   T. Schlick (2002) Molecular Modeling and Simulation

With programming background:

-   D. Rapaport (1996) The Art of Molecular Dynamics Simulation

-   D. Frenkel, B. Smith (2001) Understanding Molecular Simulation

More from the physicistâ€™s view:

-   M. Allen, D. Tildesley (1989) Computer simulation of liquids

-   H.J.C. Berendsen (2007) Simulating the Physical World: Hierarchical
    Modeling from Quantum Mechanics to Fluid Dynamics
:::

::: {#types-ensembles .section}
### Types / Ensembles

-   NVE - number of particles (N), system volume (V) and energy (E) are
    constant / conserved.

-   NVT - number of particles (N), system volume (V) and temperature (T)
    are constant / conserved. (See for more on *constant* temperature).

-   NPT - number of particles (N), system pressure (P) and
    temperature (T) are constant / conserved. (See for more on
    *constant* pressure).
:::
:::

::: {#force-field .section}
[ ]{#gmx-force-field}

## Force field

Force fields are sets of potential functions and parametrized
interactions that can be used to study physical systems. A general
introduction to their history, function and use is beyond the scope of
this guide, and the user is asked to consult either the relevant
literature or try to start at the relevant .
:::
:::
::: {#useful-mdrun-features .section}
# Useful mdrun features

This section discusses features in that donâ€™t fit well elsewhere.

::: {#re-running-a-simulation .section}
[ ]{#single-point-energy}

## Re-running a simulation

The rerun feature allows you to take any trajectory file ` `{.docutils
.literal .notranslate}[` traj.trr `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} and compute
quantities based upon the coordinates in that file using the model
physics supplied in the ` `{.docutils .literal
.notranslate}[` topol.tpr `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} file. It can be
used with command lines like ` `{.docutils .literal
.notranslate}[` mdrun `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` -s `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` topol `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` -rerun `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` traj.trr `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . That could be
different from the one that generated the trajectory. This can be used
to compute the energy or forces for exactly the coordinates supplied as
input, or to extract quantities based on subsets of the molecular system
(see and ). It is easier to do a correct â€œsingle-pointâ€? energy
evaluation with this feature than a 0-step simulation.

Neighbor searching is performed for every frame in the trajectory
independently of the value in , since can no longer assume anything
about how the structures were generated. Naturally, no update or
constraint algorithms are ever used.

The rerun feature cannot, in general, compute many of the quantities
reported during full simulations. It does only take positions as input
(ignoring potentially present velocities), and does only report
potential energies, volume and density, dH/dl terms, and restraint
information. It does notably not report kinetic, total or conserved
energy, temperature, virial or pressure.
:::

::: {#running-a-simulation-in-reproducible-mode .section}
## Running a simulation in reproducible mode

It is generally difficult to run an efficient parallel MD simulation
that is based primarily on floating-point arithmetic and is fully
reproducible. By default, will observe how things are going and vary how
the simulation is conducted in order to optimize throughput. However,
there is a â€œreproducible modeâ€? available with ` `{.docutils .literal
.notranslate}[` mdrun `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` -reprod `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} that will
systematically eliminate all sources of variation within that run;
repeated invocations on the same input and hardware will be binary
identical. However, running in this mode on different hardware, or with
a different compiler, etc. will not be reproducible. This should
normally only be used when investigating possible problems.
:::

::: {#halting-running-simulations .section}
## Halting running simulations

When receives a TERM or INT signal (e.g. when ctrl+C is pressed), it
will stop at the next neighbor search step or at the second global
communication step, whichever happens later. When receives a second TERM
or INT signal and reproducibility is not requested, it will stop at the
first global communication step. In both cases all the usual output will
be written to file and a checkpoint file is written at the last step.
When receives an ABRT signal or the third TERM or INT signal, it will
abort directly without writing a new checkpoint file. When running with
MPI, a signal to one of the ranks is sufficient, this signal should not
be sent to mpirun or the process that is the parent of the others.
:::

::: {#running-multi-simulations .section}
## Running multi-simulations

There are numerous situations where running a related set of simulations
within the same invocation of mdrun are necessary or useful. Running a
replica-exchange simulation requires it, as do simulations using
ensemble-based distance or orientation restraints. Running a related
series of lambda points for a free-energy computation is also convenient
to do this way, but beware of the potential side-effects related to
resource utilization and load balance discussed later.

This feature requires configuring GROMACS with an so that the set of
simulations can communicate. The ` `{.docutils .literal
.notranslate}[` n `{.docutils .literal .notranslate}]{.pre}` `{.docutils
.literal .notranslate} simulations within the set can use internal MPI
parallelism also, so that ` `{.docutils .literal
.notranslate}[` mpirun `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` -np `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate}[` x `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` gmx_mpi `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` mdrun `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} for
` `{.docutils .literal .notranslate}[` x `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} a multiple of
` `{.docutils .literal .notranslate}[` n `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} will use
` `{.docutils .literal .notranslate}[` x/n `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ranks per
simulation.

To launch a multi-simulation, the ` `{.docutils .literal
.notranslate}[` -multidir `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} option is used.
For the input and output files of a multi-simulation a set of
` `{.docutils .literal .notranslate}[` n `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} subdirectories
is required, one for each simulation. Place all the relevant input files
in those directories (e.g. named ` `{.docutils .literal
.notranslate}[` topol.tpr `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} ), and launch a
multi-simualtion with ` `{.docutils .literal
.notranslate}[` mpirun `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` -np `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate}[` x `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` gmx_mpi `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` mdrun `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` -s `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` topol `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` -multidir `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` <names-of-directories> `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . If the order
of the simulations within the multi-simulation is significant, you are
responsible for ordering their names when you provide them to
` `{.docutils .literal .notranslate}[` -multidir `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . Be careful
with shells that do filename globbing dictionary-style, e.g.
` `{.docutils .literal .notranslate}[` dir1 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` dir10 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` dir11 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` ... `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` dir2 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` ... `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} .

::: {#examples-running-multi-simulations .section}
### Examples running multi-simulations

::: {.highlight-default .notranslate}
::: highlight
    mpirun -np 32 gmx_mpi mdrun -multidir a b c d
:::
:::

Starts a multi-simulation on 32 ranks with 4 simulations. The input and
output files are found in directories ` `{.docutils .literal
.notranslate}[` a `{.docutils .literal .notranslate}]{.pre}` `{.docutils
.literal .notranslate} , ` `{.docutils .literal
.notranslate}[` b `{.docutils .literal .notranslate}]{.pre}` `{.docutils
.literal .notranslate} , ` `{.docutils .literal
.notranslate}[` c `{.docutils .literal .notranslate}]{.pre}` `{.docutils
.literal .notranslate} , and ` `{.docutils .literal
.notranslate}[` d `{.docutils .literal .notranslate}]{.pre}` `{.docutils
.literal .notranslate} .

::: {.highlight-default .notranslate}
::: highlight
    mpirun -np 32 gmx_mpi mdrun -multidir a b c d -gputasks 0000000011111111
:::
:::

Starts the same multi-simulation as before. On a machine with two
physical nodes and two GPUs per node, there will be 16 MPI ranks per
node, and 8 MPI ranks per simulation. The 16 MPI ranks doing PP work on
a node are mapped to the GPUs with IDs 0 and 1, even though they come
from more than one simulation. They are mapped in the order indicated,
so that the PP ranks from each simulation use a single GPU. However, the
order ` `{.docutils .literal
.notranslate}[` 0101010101010101 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} could run
faster.
:::

::: {#running-replica-exchange-simulations .section}
### Running replica-exchange simulations

When running a multi-simulation, using ` `{.docutils .literal
.notranslate}[` gmx `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` mdrun `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[` -replex `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate}[` n `{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal .notranslate} means
that a replica exchange is attempted every given number of steps. The
number of replicas is set with ` `{.docutils .literal
.notranslate}[` -multidir `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} option,
described above. All run input files should use a different value for
the coupling parameter (e.g. temperature), which ascends over the set of
input files. The random seed for replica exchange is set with
` `{.docutils .literal .notranslate}[` -reseed `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . After every
exchange, the velocities are scaled and neighbor searching is performed.
See the Reference Manual for more details on how replica exchange
functions in GROMACS.
:::

::: {#multi-simulation-performance-considerations .section}
### Multi-simulation performance considerations

The frequency of communication across a multi-simulation can have an
impact on performance. This is highly algorithm dependent, but in
general it is recommended to set up a multi-simulation to do
inter-simulation communication as infrequently as possible but as
frequently as necessary. However, even when members of multi-simulation
do not communicate frequently (or at all), and therefore the associated
performance overhead is small or even negligible, load imbalance can
still have a significant impact on performance and resource utilization.
Current multi-simulation algorithms use a fixed interval for data
exchange (e.g. replica exchange every ` `{.docutils .literal
.notranslate}[` N `{.docutils .literal .notranslate}]{.pre}` `{.docutils
.literal .notranslate} steps) and therefore all members of a
multi-simulation need to reach this step before the collective
communication can happen and any of them can proceed to step
` `{.docutils .literal .notranslate}[` N+1 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} . Hence, the
slowest member of the multi-simulation will determine the performance of
the entire ensemble. This load imbalance will not only limit performance
but will also leave resources idle; e.g. if one of the simulations in an
` `{.docutils .literal .notranslate}[` n `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} -way
multi-simulation runs at half the performance than the rest, the
resources assigned to the ` `{.docutils .literal
.notranslate}[` n-1 `{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate} faster running
simulations will be left idle for approximately half of the wall-time of
the entire multi-simulation job. The source of this imbalance can range
from inherent workload imbalance across the simulations within a
multi-simulation to differences in hardware speed or inter-node network
performance variability affecting a subset of ranks and therefore only
some of the simulations. Reducing the amount of resources left idle
requires reducing the load imbalance, which may involve splitting up
non-communicating multi-simulations, or making sure to request a
â€œcompactâ€? allocation on a cluster (if the job scheduler allows).
Note that imbalance also applies to non-communicating multi-simulations
like FEP calculations since the resources assigned to earlier finishing
simulations can not be relinquished until the entire MPI job can finish.
:::
:::

::: {#controlling-the-length-of-the-simulation .section}
## Controlling the length of the simulation

Normally, the length of an MD simulation is best managed through the
option , however there are situations where more control is useful.
` `{.samp .docutils .literal .notranslate}[` gmx `{.samp .docutils
.literal .notranslate}]{.pre}` `{.samp .docutils .literal
.notranslate}[` mdrun `{.samp .docutils .literal
.notranslate}]{.pre}` `{.samp .docutils .literal
.notranslate}[` -nsteps `{.samp .docutils .literal
.notranslate}]{.pre}` `{.samp .docutils .literal
.notranslate}[` 100 `{.samp .docutils .literal
.notranslate}]{.pre}` `{.samp .docutils .literal .notranslate} overrides
the file and executes 100 steps. ` `{.samp .docutils .literal
.notranslate}[` gmx `{.samp .docutils .literal
.notranslate}]{.pre}` `{.samp .docutils .literal
.notranslate}[` mdrun `{.samp .docutils .literal
.notranslate}]{.pre}` `{.samp .docutils .literal
.notranslate}[` -maxh `{.samp .docutils .literal
.notranslate}]{.pre}` `{.samp .docutils .literal
.notranslate}[` 2.5 `{.samp .docutils .literal
.notranslate}]{.pre}` `{.samp .docutils .literal .notranslate} will
terminate the simulation shortly before 2.5 hours elapse, which can be
useful when running under cluster queues (as long as the queuing system
does not ever suspend the simulation).
:::
:::


::: site-header
::: wrap




""
:::
:::

::: wrap
# GROMACS中文手册：第一章　简介





## 1.1 计算化学与分子建模 {#11-计算化学与分子建模}

GROMACS是一个用于分子动力学模拟和能量最小化的计算引擎.
分子动力学模拟和能量最小化是计算化学和分子建模领域众多技术中的两种.
**计算化学** 是计算技术在化学中应用,
涉及范围从分子的量子力学到复杂大分子聚集体的动力学. **分子建模**
是用实际的原子模型描述复杂化学体系的一般方法,
其目的是以原子尺度的详细知识为基础, 理解和预测物质的宏观性质. 通常,
分子建模被用于设计新的材料,
因为在这过程中需要对实际体系的物理性质进行准确的预测.

宏观的物理性质可以分为 (a) **静态平衡性质** ,
如一种酶与其一种抑制剂的结合常数, 系统的平均势能,
或液体的径向分布函数；(b) **动态或非平衡性质** , 如液体的粘度,
膜中的扩散过程, 相变的动力学, 反应动力学, 或在晶体中缺陷的动力学.
计算方法的选择取决于要回答的问题以及该方法在当前技术发展水平下得到可靠结果的可行性.
理想情况下, (相对论)含时薛定谔方程能以很高的精度描述分子体系的性质,
但这种 **从头算** 的方法水平只能处理几个原子的平衡态计算. 因此,
采用近似是必要的. 体系的复杂度越高, 待研究过程的时间跨度越长,
计算所需的近似度就越高. 到某个阶段(远早于人们所希望的),
从头算方法必须借助于 **经验** 的参数化模型, 或被其完全取代.
当体系的复杂度导致基于原子间相互作用的物理原理的模拟仍然失败时,
分子建模就完全建立在对已知结构和化学数据进行相似性分析的基础之上.
QSAR方法(定量结构-活性关系)和许多基于同源蛋白的蛋白质结构预测就属于这类方法.

宏观性质始终是分子体系某种代表性统计系综(平衡或非平衡)的系综平均值.
对分子建模, 这有两个重要的推论:

-   仅有单一结构的信息是远远不够的, 即使这个结构是全局能量最小点.
    为计算宏观性质, 必须产生指定温度下体系的代表性系综.
    但对于计算那些与自由能相关的热力学平衡性质, 如相平衡, 结合常数,
    溶解度, 分子构象的相对稳定性等等, 这仍然不够.
    自由能和热力学势的计算需要对分子模拟技术进行特殊地推广.

-   原则上, 分子模拟提供了体系结构和运动的原子尺度的细节, 然而,
    这些细节常常与那些感兴趣的宏观性质无关.
    这为简化对相互作用的描述并对无关细节进行统计平均提供了可能.
    统计力学为这些简化提供了理论框架, 并可以使用一系列不同等级的方法,
    涉及到的方法从将一组原子视为一个单元, 以少量的集合坐标描述运动,
    对溶剂分子利用平均力势和随机动力学进行统计平均\[7\], 一直到
    **介观动力学** . 介观动力学直接描述密度而不是原子,
    并以描述流(作为对热力学梯度的响应)取代描述速度或加速度(作为对力的响应)\[8\].

有两种方法可用于产生一个具有代表性的平衡系综: (a) **蒙特卡洛(Monte
Carlo, MC)模拟** 和(b) **分子动力学(Molecular Dynamics, MD)模拟** .
对于非平衡系综的产生和动态事件的分析, 只有第二种方法是适用的. 与MD相比,
蒙特卡洛模拟更简单(不需要计算力), 然而, 在一定的计算时间内,
MC并不能得到比MD明显更好的统计结果. 因此, MD是更通用的技术方法.
如果初始构型离平衡态非常远, 体系的受力可能过大, 以致MD模拟失败.
在这种情况下, 需要先对体系进行稳健的 **能量最小化** .
另一个进行能量最小化的原因是去除体系的所有动能:
如果要对动力学模拟过程中几个"快照"进行比较,
能量最小化能够减少结构和势能中的热噪声, 因此比较结果可能更好.

## 1.2 分子动力学模拟 {#12-分子动力学模拟}

对含 [ \\(N\\) ]{.math} 个相互作用原子的系统, MD模拟求解其牛顿运动方程:

[ \\\[m_i \\oppar {\\boldsymbol r_i} t = \\boldsymbol F_i, i=1, \\cdots
N \\tag{1.1}\\\] ]{.math}

原子所受的力是一个势能函数导数的负值:

\$\$ \\bi F_i = - \\opar V {\\bi r_i} \\tag{1.2} \$\$

模拟时, 会以很小的时间步长同时求解这些方程, 使系统演化一段时间,
同时小心地使温度和压力维持在设定值,
并以一定的时间间隔将原子坐标写入输出文件中.

     键的类型       振动类型    波数(cm ^-1^ )  
  --------------- ------------ ---------------- --
   C-H, O-H, N-H      伸缩        3000-3500     
    C＝C, C＝O        伸缩        1700-2000     
        HOH           弯曲           1600       
        C-C           伸缩        1400-1600     
     H ~2~ CX      剪式, 摇摆     1000-1500     
        CCC           弯曲         800-1000     
     O-H\...O         摆动         400-700      
     O-H\...O         伸缩          50-200      

  : 表1.1 分子及含氢键液体中的典型振动频率(波数). 300 K时, \\(kT/h=200\\
  \\text{cm}\^{-1}\\)

随着时间变化的坐标代表了体系的一个 **轨迹** . 经过初始的一些变化之后,
体系通常会达到 **平衡态** . 通过对平衡后的轨迹进行平均,
就可以从输出文件中提取出许多宏观性质.

此时, 了解MD模拟的局限性是有益的. 用户应该清楚这些局限性,
并始终通过对已知实验性质进行检查来评估模拟的准确度.
下面列出了MD所采用的近似.

**模拟是经典的**

> 使用牛顿运动方程自然意味着我们使用 **经典力学** 描述原子的运动.
> 对处于正常温度下的大多数原子来说, 这是合适的, 但也有例外:
> 氢原子质量非常小, 质子的运动有时具有显著的量子力学特性. 例如,
> 在沿氢键传递过程中, 质子可能通过 **隧穿效应** 越过势垒.
> 经典力学不可能正确地处理这样的过程！低温下的液氦是经典力学失效的另一个例子.
> 或许我们不是很关心氦, 但共价键的高频振动却应该让我们担心！当共振频率 [
> \\(\\n\\) ]{.math} 接近或超过 [ \\(k_BT/h\\) ]{.math} 时,
> 经典谐振子与真正的量子谐振子的统计力学明显不同. 室温下当 [ \\(h\\n=k_B
> T\\) ]{.math} 时, 波数 [ \\(\\s=1/\\l=\\n/c\\) ]{.math} , 大约为200 cm
> ^-1^ . 因此, 所有高于, 比如说100cm ^-1^ 的频率,
> 在经典模拟中的行为都可能不正确.
> 这意味着所有键和键角的振动实际上都是可疑的, 甚至氢键键合基团的运动,
> 比如平动或氢键的摆动都超出了经典的极限(见表1.1). 我们该怎么办呢？
>
> 除了进行真正的量子动力学模拟, 我们可以采取下面两种方法中的一种:
>
> \(a\) 如果进行MD模拟时对键采用了谐振子近似, 我们应该对总内能 [ \\(U =
> E\_{kin} + E\_{pot}\\) ]{.math} 和比热 [ \\(C_V\\) ]{.math} (以及熵 [
> \\(S\\) ]{.math} 自由能 [ \\(A\\) ]{.math} 或 [ \\(G\\) ]{.math} ,
> 如果要计算它们) 进行校正. 对频率为 [ \\(\\n\\) ]{.math} 的一维振子,
> 能量和热容的校正分别为\[9\]:
>
> [ \\\[U\^{QM} = U\^{cl} + kT \\left( {1\\over2} x - 1 + {x \\over
> e\^x-1} \\right) \\tag{1.3}\\\] ]{.math}
>
> [ \\\[C_V\^{QM} = C_V\^{cl} + k \\left( {x\^2 e\^x \\over
> (e\^x-1)\^2} - 1 \\right) \\tag{1.4}\\\] ]{.math}
>
> 其中 [ \\(x =h\\n/kT\\) ]{.math} . 当高频量子振子处于基态时, 具有 [
> \\({1\\over2}h\\n\\) ]{.math} 的零点能, 经典谐振子会吸收过多的能量( [
> \\(kT\\) ]{.math} ).
>
> \(b\) 我们可以将键(和键角)视为运动方程的 **约束** . 其理由是,
> 与经典振子相比, 处于基态的量子振子与被约束的键更相似.
> 作这种选择有一个很实用的理由: 当最高频率被移除后,
> 可以在算法中使用更大的时间步长. 实际中, 相比把键当作谐振子,
> 当键被约束时的时间步长可以取为原先的4倍\[10\].
> GROMACS对键和键角提供了这种方案. 灵活的键角约束是相当重要的,
> 它使得运动更加真实, 并能覆盖构型空间\[11\].

**电子处于基态**

> 在MD中, 我们使用 **保守力场** , 它只是原子位置的函数.
> 这意味电子的运动被忽略了:
> 我们假定电子能够瞬间调整自己的运动状态以适应原子位置发生的变化(玻恩-奥本海默近似),
> 并始终处于它们的基态. 这个假定几乎总是正确的,
> 但显然不能用于电子转移过程和电子激发态, 也不能正确处理化学反应. 当然,
> 暂时回避化学反应还有着其他原因.

**力场是近似的**

> 力场提供了力. 它们实际上不是模拟方法的一部分.
> 当需要或对体系有了更多了解时, 用户可以修改力场中的参数. 但是,
> 在一个特定的程序中所能使用的力的形式是有限制的.
> GROMACS中可用的力场将在第4章进行说明. 在目前的版本中,
> 力场是对势累加(pair-additive)的(除了长程库仑力), 所以不能包含极化,
> 也不包含可以微调的键相互作用. 由此还导致了下面列出的一些限制.
> 除此以外, 力场对水溶液中的生物相关的大分子是相当有用, 相当可靠的！

**力场是对势累加的**

> 这意味着, 所有的 **非键** 力来源于非键对势相互作用的加和.
> 非对势累加相互作用, 其中最重要的是通过原子极化产生的相互作用, 要通过
> **有效对势** 进行描述. 这里仅考虑了平均的非对势累加的贡献. 这也意味着,
> 对相互作用(pair interactions)并不纯粹, 也就是说, 它们对孤立的原子对,
> 或是与参数化时基于的模型有明显差距的体系, 是无效的. 实际上,
> 有效对势在实际使用中并没有那么糟糕.
> 但忽略极化也意味着原子中的电子并不能提供正常的介电常数. 举例来说,
> 实际的液体烷烃具有略大于2的介电常数,
> 这会降低(部分)电荷之间的长程静电相互作用. 因此,
> 模拟将高估远程库仑相互作用. 幸运的是, 下一近似稍稍弥补了这一缺陷.

**长程相互作用被截断**

> 在本版本中, GROMACS总是对Lennard-Jones相互作用使用截断半径,
> 对库伦作用有时也使用截断半径. GROMACS使用的"最小映像约定"要求:
> 对一个对相互作用(pair interaction)中的每个粒子,
> 只考虑其在周期性边界条件下的一个映像,
> 所以截断半径不能超过盒子大小的一半. 对大的体系来说, 这仍然相当大,
> 但仅仅对于含有带电粒子的体系会有麻烦. 这时可能会发生许多糟糕的事,
> 如电荷会在截断边界处累积, 或计算的能量完全错误！对于这样的系统,
> 你应该考虑包含了那些长程静电相互作用的算法, 如粒子网格Ewald (particle
> mesh Ewald, PME)\[12, 13\].

**边界条件是不自然的**

> 由于体系尺寸很小(即便含10000个粒子的体系也还很小),
> 粒子组成的团簇与其环境(真空)之间具有许多不需要的边界.
> 如果想模拟块状体系, 我们必须避免这种情况. 对此,
> 我们采用周期性边界条件来避免实际的相边界. 由于液体不是晶体,
> 一些不自然情况仍然存在. 我们最后提及这一方面是因为它的影响最小.
> 对大体系其误差很小, 但对于具有很强内部空间相关性的小体系,
> 周期性的边界可能会增强内部的相关性. 在这种情况下,
> 要多加小心并注意测试系统尺寸的影响.
> 当使用格点加和方法计算远程静电相互作用时, 这一点尤其重要,
> 因为我们知道这样有时会引入额外的有序.

## 1.3 能量最小化和搜索方法 {#13-能量最小化和搜索方法}

在1.1节已经提到, 许多情况下需要进行能量最小化.
GROMACS提供了许多方法进行局部能量最小化, 我们将在3.10节进行详细讨论.

(大)分子体系的势能函数是多维空间中一个超曲面, 具有非常复杂的形貌.
它有一个最低点, **全局极小点** 和大量的 **局部极小点** . 在这些点上,
势能函数对所有坐标的导数为零, 对所有坐标的二阶导数都是非负的.
二阶导数组成的矩阵, 即所谓的 **Hessian矩阵** ,
具有非负的本征值；只有对应于孤立分子的平动和转动的集约坐标具有零本征值.
在局部极小值之间有 **鞍点** , 其Hessian矩阵仅有一个负的本征值.
通过这些点, 体系可以从一个局部极小值到转移到另一个局部极小值.

拥有所有局部极小点, 包括全局最小点和所有鞍点的信息,
我们就可以描述有关的结构和构象, 它们的自由能, 以及结构转化的动力学.
不幸的是, 构型空间的维数和局部极小点的数目非常多,
我们不可能进行足够的采样来获得全部的信息. 特别是,
没有一种最小化方法能够保证在实际可承受的时间范围内找到全局极小点.
存在一些不很实用的方法, 速度有快有慢\[14\]. 然而, 给定一个初始构型,
可以找到它的 **最近极小点** .
"最近"在这里并不总是意味着结构意义上的"最近"(即二者坐标差距的平方和最小),
而是指可以通过系统地沿着局部梯度最陡方向往下移动能够到达的极小点.
很不幸, GROMACS所能为你做的只是找到这种最近极小！如果你想找到其他极小点,
并希望在此过程中找到全局极小点, 最好尝试下温度耦合的MD:
先在高温下模拟体系一段时间, 然后慢慢下降到所需的温度,
并不断重复这一过程！如果存在熔点或玻璃化转变温度,
可以先在稍低于该温度的条件下模拟一段时间, 再使用某些聪明的方案慢慢降温,
这样的过程被称为 **模拟退火** . 由于这一过程不需要与物理真实过程相对应,
你尽可以发挥你的想象力以加速这一进程.
一个经常可行的小技巧是增加氢原子的质量(可增加到10左右):
虽然这将减缓氢原子的快速运动, 却几乎不会影响到体系的慢运动,
同时能使时间步长增加为原来的3倍或4倍. 在搜索过程中你也可以修改势能函数,
例如, 通过移除势垒(去除二面角函数或以 **软核** 势取代排斥势\[15\]),
但当慢慢恢复势能函数的时候要小心.
允许结构剧烈变化的最好搜索方法是在四维空间中进行漫游\[16\],
但这超出了GROMACS的标准功能, 需要一些额外的编程工作.

有三类可能的能量最小化方法:

-   只需要计算函数值的方法. 如单纯形法及其变种.
    前进的每一步都是在前面计算结果的基础上做出的. 如果可以利用导数信息,
    这类方法要差于那些使用导数信息的方法.

-   使用导数信息的方法. 由于在MD程序中,
    势能相对于所有的坐标的偏导数(等于力的负值)都是已知的,
    由MD程序稍加修改得到的这类方法非常合适.

-   还使用二阶导数信息的方法. 这些方法在接近极小点时的收敛性非常好:
    一个二次势能函数的最小化只需要一步！问题是, 对于N粒子的体系, 必须对
    [ \\(3N \\times 3N\\) ]{.math} 的矩阵进行计算, 存储, 求逆.
    除非用额外的编码获得二阶导数, 对大多数系统, 这类方法都不可行. 此外,
    还有一些实时建立Hessian矩阵的中间方法,
    但它们也需要大量的额外存储空间. 因此, GROMACS没有使用这类方法.

GROMACS使用的 **最速下降法** 属于第二类方法.
它只是简单地沿负梯度方向(因此, 在力的方向)前进,
而不考虑前面的已有的任何步骤. 搜索过程中, 步长可以进行调整,
以便使搜索快速进行, 但搜索永远沿着能量减小的方向.
这是一个简单稳健但有些愚蠢的方法: 它的收敛速度可能相当慢,
特别是处于局部极小值附近时！收敛更快的 **共轭梯度法**
(见\[17\])使用了前面步骤的梯度信息. 一般情况下,
最陡下降法能够很快地接近最近极小点, 而共轭梯度法能够 **非常**
接近局部极小点, 但当远离极小点时效果较差. GROMACS也支持L-BFGS最小化,
这是几乎与共轭梯度法相当的方法, 但在某些情况下, 其收敛速度更快.

------------------------------------------------------------------------

------------------------------------------------------------------------

![](/jscss/molsimart.png){style="display:table;margin:0 auto;height:150px"}
[个](javascript:scroll(0,0)){#scrollTop}
:::
::: site-header
::: wrap




""
:::
:::

::: wrap
# GROMACS中文手册：第二章　定义与单位





## 2.1 符号标记 {#21-符号标记}

对数学符号, 在整个文档中都将遵循以下约定:

     含义      标注         示例
  ---------- -------- ----------------
     矢量     粗斜体   \\(\\bi r_i\\)
   矢量长度    斜体      \\(r_i\\)

我们用 **小写** 下标 [ \\(i,j,k,l\\) ]{.math} 标识粒子: [ \\(\\bi r_i\\)
]{.math} 为粒子 [ \\(i\\) ]{.math} 的 **位置矢量** , 并且使用下面的记法:

[ \\(\\alg \\bi r\_{ij} &= \\bi r_j- \\bi r_i \\tag{2.1} \\\\ r\_{ij} &=
\\abs {\\bi r\_{ij}} \\tag{2.2} \\ealg\\) ]{.math}

粒子 [ \\(i\\) ]{.math} 受到的力记为 [ \\(\\bi F_i\\) ]{.math} , 且

[ \\\[\\bi F\_{ij}= 粒子j施加于粒子i的力 \\tag{2.3}\\\] ]{.math}

请注意, 自从GROMACS 2.0版本我们已将标记改为 [ \\(\\bi r\_{ij}=\\bi
r_j-\\bi r_i\\) ]{.math} . 因为这是常用的约定. 如果你遇到错误,
请告知我们.

## 2.2 MD单位 {#22-md单位}

GROMACS使用一系列自洽的单位, 以便使相关分子性质的计算值接近单位1.
我们称其为 **MD单位** . 这个系统的基本单位是 nm, ps, K,
电子电荷(e)和原子质量单位(u), 参看表2.1.

与这些单位一致的一套导出单位, 列于表2.2.

**静电转换因子** [ \\(f={1 \\over 4\\p\\ve_0}=138.935 485(9)\\) ]{.math}
kJ mol ^-1^ nm e ^-2^ , 它联结了力学量与电学量, 即

[ \\\[V=f {q\^2 \\over r} 或 F=f {q\^2 \\over r\^2} \\tag{2.4}\\\]
]{.math}

  -----------------------------------------------------------------------
          物理量                   符号           单位
  ----------------------- ----------------------- -----------------------
           长度                      r            纳米(nm) ＝ 10 ^-9^ m

           质量                      m            原子质量单位(u) ＝
                                                  1.660 540 2(10) × 10
                                                  ^-17^ kg\
                                                  ^12^ C 原子质量的1/12

           时间                      t            皮秒(ps) ＝ 10 ^-12^ s

           电荷                      q            电子电量(e) ＝ 1.602
                                                  177 33(49) × 10 ^-19^ C

           温度                      T            K
  -----------------------------------------------------------------------

  : 表2.1 GROMACS使用的基本单位. 括号中的数字表示精确度.

  -----------------------------------------------------------------------
          物理量                   符号                    单位
  ----------------------- ----------------------- -----------------------
           能量                 \\(E, V\\)              kJ mol ^-1^

            力                 \\(\\bi F\\)         kJ mol ^-1^ nm ^-1^

           压力                   \\(p\\)         kJ mol ^-1^ nm ^-3^ ＝
                                                    10 ^30^ /N ~AV~ Pa\
                                                  1.660 54 × 10 ^6^ Pa ＝
                                                        16.6054 bar

           速度                   \\(v\\)         nm ps ^-1^ ＝ 1000 m s
                                                           ^-1^

          偶极矩                 \\(\\m\\)                 e nm

           电势                  \\(\\F\\)         kJ mol ^-1^ e ^-1^ ＝
                                                   0.010 364 272(3) Volt

         电场强度              \\(\\bi E\\)        kJ mol ^-1^ nm ^-1^ e
                                                  ^-1^ ＝ 1.036 427 2(3)
                                                       × 10 ^7^ V/m
  -----------------------------------------------------------------------

  : 表2.2 导出单位

电势 [ \\(\\F\\) ]{.math} 和电场强度 [ \\(\\bi E\\) ]{.math}
是计算能量和力的中间量. 它们不会出现在GROMACS中. 如果在计算中使用它们,
可对方程及其相应的单位进行选择. 在计算 [ \\(\\F\\) ]{.math} 和 [ \\(\\bi
E\\) ]{.math} 时, 我们强烈建议遵循惯例, 使用包含转换因子 [ \\(f\\)
]{.math} 的下列方程:

[ \\(\\alg \\F(\\bi r) &= f \\sum_j {q_j \\over \\abs{\\bi r-\\bi r_j} }
\\tag{2.5} \\\\ \\bi E(\\bi r) &= f \\sum_j q_j {\\bi r -\\bi r_j \\over
\\abs{\\bi r-\\bi r_j}\^3 } \\tag {2.6} \\ealg\\) ]{.math}

在这种定义下, [ \\(q\\F\\) ]{.math} 为能量, [ \\(q \\bi E\\) ]{.math}
为力. 它们的单位由表2.2给出: 单位电势大约10 meV. 这样,
距离一个电子电荷子1 nm的电势能等于 [ \\(f \\approx 140 单位 \\approx 1.4
\\text V\\) ]{.math} (精确值为1.439965 V).

**注意** :
这些单位彼此之间是自洽的；改变其中的任何一个都可能使得单位系统不再自洽,
因此 **强烈建议不要** 修改. 特别是, 若使用 [ \\(\\AA\\) ]{.math} 代替
nm, 单位时间将变为0.1 ps；若使用能量单位kcal mol ^-1^ 代替kJ mol ^-1^ ,
单位时间将变为0.488882 ps, 且单位温度变为4.184 K. 但在这两种情况下,
计算的所有电势能都是错误的, 因为它们仍然是以kJ mol ^-1^ 为单位计算的,
并假定nm为长度单位. 尽管对电荷重新进行细心的标度可能会得到自洽的单位,
但很显然, 所有这些容易引起混淆的做法都应该被严厉禁止.

常用的物理常数以MD单位表示, 其取值可能不同(见表2.3).
所有的物理量都是以mol为单位计算的, 而不是以单个分子为单位计算.
玻尔兹曼常数 [ \\(k\\) ]{.math} 和理想气体常数 [ \\(R\\) ]{.math}
没有区别, 它们的值都是0.008 314 51 kJ mol ^-1^ K ^-1^ .

       符号            名称       数值                                         
  --------------- --------------- -------------------------------------------- --
   \\(N\_{AV}\\)   Avogadro常数   6.022 136 7(36) × 10 ^23^ mol ^-1^           
      \\(R\\)      理想气体常数   8.314 510(70) × 10 ^-3^ kJ mol ^-1^ K ^-1^   
     \\(k_B\\)     Boltzmann常数                                               
      \\(h\\)       Planck常数    0.399 031 32(24) kJ mol ^-1^ ps              
   \\(\\hbar\\)      Dirac常数    0.063 507 807(38) kJ mol ^-1^ ps             
      \\(c\\)          光速       299 792.458 nm ps ^-1^                       

  : 表 2.3 部分物理常数

   物理量          符号                     与国际单位的关系             
  -------- -------------------- ---------------------------------------- --
    长度    \\(\\text r\^\*\\)          \\(\\text r \\s\^{-1}\\)         
    质量    \\(\\text m\^\*\\)       \\(\\text m \\text M\^{-1}\\)       
    时间    \\(\\text t\^\*\\)   \\(\\text t \\s\^{-1} \\sqrt{\\e/M}\\)  
    温度    \\(\\text T\^\*\\)        \\(\\text k_B T \\e\^{-1}\\)       
    能量    \\(\\text E\^\*\\)          \\(\\text E \\e\^{-1}\\)         
     力     \\(\\text F\^\*\\)        \\(\\text F \\s \\e\^{-1}\\)       
    压强    \\(\\text P\^\*\\)      \\(\\text P \\s\^3 \\e\^{-1}\\)      
    速度    \\(\\text v\^\*\\)        \\(\\text v \\sqrt{M/\\e}\\)       
    密度      \\(\\r\^\*\\)          \\(\\text N \\s\^3 V\^{-1}\\)       

  : 表 2.4 LJ势的约化物理量

## 2.3 约化单位 {#23-约化单位}

当模拟Lennard-Jones(LJ)系统时, 使用约化单位(即设某类原子的 [
\\(\\e\_{ii}=\\s\_{ii}=m_i=k_B=1\\) ]{.math} )可能会方便, 也是可行的.
当以约化单位输入时, GROMACS将会以约化单位输出. 但 **温度** 是唯一的例外,
它是以0.008 314 51倍的约化单位表示的.
这是由于在代码中使用玻尔兹曼常数计算温度引起的. 因此, 不是温度 [ \\(T\\)
]{.math} , 而是 [ \\(k_BT\\) ]{.math} 表示约化温度. GROMACS的温度 [
\\(T=1\\) ]{.math} 意味着约化温度为0.008...单位; 如果约化温度是1,
GROMACS的温度应该是120.2717.

表2.4 给出对应于LJ势

[ \\\[V\_{LJ}=4 \\e \\left\[ \\left({\\s \\over
r}\\right)\^{12}-\\left({\\s \\over r}\\right)\^6 \\right\]
\\tag{2.7}\\\] ]{.math}

的约化物理量.


# GROMACS中文手册：第三章　算法





## 3.1 简介 {#31-简介}

在本章中, 我们首先介绍GROMACS用到的一些基本概念: **周期性边界条件**
(3.2节)和 **组** (3.3节). MD算法将在3.4节介绍: 首先给出算法的整体形式,
然后在后面的小节中进行详细说明. (简单的)EM(Energy minimization,
能量最小化)算法在3.10节说明.
用于特殊目的动力学的一些其他算法在此后进行说明.

有几个问题是人们普遍关心的. 在所有情况下, 必须定义由分子组成的 **体系**
. 而分子又是由定义了相互作用形式的粒子组成. 关于分子 **拓扑结构** 和
**力场** 的详细描述以及力的计算将在第四章讨论. 在本章中,
我们只讨论算法的其他方面, 如配对列表(pair list)的生成, 速度和位置的更新,
与外部温度和压力的耦合, 约束的保持. 对MD模拟数据的 **分析**
将在第八章讨论.

## 3.2 周期性边界条件 {#32-周期性边界条件}

![图3.1 二维的周期性边界条件](/GMX/3.1.png)

对有限的体系, 减小边缘效应的经典方法是应用 **周期性边界条件** .
将待模拟体系的原子放到一个空间填充(space-filling)的盒子中,
周围是体系自身平移后的副本(图 3.1). 因此, 体系不存在边界,
由孤立团簇的多余边界导致的问题现在被由周期性条件引起的问题所取代.
如果体系具有晶体结构,
这样的边界条件符合预期(尽管运动自然被限制于周期性运动,
且其波长与盒子适应). 如果希望模拟非周期性体系, 如液体或溶液,
周期性就会带来误差. 此误差可以通过比较不同尺寸体系的模拟结果进行评估.
比起由不自然的真空边界引起的误差, 周期性边界引起的误差更小一些.

用于空间填充的元胞的有几种可能的形状. 其中的一些, 如 **菱形十二面体** 与
**截角八面体** \[18\]比立方体更接近于球形,
并因此更适合用于研究溶液中近似球形的大分子,
这是由于对给定的大分子映像的最小距离,
填充这两种形状的盒子需要的溶剂分子更少. 同时, 菱形十二面体和截角八面体是
**三斜晶胞** 的特殊情况, 而三斜晶胞是最一般的空间填充元胞,
组成了所有可能的空间填充形状\[19\]. 出于这个原因,
GROMACS是基于三斜晶胞的.

GROMACS使用周期性边界条件, 并结合了 **最小映像约定** :
对短程非键相互作用, 每个粒子只考虑它的一个最近的映像.
对长程静电相互作用, 这有时不够准确, 因此GROMACS还采用了点阵加和的方法,
如Ewald加和, PME和PPPM.

GROMACS支持任何形状的三斜盒子. 模拟盒(元胞)由3个盒矢量 [
\\(\\mathbf{a,b,c}\\) ]{.math} 定义. 盒矢量必须满足以下条件:

[ \\\[a_y=a_z=b_z=0 \\tag{3.1}\\\] ]{.math}

[ \\\[a_x \> 0, \\; b_y \> 0, \\; c_z \> 0 \\tag{3.2}\\\] ]{.math}

[ \\\[\\abs{b_x} \\le {1\\over2} a_x, \\; \|c_x\| \\le {1\\over2} a_x,
\\; \|c_y\| \\le {1\\over2} b_y \\tag{3.3}\\\] ]{.math}

通过旋转盒子, 总可以使得等式3.1成立,
不等式(3.2)和(3.3)也总可以通过增减盒矢量使其成立.

即便使用三斜盒子进行模拟, 为了提高计算效率,
GROMAC始终将粒子放在长方体空间内, 对二维体系的图示见图3.1. 因此,
从输出的轨迹来看, 模拟好像是在长方体盒子中进行的. ` trjconv `
程序可用于转换轨迹, 以便在不同的元胞中显示.

模拟时也可不使用周期性边界条件, 但当模拟孤立的分子团簇时,
使用一个很大的周期性盒子通常效率更高,
这是因为快速的格点搜索只能在周期性体系中使用.

![图3.2 菱形十二面体与截角八面体(任意取向)](/GMX/3.2.png)

  -------------------------------------------------------------------------------------------------------------
         盒子类型            映像距离           盒子体积              盒矢量 abc              盒矢量夹角
  ----------------------- -------------- ---------------------- ---------------------- ------------------------
           立方              \\(d\\)           \\(d\^3\\)            \\(d\\) 0 0\         \\(90\^{\\circ}\\)
                                                                     0 \\(d\\) 0\         \\(90\^{\\circ}\\)
                                                                     0 0 \\(d\\)          \\(90\^{\\circ}\\)

   菱形十二面体(XY-正方)                  \\({1\\over2}\\sqrt2        \\(d\\) 0           \\(60\^{\\circ}\\)
                                                d\^3\\)\          \\({1\\over2}d\\)\      \\(60\^{\\circ}\\)
                                            \\(0.707d\^3\\)           0 \\(d\\)           \\(90\^{\\circ}\\)
                                                                  \\({1\\over2}d\\)\   
                                                                         0 0           
                                                                 \\({1\\over2}\\sqrt2  
                                                                         d\\)          

   菱形十二面体(XY-六角)                                               \\(d\\)         
                                                                  \\({1\\over2}d\\)    
                                                                  \\({1\\over2}d\\)\   
                                                                0 \\({1\\over2}\\sqrt3 
                                                                         d\\)          
                                                                 \\({1\\over6}\\sqrt3  
                                                                        d\\)\          
                                                                         0 0           
                                                                 \\({1\\over3}\\sqrt6  
                                                                         d\\)          

        截角八面体                        \\({4\\over9}\\sqrt3         \\(d\\)          \\(71.53\^{\\circ}\\)
                                                d\^3\\)\          \\({1\\over3}d\\)     \\(109.47\^{\\circ}\\)
                                            \\(0.770 d\^3\\)     -\\({1\\over3}d\\)\    \\(71.53\^{\\circ}\\)
                                                                0 \\({2\\over3}\\sqrt2 
                                                                         d\\)          
                                                                 \\({1\\over3}\\sqrt2  
                                                                        d\\)\          
                                                                         0 0           
                                                                 \\({1\\over3}\\sqrt6  
                                                                         d\\)          
  -------------------------------------------------------------------------------------------------------------

  : 表3.1: 立方盒, 菱形十二面体和截角八面体

### 3.2.1 一些有用的盒子类型 {#321-一些有用的盒子类型}

表3.1列出了用于模拟溶液体系的三种最常用的盒子类型.
菱形十二面体(图3.2)是最小, 最规则的空间填充元胞.
12个映像元胞的每一个具有相同的距离,
其体积是具有相同映像距离的立方体体积的71%.
当模拟溶液中球形或柔性的分子时, 这样可以节省约29%的CPU时间.
有两种不同取向的菱形十二面体满足方程3.1, 3.2和3.3. 程序 ` editconf `
生成与xy平面有正方截面的菱形十二面. 之所以选择这个取向,
是因为该取向的菱形十二面的前两个盒矢量与x轴和y轴重合, 因此容易理解.
另一取向可用于膜蛋白的模拟. 这时它在xy平面的截面是一个六边形,
其面积比具有相同的映像距离的正方形的面积小14%. 为获得最佳间距,
可以改变盒子的高度( [ \\(c_z\\) ]{.math} ).
这种盒子形状不仅可以节省CPU时间, 也可以使蛋白质的分布更加均匀.

### 3.2.2 截断限制 {#322-截断限制}

最小映像约定意味着,
用于截断非键相互作用的截断半径不能超过最短盒矢量的一半:

[ \\\[R_c \< {1\\over2} \\text{min} (\\lVert \\mathbf a \\rVert, \\lVert
\\mathbf b\\rVert, \\lVert \\mathbf c\\rVert) \\tag{3.4}\\\] ]{.math}

否则将会有多个映像出现在力的截断距离内.
当研究溶液中的大分子------如蛋白质------时, 仅考虑这个限制是不够的:
原则上, 单个的溶剂分子应该无法同时"看到"大分子的两侧. 这意味着,
每个盒矢量的长度都必须超过大分子在该方向的长度 **再加上** 两倍的截断半径
[ \\(R_c\\) ]{.math} . 但人们经常不严格遵守这个限制,
以便稍微减少溶剂层从而节约计算成本. 出于效率的考虑,
三斜盒子的截断更受限制. 对格点搜索的额外限制弱一些:

[ \\\[R_c \< \\text{min}(a_x, b_y, c_z) \\tag{3.5}\\\] ]{.math}

对简单搜索的额外限制更强:

[ \\\[R_c \< {1\\over2} \\text{min}(a_x, b_y, c_z) \\tag{3.6}\\\]
]{.math}

每个元胞(立方, 长方或三斜)都被26个平移的映像所包围.
因此一个特定的映像始终可以用指向27个 **平移矢量** 之一的索引来指认,
并通过对索引矢量进行平移来构建(见3.4.3).
约束式(3.5)保证了只需要考虑26个映像.

## 3.3 组的概念 {#33-组的概念}

GROMACS的MD和分析程序可对用户自定义的原子 **组** 进行一些操作.
组的最大数目为256, 但每个原子最多只能属于六类不同的组. 这六类组如下:

**温度耦合组** 对每个温度耦合组可单独定义温度耦合参数(参考温度,
时间常数, 自由度数目, 参见3.4.4). 例如, 在高分子溶液中, 相比高分子,
溶剂分子(力和积分的误差使其容易产生更多热效应)可以使用更短的时间常数与热浴耦合,
又如, 可以将表面的温度维持得低于比吸附分子的温度.
可以定义许多不同的温度耦合组. 也请参看下面质心组.

**冻结组** 属于冻结组的原子在模拟过程中始终保持静止.
在平衡体系的过程中这是很有用的, 例如,
可避免不当放置的溶剂分子对蛋白质的原子产生不合理的碰撞,
尽管对受保护原子添加约束势可以得到同样的效果. 如果需要,
冻结选项可仅仅用于原子的一个或两个坐标,
从而将原子冻结在一个平面或一条直线上. 当一个原子被部分冻结时,
它所受约束仍然可以使它移动, 即便是在冻结方向上.
一个被完全冻结的原子不能被它所受的约束移动. 可定义许多冻结组.
冻结坐标不受压力缩放影响；在某些情况下, 这可能会产生无用的结果,
尤其是与约束同用时(在这种情况下, 你会得到非常大的压力). 因此,
我们建议避免将冻结组与约束和压力耦合混合使用. 为了平衡体系,
可以先在使用冻结进行等体积模拟时, 然后再使用位置约束与恒压模拟.

**加速组** 加速组的每个原子上会被加上一个加速度 [ \\(\\bi a\^g\\)
]{.math} , 这等同于受到一个外力. 利用这个特性可驱使体系进入非平衡态,
并进行非平衡MD模拟以计算输运性质.

**能量监测组** 在模拟中, 所有能量监测组之间的交叉相互作用都会被考虑,
且对Lennard-Jones项和库仑项的计算是分开进行的. 原则上, 最多可定义256组,
但这样将会计算256×256项相互作用！最好保守地使用.

能量监测组之间的所有非键相互作用都可以被排除在外(参见7.3节).
在能量监测组中被排除的粒子对不会被放入配对列表,
当不需要计算体系中的某些相互作用时, 这样做可以显著提高模拟速度.

**质心组** GROMACS可以移除质心(center of mass, COM) 的运动,
无论是整个体系的质心还是或原子组的质心. 后者(移除原子组的质心)是有用的,
比如, 对于存在有限的阻止质心运动的摩擦的体系(如气体体系).
对温度耦合与质心运动移除使用相同的组是合理的.

**压缩位置输出组** 为了进一步减小压缩轨迹文件(.xtc或.tng)的大小,
可以仅仅存储一部分粒子的轨迹. 所有标记为压缩组的会被保存, 其他则不会.
如果没有指定这样的输出组, 所有的原子坐标都将被保存到压缩轨迹文件.

GROMACS工具中组的使用将在8.1节详述.

## 3.4 分子动力学 {#34-分子动力学}

MD的整个流程见图3.3.
每次运行MD或EM都需要体系中所有粒子一组初始坐标和(可选的)初始速度作为输入.
本章不介绍如何获得它们; 对于如何设置并实际运行MD, 请参考
[www.gromacs.org](http://www.gromacs.org/) 上的在线手册.

![图3.3: MD算法流程概览](/GMX/3.3.png)

![图3.4: 麦克斯韦-玻尔兹曼速度分布, 通过随机数生成](/GMX/3.4.png)

### 3.4.1 初始条件 {#341-初始条件}

**拓扑和力场**

必须读入体系的拓扑, 它包含了对力场的说明.
力场和拓扑将分别在第四章和第五章进行说明. 所有这些信息都是固定的,
在运行过程中始终不变.

**坐标和速度**

然后, 在开始运行前, 需要知道盒子的尺寸, 所有粒子的坐标和速度.
盒子的尺寸和形状是由三个矢量(9个数字) [ \\(\\bi b_1, \\bi b_2, \\bi
b_3\\) ]{.math} 决定的, 它们代表了周期性盒子的三个基矢量.

如果从 [ \\(t=t_0\\) ]{.math} 开始运行, 必须知道 [ \\(t=t_0\\) ]{.math}
时刻的坐标. 如果以 [ \\(\\D t\\) ]{.math} 为时间步长, 使用默认的
**蛙跳式算法** 更新时间步(参见3.4.4节), 还需要知道 [
\\(t=t_0-{1\\over2}\\D t\\) ]{.math} 时刻的速度. 如果没有可用的速度,
程序可以根据给定的绝对温度 [ \\(T\\) ]{.math} 产生所需要的初始原子速度 [
\\(v_i, i=1 \... 3N\\) ]{.math} (图3.4):

[ \\\[p(v_i)=\\sqrt{ {m_i \\over 2\\p kT } } \\exp\\left(-{m_iv_i\^2
\\over 2kT} \\right) \\tag{3.7}\\\] ]{.math}

其中 [ \\(k\\) ]{.math} 为玻耳兹曼常数(见第二章). 为此,
会使用产生12个随机数 [ \\(R_k\\) ]{.math} , [ \\(0 \\le R_k \< 1\\)
]{.math} 并从其和中减去6的方法来产生服从正态分布的随机数.
结果会乘上速度分布的标准偏差 [ \\(\\sqrt{kT/m_i}\\) ]{.math} .
因为由此得到的总能量不会精确地对应于所需的温度 [ \\(T\\) ]{.math} ,
需要进行校正: 首先移除质心的运动, 然后再对所有的速度进行缩放,
以使总能量恰好对应于 [ \\(T\\) ]{.math} (参见公式3.18).

**质心运动**

正常情况下, 在每一步中都会将质心的速度设置为零,
体系(通常)不受净的合外力作用, 其质心速度应该保持不变. 然而在实际中,
更新算法会导致质心速度发生缓慢的变化, 并因此使得体系的总动能发生变化,
特别是使用温度耦合时. 如果不对这种变化进行处理,
长时间后质心会有明显的运动, 温度也出现显著异常.
体系的整体转动也会导致同样的问题, 但只出现在孤立团簇的模拟中.
在填满盒子的周期性体系中, 整体转动会与其它自由度耦合, 不会导致这个问题.

### 3.4.2 近邻搜索 {#342-近邻搜索}

正如在第四章提到的, 内力或者由固定(静态)列表产生, 或者由动态列表产生.
后者包含了任意粒子对之间的非键相互作用. 当计算非键力时,
将所有粒子置于长方体盒子中计算更容易. 如图3.1所示,
可以通过一定的方法将三斜盒转换为长方盒.
所以GROMACS的输出坐标总是处于一个长方盒中,
即使模拟时使用了十二面体盒子或三斜盒子.
方程3.1保证了我们可以通过如下方法重置粒子使其处于长方盒中: 先沿盒矢量 [
\\(\\bi c\\) ]{.math} 移动, 再沿 [ \\(\\bi b\\) ]{.math} 移动, 最后沿 [
\\(\\bi a\\) ]{.math} 移动. 根据三个限制性方程3.3, 3.4和3.5,
我们可以利用不超过一倍盒矢量的线性组合找到14个最近的三斜盒子映象.

**配对列表的生成**

只需要对一些粒子对 [ \\(i, j\\) ]{.math} 之间的非键配对力进行计算,
在这些粒子对中, 粒子 [ \\(i\\) ]{.math} 和 [ \\(j\\) ]{.math}
的最近映象之间的距离 [ \\(r\_{ij}\\) ]{.math} 小于给定的截断半径 [
\\(R_c\\) ]{.math} . 如果彼此之间的相互作用已完全被键合作用所考虑,
一些满足这一条件的粒子对仍然会被排除. GROMACS使用了一个 **配对列表** ,
其中包含了那些必须计算彼此之间非键力的粒子对. 这个列表中包含原子 [
\\(i\\) ]{.math} , 原子 [ \\(i\\) ]{.math} 的位移向量, 距离原子 [
\\(i\\) ]{.math} 的这个特殊映象 ` rlist ` 范围内的所有粒子 [ \\(j\\)
]{.math} . 该列表每 ` nstlist ` 步更新一次, ` nstlist ` 的典型值为10.
有一个选项可用来计算每个粒子所受到的总的非键力,
这些力来源于围绕列表截断值, 即距离在 ` rlist ` 和 ` rlistlong `
之间的壳层中的所有粒子. 在更新配对列表时, 会计算这些力, 并在随后的
` nstlist ` 中保持不变.

为创建邻区列表, 必须找到与给定粒子相近(即在邻居列表截断内)的所有粒子.
这种搜索通常被称为邻区搜索(NS, neighbor search)或对搜索(pair search),
涉及到周期性边界条件和映象的确定(参见3.2节). 搜索算法的复杂度为 [
\\(O(N)\\) ]{.math} , 尽管更简单的 [ \\(O(N\^2)\\) ]{.math}
算法在一定条件下仍然可用.

**邻区截断方案: 原子组与Verlet缓冲**

从4.6版本开始, GROMACS支持两种不同的截断方案设置:
最初的基于原子组的方案和使用Verlet缓冲区的方案.
它们之间存在一些非常重要的区别, 这些区别可能会影响计算结果,
计算性能和某些功能的支持情况. 组方案(几乎)可以像Verlet方案一样运行,
但这将导致性能降低. 对在模拟中常用的水分子, 组方案特别快,
但在最近的x86处理器中, 这种优势消失了,
因为可以在Verlet方案的实现中使用更好的指令级并行.
在5.0版本中已经不再提倡使用组方案了, 将来的版本中将会删除此方案.

在组方案中, 近邻列表由至少含一个原子的原子对构成.
这些原子组最初是电荷组(参见3.4.2节), 但对长程静电进行了妥善处理,
性能是它们唯一的优势. 几何中心在截断距离内的两个组会被放入近邻列表中.
在一定数目的MD模拟步中,
会计算所有原子对(每个电荷组一个)之间的相互作用力,
直到下一次更新近邻列表. 这种设置高效, 因为近邻搜索只检查电荷组对,
而不是原子对(对三原子水模型可节约 [ \\(3\\times 3=9\\) ]{.math} 倍),
而且还可以优化非键合力的计算内核, 比如说一个水分子"组".
没有明确的缓冲时, 由于一些原子对处于截断距离之内却没有相互作用,
而一些原子对处于截断距离之外却有相互作用, 这种设置会导致能量的漂移.
可能有以下原因:

-   原子在两次近邻搜索之间穿过了截断区域, 和/或
-   对包含一个以上原子的电荷组,
    当电荷组的几何中心移动到截断距离以外/内时,
    会导致一部分原子对移动到截断距离以内/外.

显式地为近邻列表增加一个缓冲会消除这些问题, 但这需要较高的计算成本.
问题的严重程度取决于体系, 你感兴趣的性质, 以及截断距离的设置.

Verlet截断方案默认使用缓冲对列表. 它也使用了原子团簇,
但这些不像在组方案中是静态的. 相反, 团簇以空间定义, 包含4个或8个原子,
使用如SSE, AVX和GPU的CUDA等可方便地对此进行流计算. 在近邻搜索步骤中,
使用Verlet缓冲创建对列表, 即对列表的截断距离大于相互作用的截断距离.
在计算非键力的内核中, 只有当一个原子对在特定时间步处于截断距离之内时,
这个力才会被加入到近邻列表中. 当原子在两次对搜索步骤中移动时,
这确保了几乎所有处于截断距离内的原子之间的力都会被计算. 我们说, **几乎**
所有的原子, 是因为GROMACS使用了一个固定的对列表更新频率以提高效率.
一个处于截断距离外的原子对, 在这样固定的步数中,
可能移动得足够多以致处于截断距离之内. 这种小概率事件会导致小的能量漂移,
而且概率的大小取决于温度. 当使用温度耦合时, 给定能量漂移的一定容差,
可以自动确定缓冲大小.

在 ` mdp ` 文件中Verlet方案的设置为:

    cutoff-scheme             = Verlet
    Verlet-buffer-tolerance   = 0.005

Verlet缓冲的大小由后一选项决定, 这里使用了默认设置:
在一对原子中每个原子的能量误差为0.005 kJ/mol/ps. 需要注意的是,
在配对能量的误差会相互抵消,
这对总能量漂移的影响通常至少比容差小一个数量级. 此外,
总能量的漂移受许多其他因素影响, 通常, 来自约束算法的贡献占主导地位.

对等能量(NVE)模拟, 缓冲大小由对应于速度(无论由何种合适的方法产生,
或由输入文件提供)的温度来决定. 此外, 容差可以设置为--1, 并手动指定缓冲:
` rlist > max(rcoulomb, rvdw) ` . 得到合理缓冲大小的最简单方法是:
利用NVT的 ` mdp ` 文件并将目标温度设定为NVE模拟中你希望使用的温度,
然后将 ` grompp ` 打印出的缓冲大小移植到NVE的 ` mdp ` 文件中.

基于粒子团簇实现的Verlet截断方案非常高效.
最简单的例子是包含4个粒子的团簇. 然后基于团簇对构建对列表.
团簇对搜索比基于粒子对的搜索快得多, 因为一次可以将 [ \\(4 \\times 4=
16\\) ]{.math} 个粒子置于列表中.
然后就可以一次计算这16个粒子对之间的非键相互作用,
这可以很好地映射到SIMD单元, 它一次可以执行多个浮点运算(例如基于SSE, AVX,
GPU的CUDA, BlueGene FPUs). 在绝大多数类型的体系中,
这种非键相互作用的计算内核要比组方案的内核快很多,
除了在短SIMD宽度的处理器上, 对水分子不使用缓冲对列表时.
后者在(生物)分子模拟中很常见, 所以为了达到最快速度,
值得比较两种方案的性能.

由于Verlet截断方案在4.6版本的GROMACS中才推出,
所以它并不支持组方案中的所有功能.
Verlet截断方案支持一些组方案不支持的功能,
表3.2给出了两种截断方案中不(完全)支持的功能.

  非键相互作用特性               组          Verlet     
  -------------------------- ----------- -------------- --
  无缓冲截断方式                  √          非默认     
  精确截断                    移位/切换        √        
  移位相互作用                 力+能量        能量      
  切换势能                        √            √        
  切换力                          √            √        
  非周期性体系                    √           Z+墙      
  隐式溶剂                        √                     
  自由能微扰的非键相互作用        √            √        
  组能量贡献                      √       CPU(而非GPU)  
  能量组排除                      √                     
  AdResS多尺度                    √                     
  OpenMP多线程                  仅PME          √        
  GPU原生支持                                  √        
  Lennard-Jones PME               √            √        

  : 表3.2: 组方案与Verlet截断方案之间(仅)在非键功能上支持的区别

**能源漂移与对列表缓冲**

对于一个正则系综(NVT), 由有限的Verlet缓冲大小所造成的平均能量误差,
可以由截断处的原子位移和势能形状来确定. 在温度 [ \\(T\\) ]{.math} 下,
一个质量为 [ \\(m\\) ]{.math} 的自由粒子, 其一维方向上的位移在时间 [
\\(t\\) ]{.math} 内的分布为高斯分布, 均值为0, 方差为 [
\\(\\s\^2=tk_BT/m\\) ]{.math} . 对两个原子之间的距离, 其方差变为 [
\\(\\s\^2 = \\s\_{12}\^2 = t k_B T(1/m_1 +1/m_2)\\) ]{.math} . 注意,
在实际过程中, 时间 [ \\(t\\) ]{.math} 内粒子通常还会与其他粒子相互作用,
所以实际的位移分布会窄得多. 给定非键相互作用的截断距离 [ \\(r_c\\)
]{.math} , 对列表截断距离 [ \\(r_l=r_c+r_b\\) ]{.math} .
当类型为1的粒子被数密度为 [ \\(\\r_2\\) ]{.math} 的粒子类型2包围,
粒子间距从 [ \\(r_0\\) ]{.math} 变到 [ \\(r_t\\) ]{.math} 时,
我们可以得到在时间 [ \\(t\\) ]{.math}
之后1和2两种类型的粒子之间的相互作用的平均能量误差:

[ \\\[\\alg \\langle \\D V \\rangle & = \\int_0\^{r_c}
\\int\_{r_l}\^\\infty 4 \\p r_0\^2 \\r_2 V(r_t)G\\left({r_t-r_0 \\over
\\s} \\right) \\rmd {r_0} \\rmd{r_t} \\tag{3.8} \\\\ & \\approx
\\int\_{-\\infty}\^{r_c} \\int\_{r_l}\^\\infty 4 \\p r_0\^2 \\r_2
\\bigg\[ V\'(r_c)(r_t-r_c)+ \\\\ &\\phantom{\\approx
\\int\_{-\\infty}\^{r_c} \\int\_{r_l}\^\\infty 4 \\p r_0\^2 \\r_2
\\bigg\[{}\\ } V\'\'(r_c){1\\over2}(r_t-r_c)\^2 \\bigg\]
G\\left({r_t-r_0 \\over \\s}\\right) \\rmd {r_0} \\rmd{r_t} \\tag{3.9}
\\\\ & \\approx 4\\p(r_l+\\s)\^2 \\r_2 \\int\_{-\\infty}\^{r_c}
\\int\_{r_l}\^\\infty \\bigg\[ V\'(r_c)(r_t-r_c)+ \\\\
&\\phantom{\\approx 4\\p(r_l+\\s)\^2 \\r_2 \\int\_{-\\infty}\^{r_c}
\\int\_{r_l}\^\\infty \\bigg\[{}\\ } V\'\'(r_c){1\\over2}(r_t-r_c)\^2 +
\\\\ &\\phantom{\\approx 4\\p(r_l+\\s)\^2 \\r_2 \\int\_{-\\infty}\^{r_c}
\\int\_{r_l}\^\\infty \\bigg\[{}\\ } V\'\'\'(r_c){1\\over6}(r_t-r_c)\^3
\\bigg\] G\\left({r_t-r_0 \\over \\s}\\right) \\rmd {r_0} \\rmd{r_t}
\\tag{3.10} \\\\ & = 4\\p(r_l+\\s)\^2 \\r_2 \\bigg\\{ {1\\over2}
V\'(r_c) \\left\[ r_b \\s
G\\left(r_b\\over\\s\\right)-(r_b\^2+\\s\^2)E\\left(r_b\\over\\s\\right)
\\right\] + \\\\ &\\phantom{= 4\\p(r_l+\\s)\^2 \\r_2 \\bigg\\{ {}\\ }
{1\\over6} V\'\'(r_c) \\left\[ \\s(r_b\^2+2\\s\^2)
G\\left(r_b\\over\\s\\right)-r_b(r_b\^2+3\\s\^2)E\\left(r_b\\over\\s\\right)
\\right\] + \\\\ &\\phantom{= 4\\p(r_l+\\s)\^2 \\r_2 \\bigg\\{ {}\\ }
{1\\over24} V\'\'\'(r_c) \\left\[ r_b\\s(r_b\^2+5\\s\^2)
G\\left(r_b\\over\\s\\right)-(r_b\^4+6r_b\^2\\s\^2+3\\s\^2)E\\left(r_b\\over\\s\\right)\\right\]
\\bigg\\} \\tag{3.11} \\ealg\\\] ]{.math}

其中 [ \\(G\\) ]{.math} 为零均值单位方差的高斯分布, [
\\(E(x)={1\\over2}\\text{erfc}(x/\\sqrt 2)\\) ]{.math} .
我们总是希望得到的误差很小, 所以 [ \\(\\s\\) ]{.math} 比 [ \\(r_c\\)
]{.math} 和 [ \\(r_l\\) ]{.math} 都小, 这样上述方程中的近似很好,
因为高斯分布衰减很快. 能量误差需要对所有粒子对类型进行平均,
并对粒子数进行加权. 在GROMACS中我们不允许粒子对类型之间的误差抵消,
所以我们对绝对值进行平均. 为获得单位时间的平均能量误差,
需要将平均能量误差除以近邻列表时间长度 [ \\(t=(\\text{nslist}-1)\\times
\\text{dt}\\) ]{.math} . 此函数不能解析地得到, 因此对给定的目标漂移,
我们使用二分法来获得缓冲大小 [ \\(r_b\\) ]{.math} . 我们还注意到,
在实际中误差通常比这里估计的小很多,
如凝聚相中粒子的位移会比自由移动粒子的位移小得多, 这里使用了这个假定.

当存在(键)约束时, 一些粒子的自由度会变少. 这会减少能量误差.
一个具有两个自由度的粒子任意方向上的位移并不是高斯分布,
而是服从余误差函数:

[ \\\[{\\sqrt \\p \\over 2\\sqrt 2 \\s} \\text{erfc}\\left({\|r\| \\over
\\sqrt 2 \\s} \\right) \\tag{3.12}\\\] ]{.math}

其中 [ \\(\\s\^2\\) ]{.math} 为 [ \\(k_BT/m\\) ]{.math} .
没有办法解析地对此分布进行积分以获得能量误差.
但我们可以使用缩放和移位高斯分布来得到紧上界(这里未给出).
这种高斯分布可用于计算能量误差, 如上所述. 现在我们来考虑约束粒子,
即具有2个或更少自由度的粒子, 它们通过约束连接到其他粒子上,
其他粒子的总质量至少为约束粒子本身质量1.5倍. 对具有单个约束的粒子,
沿约束方向的总质量至少是2.5倍,
这样沿约束方向的位移方差至少减少为原来的1/6.25.
由于高斯分布衰减非常迅速, 这有效地移除了来自位移的一个自由度.
多重约束会减少更多位移, 但因为会变得非常复杂,
我们将那些粒子视为只有2个自由度的粒子.

还有一个重要的实现细节, 可减少因有限的Verlet缓冲列表大小造成的能量误差.
上述推导假定了粒子对列表. 然而, GROMACS实现时使用了团簇对列表以提高效率.
在大多数情况下, 对列表包含4个粒子组成的团簇之间的对, 也称为 [
\\(4\\times4\\) ]{.math} 列表, 但也可以是 [ \\(4\\times8\\) ]{.math}
(GPU CUDA内核和AVX 256位单精度内核)或 [ \\(4\\times2\\) ]{.math}
(SSE双精度内核). 这意味着对列表比相应的 [ \\(1\\times1\\) ]{.math}
列表高效得多. 这样稍微超出对列表截断时, 列表中仍然会有一大部分粒子.
这些粒子所占的总粒子的分数可以在模拟中确定,
并精确地根据一些合理的假设进行估计. 随着对列表范围的增加,
这些粒子分数减小, 意味着可以使用较小的缓冲. 对于典型的全原子模拟,
使用0.9 nm截断, 这个分数大约是0.9, 可使能量误差减少到原来的1/10.
在自动Verlet的缓冲计算时考虑了这种减少, 这样得到的缓冲尺寸较小.

由图3.5可以看出, 对小的缓冲大小, 由于误差抵消,
总能量漂移比对能量误差容差小得多. 对于较大的缓冲大小,
误差估计比总能量漂移高6倍, 或者缓冲估计大0.024 nm.
这是因为质子自由移动不能超过18 fs, 但振动可以.

<figure>
<img src="/GMX/3.5.png"
alt="图3.5: 温度 300 K时, SPC/E水体系中每个原子的能量漂移, 模拟使用的时间步长为2 fs, 对列表更新周期为10步(对列表更新时间长度: 18 fs). 使用了PME方法, ewald-rtol设置为 $10^{-5}$; 该参数影响截断处的势能形状. 图中显示了因有限Verlet缓冲大小, 对 $1\times1$ 和 $4\times4$ 原子对列表, 不使用和使用(虚线)正负误差抵消时引起的误差估计. 图中显示的实际能源漂移在模拟时使用了双精度和混合精度. 使用单精度时, 由SETTLE约束算法的舍入误差引起的漂移在缓冲尺寸很大时变为负值. 注意, 缓冲大小为零时, 实际漂移很小, 因为正的(H-H)和负的(O-H)能量误差会相互抵消." />
<figcaption>图3.5: 温度 300 K时, SPC/E水体系中每个原子的能量漂移,
模拟使用的时间步长为2 fs, 对列表更新周期为10步(对列表更新时间长度: 18
fs). 使用了PME方法, <code> ewald-rtol </code> 设置为 <span class="math">
\(10^{-5}\) </span> ; 该参数影响截断处的势能形状.
图中显示了因有限Verlet缓冲大小, 对 <span class="math"> \(1\times1\)
</span> 和 <span class="math"> \(4\times4\) </span> 原子对列表,
不使用和使用(虚线)正负误差抵消时引起的误差估计.
图中显示的实际能源漂移在模拟时使用了双精度和混合精度. 使用单精度时,
由SETTLE约束算法的舍入误差引起的漂移在缓冲尺寸很大时变为负值. 注意,
缓冲大小为零时, 实际漂移很小,
因为正的(H-H)和负的(O-H)能量误差会相互抵消.</figcaption>
</figure>

**截断假象与切换相互作用**

使用Verlet方案时, 可以平移对势使其在截断处为零, 以保证势能等于力的积分.
在组方案中, 只有当势能满足在截断距离处的值为零时,
才可以保证势能等于力的积分. 然而, 当力在截断处不为零时仍会引起能量漂移.
这种影响非常小, 通常觉察不到,
因为其它积分误差(如来自约束的)可能占主到地位. 为完全避免截断假象,
可以将非键力在到达近邻列表截断前精确地切换至零(在GROMACS中有几种方式完成,
见4.1.5节). 这样就形成一个大小等于近邻列表截断,
小于最长相互作用截断的缓冲.

使用组截断方案, 也可以选择让 ` mdrun ` 只在需要时才更新近邻列表,
也就是当一个或多个粒子从它们所属的电荷组(见3.4.2节)的几何中心移动的距离超过半个缓冲大小时,
中心由前一步的近邻搜索决定. 此选项可保证没有截断假象, **注意** ,
对较大的体系, 这种计算的代价很高,
因为近邻列表更新频率将由移动稍微超过半个缓冲长度的一两个粒子决定(这甚至都不意味着近邻列表无效),
而99.99%的粒子近邻列表依然有效.

**简单搜索**

由于方程3.1和3.6, 连接处于截断距离 [ \\(R_c\\) ]{.math} 内的映象的向量 [
\\(\\bi r\_{ij}\\) ]{.math} 可通过下面方法获得:

[ \\\[\\alg \\bi r\'\'\' &= \\bi r_j-\\bi r_i \\tag{3.13} \\\\ \\bi
r\'\' &= \\bi r\'\'\'-\\bi c \* \\text{round}(r_z\'\'\'/c_z) \\tag{3.14}
\\\\ \\bi r\' &= \\bi r\'\'-\\bi b \* \\text{round}(r_y\'\'/b_y)
\\tag{3.15} \\\\ \\bi r\_{ij} &= \\bi r\'-\\bi a \*
\\text{round}(r_x\'/a_x) \\tag{3.16} \\\\ \\ealg\\\] ]{.math}

当需要计算三斜盒子中两粒子间的距离时, 它们不服从方程3.1,
需要将许多盒向量的组合进行移位, 以找到最近的映象.

![图3.6: 二维格点搜索. 箭头为盒向量.](/GMX/3.6.png)

**格点搜索**

格点搜索示意图见图3.6. 所有粒子被置于NS格点上, 每一方向上的最小间距 [
\\(\\ge R_c/2\\) ]{.math} . 在每一盒向量方向上, 粒子 [ \\(i\\) ]{.math}
有三个映象. 对每一方向映象可能是--1, 0或1, 相应于平移--1, 0或+1个盒向量.
对 [ \\(i\\) ]{.math} 的近邻, 我们不是先搜索周围的NS格点单元再计算映象,
而是先构造映象再搜索对应 [ \\(i\\) ]{.math} 的映象的近邻. 如图3.6所示,
对 [ \\(i\\) ]{.math} 的不同映象, 一些格点单元的搜索次数会查过一.
这并不是一个问题, 因为由于最小映象约定, 最多只有一个映象能够"看到"粒子 [
\\(j\\) ]{.math} . 对每个粒子, 搜索的近邻单元少于125(5 ^3^ )个. 因此,
算法对粒子数是线性标度的. 虽然前因子很大, 当粒子数超过几百时,
标度行为使得算法远优于标准的 [ \\(O(N\^2)\\) ]{.math} 算法.
格点搜索对长方盒子与三斜盒子同样快. 这样对大多数蛋白质和多肽模拟,
使用菱形十二面体盒子更好.

**电荷组**

最初引入电荷组是为了减少库仑相互作用的截断假象. 使用普通截断时,
当带(部分)电荷的原子移进移出截断半径时, 势能与力会出现明显的跃变.
当所有化学基团的净电荷为零时,
通过移动净电荷为零的原子组进出近邻列表可以减小这些跃变.
这些原子组被称为电荷组.
这种方法将截断效应从电荷电荷水平降低到衰减快得多的偶极偶极水平.
随着全范围静电方法的出现, 如粒子网格Ewald方法(见4.8.2节),
不再需要使用电荷组来提高精度了. 依赖于如何创建近邻列表,
如何计算相互作用, 电荷组甚至可能对精度和效率有小的负面影响.

但仍然有一个重要原因来使用"电荷组": 组截断方案的效率. 当适用时,
近邻搜索基于在分子拓扑中定义的电荷组进行. 若两个电荷组原子的
**几何中心** 之间的最近映象距离小于截断半径,
对列表中会包含电荷组之间的所有原子对. 例如, 对水体系的近邻搜索,
当每个分子被视为一个电荷组时 会快3 ^2^ =9倍. 另外,
计算水中原子受力的高度优化的循环只能用于水分子中的所有原子形成单个电荷组的情况.
目前使用 **近邻搜索组** 可能更合适, 但由于历史原因仍保留了名称电荷组.
当发展新的力场时, 建议使用3到4个原子的电荷组以获得最佳性能.
对全原子力场这相对容易, 因为可以简单地把氢原子, 一些情况下的氧原子,
置于与其相连的重原子相同的电荷组中, 如CH ~3~ , CH ~2~ , CH, NH ~2~ , NH,
OH, CO ~2~ , CO.

使用Verlet截断方案时, 电荷组被忽略.

### 3.4.3 计算力 {#343-计算力}

**势能**

当计算力时, 同时会计算每项相互作用的势能. 总势能是所有项的加和,
如Lennard-Jones项, 库仑项和键合项. 也可以计算 **能量监测组**
对这些项的贡献, 组成能量监测组的原子可以单独定义(参见3.3节).

**动能和温度**

对含有 [ \\(N\\) ]{.math} 个粒子的体系, 温度由总动能给出:

[ \\\[E\_{\\text{kin} }={1\\over2} \\sum\_{i=1}\^N m_i v_i\^2
\\tag{3.17}\\\] ]{.math}

由此可计算绝对温度 [ \\(T\\) ]{.math} :

[ \\\[{1\\over2}N\_{\\text{df} }kT=E\_{\\text{kin} } \\tag{3.18}\\\]
]{.math}

其中 [ \\(k\\) ]{.math} 为玻尔兹曼常数, [ \\(N\_{\\text{df} }\\)
]{.math} 为自由度数, 可根据下式计算:

[ \\\[N\_{\\text{df} } = 3N-N_c-N\_{\\text{com} } \\tag{3.19}\\\]
]{.math}

这里 [ \\(N_c\\) ]{.math} 为施加在体系上的 **约束** 的数目.
在进行分子动力学模拟时, 必须去除 [ \\(N\_{\\text{com} }=3\\) ]{.math}
个额外的自由度, 因为三个质心速度是运动常量, 通常设置为零.
当在真空中进行模拟时, 绕质心的转动也可以被去除, 这种情况下 [
\\(N\_{\\text{com} }=6\\) ]{.math} . 当使用一个以上的温度耦合组时, 第 [
\\(i\\) ]{.math} 组的自由度数目为:

[ \\\[N\_{\\text{df} }\^i=(3N\^i-N_c\^i) {3N-N_c-N\_{\\text{com} }
\\over 3N-N_c} \\tag{3.20}\\\] ]{.math}

当计算三斜体系的压力, 或者体系受到剪切力作用时,
将动能写成张量形式能带来方便

[ \\\[\\bi E\_{\\text{kin} }={1\\over2}\\sum_i\^N m_i \\bi v_i \\otimes
\\bi v_i \\tag{3.21}\\\] ]{.math}

**压力和维里**

压力张量 [ \\(\\bi P\\) ]{.math} 可以通过动能 [ \\(E\_{\\text{kin} }\\)
]{.math} 和维里 [ \\(\\bi \\X\\) ]{.math} 的差值来计算:

\$\$ \\bi P={2\\over V}(\\bi E\_{\\text{kin}}-\\bi \\X) \\tag{3.22}\$\$

其中 [ \\(V\\) ]{.math} 为盒子的体积.
在各向同性体系中被用于压力耦合的标量压力 [ \\(P\\) ]{.math} 为:

[ \\\[P = \\text{trace} (\\bi P)/3 \\tag{3.23}\\\] ]{.math}

维里张量 [ \\(\\bi \\X\\) ]{.math} 定义为:

[ \\\[\\bi \\X = -{1\\over2} \\Sum\_{i \< j} \\bi r\_{ij} \\otimes \\bi
F\_{ij} \\tag{3.24}\\\] ]{.math}

GROMACS计算维里的实现方法请参考B.1节.

<figure>
<img src="/GMX/3.7.png"
alt="图3.7: 蛙跳式积分方法. 该算法被称为蛙跳是因为 $\bi r$ 和 $\bi v$ 好像青蛙一样在彼此的背上跳跃." />
<figcaption>图3.7: 蛙跳式积分方法. 该算法被称为蛙跳是因为 <span
class="math"> \(\bi r\) </span> 和 <span class="math"> \(\bi v\) </span>
好像青蛙一样在彼此的背上跳跃.</figcaption>
</figure>

### 3.4.4 蛙跳式积分方法 {#344-蛙跳式积分方法}

GROMACS中默认的MD积分方法是所谓的 **蛙跳式算法** \[20\],
用于积分运动方程. 当需要非常精确的积分方法并采用温度和/或压力耦合时,
使用速度Verlet积分方法可能更好(参见3.4.5节). 蛙跳式算法使用了 [ \\(t\\)
]{.math} 时刻的位置 [ \\(\\bi r\\) ]{.math} 和 [ \\(t-{1\\over2}\\D t\\)
]{.math} 时刻的速度 [ \\(\\bi v\\) ]{.math} , 根据 [ \\(t\\) ]{.math}
时刻的位置计算出力 [ \\(\\bi F(t)\\) ]{.math} ,
并利用下面的方法更新位置和速度

[ \\(\\alg \\bi v(t+{1\\over2}\\D t) &= \\bi v(t-{1\\over2}\\D t)+{\\D
t\\over m}\\bi F(t) \\tag{3.25} \\\\ \\bi r(t+\\D t) &= \\bi r(t)+\\D t
\\bi v(t+{1\\over2}\\D t) \\tag{3.26} \\ealg\\) ]{.math}

图3.7是蛙跳式算法的形象说明. 它产生的轨迹与Verlet算法\[21\]完全一样,
它更新位置的方法是

[ \\\[\\bi r(t +\\D t)=2 \\bi r(t)-\\bi r(t-\\D t) +{1\\over m} \\bi
F(t)\\D t\^2 + O(\\D t\^4) \\tag{3.27}\\\] ]{.math}

蛙跳式算法对 [ \\(\\bi r\\) ]{.math} 具有三阶精度, 并且时间可逆.
关于此算法的优点以及与其他时间积分算法的比较, 请参看文献\[22\].

为考虑温度耦合和压力耦合并扩展以包含约束守恒, 我们修改了运动方程,
详细情况将在后面进行讨论.

### 3.4.5 速度verlet积分方法 {#345-速度verlet积分方法}

GROMACS也实现了速度Verlet算法\[23\], 尽管它与所有选项的整合还没有完全好.
在速度Verlet方法中, 利用 [ \\(t\\) ]{.math} 时刻的位置 [ \\(\\bi r\\)
]{.math} 和速度 [ \\(\\bi v\\) ]{.math} 积分运动方程,
并不需要前半步时刻的速度.

[ \\(\\alg \\bi v(t+{1\\over2}\\D t) &= \\bi v(t)+{\\D t \\over 2m} \\bi
F(t) \\tag{3.28} \\\\ \\bi r(t+\\D t) &= \\bi r(t)+\\D t \\bi
v(t+{1\\over2}\\D t) \\tag{3.29} \\\\ \\bi v(t+\\D t) &= \\bi
v(t+{1\\over2}\\D t)+{\\D t \\over 2m} \\bi F(t+\\D t) \\tag{3.30}
\\ealg\\) ]{.math}

或者, 等价地,

[ \\(\\alg \\bi r(t+\\D t) &= \\bi r(t)+\\D t \\bi v + {\\D t\^2 \\over
2m} \\bi F(t) \\tag{3.31} \\\\ \\bi v(t+\\D t) &= \\bi v(t)+{\\D t
\\over 2m}\[\\bi F(t)+ \\bi F(t+\\D t)\] \\tag{3.32} \\ealg\\) ]{.math}

不使用温度或压力耦合, 并从 **对应** 的起始点出发,
蛙跳式方法和速度Verlet方法会给出完全相同的轨迹,
你可以容易地利用上面给出的方程证明这一点. 给定一个具有 **相同** 起始点 [
\\(\\bi x(0)\\) ]{.math} 和 [ \\(\\bi v(0)\\) ]{.math} 的起始文件,
蛙跳式方法和速度Verlet方法 **不会** 给出相同的轨迹,
因为蛙跳式方法的速度对应于 [ \\(t=-{1\\over2}\\D t\\) ]{.math} 时刻,
而速度Verlet方法会认为它们对应于 [ \\(t=0\\) ]{.math} 时刻.

### 3.4.6 理解可逆的积分方法: Trotter分解 {#346-理解可逆的积分方法-trotter分解}

为进一步理解速度Verlet和蛙跳式积分方法之间的关系,
我们引入动力学中的可逆Trotter公式,
它对于理解GROMACS的热浴和压力浴的实现也是非常有用的.

对一个耦合一阶微分方程系统, 可利用演化算符用得到体系从 [ \\(t=0\\)
]{.math} 时刻到 [ \\(t\\) ]{.math} 时刻的演化

[ \\(\\alg \\G(t) &= \\exp(iLt) \\G(0) \\\\ iL &= \\dot \\G \\cdot
\\nabla\_\\G \\tag{3.33} \\ealg\\) ]{.math}

其中 [ \\(L\\) ]{.math} 为Liouville算符, [ \\(\\G\\) ]{.math}
为自变量(位置和速度)的多维向量. 将精确算符的一个短时间近似, 在 [ \\(\\D
t=t/P\\) ]{.math} 时刻是精确的, 连续应用 [ \\(P\\) ]{.math}
次可使体系演化为

[ \\\[\\G(t)=\\prod\_{i=1}\^P \\exp(iL\\D t) \\G(0) \\tag{3.34}\\\]
]{.math}

对NVE动力学, Liouville算子为

[ \\\[iL=\\Sum\_{i=1}\^N \\bi v_i \\cdot \\nabla\_{\\bi r_i} +
\\Sum\_{i=1}\^N {1 \\over m_i} \\bi F(r_i) \\cdot \\nabla\_{\\bi v_i}
\\tag{3.35}\\\] ]{.math}

它可以被分解为两个算符的加和

[ \\(\\alg iL_1 &= \\Sum\_{i=1}\^N {1 \\over m_i} \\bi F(r_i) \\cdot
\\nabla\_{\\bi v_i} \\\\ iL_2 &= \\Sum\_{i=1}\^N \\bi v_i \\cdot
\\nabla\_{\\bi r_i} \\tag{3.36} \\ealg\\) ]{.math}

这样, 真正动力学在短时间内, 对称可逆的近似为

[ \\\[\\exp(iL\\D t) = \\exp(iL_2{1\\over2}\\D t) \\exp(iL_1 \\D t)
\\exp(iL_2{1\\over2}\\D t)+O(\\D t\^3) \\tag{3.37}\\\] ]{.math}

这对应于速度Verlet积分方法. 第一个 [ \\({1\\over2}\\D t\\) ]{.math}
指数项对应于半个速度步, 第二个 [ \\(\\D t\\) ]{.math}
指数项对应于一个完整的速度步, 最后的 [ \\({1\\over2}\\D t\\) ]{.math}
指数项是最终的半个速度步. 对于未来时刻 [ \\(t=n\\D t\\) ]{.math} ,
上式变为

[ \\(\\alg \\exp(iLn\\D t) &\\approx &\\left( \\exp(iL_2{1\\over2}\\D t)
\\exp(iL_1 \\D t) \\exp(iL_2{1\\over2}\\D t) \\right)\^n \\\\ & \\approx
&\\exp(iL_2{1\\over2}\\D t) \\left( \\exp(iL_1 \\D t) \\exp(iL_2 \\D t)
\\right)\^{n-1} \\\\ & &\\exp(iL_1 \\D t) \\exp(iL_2{1\\over2}\\D t)
\\tag{3.38} \\ealg\\) ]{.math}

利用这种形式, 我们可以很容易看到的不同Verlet积分方法之间的差异.
蛙跳式积分方法可以看作使用方程3.37的 [ \\(\\exp(iL_1 \\D t)\\) ]{.math}
项代替半步速度项启动, 得到

[ \\\[\\exp(iL n \\D t) = \\exp(iL_1 \\D t) \\exp(iL_2 \\D t) +O(\\D
t\^3) \\tag{3.39}\\\] ]{.math}

这里, 速度的整步处于 [ \\(t-{1\\over2}\\D t\\) ]{.math} 和 [
\\(t+{1\\over2}\\D t\\) ]{.math} 之间,
因为它是速度Verlet中速度半步的组合. 对未来的时刻 [ \\(t=n\\D t\\)
]{.math} , 此式变为

[ \\\[\\exp(iL n \\D t) \\approx \\left( \\exp(iL_1 \\D t) \\exp(iL_2
\\D t) \\right)\^n \\tag{3.40}\\\] ]{.math}

虽然上式初看起来不对称, 只要整个速度步处于 [ \\(t-{1\\over2}\\D t\\)
]{.math} 和 [ \\(t+{1\\over2}\\D t\\) ]{.math} 之间,
这就是在循环中的不同地方启动速度Verlet的一种简单方法.

尽管蛙跳式方法和速度Verlet方法得到的轨迹和势能完全相同,
动能和温度并不一定相同. 标准的速度Verlet方法使用 [ \\(t\\) ]{.math}
时刻的速度计算动能, 因而只有 [ \\(t\\) ]{.math} 时刻的温度,
动能是对所有粒子的加和

[ \\(\\alg KE\_{\\text{full} }(t) &= \\Sum_i \\left({1\\over 2m_i}\\bi
v_i(t) \\right)\^2 \\\\ &=\\Sum_i {1\\over 2m_i} \\left({1\\over 2}\\bi
v_i(t-{1\\over2}\\D t) + {1\\over 2}\\bi v_i(t+{1\\over2}\\D t)
\\right)\^2 \\tag{3.41} \\ealg\\) ]{.math}

平方出现于平均的 **外部** . 标准的蛙跳式方法基于时间步 [
\\(t+{1\\over2}\\D t\\) ]{.math} 和 [ \\(t-{1\\over2}\\D t\\) ]{.math}
的平均动能来计算 [ \\(t\\) ]{.math} 时刻的动能, 或对所有粒子的加和

[ \\\[KE\_{\\text{average} }(t) =\\Sum_i {1\\over 2m_i} \\left({1\\over
2}\\bi v_i(t-{1\\over2}\\D t)\^2 + {1\\over 2}\\bi v_i(t+{1\\over2}\\D
t)\^2 \\right) \\tag{3.42}\\\] ]{.math}

其中平方处于平均的 **内部** .

速度Verlet方法的非标准形式会对动能 [ \\(KE(t+{1\\over2}\\D t)\\)
]{.math} 和 [ \\(KE(t-{1\\over2}\\D t)\\) ]{.math} 进行平均,
与蛙跳式方法相同. GROMACS现在也实现了这种方法(利用 ` .mdp ` 文件中的
` md-vv-avek ` 选项). 无温度耦合和压力耦合时,
半步动能平均的速度Verlet方法和蛙跳式方法在数值精度内是完全相同的. 但是,
对于控温和控压方案, 半步动能平均的速度Verlet方法和蛙跳式方法会有所不同,
我们将在控温器和控压器部分对此进行讨论.

对于给定的步长, 半步平均的动能和温度稍微准确一些; 比起整步动能(使用
` md-vv ` ), 采用半步平均的动能( ` md ` 和 ` md-vv-avek `
)得到的平均动能的差异更接近于小步长极限情况下获得的动能. 对NVE模拟,
这种差别通常不明显, 因为粒子的位置与速度仍然完全相同;
差别在于模拟温度含义的 **解释** , 而 **不** 在于所产生的轨迹.
虽然半步平均方法得到的动能更精确, 意味着当时间步长变大时它受的影响小些,
但这种方法的噪声更大. 与整步动能方法相比,
半步平均动能方法得到的体系总能量(动能和势能的总和)的RMS偏差更大(在大多数情况下约高一倍).
漂移仍然是相同的, 并且轨迹也完全相同.

对NVT模拟, 两种方法 **将** 会有差异, 正如控温部分所讨论的,
因为会调节粒子的速度以使得模拟的动能,
以任何一种方式计算,都能达到与设定温度相应的分布. 在这种情况下,
三种方法不会给出完全相同的结果.

由于速度和位置都定义于同一时刻 [ \\(t\\) ]{.math} ,
速度Verlet积分方法可用于一些方法中, 特别是那些严格正确的控压方法,
实际上这些控压方法不能使用蛙跳式积分方法. 相比蛙跳式积分方法,
速度Verlet方法多耗费的时间可以忽略不计, 但目前需要的通讯调用多一倍.
在大多数情况下, 尤其是对于大的体系,其通讯速度对并行化非常重要,
热力学系综之间的差异以 [ \\(1/N\\) ]{.math} 极限消失. 当只需要NVT系综时,
蛙跳式可能是首选的积分方法. 对控压模拟, 热力学细节非常重要,
只有速度Verlet方法能给出真正的系综. 在任一情况下,
都可能需要采用双精度进行模拟以得到正确的热力学校正细节.

### 3.4.7 双程截断 {#347-双程截断}

为了节省计算时间, 相比变化迅速的力,
对变化缓慢的力计算时所用的频率可以低些. 在GROMACS中,
可以对短程和长程非键相互作用采用这样的多重时间步长分解. 直到GROMACS
4.0版本, 对此都采用了一种不可逆的积分方案, 这种方案也被用于GROMOS模拟包:
每 [ \\(n\\) ]{.math} 步计算一次长程力,
随后将这些值(不加修改)用于方程3.25中的后面 [ \\(n-1\\) ]{.math} 积分步.
这种不可逆的方案能量守恒性不好, 取样可能不充分. 从4.5版本开始,
采用了可逆Trotter分解方案的蛙跳式方法\[24\]. 在这种积分方法中, 每 [
\\(n\\) ]{.math} 步计算一次长程力, 然后使用时间步长 [ \\(\\D
t\_{LR}=n\\D t\\) ]{.math} 将其应用到方程3.25中的速度,

[ \\\[\\bi v(t+{1\\over2}\\D t)=\\begin{cases} \\bi v(t-{1\\over2}\\D
t)+{1\\over m}\[\\bi F\_\\text{SR}(t)+n\\bi F\_\\text{LR}(t)\\D t\]&,
&\\; \\text{step} \\% n=0 \\\\ \\bi v(t-{1\\over2}\\D t)+{1\\over m}\\bi
F\_\\text{SR}(t)\\D t &, &\\; \\text{step} \\% n \\ne 0 \\\\
\\end{cases} \\tag{3.43}\\\] ]{.math}

参数 [ \\(n\\) ]{.math} 等于近邻列表的更新频率. 在4.5版本中,
多重时间步的速度Verlet方案进尚未完全实现.

一些其他的模拟程序对键合力和/或PME网格力使用多重时间步长方法.
在GROMACS中, 我们(还)没有实现这个方法, 因为我们有着不同的想法.
键可以被约束(这也是对物理量子振子的更佳近似),
这允许将最小时间步长增加至更大值. 这不仅将计算力的次数减半,
也将更新计算的次数减半. 对于更大的时间步长,
涉及氢原子的键角振动可以使用虚拟相互作用位点移除(见6.8节),
这使得最短时间步达到多时间步方案中PME网格的更新频率.

<figure>
<img src="/GMX/3.8.png"
alt="图3.8: SPC/E水模型模拟中每个自由度的能量漂移和长程时间步长的关系, 使用双程截断时, 不可逆的GROMOS方案和可逆Trotter方案的对比: (左)反应场; (右) Lennard-Jones相互作用." />
<figcaption>图3.8:
SPC/E水模型模拟中每个自由度的能量漂移和长程时间步长的关系,
使用双程截断时, 不可逆的“GROMOS”方案和可逆Trotter方案的对比: (左)反应场;
(右) Lennard-Jones相互作用.</figcaption>
</figure>

作为一个例子, 我们在如3.8中展示了积分300
K温度下SPC/E水体系运动方程的能量守恒性. 为避免截断效应, 使用了反应场, [
\\(\\e\_{RF}=\\infty\\) ]{.math} 和移位Lennard-Jones相互作用.
二者都使用了缓冲. 长程相互作用在1.0和1.4 nm之间进行计算.
从图3.7可以看到, 对静电相互作用, 直到 [ \\(\\D t\_{LR}=16\\) ]{.math}
fs, Trotter方案的能量守恒性都要好一个数量级.
静电相互作用强烈地依赖于水分子变化很快的取向. 对Lennard-Jones相互作用,
能量漂移与 [ \\(\\D t\_{LR}\\) ]{.math} 呈线性关系,
大致比静电小两个数量级. Lennard-Jones力比库仑力小,
它们主要受水分子的平动影响, 而不是转动.

### 3.4.8 温度耦合 {#348-温度耦合}

直接使用的分子动力学模拟对应于NVE系综(粒子数不变, 体积不变,
能量恒定的系综), 我们希望计算的大多数物理量实际上对应于等温(NVT)系综,
也被称为正则系综. GROMACS可以使用Berendsen的 **弱耦合** 方案\[25\],
通过Andersen恒温器的随机化\[26\], 扩展系综的Nose-Hoover方案\[27, 28\],
或速度重缩放方案\[29\]来模拟恒温过程, 这些方案各自的优缺点将在下面介绍.

还有其他一些原因使得我们需要对体系的温度进行调控(平衡过程中的漂移,
力截断和积分误差引起的漂移, 外力或摩擦力导致的加热),
但从热力学的观点来看, 这并不是完全正确的. 在某些情况下,
这些做法只是掩盖了问题(增加了体系的温度),
而没有从根本上解决问题(动力学与真实物理过程之间存在的偏差).
对于大的体系, 系综平均引起的误差,
用于消除温度缓慢漂移的控温对结构性质的影响几乎可以忽略.
但如果没有进行完全的综合比较, 在解释模拟结果时必须谨慎.

**Berendsen温度耦合**

Berendsen算法模仿了与给定温度 [ \\(T_0\\) ]{.math} 的外部热浴相连,
并具有一级动力学特征的弱耦合.
参考文献\[30\]将它与Nose-Hoover方案进行了比较. 该算法的效果是,
根据下式慢慢校正体系温度对 [ \\(T_0\\) ]{.math} 的偏差:

[ \\\[{dT \\over dt} = {T_0-T \\over \\t} \\tag{3.44}\\\] ]{.math}

这意味着温度偏差指数衰减, 其时间常数为 [ \\(\\t\\) ]{.math} .
这种耦合方法的优点是, 耦合的强度可以改变以适应用户的需要:
对于以平衡为目的模拟可采取很小的时间常数(如0.01 ps);
但对于可靠的平衡模拟, 可采用更大的时间常数(如0.5 ps), 在这种情况下,
它几乎不会影响动力学的守恒性.

Berendsen恒温可降低动能的涨落. 这意味着, 它不会产生正确的正则系综,
所以严格来说, 采样是不正确的. 引入误差的标度为 [ \\(1/N\\) ]{.math} ,
因此对于非常大的体系, 大部分系综平均值不会受到显著影响,
除了动能本身的分布. 然而, 涨落性质, 如热容量, 将受到影响.
后面将要描述的速度重缩放恒温器\[29\]是一种与此类似的控温方法,
但能产生正确的系综.

流入或流出体系的热量受到对每个粒子的速度进行重新缩放的影响, 缩放每步或每
[ \\(n\_{\\text{tc}}\\) ]{.math} 步进行一次, 使用一个与时间相关的因子 [
\\(\\l\\) ]{.math} , :

[ \\\[\\l=\\left\[ 1+{n\_{\\text{TC}} \\D t \\over \\t_T} \\left\\{ {T_0
\\over T(t-{1\\over2}\\D t)}-1\\right\\} \\right\] \\tag{3.45}\\\]
]{.math}

参数 [ \\(\\t_T\\) ]{.math} 接近但不完全等于温度耦合的时间常数 [
\\(\\t\\) ]{.math} (方程3.44):

[ \\\[\\t=2C_V \\t_T / N\_{df} k \\tag{.46}\\\] ]{.math}

其中 [ \\(C_V\\) ]{.math} 为体系总的热容, [ \\(k\\) ]{.math}
为玻尔兹曼常数, [ \\(N\_{df}\\) ]{.math} 为总的自由度数. [ \\(\\t \\ne
\\t_T\\) ]{.math} 的原因在于,
缩放速度引起的动能变化会部分地在动能和势能之间进行重新分布, 因此,
温度的变化小于缩放能量. 实际上, 比值 [ \\(\\t/\\t_T\\) ]{.math}
的范围从1(气体)到2(简谐固体)到3(水). 当我们使用术语"温度耦合时间常数"时,
我们指的是参数 [ \\(\\t\\) ]{.math} . **注意** 缩放因子 [ \\(\\l\\)
]{.math} 在实际中被限制在 [ \\(0.8\<=\\l\<=1.25\\) ]{.math} 的范围内,
以避免当其过大时导致模拟体系崩溃. 在正常使用中, [ \\(\\l\\) ]{.math}
总是会更接近1.0.

**速度重缩放温度耦合**

速度重缩放恒温器\[29\]本质上是一个Berendsen恒温器(见上文),
并附加了一个随机项, 以保证能够给出正确的动能分布,
使用时根据下面的公式对动能进行修改:

[ \\\[dK = (K_O-K){dt \\over \\t_T}+2 \\sqrt{ {K K_0 \\over Nf} } {dW
\\over \\sqrt \\t_T} \\tag{3.47}\\\] ]{.math}

其中 [ \\(K\\) ]{.math} 为动能, [ \\(N_f\\) ]{.math} 为自由度数, [
\\(dW\\) ]{.math} 为Wiener过程. 除了随机数种子外, 没有另外的参数.
这种温控器能够产生正确的正则系综, 仍然具有Berendsen温控器的优点:
温度偏差一阶衰减, 无振荡. 当使用 [ \\(NVT\\) ]{.math} 系综时,
守恒的能量会被写入到能量文件和log文件.

**Andersen温控器**

保持恒温系综的一种简单的方式如下, 使用 [ \\(NVE\\) ]{.math} 积分方法,
并周期性地从麦克斯韦-玻尔兹曼分布中重新选择粒子的速度. \[26\]
这可以通过每 [ \\(\\t_T/\\D t\\) ]{.math}
步同时(大规模碰撞)将所有粒子的速度进行随机化( ` andersen-massive ` ),
或通过每步以小概率, 等于 [ \\(\\D t/\\t\\) ]{.math} , 随机化每个粒子(
` andersen ` ), 在这两种情况下, [ \\(\\D t\\) ]{.math} 为时间步长, [
\\(\\t_T\\) ]{.math} 为特征的耦合时间尺度. 由于约束的操作方式,
同一约束组中所有粒子的速度必须同时随机化. 由于并行问题, ` andersen `
选项目前(5.0)还不能用于含有约束的体系. ` andersen-massive `
的使用不受约束限制. 此温控器也是目前唯一可与速度Verlet算法一同使用的,
因为它在每个时间步的直接对速度进行操作.

这个算法完全避免了其他恒温算法具有的一些遍历性问题,
像能量不能在体系的能量去耦合组分间来回流动, 如在速度缩放运动中. 但是,
它可以通过随机化体系的相关运动降低体系的动能, 包括减慢采样, 当 [
\\(\\t_T\\) ]{.math} 处于中等水平时(小于10 ps). 因此,
该算法通常不能用于考察体系的动力学或输运性质. \[31\]

**Nose-Hoover温度耦合**

Berendsen弱耦合算法可以非常高效地将体系弛豫到到目标温度, 但是,
一旦系统达到平衡, 维持正确的正则系综更重要. 很可惜,
弱耦合方案并不能满足这一点.

为了使用正则系综模拟, GROMACS还支持扩展系综方法.
这种方法首先由Nose提出\[27\], 后经Hoover修改\[28\].
通过在运动方程中引入一个热容器和一个摩擦项,
方法对体系的哈密顿量进行了扩展. 摩擦力正比于每个粒子的速度和摩擦参数 [
\\(\\x\\) ]{.math} 的乘积.
这个摩擦参数(或"热浴"变量)是一个完全的动力学量, 有着自己是动量( [
\\(p\_\\x\\) ]{.math} )和运动方程;
其时间导数由当前动能和参考温度之间的差值来计算.

在这个公式中, 图3.3中粒子的运动方程被替换为:

[ \\\[{d\^2 \\bi r_i \\over dt\^2}={\\bi F_i \\over m_i}-{p\_\\x \\over
Q}{d \\bi r_i \\over dt} \\tag{3.48}\\\] ]{.math}

其中热浴参数 [ \\(\\x\\) ]{.math} 的运动方程为:

[ \\\[{d p\_\\x \\over dt}=(T_0-T) \\tag{3.49}\\\] ]{.math}

参考温度以 [ \\(T_0\\) ]{.math} 表示, 而 [ \\(T\\) ]{.math}
为体系当前的瞬时温度. 耦合强度由常数 [ \\(Q\\) ]{.math}
(通常被称为容器的"质量参数")和参考温度共同决定
[\[1\]](#fn:1 "see footnote"){#fnref:1 .footnote}

Nose-Hoover运动方程的守恒量并不是总能量, 而是

[ \\\[H=\\Sum\_{i=1}\^N {\\bi p_i \\over 2m_i}+U(\\bi r_1, \\bi
r_2,\...,\\bi r_N)+{p\_\\x\^2 \\over 2Q}+N_f kT\\x \\tag{3.50}\\\]
]{.math}

其中 [ \\(Nf\\) ]{.math} 为总的自由度数.

依我们看, 利用质量参数来描述耦合强度让人有点难以理解,
特别是它还依赖于参考温度(在一些实现中 [ \\(Q\\) ]{.math}
的定义还和体系的自由度数有关). 为了维持耦合强度, [ \\(Q\\) ]{.math}
的改变必须正比于参考温度的改变. 基于这个原因,
我们更愿意让GROMACS用户使用体系和容器之间动能的振荡周期 [ \\(\\t_T\\)
]{.math} 来代替 [ \\(Q\\) ]{.math} , 它通过下式直接与 [ \\(Q\\) ]{.math}
和 [ \\(T_0\\) ]{.math} 相关:

[ \\\[Q={\\t_T\^2 T_0 \\over 4 \\p\^2} \\tag{3.51}\\\] ]{.math}

这为选择Nose-Hoover耦合强度(弱耦合弛豫与此类似)提供了一个更为直观的方式,
并且 [ \\(\\t_T\\) ]{.math} 与体系的大小和参考温度无关.

然而, 要特别注意弱耦合方案和Nose-Hoover算法的区别:
使用弱耦合你将得到一个具有强烈阻尼的 **指数弛豫** ,
而Nose-Hoover方法产生 **振荡弛豫** . Nose-Hoover耦合需要的实际弛豫时间
比你选择的振荡周期要大几倍.
这些振荡(相比于指数弛豫)也意味着时间常数通常应该比弱耦合所使用的弛豫时间大4--5倍,
但你可以根据情况改变.

Nose-Hoover动力学在简单的体系, 如谐振子集合中, 可能是非遍历的,
这意味着即使模拟运行了无限长时间, 也只能对相空间的一小部分进行采样.
因此, 人们发展了Nose-Hoover链方法,
其中每个的Nose-Hoover控温器都有自己的Nose-Hoover恒温器来控制其温度.
当恒温器链的长度趋向无限时, 可以保证过程是遍历的.
只使用几个链可以大大提高遍历性, 但最近的研究表明, 体系仍然是非遍历的,
并且仍然不完全清楚其实际影响\[32\]. 目前, 链的默认数目为10,
但用户可以更改. 在使用Nose-Hoover链的情况下,
方程修改为下面的形式以包含恒温粒子链\[33\]:

[ \\(\\alg {d\^2 \\bi r_i \\over d t\^2} &= {\\bi F_i \\over
m_i}-{p\_{\\x_1} \\over Q_1}{d\\bi r_i \\over dt} \\\\ {d p\_{\\x_1}
\\over d t} &= (T-T_0)-p\_{\\x_1}{p\_{\\x_2} \\over \\x_2} \\\\ {d
p\_{\\x\_{i=2\...N} } \\over d t} &= \\left( {p\_{\\x\_{i-1} }\^2 \\over
Q\_{i-1}} -kT \\right) -p\_{\\x_i} {p\_{\\x\_{i+1}} \\over Q\_{i+1}}
\\\\ {d p\_{\\x_N} \\over d t} &= \\left( {p\_{\\x\_{N-1} }\^2 \\over
Q\_{N-1}} -kT \\right) \\ealg \\tag{3.52}\\) ]{.math}

Nose-Hoover链的守恒量为

[ \\\[H=\\Sum\_{i=1}\^N {\\bi p_i \\over 2m_i}+U(\\bi r_1, \\bi r_2,
\...,\\bi r_N)+\\Sum\_{k=1}\^M {p\_{\\x_k}\^2 \\over 2Q_k\'}+ N_f kT
\\x_1 + kT \\Sum\_{k=2}\^M \\x_k \\tag{3.53}\\\] ]{.math}

Nose-Hoover恒温器变量的值与速度一般不包含在输出中,
因为它们会占用相当大的空间并且通常对于分析模拟结果不是很重要. 但是,
可以通过定义环境变量 ` GMX_NOSEHOOVER_CHAINS ` ,
将链中所有Nose-Hoover粒子的位置和速度输出到 ` .edr ` 文件中.
在目前的版本中, 蛙跳式积分方法只能使用长度为1的Nose-Hoover链,
但在以后的版本中可能会支持更长的链.

如在积分方法那节讲的, 对于温度耦合,
速度Verlet方法和蛙跳式算法在试图匹配参考温度时, 对温度的计算有所不同.
速度Verlet( ` md-vv ` )使用了整步动能, 而蛙跳式缩放和 ` md-vv-avek `
使用了半步平均的动能.

通过再次考查Trotter分解, 我们可以更好地理解这些等温积分方法之间的差异.
对Nose-Hoover动力学(为简单起见, 使用的链长 [ \\(N=1\\) ]{.math} ,
更多细节请参考文献\[34\]), 将Liouville算子劈分为

[ \\\[iL=iL_1+iL_2+iL\_{\\text{NHC} } \\tag{3.54}\\\] ]{.math}

其中,

[ \\(\\alg iL_1 &=\\Sum\_{i=1}\^N \\left\[{\\bi p_i \\over m_i}\\right\]
\\cdot {\\partial \\over \\partial \\bi r_i} \\\\ iL_2 &=\\Sum\_{i=1}\^N
{\\bi F_i \\cdot {\\partial \\over \\partial \\bi p_i} } \\\\
iL\_{\\text{NHC} } &= \\Sum\_{i=1}\^N -{p\_\\x \\over Q} \\bi v_i \\cdot
\\nabla \\bi v_i + {p\_\\x \\over Q} {\\partial \\over \\partial \\x} +
(T-T_0) {\\partial \\over \\partial p\_\\x} \\ealg \\tag{3.55}\\)
]{.math}

对于使用Nose-Hoover温度控制的标准速度Verlet方法, 上式变为

[ \\(\\alg \\exp(iL\\D t)=\\; &\\exp(iL\_{\\text{NHC} }\\D t/2)
\\exp(iL_2 \\D t/2) \\\\ &\\exp(iL_1 \\D t) \\exp(iL_2 \\D t/2)
\\exp(iL\_{\\text{NHC} }\\D t/2) + O(\\D t\^3) \\ealg \\tag{3.56}\\)
]{.math}

对于使用 ` md-vv-avek ` 的半步平均温度控制, 这种分解不适用,
因为我们在第二速度步完成前不可能得到整步的温度. 然而,
我们可以通过交换分解中NHC和速度部分的位置构造另一个分解, 它仍然是可逆的,

[ \\(\\alg \\exp(iL\\D t)=\\; &\\exp(iL_2 \\D t/2)
\\exp(iL\_{\\text{NHC} }\\D t/2) \\exp(iL_1 \\D t) \\\\
&\\exp(iL\_{\\text{NHC} }\\D t/2) \\exp(iL_2 \\D t/2) + O(\\D t\^3)
\\ealg \\tag{3.57}\\) ]{.math}

利用这种形式我们可以很容易地看出各种速度Verlet积分方法之间的差异.
蛙跳式积分方法可视为以方程3.57 \$\$\\exp(iL_1\\D t)\$ 之前的项开始,
得到:

[ \\(\\alg \\exp(iL\\D t)=\\; & \\exp(iL_1 \\D t) \\exp(iL\_{\\text{NHC}
}\\D t/2) \\\\ &\\exp(iL_2 \\D t) \\exp(iL\_{\\text{NHC} }\\D t/2) +
O(\\D t\^3) \\ealg \\tag{3.58}\\) ]{.math}

然后使用了一些代数技巧来求解,
因为有一些量在实际计算之前就需要知道\[35\].

**组内温度耦合**

在GROMACS中, 温度耦合可用于原子组, 通常是蛋白质和溶剂.
引入这种算法的原因是, 由于各种不同的效应, 包括截断等等,
不同组分之间的能量交换并不完美. 如果现在整个体系耦合到一个热浴,
水(受到的截断噪声最大)将倾向于升温, 而蛋白质会冷却.
这通常会导致二者之间有100 K的温度差异. 通过使用合适的静电方法(PME),
这些差异会小很多, 但仍然不可忽视. 组内温度耦合的参数中在 ` mdp `
文件中给出. 最近的研究表明, 蛋白质和水之间细微的温度差异,
实际上可能是虚假的, 是由时间步长有限时计算温度的方式导致的,
非常大的温度差异很可能是体系严重出错的标志, 应该仔细检查\[36\].

应该提到一种特殊情况: 可以只对体系的一部分进行温度耦合,
而其它部分不进行温度耦合.
这可以通过对那些不进行恒温的组指定--1的时间常数 [ \\(\\t_T\\) ]{.math}
来实现. 如果只有体系的一部分进行恒温, 体系最终仍然会收敛到一个NVT体系.
实际上, 有一个建议可尽量降低离散时间步长所造成的温度误差:
如果对水使用了约束, 那么应该只对水的自由度进行恒温,
而不是蛋白质的自由度,
因为蛋白质更高频率的模式可能会导致温度与"真实"温度有更大的偏差,
这里的真实温度指的是使用小的时间步长得到的温度\[36\].

### 3.4.9 压力耦合 {#349-压力耦合}

与温度耦合类似, 体系也可以耦合到一个"压力浴".
GROMACS既支持每步重新缩放坐标与盒矢量的Berendsen算法\[25\],
扩展系综的Parrinello-Rahman方法\[37, 38\], 也支持速度Verlet的一种变形,
Martyna-Tuckerman-Tobias-Klein (MTTK)方法的压力控制\[34\].
Parrinello-Rahman和Berendsen方法可以与任何上述的温度耦合方法联用;
MTTK只能与Nose-Hoover温度控制方法联用.

**Berendsen压力耦合**

Berendsen算法会利用矩阵 [ \\(\\bi \\m\\) ]{.math} 重新缩放坐标和盒矢量,
每步或每 [ \\(n\_{\\text{PC} }\\) ]{.math} 步一次, 压力向给定参考压力 [
\\(\\bi P_0\\) ]{.math} 的弛豫符合一级动力学特征

[ \\\[{\\rmd{\\bi P} \\over \\rmd t}={\\bi P_0- \\bi P \\over \\t_p}
\\tag{3.59}\\\] ]{.math}

缩放矩阵 [ \\(\\bi \\m\\) ]{.math} 由下式给出

[ \\\[\\m\_{ij}=\\d\_{ij} - {n\_{\\text{PC} } \\D t \\over 3 \\t_p}
\\b\_{ij}\\{P\_{0ij}-P\_{ij}(t)\\} \\tag{3.60}\\\] ]{.math}

这里, [ \\(\\bi \\b\\) ]{.math} 为体系的等温压缩系数. 大多数情况下,
它是一个对角矩阵, 且对角线上的值相等, 这个值通常是未知的,
但完全可以采取一个粗略的估计值, 因为 [ \\(\\bi \\b\\) ]{.math}
的值仅影响压力弛豫的非临界时间常数, 而不影响平均压力本身. 1个标准大气压,
300 K条件下, 水的 [ \\(\\b= 4.6 \\times 10\^{-10} \\text{Pa}\^{-1} = 4.6
\\times 10\^{-5} \\text{bar}\^{-1}\\) ]{.math} , 相应于 [ \\(7.6 \\times
10\^{-4}\\) ]{.math} MD单位(参见第二章).
大多数其它的液体具有与此相近的值. 当缩放具有完全的各向异性时,
必须旋转体系使其服从方程 3.1. 缩放时, 旋转采用一阶近似, 通常小于10 ^-4^
. 实际的缩放矩阵 [ \\(\\bi \\m\'\\) ]{.math} 为

[ \\\[\\bi \\m\' =\\pmat \\m\_{xx} & \\m\_{xy}+\\m\_{yx} &
\\m\_{xz}+\\m\_{zx} \\\\ 0 & \\m\_{yy} & \\m\_{yz}+\\m\_{zy} \\\\ 0 & 0
& \\m\_{zz} \\\\ \\epmat \\tag{3.61}\\\] ]{.math}

速度既不缩放, 也不旋转.

在GROMACS中, Berendsen缩放也可以各向同性地进行, 这意味着, 使用对角元素为
[ \\(\\text{trace}(\\bi P)/3\\) ]{.math} 的对角矩阵代替 [ \\(\\bi P\\)
]{.math} . 对存在界面的体系, 半各向同性缩放可能有用. 在这种情况下, 在 [
\\(x/y\\) ]{.math} 方向上进行各向同性缩放, 而在 [ \\(z\\) ]{.math}
方向上进行独立的缩放. 将 [ \\(x/y\\) ]{.math} 或 [ \\(z\\) ]{.math}
方向上的压缩系数可以设置为零, 以便只在另一方向上进行缩放.

如果允许完全的各向异性变形并使用约束, 你可能必须使用更缓慢的缩放,
或是减少时间步长以避免约束算法导致的误差. 需要注意的是,
尽管Berendsen控压算法在模拟时能产生正确的平均压力,
但它不能得到精确的NPT系综, 而且目前尚不完全清楚这种方法可能导致的误差.

**Parrinello-Rahman压力耦合**

若压力或体积的涨落就其自身而言非常重要(例如, 计算热力学性质),
特别是对于小的体系, 弱耦合方案可能存在的一个问题,
这种方案没有很好地定义精确的系综, 模拟的并不是真正的NPT系综.

GROMACS也支持使用Parrinello-Rahman方法\[37, 38\]的等压模拟,
这种方法类似于Nose-Hoover温控方法, 理论上能给出真正NPT系综.
使用Parrinello-Rahman恒压器, 以矩阵 [ \\(\\bi b\\) ]{.math}
表示的盒矢量服从矩阵运动方程 [\[2\]](#fn:2 "see footnote"){#fnref:2
.footnote}

[ \\\[{\\rmd{\\bi b\^2} \\over \\rmd{t\^2} }=V \\bi W\^{-1} \\bi
b\^{\'-1}(\\bi P-\\bi P\_{ref}) \\tag{3.62}\\\] ]{.math}

其中 [ \\(V\\) ]{.math} 代表盒子的体积, [ \\(\\bi W\\) ]{.math}
为决定耦合强度的矩阵参数. 矩阵 [ \\(\\bi P\\) ]{.math} 和 [ \\(\\bi
P\_{ref}\\) ]{.math} 分别是当前压力和参考压力.

和Nose-Hoover耦合一样, 粒子的运动方程也改变了. 在大多数情况下,
你将联合使用Parrinello-Rahman恒压器与Nose-Hoover恒温器, 为简单起见,
我们这里只给出Parrinello-Rahman导致的变化:

[ \\(\\alg {\\rmd {\\bi r_i\^2} \\over \\rmd {t\^2}} &= {\\bi F_i \\over
m_i} -\\bi M {\\rmd{\\bi r_i} \\over \\rmd t} \\tag{3.63} \\\\ \\bi M &=
\\bi b\^{-1} \\left\[\\bi b {\\rmd{\\bi b\'} \\over \\rmd t}+
{\\rmd{\\bi b} \\over \\rmd t} \\bi b\' \\right\] \\bi b\^{\'-1}
\\tag{3.64} \\ealg\\) ]{.math}

(逆)质量参数矩阵 [ \\(\\bi W\^{-1}\\) ]{.math} 决定了耦合的强度,
以及盒子如何变形. 如果 [ \\(\\bi W\^{-1}\\) ]{.math} 的对应元素为0,
盒子的限制条件(3.1)会自动满足. 由于耦合强度也取决于盒子的大小,
我们更愿意在GROMACS中自动计算盒子的大小.
你只需要在输入文中提供近似的等温压缩系数 [ \\(\\bi \\b\\) ]{.math}
和压力的时间常数 [ \\(\\t_P\\) ]{.math} ( [ \\(L\\) ]{.math}
为盒矩阵元素的最大值):

[ \\\[(\\bi W\^{-1})\_{ij} = {4 \\p\^2 \\b\_{ij} \\over 3 \\t_p\^2 L}
\\tag{3.65}\\\] ]{.math}

正如在Nose-Hoover恒温器, 你应该认识到, Parrinello-Rahman时间常数并
**不** 等同于Berendsen压力耦合算法中使用的弛豫时间. 大多数情况下,
对于Parrinello-Rahman耦合, 你需要使用4--5倍大的时间常数.
如果压力离平衡态非常远,
Parrinello-Rahman耦合会导致盒子产生非常大的振荡甚至最终导致运行崩溃.
在这种情况下, 你可能必须增加时间常数,
或(更好的办法)先使用弱耦合方案达到目标压力,
等系统平衡后再切换到Parrinello-Rahman耦合. 此外, 使用蛙跳式算法时,
在整个时间步骤完成之前不能得到 [ \\(t\\) ]{.math} 时刻的压力,
因此必须使用上一步中的压力, 这使得算法不是直接可逆的,
并且可能不适合进行高精度的热力学计算.

**表面张力耦合**

当周期性体系中包含一个以上的相, 且这些相被平行于 [ \\(xy\\) ]{.math}
表面的表面所隔离时, 表面张力和压力的 [ \\(z\\) ]{.math}
分量会与压力浴相耦合. 目前, 这只适用于GROMACS中的Berendsen压力耦合算法.
平均表面张力 [ \\(\\g(t)\\) ]{.math}
可以通过法向压力与横向压力之间的差值来计算

[ \\(\\alg \\g(t) &={1\\over n}\\int_0\^{L_z} \\left\\{ P\_{zz}(z,t) -
{P\_{xx}(z,t)+P\_{yy}(z,t) \\over 2} \\right\\} \\rmd z \\tag{3.66} \\\\
&= {L_z\\over n}\\left\\{ P\_{zz}(t) - {P\_{xx}(t)+P\_{yy}(t) \\over 2}
\\right\\} \\tag{3.67} \\ealg\\) ]{.math}

其中 [ \\(L_z\\) ]{.math} 为盒子的高度, [ \\(n\\) ]{.math} 为表面的数目.
z方向的压力通过使用 [ \\(\\m\_{zz}\\) ]{.math} 缩放盒子的高度进行校正

[ \\(\\alg \\D P\_{zz} &={\\D t \\over \\t_p} \\{P\_{0zz}-P\_{zz}(t) \\}
\\tag{3.68} \\\\ \\m\_{zz} &=1+\\b\_{zz} \\D P\_{zz} \\tag{3.69}
\\ealg\\) ]{.math}

除缺少 [ \\(1/3\\) ]{.math} 这个因子外, 法向压力耦合的校正与此类似. [
\\(z\\) ]{.math} 方向上的压力校正, 被用于得到表面张力相对于参考值 [
\\(\\g_0\\) ]{.math} 的正确收敛值. [ \\(x/y\\) ]{.math}
方向盒子长度的校正因子为

[ \\\[\\m\_{x/y}=1+{\\D t \\over 2 \\t_p} \\b\_{x/y} \\left( {n\\g_0
\\over \\m\_{zz} L_z} -\\left\\{P\_{zz}(t) + \\D
P\_{zz}-{P\_{xx}(t)+P\_{yy}(t) \\over 2} \\right\\} \\right)
\\tag{3.70}\\\] ]{.math}

相比法向压力耦合, [ \\(\\b\_{zz}\\) ]{.math} 的值更关键.
正常情况下不正确的压缩系数仅仅缩放 [ \\(\\t_p\\) ]{.math} ,
但对表面张力耦合还会影响表面张力的收敛性. 当 [ \\(b\_{zz}\\) ]{.math}
设为零时(盒子的高度不变), [ \\(\\D P\_{zz}\\) ]{.math} 也设为零,
以获得正确的表面张力.

**MTTK压力控制算法**

正如上一节所讲, 蛙跳式积分方法一个缺点在于恒压模拟,
因为计算压力需要整个时间步内的维里和动能, 对蛙跳式积分方法, 这些信息
**直到** 整个时间步完成之后才能得到.

速度Verlet方法确实可以计算, 但需要额外的全局通讯作为代价,
并计算真正的NPT系综, 忽略任何积分误差.

综合了压力耦合和温度耦合的完整方程,
这里称其为MTTK方程(Martyna-Tuckerman-Tobias-Klein),
取自Martyna等\[34\]和Tuckerman\[39\]的论文, . 为方便, 我们引入 [
\\(\\e=(1/3) \\ln(V/V_0)\\) ]{.math} , 其中 [ \\(V_0\\) ]{.math}
为参考体积. [ \\(\\e\\) ]{.math} 的动量为 [ \\(v\_\\e = p\_\\e/W
=\\dot{\\e}=\\dot V/3V\\) ]{.math} , 并定义 [ \\(\\a=1+3/N\_{dof}\\)
]{.math} (参见参考文献\[39\])

等压方程为

[ \\(\\alg \\dot{\\bi r}\_i &= {\\bi p_i \\over m_i}+{p\_\\e \\over W}
\\bi r_i \\\\ {\\dot{\\bi p_i} \\over m_i} &= {1\\over m_i} \\bi F_i
-\\a {p\_\\e \\over W} {\\bi p_i \\over m_i} \\tag{3.71} \\\\ \\dot \\e
&= {p\_\\e \\over W} \\\\ {\\dot{p\_\\e} \\over W} &={3V \\over
W}(P\_{\\text{kin} }-P) +(\\a-1)\\left( \\Sum\_{i=1}\^N {\\bi p_i\^2
\\over m_i}\\right) \\\\ \\tag{3.72} \\ealg\\) ]{.math}

其中

[ \\\[P\_{\\text{int} } = P\_{\\text{kin} } - P\_{\\text{vir} }={1\\over
3V}\\left\[\\Sum\_{i=1}\^N \\left({\\bi p_i\^2 \\over 2 m_i}-\\bi r_i
\\cdot \\bi F_i \\right) \\right\] \\tag{3.73}\\\] ]{.math}

包含 [ \\(\\a\\) ]{.math} 的项可保证相空间不可压缩\[39\]. [ \\(\\e\\)
]{.math} 加速度项可以改写为

[ \\\[{\\dot{p\_\\e} \\over W} = {3V \\over W}(\\a P\_{\\text{kin}
}-P\_{\\text{vir} }-P) \\tag{3.74}\\\] ]{.math}

对速度项, 这些方程变为

[ \\(\\alg \\dot{\\bi r_i} &= \\bi v_i + v\_\\e \\bi r_i \\\\ \\dot{\\bi
v_i} &= {1\\over m_i} \\bi F_i -\\a v\_\\e \\bi v_i \\\\ \\dot \\e &=
v\_\\e \\\\ \\dot{v\_\\e} &= {3V \\over W}(P\_{\\text{int}
}-P)+(\\a-1)\\left(\\Sum\_{i=1}\^N {1\\over2} m_i \\bi v_i\^2 \\right)
\\\\ P\_{\\text{int} } &= P\_{\\text{kin} } - P\_{\\text{vir} }={1\\over
3V}\\left\[ \\Sum\_{i=1}\^N \\left({1\\over2} m_i \\bi v_i\^2 -\\bi r_i
\\cdot \\bi F_i \\right) \\right\] \\tag{3.75} \\ealg\\) ]{.math}

对于这些方程, 守恒量为

[ \\\[H= \\Sum\_{i=1}\^N {\\bi p_i\^2 \\over 2 m_i} +U(\\bi r_1, \\bi
r_2, \..., \\bi r_N)+{p\_\\e \\over 2W} +PV \\tag{3.76}\\\] ]{.math}

下一步是添加温度控制, 添加Nose-Hoover链, 并将其添加到恒压器自由度. 令 [
\\(\\h\\) ]{.math} 为恒压器的Nose-Hoover变量, [ \\(Q\'\\) ]{.math}
为恒压器的恒温器常数, 我们得到

[ \\(\\alg \\dot{\\bi r}\_i &= {\\bi p_i \\over m_i}+{p\_\\e \\over W}
\\bi r_i \\\\ {\\dot{\\bi p}\_i \\over m_i} &= {1\\over m_i} \\bi F_i
-\\a {p\_\\e \\over W} {\\bi p_i \\over m_i} - {p\_{\\x_1} \\over Q_1}
{\\bi p_i \\over m_i} \\\\ \\dot \\e &= {p\_\\e \\over W} \\\\
{\\dot{p\_\\e} \\over W} &={3V \\over W}(\\a P\_{\\text{kin}
}-P\_{\\text{vir} }-P) - {p\_{\\h_1} \\over Q_1\'} p\_\\e \\\\
\\dot{\\x}\_k &= {p\_{\\x_k} \\over Q_k} \\\\ \\dot \\h_k&= {p\_{\\h_k}
\\over Q_k\'} \\\\ \\dot p\_{\\x_k} &= G_k -{p\_{\\x\_{k+1} } \\over
Q\_{k+1} } \\qquad k=1,\...,M-1 \\\\ \\dot p\_{\\h_k} &= G_k\'
-{p\_{\\h\_{k+1} } \\over Q\_{k+1}\' } \\qquad k=1,\...,M-1 \\\\ \\dot
p\_{\\x_M} &= G_M \\\\ \\dot p\_{\\h_M} &= G_M\' \\tag{3.77} \\ealg\\)
]{.math}

其中

[ \\(\\alg P\_{\\text{int} } &= P\_{\\text{kin} } - P\_{\\text{vir} } =
{1\\over 3V}\\left\[ \\Sum\_{i=1}\^N \\left({\\bi p_i\^2 \\over
2m_i}-\\bi r_i \\cdot \\bi F_i \\right)\\right\] \\\\ G_1
&=\\Sum\_{i=1}\^N {\\bi p_i\^2 \\over 2m_i}-N_f kT \\\\ G_k &=
{p\_{\\x\_{k-1}}\^2 \\over 2 Q\_{k-1}} - kT \\;\\; k=1,\..., M \\\\
G_1\' &= {p\_\\e\^2 \\over 2W} -kT \\\\ G_k\' &= {p\_{\\h\_{k-1}}\^2
\\over 2 Q\_{k-1}\'} - kT \\;\\; k=1,\..., M \\tag{3.78} \\ealg\\)
]{.math}

现在的守恒量为

[ \\(\\alg H &=\\Sum\_{i=1}\^N {\\bi p_i\^2 \\over 2m_i}+U(\\bi r_1,
\\bi r_2, \..., \\bi r_N)+{p\_\\e\^2 \\over 2W}+PV \\\\
&+\\Sum\_{k=1}\^M {p\_{\\x_k}\^2 \\over 2Q_k} + \\Sum\_{k=1}\^M
{p\_{\\h_k}\^2 \\over 2Q_k\'} + N_f kT \\x_1 + kT \\Sum\_{k=2}\^M \\x_k
+\\Sum\_{k=2}\^M \\h_k \\tag{3.79} \\ealg\\) ]{.math}

回到Trotter分解形式, 对压力控制和温度控制\[34\]我们得到:

[ \\\[iL=iL_1+iL_2+iL\_{\\e,1}+iL\_{\\e,2}+iL\_{\\text{NHC-baro}
}+iL\_{\\text{NHC} } \\tag{3.80}\\\] ]{.math}

其中, "NHC-baro"对应于恒压器的Nose-Hoover链, NHC对应于粒子的NHC

[ \\(\\alg iL_1 &= \\Sum\_{i=1}\^N \\left\[{\\bi p_i \\over m_i}+{p\_\\e
\\over W} \\bi r_i \\right\] \\cdot {\\partial \\over \\partial \\bi
r_i} \\tag{3.81} \\\\ iL_2 &= \\Sum\_{i=1}\^N \\bi F_i -\\a {p\_\\e
\\over W} \\bi p_i \\cdot {\\partial \\over \\partial \\bi p_i}
\\tag{3.82} \\\\ iL\_{\\e,1} &= {p\_\\e \\over W} {\\partial \\over
\\partial \\e} \\tag{3.83} \\\\ iL\_{\\e,2} &= G\_\\e {\\partial \\over
\\partial p\_\\e} \\tag{3.84} \\ealg\\) ]{.math}

其中

[ \\\[G\_\\e = 3V(\\a P\_{\\text{kin}} - P\_{\\text{vir}} -P)
\\tag{3.85}\\\] ]{.math}

用Trotter分解, 我们得到

[ \\(\\alg \\exp(iL\\D t) = \\;\\; & \\exp(iL\_{\\text{NHC-baro} } \\D
t/2) \\exp(iL\_{\\text{NHC} } \\D t/2) \\\\ &\\exp(iL\_{\\e,2} \\D t/2)
\\exp(iL_2 \\D t/2) \\\\ &\\exp(iL\_{\\e,1} \\D t) \\exp(iL_1 \\D t)
\\\\ &\\exp(iL_2 \\D t/2) \\exp(iL\_{\\e,2} \\D t/2) \\\\
&\\exp(iL\_{\\text{NHC} } \\D t/2) \\exp(iL\_{\\text{NHC-baro} } \\D
t/2) +O(\\D t\^3) \\tag{3.86} \\ealg\\) ]{.math}

[ \\(\\exp(iL_1 \\D t)\\) ]{.math} 作用来自于微分方程 [ \\(\\dot{\\bi
r}\_i=\\bi v_i+v\_\\e \\bi r_i\\) ]{.math} 的解, 其中 [ \\(\\bi v_i=\\bi
p_i/m_i\\) ]{.math} , [ \\(v\_\\e\\) ]{.math} 为常数, 初始条件为 [
\\(\\bi r_i(0)\\) ]{.math} , 在 [ \\(t=\\D t\\) ]{.math} 时刻进行计算.
这样可以得到

[ \\\[\\bi r_i(\\D t)=\\bi r_i(0) e\^{v\_\\e \\D t} + \\D t \\bi
v_i(0)e\^{v\_\\e \\D t/2} {\\sinh(v\_\\e \\D t/2) \\over v\_\\e \\D t/2}
\\tag{3.87}\\\] ]{.math}

[ \\(\\exp(iL_2 \\D t/2)\\) ]{.math} 作用来自于微分方程 [ \\(\\dot{\\bi
v}\_i={\\bi F_i \\over m_i}-\\a v\_\\e \\bi v_i\\) ]{.math} 的解, 得到

[ \\\[\\bi v_i(\\D t/2)=\\bi v_i(0) e\^{-\\a v\_\\e \\D t/2} + {\\D
t\\over 2m_i} \\bi F_i(0)e\^{-\\a v\_\\e \\D t/4} {\\sinh(\\a v\_\\e \\D
t/4) \\over \\a v\_\\e \\D t/4} \\tag{3.88}\\\] ]{.math}

` md-vv-avek ` 使用完整步的动能来确定压力控制的压力,
但使用半步平均动能来确定温度, 这可以写为Trotter分解

[ \\(\\alg \\exp(iL\\D t) = \\;\\; & \\exp(iL\_{\\text{NHC-baro} } \\D
t/2) \\exp(iL\_{\\e,2} \\D t/2)\\exp(iL_2 \\D t/2) \\\\
&\\exp(iL\_{\\text{NHC} } \\D t/2) \\exp(iL\_{\\e,1} \\D t) \\exp(iL_1
\\D t) \\exp(iL\_{\\text{NHC} } \\D t/2) \\\\ & \\exp(iL_2 \\D t/2)
\\exp(iL\_{\\e,2} \\D t/2) \\exp(iL\_{\\text{NHC-baro} } \\D t/2) +O(\\D
t\^3) \\tag{3.89} \\ealg\\) ]{.math}

使用约束时, 这些方程会变得更为复杂, 对约束力需要迭代求解每个方程.
对迭代细节的讨论超出了本手册的范围; 我们鼓励读者参看文献\[40\]中的实现.

**温度和压力耦合的不频繁计算**

温度和压力的控制需要全局通信来计算的动能和维里, 对大的体系,
如果在每一步都进行会使计算变得十分耗时. 我们可以重排Trotter分解,
给出另一种可逆的辛积分方法, 每 [ \\(n\\) ]{.math}
步进行一次而不是每步一次. 当耦合时间步长过大时, 这些新的积分方法将发散,
因为辅助变量积分不收敛. 然而, 在大多数情况下, 长的耦合时间更合适,
因为他们对动力学的扰动小些\[34\].

使用Nose-Hoover温度控制时, 标准的速度Verlet方法有如下的Trotter展开

[ \\(\\alg \\exp(iL\\D t) \\approx \\;\\; &\\exp(iL\_{\\text{NHC} } \\D
t/2) \\exp(iL_2 \\D t/2) \\\\ &\\exp(iL_1 \\D t) \\exp(iL_2 \\D
t/2)\\exp(iL\_{\\text{NHC} } \\D t/2) \\tag{3.90} \\ealg\\) ]{.math}

如果相对于系统运动, Nose-Hoover链的运动足够慢, 对速度Verlet方法,
我们可以写出一个进行 [ \\(n\\) ]{.math} 步的积分方法

[ \\(\\alg \\exp(iL\\D t) \\approx \\;\\; &\\exp(iL\_{\\text{NHC} }(n\\D
t/2)) \[\\exp(iL_2 \\D t/2) \\\\ &\\exp(iL_1 \\D t) \\exp(iL_2 \\D
t/2)\]\^n \\exp(iL\_{\\text{NHC} }(n\\D t/2)) \\tag{3.91} \\ealg\\)
]{.math}

对于压力控制, 这成为

[ \\(\\alg \\exp(iL\\D t) \\approx \\;\\; & \\exp(iL\_{\\text{NHC-baro}
}(n\\D t/2)) \\exp(iL\_{\\text{NHC} }(n\\D t/2)) \\\\
&\\exp(iL\_{\\e,2}(n\\D t/2)) \[ \\exp(iL_2 \\D t/2) \\\\
&\\exp(iL\_{\\e,1} \\D t) \\exp(iL_1 \\D t) \\\\ &\\exp(iL_2 \\D
t/2)\]\^n \\exp(iL\_{\\e,2}(n\\D t/2)) \\\\ &\\exp(iL\_{\\text{NHC}
}(n\\D t/2)) \\exp(iL\_{\\text{NHC-baro} }(n\\D t/2)) \\tag{3.92}
\\ealg\\) ]{.math}

其中对盒子体积的积分每步都进行, 但对辅助变量的积分每 [ \\(n\\) ]{.math}
步一次.

### 3.4.10 完整的更新算法 {#3410-完整的更新算法}

使用蛙跳式积分方法时, 更新速度和坐标的完整算法见图3.9.
步骤4的SHAKE算法在下面进行说明.

GROMACS具有"冻结"(防止运行)选中粒子的规定, 这些粒子必须被定义为"冻结组".
这是使用 **冻结因子** [ \\(\\bi f_g\\) ]{.math} 实现的,
冻结因子时一个向量, 对每个冷冻组都不相同(参见3.3节).
此向量只包含零(冻结)或1(不冻结). 当我们考虑冻结因子和外部加速度 [
\\(\\bi a_h\\) ]{.math} 时, 速度的更新算法变为

[ \\\[\\bi v(t+{\\D t \\over 2}) = \\bi f_g \* \\l \* \\left\[ \\bi
v(t-{\\D t \\over 2}+{\\bi F(t) \\over m} \\D t + \\bi a_h \\D t
\\right\] \\tag{3.93}\\\] ]{.math}

其中 [ \\(g\\) ]{.math} 和 [ \\(h\\) ]{.math} 为组索引, 每个原子都不同.

![图3.9: 蛙跳式积分方法对应的MD更新算法](/GMX/3.9.png)

### 3.4.11 输出步 {#3411-输出步}

MD运行的最重要输出是 **轨迹文件** ,
它包含了规则间隔时刻粒子的坐标和(可选的)速度. 轨迹文件包含许多帧,
每帧可能包括位置, 速度和/或力, 以及模拟体积尺寸, 积分步, 积分时间等信息.
时间的解释与所选择的积分方法有关, 如上所述. 对速度Verlet积分方法,
标记时刻 [ \\(t\\) ]{.math} 的速度是那个时刻的速度.
对于其他积分方法(如蛙跳式, 随机动力学), 标记时刻 [ \\(t\\) ]{.math}
的速度是 [ \\(t-{1\\over2}\\D t\\) ]{.math} 时刻的速度.

由于轨迹文件很长, 不要每一步都保存! 为保留所有信息,
每15步输出一帧就够了, 因为对体系中最大频率的每一周期至少使用了30步,
并且Shannon的采样定理指出, 对带限信号,
最大频率的每一周期进行两次采样就包含了所有可用的信息.
但这样做仍然会得到很大的文件! 所以, 如果对最高频率不感兴趣,
每ps进行10或20此采样就够了. 注意由频闪效应导致的高频运动失真,
这被称为混叠: 较高的频率相对采样频率出现镜像, 显得频率较低.

GROMACS也可以将模拟体系一部分坐标的精度进行降低,
并写入到特殊的压缩格式的轨迹文件. 所有其他的工具可以读取和写入这种格式.
参见7.3节关于如何设置 ` .mdp ` 文件以便使用 ` mdrun ` 此功能的详细信息.

## 3.5 壳层分子动力学 {#35-壳层分子动力学}

GROMACS可以使用Dick和Overhauser的壳层模型来模拟极化率\[41\].
在这个模型中, 表示电子自由度的壳层粒子通过弹性势连接到原子核上.
在模拟的每一步, 都会对相对于壳层位置的势能进行最小化(见后面).
GROMACS中的壳层模型已经成功用于N ~2~ \[42\]和水\[43\].

### 3.5.1 优化壳层位置 {#351-优化壳层位置}

壳层粒子 [ \\(S\\) ]{.math} 上的力 [ \\(\\bi F_S\\) ]{.math}
可分解为两部分,

[ \\\[\\bi F_S=\\bi F\_{bond}+\\bi F\_{nb} \\tag{3.94}\\\] ]{.math}

其中 [ \\(\\bi F\_{bond}\\) ]{.math} 代表表示极化能量的分量,
通常以简谐势代替, [ \\(\\bi F\_{nb}\\) ]{.math} 为库仑与van der
Waals相互作用的加和. 如果我们假定 [ \\(\\bi F\_{nb}\\) ]{.math}
几乎为常数, 就可以解析地导出壳层的最佳位置, 即 [ \\(bi F_S=0\\) ]{.math}
的位置. 若壳层S连接到原子A:

[ \\\[\\bi F\_{bond}=k_b(\\bi x_S-\\bi x_A) \\tag{3.95}\\\] ]{.math}

在迭代求解过程中, 设 [ \\(n\\) ]{.math} 次迭代的位置为 [ \\(\\bi
x_S(n)\\) ]{.math} , 则在第 [ \\(n\\) ]{.math} 次迭代中,

[ \\\[\\bi F\_{nb}=\\bi F_S-k_b(\\bi x_S(n)-\\bi x_A) \\tag{3.96}\\\]
]{.math}

由此壳层的最佳位置符合下面的关系

[ \\\[\\bi F_S-k_b(\\bi x_S(n)-\\bi x_A)+k_b(\\bi x_S(n+1)-\\bi x_A)=0
\\tag{3.97}\\\] ]{.math}

若记

[ \\\[\\D \\bi x_S=\\bi x_S(n+1)-\\bi x_S(n) \\tag{3.98}\\\] ]{.math}

最终得到

[ \\\[\\D x_S=\\bi F_S/k_b \\tag{3.99}\\\] ]{.math}

这样就得到了优化壳层位置时计算下一步尝试的算法

[ \\\[\\bi x_S(n+1)=\\bi x_S(n)+\\bi F_S/k_b \\tag{3.100}\\\] ]{.math}

## 3.6 约束算法 {#36-约束算法}

在GROMACS中可以使用LINCS(默认)或传统的SHAKE方法来施加约束.

### 3.6.1 SHAKE {#361-shake}

SHAKE算法\[44\]将一组不受约束的坐标 [ \\(\\bi r\'\\) ]{.math}
转变为一组坐标 [ \\(\\bi r\'\'\\) ]{.math} , 使其满足一系列距离约束条件,
使用一组 [ \\(\\bi r\\) ]{.math} 作为参考,

[ \\\[\\text{SHAKE}(\\bi r\' \\rightarrow \\bi r\'\'; \\bi r)
\\tag{3.101}\\\] ]{.math}

算法所起的作用与求解一组约束运动方程的Lagrange乘子相同. SHAKE需要指定
**相对容差** . 算法会继续直到所有的约束都处于相对容差之内.
若由于偏差太大, SHAKE不能重置坐标, 或迭代次数超过指定数目,
会给出错误信息.

假定运动方程必须满足 [ \\(K\\) ]{.math} 个完整可积分约束, 表述为

[ \\\[\\s_k(\\bi r_1\...\\bi r_N)=0; \\; k=1\...K \\tag{3.102}\\\]
]{.math}

例如 [ \\((\\bi r_1-\\bi r_2)\^2-b\^2=0\\) ]{.math} . 力的定义为:

[ \\\[-{\\partial \\over \\partial \\bi r_i} \\left(V+\\Sum\_{k=1}\^K
\\l_k \\s_k\\right) \\tag{3.103}\\\] ]{.math}

其中 [ \\(\\l_k\\) ]{.math} 为Lagrange乘子, 必须求解它们以满足约束方程.
上面求和的第二部分决定了 **约束力** [ \\(\\bi G_i\\) ]{.math} , 定义为:

[ \\\[\\bi G_i=-\\Sum\_{k=1}\^K \\l_k \\opar {\\s_k}{\\bi r_i}
\\tag{3.104}\\\] ]{.math}

在蛙跳式或Verlet算法中, 由约束力引起的位移为 [ \\((\\bi G_i/m_i)(\\D
t)\^2\\) ]{.math} .
求解Lagrange乘子(进而位移)需要求解一组二度耦合的方程,
这可使用SHAKE方法迭代求解. 对于刚性水分子的特殊情况,
这种模拟构成了超过了80%的模拟体系,
我们已经实现了SETTLE算法(见5.5节)\[45\].

对速度Verlet, 必须施加额外的约束, 以约束第二个半速度步的速度,
并去除平行于键向量的任何速度分量, 这一步骤被称为RATTLE,
Andersen的论文中对其有更详细的论述\[46\].

### 3.6.2 LINCS {#362-lincs}

**LINCS算法**

在未约束的一步更新之后, LINCS算法会将键重置为它们的正确长度.
这个方法不进行迭代, 总是包含两个步骤. 尽管LINCS方法基于矩阵,
但并不需要进行矩阵乘法. LINCS方法比SHAKE方法更稳定, 也更快,
但只能用于键约束和孤立的键角约束, 如OH的质子键角. 由于其稳定性,
LINCS特别适用于Brown动力学. LINCS有两个参数, 在后文的参数节中将会解释.
并行版本的LINCS, P-LINCS, 将在3.17.3节介绍.

**LINCS公式**

考虑 [ \\(N\\) ]{.math} 个粒子的体系, 粒子位置由 [ \\(3N\\) ]{.math}
向量 [ \\(\\bi r(t)\\) ]{.math} 给出.
分子动力学中的运动方程由牛顿定律给出:

[ \\\[{\\mathrm d\^2 \\bi r \\over \\mathrm d t\^2} = \\bi M\^{-1} \\bi
F \\tag{3.105}\\\] ]{.math}

其中 [ \\(\\bi F\\) ]{.math} 为 [ \\(3N\\) ]{.math} 个力向量, [ \\(\\bi
M\\) ]{.math} 为 [ \\(3N \\times 3N\\) ]{.math} 的对角矩阵,
包含了粒子的质量. 体系受到 [ \\(K\\) ]{.math} 个与时间无关的约束方程

[ \\\[g_i(\\bi r) =\|\\bi r\_{i_1}-\\bi r\_{i_2}\|-d_i=0 \\;\\;
i=0,\...,K \\tag{3.106}\\\] ]{.math}

<figure>
<img src="/GMX/3.10.png"
alt="图 3.10: 一个时间步中进行的三次位置更新. 虚线为原先的键, 长度为 $d$, 实线为新的键. $l=d\cos\q$, $p=(2d^2-l^2)^{1\over2}$" />
<figcaption>图 3.10: 一个时间步中进行的三次位置更新. 虚线为原先的键,
长度为 <span class="math"> \(d\) </span> , 实线为新的键. <span
class="math"> \(l=d\cos\q\) </span> , <span class="math">
\(p=(2d^2-l^2)^{1\over2}\) </span></figcaption>
</figure>

在数值积分方案中, LINCS会在一个未约束的更新之后施加, 如SHAKE一样.
LINCS算法分两步工作(见图3.10). 在第一步中, 新键到旧键的投影被设置为零,
在第二步中, 对因旋转导致的键伸长进行校正. 第一步与第二步的计算非常相似.
算法的完整推导见\[47\], 这里只给出第一步的一个简短说明.

对约束方程的梯度矩阵使用新的记号, 记为

[ \\\[B\_{hi}=\\opar {g_H}{r_i} \\tag{3.107}\\\] ]{.math}

注意 [ \\(\\bi B\\) ]{.math} 为 [ \\(K\\times 3N\\) ]{.math} 的矩阵,
包含了约束的方向. 下列方程显示了新的约束坐标 [ \\(\\bi r\_{n+1}\\)
]{.math} 与未约束坐标 [ \\(\\bi r\_{n+1}\^{unc}\\) ]{.math} 的关系

[ \\\[\\bi r\_{n+1}=(\\bi I-\\bi T_n \\bi B_n)\\bi r\_{n+1}\^{unc}+\\bi
T_n \\bi d = \\\\ \\bi r\_{n+1}\^{unc}-\\bi M\^{-1}\\bi B_n (\\bi B_n
\\bi M\^{-1} \\bi B_n\^T)\^{-1} (\\bi B_n \\bi r\_{n+1}\^{unc}-\\bi d)
\\tag{3.108}\\\] ]{.math}

其中 [ \\(\\bi T=\\bi M\^{-1}\\bi B\^T(\\bi B\\bi M\^{-1}\\bi
B\^T)\^{-1}\\) ]{.math} . 由方程3.105,
3.106推导此方程的过程可参见\[47\].

第一步并未将实际键的长度设置为需要的长度, 而是将新键投影到旧键的方向上.
为校正键 [ \\(i\\) ]{.math} 的旋转, 键在原先方向上的投影 [ \\(p_i\\)
]{.math} 被设置为

[ \\\[p_i=\\sqrt{2d_i\^2-l_i\^2} \\tag{3.109}\\\] ]{.math}

其中 [ \\(l_i\\) ]{.math} 为经第一步投影后键的长度. 校正后的位置为

[ \\\[\\bi r\_{n+1}\^\* =(\\bi I -\\bi T_n\\bi B_n)\\bi r\_{n+1}+\\bi
T_n \\bi p \\tag{3.110}\\\] ]{.math}

对旋转效应的校正实际上是一个迭代过程, 但在MD过程中只进行了一步.
对每一约束, 经过这一校正后, 约束的相对偏差将小于0.0001. 在能量最小化中,
这可能不够精确, 因此, 迭代次数被设置为展开的阶数(见后文).

约一半的CPU时间被用于对约束耦合矩阵 [ \\(\\bi B_n \\bi M\^{-1}\\bi
B_n\^T\\) ]{.math} 进行求逆, 而且必须每步进行一次. [ \\(K\\times K\\)
]{.math} 矩阵的对角元素为 [ \\(1/m\_{i_1}+1/m\_{i_2}\\) ]{.math} .
只有当两个键相连时非对角元素才不为零, 而是 [ \\(\\cos\\f/m_c\\) ]{.math}
, 其中 [ \\(m_c\\) ]{.math} 为连接两个键的原子质量, [ \\(\\f\\) ]{.math}
为键之间的夹角.

使用幂展开方法对矩阵 [ \\(\\bi T\\) ]{.math} 求逆. 为此引入 [
\\(K\\times K\\) ]{.math} 的矩阵 [ \\(\\bi S\\) ]{.math} , 其元素为矩阵
[ \\(\\bi B_n \\bi M\^{-1}\\bi B_n\^T\\) ]{.math} 对角元素平方根的倒数.
这一矩阵可用于将耦合矩阵的对角元素变换为1:

[ \\\[(\\bi B_n \\bi M\^{-1}\\bi B_n\^T)\^{-1}=\\bi S \\bi S\^{-1} (\\bi
B_n \\bi M\^{-1}\\bi B_n\^T)\^{-1} \\bi S\^{-1} \\bi S \\\\ =\\bi S
(\\bi S \\bi B_n \\bi M\^{-1}\\bi B_n\^T \\bi S)\^{-1} \\bi S=\\bi
S(\\bi I-\\bi A_n)\^{-1} \\bi S \\tag{3.111}\\\] ]{.math}

矩阵 [ \\(\\bi A_n\\) ]{.math} 是对称的稀疏矩阵, 对角元素中含有零,
因此可以使用一个简单的技巧来计算其逆矩阵

[ \\\[(\\bi I-\\bi A_n)\^{-1}=\\bi I+\\bi A_n+\\bi A_n\^2+\\bi
A_n\^3+\... \\tag{3.112}\\\] ]{.math}

这种求逆方法只有当所有 [ \\(\\bi A_n\\) ]{.math}
本征值的绝对值都小于1时才使用. 对只含有键约束的分子, 其连接度非常低,
这个条件总是成立, 即使有环状结构出现也是一样. 对含有键角约束的分子,
可能会有问题. 使用额外的距离约束来约束键角, 可以引入多个小的环状结构.
这样分子的连接度变高, 本征值变大. 因此LINCS方法 **不能**
应用于耦合键角约束.

对所有键都进行约束的分子, [ \\(\\bi A_n\\) ]{.math} 的本征值约为0.4,
这意味着在展开方程3.112中, 每增大一个阶数, 偏差会下降为原来的0.4.
但对相对孤立的三角约束, 最大的本征值大约为0.7.
当使用额外的角约束移除醇类基团中含氢的键角振动, 或当使用LINCS约束水分子,
如使用柔性约束时, 会导致这些三角约束出现.
这些三角约束的收敛速度比其他约束慢两倍. 因此, 从GROMACS 4.0版本开始,
一些额外的项被添加到这些三角约束的展开中

[ \\\[(\\bi I-\\bi A_n)\^{-1} \\approx \\bi I+\\bi A_n+\...+\\bi
A_n\^{N_i}+\\left(\\bi A_n\^\*+\...+\\bi A_n\^{\*N_i} \\right) \\bi
A_n\^{N_i} \\tag{3.113}\\\] ]{.math}

其中 [ \\(N_i\\) ]{.math} 为正常的展开阶数, [ \\(\\bi A\^\*\\) ]{.math}
只包含 [ \\(\\bi A\\) ]{.math} 中处于刚性三角耦合约束内的元素,
所有其他元素为零. 使用这种方法, 角约束的精度接近其他约束的精度,
同时确定展开所需要的一系列矩阵矢量乘法只需要对几个约束耦合进行.
这一过程在P-LINCS的论文\[48\]中有说明.

**LINCS参数**

LINCS精度取决于展开方程3.112中矩阵的数目. 对MD计算四阶展开就足够了;
对Brown动力学, 使用大的时间步长时, 可能需要八阶展开. 展开阶数是
` *.mdp ` 文件中的一个参数. LINCS的实现方式使得其算法不可能失败.
即使不可能重置约束时, LINCS也将创建一个尽可能满足约束构型. 然而,
当在某一步中键的旋转超过了预先定义的角度时, LINCS会给警告.
这一角度用户可以在 ` *.mdp ` 文件中设置.

## 3.7 模拟退火 {#37-模拟退火}

GROMACS支持众所周知的模拟退火方法.
你甚至可以独立地将多个原子组和任意数目的参考温度进行耦合,
参考温度在模拟中会改变. 对温度耦合中的每一组,
退火是通过简单地改变当前的参考温度实现的. 因此,
实际的弛豫和耦合性质取决于你使用的热浴类型与耦合强度.
由于参考温度会变化, 请务必记住体系温度 **不会**
瞬时达到参考值--你必须考虑到耦合算法内在的弛豫时间.
如果退火参考温度的改变快于温度弛豫, 当它们之间相差过大时,
模拟可能会崩溃.

退火策略是对每个组指定一系列相应的时间和参考温度.
你还可以选择只使用单个序列(退火完成后温度将耦合到最后的参考值),
或是使用周期性退火, 当退火序列完成后重新从第一个参考温度开始. 在模拟中,
你可以混合配合使用两种退火类型和不退火的组.

## 3.8 随机动力学 {#38-随机动力学}

随机或速度Langevin动力学在牛顿运动方程中增加了摩擦项和噪声项:

[ \\\[m_i {\\mathrm d\^2 \\bi r_i \\over \\rmd {t\^2} } = -m_i \\g_i
{\\rmd {\\bi r_i} \\over \\rmd t}+\\bi F_i(\\bi r)+\\mathring{\\bi r}\_i
\\tag{3.114}\\\] ]{.math}

其中 [ \\(\\g_i\\) ]{.math} 为摩擦常数\[1/ps\], [ \\(\\mathring {\\bi
r}\_i\\) ]{.math} 为噪声过程, 满足 [ \\(\\langle \\mathring r_i(t)
\\mathring r_j(t+s) \\rangle=2m_i \\g_i k_B T \\d(s)\\d\_{ij}\\)
]{.math} . 当与体系的时间尺度相比, [ \\(1/\\g_i\\) ]{.math} 较大时,
随机动力学可视为具有随机温度耦合的分子动力学.
与使用Berendsen温度耦合的MD相比, SD的优势在于它产生的系综是已知的.
模拟真空中的体系时, SD还有另外一个优点:
对整个平动转动自由度不存在误差累积. 当 [ \\(1/\\g_i\\) ]{.math}
小于体系的时间尺度时, 动力学与MD完全不同, 但取样仍然正确.

在GROMACS中有两种算法可用于积分方程3.114:
简单有效的方法和更复杂的蛙跳式算法\[49\]. 后一方法现在已经废弃.
这两种积分方法的精度等价于常规MD的蛙跳式积分方法与速度Verlet积分方法的精度,
不同在于存在约束时复杂SD积分方法的采样温度稍微过高(尽管误差小于使用整步速度动能项的速度Verlet积分方法).
简单积分方法几乎与等同于常用的离散Langevin方程方法,
但以脉冲方式施加摩擦项与速度项\[50\]. 简单积分方法如下:

[ \\\[\\alg \\bi v\' &= \\bi v(t-{1\\over2}\\D t)+{1\\over m}\\bi F(t)
\\D t \\tag{3.115} \\\\ \\D \\bi v &= -\\a \\bi v\'(t+{1\\over2}\\D
t)+\\sqrt{ {k_B T\\over m}(1-\\a\^2)} \\bi r_i\^G \\tag{3.116} \\\\ \\bi
r(t+\\D t) &= \\bi r(t)+ \\left(\\bi v\'+{1\\over2}\\D t\\right) \\D t
\\tag{3.117} \\\\ \\bi r(t+{1\\over2}\\D t) &= \\bi v\'+\\D \\bi v
\\tag{3.118} \\\\ \\a &= 1-e\^{-\\g \\D t} \\tag{3.119} \\ealg\\\]
]{.math}

其中 [ \\(\\bi r_i\^G\\) ]{.math} 为服从高斯分布的噪声, 其 [ \\(\\m=0\\)
]{.math} , [ \\(\\s=1\\) ]{.math} .
算法首先在无摩擦与噪声的情况下更新整个时间步的速度, 获得 [ \\(\\bi
v\'\\) ]{.math} , 这完全与蛙跳式的常规更新相同. 然后在 [ \\(t+\\D t\\)
]{.math} 步以脉冲方式施加摩擦与噪声.
这种方案的优点在于依赖速度的项在整个时间步中都起作用,
由于对力的积分取决于坐标与速度, 这样就使得方案对力进行正确积分很简单,
如在约束和耗散粒子动力学(DPD, dissipative particle dynamics,
还未实现)情况下. 有约束时, 坐标更新方程3.117会被划分为常规的蛙跳式更新与
[ \\(\\D \\bi v\\) ]{.math} . 这些更新都完成后, 再对坐标和速度施加约束.

在已废弃的复杂方法中, 在每个积分步对每个自由度需要四个高斯随机数,
有约束时, 每个积分步坐标需要约束两次. 取决于力的计算代价,
这可能会占用显著一部分模拟时间.
精确地对随机动力学进行继续运行是不可能的,
因为在模拟过程中没有存储随机数产生器的状态.

当使用SD控温时, [ \\(\\g\\) ]{.math} 的合适值可取0.5 ps ^-1^ ,
因为这样得到的摩擦低于水的内摩擦, 同时仍能提供有效的控温.

## 3.9 Brown动力学 {#39-brown动力学}

在高摩擦的极限情况下, 随机动力学退化为Brown动力学,
也被称为位置Langevin动力学. 它施加于过阻尼体系, 即惯性效应可忽略的体系.
方程为

[ \\\[{\\mathrm d \\bi r_i \\over \\rmd t}={1\\over \\g_i} \\bi F_i(\\bi
r)+\\mathring {\\bi r}\_i \\tag{3.120}\\\] ]{.math}

其中 [ \\(\\g_i\\) ]{.math} 为摩擦系数\[amu/ps\], [ \\(\\mathring {\\bi
r}\_i(t)\\) ]{.math} 为噪声过程, 满足 [ \\(\\langle \\mathring r_i(t)
\\mathring r_j(t+s) \\rangle=2\\d(s)\\d\_{ij} k_B T/\\g_i\\) ]{.math} .
在GROMACS中, 使用简单的显示方案进行上面的方程进行积分:

[ \\\[\\bi r_i(t+\\D t) = \\bi r_i(t) +{\\D t\\over \\g_i} \\bi F_i(\\bi
r(t)) +\\sqrt{ 2k_B T{\\D t\\over \\g_i} } \\bi r_i\^G \\tag{3.121}\\\]
]{.math}

其中 [ \\(\\bi r_i\^G\\) ]{.math} 为服从高斯分布的噪声, 其 [ \\(\\m=0\\)
]{.math} , [ \\(\\s=1\\) ]{.math} . 摩擦系数 [ \\(\\g_i\\) ]{.math}
可以取为对所有粒子相同, 或者取为 [ \\(\\g_i=m_i \\g_i\\) ]{.math} ,
其中的摩擦系数 [ \\(\\g_i\\) ]{.math} 对不同组的原子可取不同值.
由于假定体系处于过阻尼状态, 因此可以使用大的时间步长.
应使用LINCS方法进行约束, 因为SHAKE方法对大的原子位移不收敛. BD是
` mdrun ` 程序的一个选项.

## 3.10 能量最小化 {#310-能量最小化}

GROMACS中的能量最小化可以使用最速下降, 共轭梯度,
或L-BFGS(有限内存的Broyden-Fletcher-Goldfarb-Shanno准牛顿最小化,
我们倾向于使用简称). EM只是 ` mdrun ` 程序的一个选项.

### 3.10.1 最速下降 {#3101-最速下降}

尽管最速下降方法确实不是最有效的搜索算法, 它很稳健, 并且易于实现.

定义代表所有 [ \\(3N\\) ]{.math} 个坐标的向量 [ \\(\\bi r\\) ]{.math} .
初始时, 必须给出的最大位移值 [ \\(h_0\\) ]{.math} (例如0.01 nm).

首先计算力 [ \\(\\bi F\\) ]{.math} 和势能. 新位置的计算方法如下:

[ \\\[\\bi r\_{n+1}=\\bi r_n+{\\bi F_n \\over \\max(\|\\bi F_n\|)} h_n
\\tag{3.122}\\\] ]{.math}

其中 [ \\(h_n\\) ]{.math} 为最大位移, [ \\(\\bi F_n\\) ]{.math} 为力,
也即势能 [ \\(V\\) ]{.math} 的负梯度. [ \\(\\max(\|\\bi F_n\|)\\)
]{.math} 表示力分量绝对值的最大值. 再次计算新位置的力与能量,

-   若 [ \\(V\_{n+1} \\lt V_n\\) ]{.math} , 则接受新位置, 令 [
    \\(h\_{n+1}=1.2h_n\\) ]{.math}
-   若 [ \\(V\_{n+1} \\ge V_n\\) ]{.math} , 则拒绝新位置, 令 [
    \\(h\_{n+1}=0.2h_n\\) ]{.math}

当力的计算次数达到用户指定的数目(如100),
或力(梯度)分量绝对值的最大值小于设定值 [ \\(\\e\\) ]{.math} 后,
算法停止. 由于力的截断会使能量计算产生一些噪声, 停止条件不应该设得过高,
以免算法迭代无法结束. [ \\(\\e\\) ]{.math}
的合理值可以根据简谐振子在温度 [ \\(T\\) ]{.math} 下的受到的根均方力 [
\\(f\\) ]{.math} 来估计, 其值为

[ \\\[f=2\\p\\n \\sqrt{2mkT} \\tag{3.123}\\\] ]{.math}

其中 [ \\(\\n\\) ]{.math} 为振子频率, [ \\(m\\) ]{.math} 为(约化)质量, [
\\(k\\) ]{.math} 为Boltzmann常数. 对波数为100 cm ^-1^ , 质量为10
原子单位, 温度 1 K时的弱振子, [ \\(f=7.7\\) ]{.math} kJ mol ^-1^ nm ^-1^
. [ \\(\\e\\) ]{.math} 的值在1到10之间是可以接受的.

### 3.10.2 共轭梯度 {#3102-共轭梯度}

共轭梯度在最小化早期慢于最速下降, 但靠近能量最低点时更高效.
方法的参数和停止条件与最速下降相同. 在GROMACS中,
共轭梯度不能与约束一起使用, 包括用于刚性水的SETTLE算法\[45\],
因为还未实现. 若体系中存在水分子, 必须使用柔性水模型, 这可以在 ` *.mdp `
文件中利用 ` define = -DFLEXIBLE ` 指定.

这真的不是一个限制,
因为只有在简正模式分析前的能量最小化中才需要共轭梯度的精度,
简正分析时不能使用约束. 对大多数其他目的, 最速下降足够高效.

### 3.10.3 L-BFGSD {#3103-l-bfgsd}

原始的BFGS算法会逐步产生更好的逆Hess矩阵的近似,
并将体系移动到当前的估计的最小点. 这种方法需要的内存正比于粒子数的平方,
因此实用中不能用于大体系如生物分子. 作为替代,
我们使用了Nocedal的L-BFGS算法\[51, 52\].
它使用来自前一步的固定数目的校正得到近似的逆Hess矩阵.
这种滑动窗技术几乎与原始方法一样有效,
但所需内存要少得多--正比于粒子数与校正步数的乘积. 实用中,
我们发现它比共轭梯度收敛得更快, 但由于存在校正步, 此方法还未并行化.
也需要指出, 切换或移位相互作用通常可以提高收敛性,
因为明显的截断意味着当前坐标下的势能函数与前一步用于构建逆Hess矩阵近似的势能函数稍有不同.

## 3.11 简正模式分析 {#311-简正模式分析}

GROMACS可以进行简正模式分析\[53, 54, 55\],
计算是通过对角化质量加权的Hess矩阵 [ \\(H\\) ]{.math} 进行的:

[ \\\[\\alg R\^T M\^{-1/2} H M\^{-1/2} R &= \\text{diag}(\\l1, \...,
\\l\_{3N}) \\tag{3.124} \\\\ \\l_i &= (2\\p \\w_i)\^2 \\tag{3.125}
\\ealg\\\] ]{.math}

其中 [ \\(M\\) ]{.math} 包含了原子质量, [ \\(R\\) ]{.math}
的列为本征向量, [ \\(\\l_i\\) ]{.math} 为本征值, [ \\(\\w_i\\) ]{.math}
为相应的频率.

首先需要计算Hess矩阵, 它是一个 [ \\(3N\\times 3N\\) ]{.math} 的矩阵,
其中 [ \\(N\\) ]{.math} 为原子数,

[ \\\[H\_{ij}={\\partial\^2 V \\over \\partial x_i \\partial x_j}
\\tag{3.126}\\\] ]{.math}

其中 [ \\(x_i\\) ]{.math} 和 [ \\(x_j\\) ]{.math} 代表原子的x, y或z坐标.
实际计算时并不使用上面的方程, 而是根据得到的力, 利用数值方法计算Hess矩阵

[ \\\[\\alg H\_{ij} &= -{f_i(\\bi x+h\\bi e_j) - f_i(\\bi x-h\\bi e_j)
\\over 2h} \\tag{3.127} \\\\ f_i &=-\\opar V {x_i} \\tag{3.128}
\\ealg\\\] ]{.math}

其中 [ \\(\\bi e_j\\) ]{.math} 为 [ \\(j\\) ]{.math} 方向的单位向量.
应当指出, 对通常的简正模式计算,
在计算Hess矩阵前需要进行彻底的能量最小化,
需要的能量容差取决于体系的类型, 粗略的指示值为0.001 kJ mol ^-1^ .
应当使用共轭梯度或L-BFGS方法进行能量最小化, 并使用双精度版本.

在这些计算中会涉及多个GROMACS程序. 首先应该使用 ` mdrun `
进行能量最小化, 其次再使用 ` mdrun ` 计算Hess矩阵. **注意** ,
创建运行输入文件时, 应使用来自全精度轨迹文件中的最小化的构型,
因为结构文件不够精确. ` g_nmeig ` 程序进行对角化计算,
并将简正模式按其频率进行排序. ` mdrun ` 和 ` g_nmeig `
都应当使用双精度版本. 可以使用 ` g_anaeig ` 程序分析简正模式.
要创建任意温度下的结构系综中的任意一组简正模式, 可使用 ` g_nmens ` 程序.
关于简正模式分析及其相关的主成分分析(见8.10节)的概述可参见\[56\].

## 3.12 自由能计算 {#312-自由能计算}

<figure>
<img src="/GMX/3.11.png"
alt="图3.11: 自由能循环. A: 计算 $\D G_{12}$, 抑制剂I分别与酶E, E结合时的自由能差值. B: 计算 $\D G_{12}$, 抑制剂I, I分别与酶结合时的自由能差值." />
<figcaption>图3.11: 自由能循环. A: 计算 <span class="math"> \(\D
G_{12}\) </span> , 抑制剂I分别与酶E, E’结合时的自由能差值. B: 计算 <span
class="math"> \(\D G_{12}\) </span> , 抑制剂I,
I’分别与酶结合时的自由能差值.</figcaption>
</figure>

### 3.12.1 慢增长方法 {#3121-慢增长方法}

GROAMCS可使用几种不同的方法计算自由能, 其中包括"慢增长"方法.
自由能计算的一个例子是计算抑制剂I分别与酶E,
突变后的酶E'结合时的自由能差值. 对这样的大体系,
利用计算机模拟来进行对接计算是不可行的,
即便是在合理的计算时间内以合理的计算精度模拟抑制剂从酶中释放的过程,
也是不可行的. 然而, 如果我们考虑图3.11 A中的热力学循环, 可得到

[ \\\[\\D G_1-\\D G_2 =\\D G_3 -\\D G_4 \\tag{3.129}\\\] ]{.math}

若对左边的项感兴趣, 我们也可以同样好地计算右边的项.

如果我们要计算两个抑制剂I和I'与酶E'结合时的自由能差值(图3.11 B),
我们仍然可以使用方程3.129来计算所需要的性质.

在GROMACS中可以利用"慢增长"方法计算两个分子物种之间的自由能差值.
不同分子物种之间的这种自由能差值没有物理意义, 但利用热力学循环,
可由它们获得有意义的量.
这种方法要求在模拟中体系的哈密顿量缓慢地从描述一个体系(A)转变到描述另一个体系(B).
变化必须足够缓慢. 以保证体系在这个过程中仍保持平衡状态.
若能满足这些要求, 变化是可逆的,
并且从B到A的慢增长模拟与从A到B的慢增长模拟会得到同样的结果(但符号相反).
这是一个有用的核查方法, 但用户应当心,
正向与反向增长结果的相等并不能确保结果的正确性.

对哈密顿量所需的修改是通过将 [ \\(H\\) ]{.math} 作为 **耦合参数** [
\\(\\l\\) ]{.math} 的函数实现的: [ \\(H=H(p,q;\\l)\\) ]{.math} . 这样 [
\\(\\l=0\\) ]{.math} 描述体系A, [ \\(\\l=1\\) ]{.math} 描述体系B:

[ \\\[H(p,q;0)=H\^A(p,q); \\;\\; H(p,q;1)=H\^B(p,q) \\tag{3.130}\\\]
]{.math}

在GROMACS中, [ \\(\\l\\) ]{.math} 依赖的函数形式对各种力场贡献是不同的,
对此的说明请参看4.5节.

Helmholtz自由能 [ \\(A\\) ]{.math} 与 [ \\(N\\) ]{.math} , [ \\(V\\)
]{.math} , [ \\(T\\) ]{.math} 系综的配分函数 [ \\(Q\\) ]{.math} 有关,
这一系综被认为是等容等温MD模拟产生的平衡系综. 一般更有用的Gibbs自由能 [
\\(G\\) ]{.math} 与 [ \\(N\\) ]{.math} , [ \\(P\\) ]{.math} , [ \\(T\\)
]{.math} 系综的配分函数 [ \\(\\D\\) ]{.math} 有关,
这一系综被认为是等压等温MD模拟产生的平衡系综.

[ \\\[\\alg A(\\l) &= -k_B T\\ln Q \\tag{3.131} \\\\ Q &= c\\iint
\\exp\[-\\b H(p,q;\\l)\] \\rmd p \\rmd q \\tag{3.132} \\\\ G(\\l) &=
-k_BT\\ln \\D \\tag{3.133} \\\\ \\D &= c\\iiint \\exp\[-\\b
H(p,q;\\l)-\\b pV\] \\rmd p \\rmd q \\rmd V \\tag{3.134} \\\\ G &= A+pV
\\tag{3.135} \\ealg\\\] ]{.math}

其中 [ \\(\\b=1/(k_B T)\\) ]{.math} , [ \\(c=(N!h\^{3N})\^{-1}\\)
]{.math} . 这些对相空间的积分不能由模拟得到, 但可以计算它们对 [
\\(\\l\\) ]{.math} 的导数作为系综平均:

\$\${\\rmd A \\over \\rmd \\l}={\\iint (\\partial H/\\partial \\l)
\\exp\[-\\b H(p,q;\\l)\] \\rmd p \\rmd q \\over \\iint \\exp\[-\\b
H(p,q;\\l)\] \\rmd p \\rmd q} = \\left\< \\opar H \\l
\\right\>\_{NVT;\\l} \\tag{3.136} \$\$

在 [ \\(N\\) ]{.math} , [ \\(p\\) ]{.math} , [ \\(T\\) ]{.math}
系综中的关系与此类似. A和B之间的自由能差值可通过积分对 [ \\(\\l\\)
]{.math} 的导数获得:

[ \\\[\\alg A\^B(V,T)-A\^A(V,T) &= \\int_0\^1 \\left\< \\opar H \\l
\\right\>\_{NVT;\\l} \\rmd \\l \\tag{3.137} \\\\ G\^B(p,T)-G\^A(p,T) &=
\\int_0\^1 \\left\< \\opar H \\l \\right\>\_{NpT;\\l} \\rmd \\l
\\tag{3.138} \\\\ \\ealg\\\] ]{.math}

若要计算 [ \\(G\^B(p,T)-G\^A(p,T)\\) ]{.math} , 自然的选择是等压模拟.
然而, 也可以从等容的慢增长模拟计算这个量, 模拟由压力为 [ \\(p\\)
]{.math} 体积为 [ \\(V\\) ]{.math} 的体系A开始, 到压力为 [ \\(p_B\\)
]{.math} 的体系B结束, 并进行下面的小(但原则上精确)校正:

[ \\\[G\^B(p)-G\^A(p) = A\^B(V)-A\^A(V)-\\int_p\^{p\^B} \[V\^B(p\')-V\]
\\rmd {p\'} \\tag{3.139}\\\] ]{.math}

这里的记号中忽略了温度 [ \\(T\\) ]{.math} . 这一校正粗略地等于 [
\\(-{1\\over2}(p\^B-p)\\D V=(\\D V)\^2/(2 \\k V)\\) ]{.math} , 其中 [
\\(\\D V\\) ]{.math} 为 [ \\(p\\) ]{.math} 时的体积变化, [ \\(\\k\\)
]{.math} 为等温压缩率. 这一校正通常很小, 例如, 等容情况下,
在1000个水分子的体系中凭空产生一个水分子增加的额外压力最大为22 bar,
但对Helmholtz自由能的校正只有--1 kJ mol ^-1^ .

在直角坐标系中, 哈密顿量的动能项只取决于动量, 可独立进行积分,
并且实际上可从方程中去除. 当质量不变时, 动能对自由能完全没有贡献.
当质量变化时, 对自由能的累计贡献为 [ \\(-{3\\over2}k_B
T\\ln(m\^B/m\^A)\\) ]{.math} . **注意** 这只对无约束的情况适用.

### 3.12.2 热力学积分 {#3122-热力学积分}

GROMACS也可以在一个模拟中对方程3.137或3.138从A到B的整个范围内进行积分.
然而, 若变化太大, 采样可能不充分, 用户可能更倾向于在仔细选择的中间的 [
\\(\\l\\) ]{.math} 值上精确地确定 [ \\(\\langle \\rmd G/\\rmd \\l
\\rangle\\) ]{.math} 的值. 通过将步长 ` delta_lambda ` 设定为零,
这很容易实现. 每一模拟都可以先进行平衡, 由 [ \\(\\partial H/\\partial
\\l\\) ]{.math} 的涨落可以得到每个 [ \\(\\langle \\rmd G/\\rmd \\l
\\rangle\\) ]{.math} 值的合适的误差估计. 然后,
可以通过适当的数值积分获得总的自由能变化.

GROMACS现在也支持使用 ` g_bar ` 程序计算从状态A转变到状态B的 [ \\(\\D
G\\) ]{.math} 值, 计算时利用BAR(Bennett's Acceptance Ratio)方法.
相同的数据也可用MBAR\[58\]方法来计算自由能, 但目前分析时需要来自外部
` pybar ` 程序包中的工具, 可从 <https://SimTK.org/home/pymbar> 下载.

力场贡献与 [ \\(\\l\\) ]{.math} 的依赖关系将在4.5节详细讨论.

## 3.13 副本交换动力学 {#313-副本交换动力学}

副本交换分子动力学(REMD, replica exchange molecular
dynamics)是一种加速抽样的方法, 可用于任何类型的模拟,
特别适用于不同构象之间存在较高能量势垒的情况.
它对同一体系处于不同温度下的多个副本进行模拟,
并以一定的时间间隔随机地完全交换两个副本的状态, 交换的概率为:

\$\$ P(1 \\leftrightarrow 2)=\\min\\left(1, \\exp\\left\[
\\left({1\\over k_B T_1} -{1\\over k_B T_2} \\right)(U_1-U_2) \\right\]
\\right) \\tag{3.140}\$\$

其中 [ \\(T_1\\) ]{.math} 和 [ \\(T_2\\) ]{.math} 为参考温度, [
\\(U_1\\) ]{.math} 和 [ \\(U_2\\) ]{.math} 分别为副本1和2的瞬时势能.
交换后, 使用 [ \\((T_1/T_2)\^{\\pm 0.5}\\) ]{.math} 对速度进行缩放,
并在下一步进行近邻搜索. 这方法将快速采样和最高温度频繁跨垒方法结合起来,
在所有不同温度下都使用了正确的玻耳兹曼抽样\[59, 60\].
由于随着温差的增大概率下降非常迅速, 我们只会尝试交换相邻的温度.
在一步中我们不应尝试对所有可能的副本对进行交换. 例如, 如果交换副本1和2,
交换副本2和3的机会不仅取决于副本2和3的能量, 还取决于副本1的能量.
在GROMACS中这个问题的解决方法是,
在"奇数"次尝试试着交换所有的"奇数"副本对,
在"偶数"次尝试试着交换所有的"偶数"副本对.
如果我们有四个按温度排序的副本: 0, 1, 2和3,
并且每1000步尝试进行一次交换, 那么将会在1000,
3000等步尝试对副本对0--1和2--3进行交换, 在2000,
4000等步尝试对副本对1--2进行交换.

应该如何选择温度呢? 能量差可以写成:

\$\$ U_1-U_2=N\_{df} {c \\over2} k_B (T_1-T_2) \\tag{3.141}\$\$

其中 [ \\(N\_{df}\\) ]{.math} 为一个副本的总自由度数, 对简谐势 [ \\(c\\)
]{.math} 为1, 对蛋白质/水体系 [ \\(c\\) ]{.math} 为2左右. 如果 [
\\(T_2=(1+\\e)T_1\\) ]{.math} 则概率变为:

[ \\\[P(1 \\leftrightarrow 2)=\\exp\\left(-{\\e\^2 c N\_{df} \\over
2(1+\\e)} \\right) \\approx \\exp\\left(-\\e\^2
{c\\over2}N\_{df}\\right) \\tag{3.142}\\\] ]{.math}

这样, 对于大小为 [ \\(e\^{-2} \\approx 0.135\\) ]{.math} 的概率, 可得到
[ \\(\\e \\approx 2/\\sqrt{c N\_{df} }\\) ]{.math} .
对所有键都进行约束时, [ \\(N\_{df}\\approx 2 N\_{atoms}\\) ]{.math} ,
这样对于 [ \\(c=2\\) ]{.math} 我们应选择的 [ \\(\\e\\) ]{.math} 为 [
\\(1/\\sqrt{N\_{atoms} }\\) ]{.math} . 然而,
当我们使用压力耦合时会出现一个问题. 更高温时密度会下降,
并导致能量增加\[61\], 这些情况我们需要考虑到.
GROMACS网站提供了一个被称为"REMD calculator"的计算器,
它可以根据你输入的温度范围和原子数给出一组温度.

Okabe等人提出了等压等温系综的REMD扩展\[62\]. 他们将交换概率修改为:

\$\$ P(1 \\leftrightarrow 2)=\\min\\left(1, \\exp\\left\[
\\left({1\\over k_B T_1} -{1\\over k_B T_2} \\right)(U_1-U_2) +
\\left({P_1\\over k_B T_1} -{P_2\\over k_B T_2}
\\right)(V_1-V_2)\\right\] \\right) \\tag{3.143}\$\$

其中 [ \\(P_1\\) ]{.math} 和 [ \\(P_2\\) ]{.math} 为各自的参考压力, [
\\(V_1\\) ]{.math} 和 [ \\(V_2\\) ]{.math} 为模拟中各自的瞬时体积.
在大多数情况下, 体积的差别很小以至于可以忽略第二项. 只有在 [ \\(P_1\\)
]{.math} 和 [ \\(P_2\\) ]{.math}
之间相差很大或者存在相变的情况下第二项才起作用.

GROMACS也支持哈密顿量副本交换. 在哈密顿量副本交换中,
每个副本的哈密顿量不同, 并根据模拟指定的自由能途径进行定义.
用来维持正确系综概率的交换概率为:

\$\$ P(1 \\leftrightarrow 2)=\\min\\left(1, \\exp\\left\[
\\left({1\\over k_B T_1} -{1\\over k_B t_2} \\right)(
(U_1(x_2)-U_1(x_1)) +(U_2(x_1)-U_2(x_2)) )\\right\] \\right)
\\tag{3.144}\$\$

各自的哈密顿量由GROMCAS内置的自由能函数定义, 并在不同 [ \\(\\l\\)
]{.math} 值之间进行交换, [ \\(\\l\\) ]{.math} 在mdp文件中定义.

也可以同时进行哈密顿量副本交换和温度副本交换, 使用的接受标准为:

\$\$ P(1 \\leftrightarrow 2)=\\min\\left(1, \\exp\\left\[
\\left({1\\over k_B T_1} - \\right)({U_1(x_2)-U_1(x_1) \\over k_B T} +
{U_2(x_1)-U_2(x_2) \\over k_B T_2})\\right\] \\right) \\tag{3.145}\$\$

GROMACS还实现了吉布斯抽样副本交换\[63\]. 在吉布斯抽样副本交换中,
会测试所有可能交换的副本对, 并允许交换不相邻的副本.

吉布斯抽样副本交换不需要额外的势能计算. 然而,
在吉布斯抽样副本交换中存在额外的通讯成本, 对一些排列,
肯定会发生超过一轮的交换. 在某些情况下,
这些额外的通讯成本可能会影响效率.

` mdrun ` 程序的包含了所有不同副本交换方法的选项.
由于算法中内在的并行化, 只有安装了MPI时候才能运行副本交换模拟.
为提高效率, 每个副本可以在一个独立的队列上运行.
想了解如何使用这些多节点功能, 可以参考 ` mdrun ` 的帮助文档.

## 3.14 主成分动力学抽样 {#314-主成分动力学抽样}

蛋白质主成分动力学(参见8.10节)的结果可用于指导MD模拟. 基本思想是,
我们可以从初始MD模拟(或源自其他途径)中获得拥有最大振幅的集约涨落.
对沿一个或多个这些集约模式的那些位置,
在接下来的(第二次)MD模拟中可以使用约束,
约束时可根据不同的目的使用不同的方法. 例如,
可以固定沿一个特定模式的位置以监测在此位置坐标上的平均力(自由能梯度).
另外一个应用是提高相对于普通MD的抽样效率\[64, 65\]. 在这种情况下,
与蛋白质通常采用的类扩散途径相比, 对体系构型空间的采样更系统.

另外一个提高抽样效率的可能方法是洪泛方法,
将洪泛势添加到一些(集约)自由度上,
以将体系排除到在某些相空间区域之外\[66\].

主成分动力学抽样或洪泛方法的步骤如下. 首先使用协方差分析( ` g_covar `
)或者简正模式分析( ` g_nmeig ` )确定特征向量和特征值. 然后将这些信息用于
` make_edi ` , 这个命令有很多用于选择向量和设定参数的选项, 请参考
` gmx make_edi -h ` . 最后将生成的 ` edi ` 输入文件传递给 ` mdrun ` .

## 3.15 扩展系综动力学 {#315-扩展系综动力学}

在扩展系综模拟\[67\]中, 坐标和热力学系综都可以被视为构型变量进行抽样.
任何给定状态的概率可写为:

\$\$ P(\\vec x, k) \\propto \\exp(-\\b_k U_k +g_k) \\tag{3.146}\$\$

其中 [ \\(\\b_k={1\\over k_B T_k}\\) ]{.math} 为对应于第 [ \\(k\\)
]{.math} 个热力学状态 [ \\(\\b\\) ]{.math} , [ \\(g_k\\) ]{.math}
为用户定义的对应于第 [ \\(k\\) ]{.math} 个状态的权重因子. 因此,
这一空间是 **混合** , **通用** , 或 **扩展** 的系综,
是对多个热力学系综同时抽样得到的. [ \\(g_k\\) ]{.math}
用于为扩展系综中的每个子系综指定权重, 既可以是固定的,
也可以由迭代程序确定. 通常选择的 [ \\(g_k\\) ]{.math}
集合对每个热力学系综会给出相同的概率, 在这种情况下, [ \\(g_k\\) ]{.math}
等于无量纲的自由能, 但根据需要也可以将它们设定为任意值.
在mdp选项列表中有好几种算法可以用来平衡这些权重.

在GROMACS中, 这个空间通过交替地在 [ \\(k\\) ]{.math} 和 [ \\(\\vec x\\)
]{.math} 方向上采样得到. [ \\(\\vec x\\) ]{.math}
方向的采样是由标准的分子动力学采样完成; 不同热力学状态之间的采样由Monte
Carlo完成, 且支持几种不同的Monte Carlo移动方法. [ \\(k\\) ]{.math}
状态可以根据温度的不同进行定义, 或根据自由能 [ \\(\\l\\) ]{.math}
变量的选择进行定义, 或者同时根据两者进行定义.
因此扩展系综模拟是系列化的副本交换形式, 单次模拟就能探索多个热力学状态.

## 3.16 并行 {#316-并行}

通过在多个核上并行地进行计算, 可以缩短模拟所需要的CPU时间. 理想情况下,
我们能够得到线性标度: 在 [ \\(N\\) ]{.math} 个核上运算就能使计算速度加快
[ \\(N\\) ]{.math} 倍. 但实际上, 只有当CPU核数目很少时才能达到这种效果.
计算的标度行为与所使用的算法关系很大. 此外,
不同算法对原子间的相互作用范围有不同的限制.

## 3.17 区域分解 {#317-区域分解}

由于分子模拟中的大部分相互作用都是局部的,
区域分解是分解体系的的自然方法. 在区域分解中, 每个队列分配一个空间区域,
然后对当前处于局部区域内粒子的运动方程进行积分. 使用区域分解,
你必须要做两个选择: 将单位晶胞分成多个区域和将力分配给各个区域.
绝大部分分子模拟软件都是使用半壳层方法来分配力.
但还有另外两种需要通讯更少的方法: 八壳层方法\[68\]和中点法\[69\].
GROMACS目前使用的是八壳层法, 但对于某些体系或者硬件架构来说,
中点法可能更合适. 因此, 将来我们可能会实现中点法.
绝大部分区域分解的技术细节可以在GROMACS 4的论文\[5\]中找到.

### 3.17.1 通讯坐标和力 {#3171-通讯坐标和力}

对三斜单元晶胞的最一般情况, 我们用1D, 2D或3D格点将空间分成平行六边体,
并称其为区域分解晶胞. 每个晶胞被分配到一个粒子-粒子队列.
在每个MD步的开始, 整个体系被分到多个队列, 并在那里执行近邻搜索.
由于近邻搜索基于电荷组, 因此电荷组也是区域分解的基本单位.
电荷组被分配到其几何中心所在的晶胞. 在计算力之前,
需要对一些来自近邻晶胞的坐标进行通讯, 在力的计算完成之后,
需要将力以相反的方向进行通讯.
通讯和力的分配基于能覆盖一个或多个晶胞的区域.
图3.12展示了一个区域设置的例子.

<figure>
<img src="/GMX/3.12.png"
alt="图3.12: $3\times2\times2$ 晶胞无交错的区域分解格点. 区域1到7中的坐标被通讯到区域0中拥有自己粒子的边角晶胞. $r_c$ 为截断半径." />
<figcaption>图3.12: <span class="math"> \(3\times2\times2\) </span>
晶胞无交错的区域分解格点.
区域1到7中的坐标被通讯到区域0中拥有自己粒子的边角晶胞. <span
class="math"> \(r_c\) </span> 为截断半径.</figcaption>
</figure>

坐标通讯是通过将数据沿 [ \\(x\\) ]{.math} , [ \\(y\\) ]{.math} 或 [
\\(z\\) ]{.math} 的"负"方向移动到下一个近邻完成的.
这可以在一个或多个脉冲内完成. 在图3.12中, [ \\(x\\) ]{.math}
方向需要两个脉冲, 然后 [ \\(y\\) ]{.math} 方向需要1个脉冲, 然后 [
\\(z\\) ]{.math} 方向需要1个脉冲. 而力的通讯步骤则与此过程相反.
要想了解确定哪些非键力和键合力需要在哪个队列上进行计算的细节,
请参考GROMACS 4论文\[5\].

### 3.17.2 动态负载均衡 {#3172-动态负载均衡}

当不同队列的计算负载不同(负载失衡)时,
所有队列都必须等待最耗时的那个队列. 这是我们极力要避免的情况.
负载失衡可能由以下三个原因造成:

-   不均匀的粒子分布
-   不均匀的相互作用计算时间分布(带电/不带电,
    由GROMACS内部的水计算循环造成的水/非水计算)
-   统计涨落(仅当粒子数目较少时)

因此我们需要一个动态负载均衡算法, 它能够 **独立地**
调整每个区域分解晶胞的体积. 为了达到这个目的,
需要交错2D或3D区域分解的格点. 图3.13显示了2D中的最一般情况. 由于交错,
我们可能需要两个距离检查, 以决定一个电荷组是否需要通讯:
非键距离检查和键合距离检查.

<figure>
<img src="/GMX/3.13.png"
alt="图3.13: 通讯到区域0队列的各个区域, 详情见正文. $r_c$ 和 $r_b$ 分别为非键截断半径和键合截断半径, $d$ 为晶胞交错边界之间的距离." />
<figcaption>图3.13: 通讯到区域0队列的各个区域, 详情见正文. <span
class="math"> \(r_c\) </span> 和 <span class="math"> \(r_b\) </span>
分别为非键截断半径和键合截断半径, <span class="math"> \(d\) </span>
为晶胞交错边界之间的距离.</figcaption>
</figure>

默认情况下, 在模拟中, 当由力计算失衡造成的总体性能损失达到5%或更多时,
` mdrun ` 会自动开启动态负载均衡. **注意** , 由于在一个积分步中,
力的计算只是所需要工作的一部分, 所以报告中力的负载失衡数据可能会偏高.
负载失衡会记录日志文件中, 输出频率由设定的日志输出步决定, 当使用 ` -v `
选项时, 也会在屏幕上输出负载失衡.
平均负载失衡和由负载失衡导致的总性能损失会记录在日志文件的结尾处.

最小允许缩放比例是动态负载均衡的一项重要参数. 默认情况下,
在每个方向上区域分解晶胞至少能够缩小为原来的0.8. 对于3D区域分解,
这相当于允许晶胞的体积缩小为原来的0.5, 补偿100%的负载失衡.
这个最小允许缩放比例可以通过 ` mdrun ` 的 ` -dds ` 选项进行调整.

### 3.17.3 并行中的约束 {#3173-并行中的约束}

由于使用区域分解时, 分子的各个部分可以处于不同的队列上,
键约束可以跨越晶胞的边界. 因此需要一个并行的约束算法.
GROMACS使用了P-LINCS算法\[48\], 它LINCS算法\[47\]的并行版(参见3.6.2节).
P-LINCS算法过程的示意见图3.14. 当分子跨越晶胞边界时,
会在晶胞边界中对此分子中相邻直到( ` lincs_order + 1 `
)键远的原子进行通讯. 然后,
会对局部的键和通讯得到的键施加正常的LINCS算法. 经过这个步骤之后,
已经正确地被约束了局部的键, 尽管额外通讯得到的键还没有.
LNICS的初始步需要一个坐标通讯步. 不需要对力进行通讯.

![图3.14: P-LINCS算法并行设置示例. 一个分子被划分到3个区域分解晶胞中,
使用的矩阵展开阶数为3.
上面部分展示了需要通讯的原子坐标及其要通讯到的晶胞.
下面部分展示了三个晶胞中各自的局部约束(实线)和非局部约束(虚线).](/GMX/3.14.png)

### 3.17.4 相互作用范围 {#3174-相互作用范围}

区域分解利用了相互作用的局域性. 这就意味着对相互作用的范围有所限制.
默认情况下, ` mdrun ` 程序会试着找到相互作用范围和效率之间的最佳平衡.
但也有可能发生模拟停止并给出缺失相互作用的错误信息,
或者当使用更短的相互作用范围时, 模拟运行稍微快一些的情况.
相互作用范围及其默认值都列在表3.3中.

  相互作用                                   范围                                       选项              默认       
  ---------- -------------------------------------------------------------------- ----------------- ---------------- --
  非键        \\(r_c = \\max(r\_\\text{list}, r\_\\text{VdW},r\_\\text{Coul})\\)    ` mdp ` 文件                     
  双体键合                      \\(\\max(r\_\\text{mb},r_c)\\)                     ` mdrun -rdd `    初始构型 + 10%  
  多体键合                           \\(r\_\\text{mb}\\)                           ` mdrun -rdd `    初始构型 + 10%  
  约束                               \\(r\_\\text{con}\\)                          ` mdrun -rcon `     由键长估计    
  虚拟位点                           \\(r\_\\text{con}\\)                          ` mdrun -rcon `         0         

  : 表3.3: 区域分解的相互作用范围

在大多数情况下, ` mdrun `
的默认设置不会导致模拟停止并给出缺失相互作用的出错信息.
键合相互用作的范围由初始构型中键合的电荷组之间的距离, 再加上10%确定.
对约束, [ \\(r\_\\text{con}\\) ]{.math} 的值由( ` lincs_order + 1 `
)个键所能覆盖的最大距离决定, 并且所有这些键以120度的角相连接.
实际的约束通讯并不受 [ \\(r\_\\text{con}\\) ]{.math} 限制,
而是受最小晶胞尺寸 [ \\(L_C\\) ]{.math} 限制:

[ \\\[L_C \\ge \\max(r\_\\text{mb}, r\_\\text{com}) \\tag{3.147}\\\]
]{.math}

不使用动态负载均衡, 并使用压力缩放时, 实际上允许体系的缩放超过这个限制.
**注意** , 对于三斜盒子, [ \\(L_C\\) ]{.math}
并不是简单地取盒子对角分量与此方向晶胞数目的比值,
而是三斜晶胞边界之间的最小距离. 对于菱形十二面体盒子, 此距离是沿 [
\\(x\\) ]{.math} 和 [ \\(y\\) ]{.math} 方向长度的 [ \\(\\sqrt{3/2}\\)
]{.math} .

当 [ \\(r\_\\text{mb} \\gt r_c\\) ]{.math} 时, ` mdrun `
会采用一个灵巧的算法以减少通讯. 如果只是简单地通讯 [ \\(r\_\\text{mb}\\)
]{.math} 之内的所有电荷组, 这将大大增加通讯次数.
因此只会对那些与不在局部出现的电荷组之间存在键合相互作用连接的电荷组进行通讯.
这将导致很少的额外通讯, 也会稍微增加区域分解设置的成本. 在某些情况下,
例如粗粒化模拟中使用非常短的截断, 可能需要手动设置 [ \\(r\_\\text{mb}\\)
]{.math} 以减小这个成本.

### 3.17.5 多程序多数据PME并行 {#3175-多程序多数据pme并行}

静电相互作用是长程的, 因此需要使用特殊的算法来避免对许多原子对进行加和.
在GROMACS中通常使用的方法是PME(参见4.8.2节). 由于在PME算法中,
所有粒子彼此之间都存在相互作用, 因此需要全局通讯.
这通常就是区域分解标度行为的限制因素. 为了减小这个问题带来的影响,
我们提出了多程序多数据(Multiple-Program, Multiple-Data)方法\[5\].
在这个方法中, 我们选择一些队列只进行PME网格计算,
而其他被称为粒子-粒子(PP)队列的队列则用于完成所有剩余的其他任务.
对于长方体盒子, PP队列与PME队列的最佳比例通常是3:1,
而对于菱形十二面体盒子最佳比例是2:1. 当PME队列的数量减少为原来的1/4时,
通讯调用的次数大约减少到原来的1/16. 或者换句话说,
现在我们可以使用4倍多的队列. 另外, 对于网络中4核或8核的现代设备来说,
PME的有效网络带宽将提高4倍, 因为在PME计算中,
每个机器上只有四分之一的核在使用网络连接.

![图3.15: 8个队列不使用MPMD(左边)和使用MPMD(右边)的例子.
左边的PME通讯(红箭头)比右边的多得多. 对MPMD算法,
虽然需要额外的PP-PME坐标和力通讯(蓝箭头),
但是通讯复杂度更低.](/GMX/3.15.png)

` mdrun ` 默认会交错运行PP和PME队列. 如果设备中的队列没有依次编号,
可以使用 ` mdrun -ddorder pp_pme ` 命令.
对带有真正的三维环及相应的合适的队列分配通讯软件的设备, 我们应该使用
` mdrun -ddorder cartesian ` 命令.

为了优化性能,
我们通常应该设置截断和PME格点使得PME负载达到总计算负载的25%到33%.
` grompp ` 会在末尾输出此负载的估计值, 并且 ` mdrun `
也会计算相同的估计值以确定使用的PME队列的最佳数目. 对高度并行化计算,
利用 ` mdp ` 设置和/或由 ` mdrun ` 的 ` -npme `
选项设定的PME队列数目来优化PME负载是值得的. 为了改变静电设置,
了解当对库仑截断和PME格点间距使用相同的比例进行缩放时,
静电的精度几乎保持不变, 对我们是很有用的. **注意** ,
由于PME队列数目比PP队列数目的小,
所以通常在我们估算PME队列数目的时候最好多算一些,
这样可以减少总的等待时间.

PME区域分解可以是沿 [ \\(x\\) ]{.math} 和/或 [ \\(y\\) ]{.math}
方向的1D或2D分解. 因为在高度并行化中, 2D分解的区域形状和铅笔很相似,
所以2D分解也被称为铅笔分解. 只有当PP分解沿 [ \\(x\\) ]{.math}
方向有唯一一个区域时, 才能使用沿 [ \\(y\\) ]{.math} 方向的1D分解. 2D
PME分解沿 [ \\(x\\) ]{.math} 方向的区域数目必须等于PP分解数目. ` mdrun `
会自动选择1D或2D PME分解(当可以使用给定的全部队列数时),
基于PME中坐标再分布通讯加上格点重叠和转置通讯的最小数目.
为了避免PP和PME队列之间坐标和力的多余通讯, 理想情况下 [ \\(x\\) ]{.math}
方向上的DD晶胞数目应等于PME队列的数目或其倍数. 默认情况下, ` mdrun `
会考虑这些情况.

### 3.17.6 区域分解流程图 {#3176-区域分解流程图}

流程图3.16显示了区域分解中不同算法所有可能的通讯. 对于简单点的模拟,
流程图也一样, 只是不包含未使用的算法及与其相应的通讯.

![图 3.16: 标准MD模拟中算法和通讯(箭头)的流程图, 模拟使用了虚拟位点,
约束和独立PME网格队列.](/GMX/3.16.png)

## 3.18 隐式溶剂模型 {#318-隐式溶剂模型}

隐式溶剂模型提供了一种表现溶剂分子静电效应的有效方式,
同时避免了分子动力学模拟中的大量计算,
这些计算涉及对周围水分子进行精确的, 溶剂化的描述. 与显式溶剂模型相比,
隐式溶剂模型有以下几个优点: 不需要对溶质周围的水分子进行平衡;
不存在粘度, 蛋白质能够更快地探索构象空间.

GROMACS中的隐式溶剂计算利用广义Born公式,
Born半径的计算可使用Still\[70\], HCT\[71\]和OBC\[72\]模型.

溶剂化自由能 [ \\(G\_\\text{solv}\\) ]{.math} 是三项的加和,
溶剂-溶剂空穴项( [ \\(G\_\\text{cav}\\) ]{.math} ), 溶质-溶剂范德华项( [
\\(G\_\\text{vdw}\\) ]{.math} ), 还有溶质-溶剂静电极化项( [
\\(G\_\\text{pol}\\) ]{.math} ).

[ \\(G\_\\text{cav}\\) ]{.math} 和 [ \\(G\_\\text{vdw}\\) ]{.math}
的总和对应于移除所有电荷的分子所具有的(未极化)溶剂化自由能, 通常称作 [
\\(G\_\\text{np}\\) ]{.math} , 等于总的溶剂可及表面积乘上表面张力.
因此溶剂化自由能的总表达式可写为:

[ \\\[G\_\\text{solv}=G\_\\text{np}+G\_\\text{pol} \\tag{3.148}\\\]
]{.math}

对于广义Born模型, [ \\(G\_\\text{pol}\\) ]{.math}
可由广义Born方程计算\[70\]:

[ \\\[G\_\\text{pol}=\\left(1-{1\\over \\e}\\right) \\Sum\_{i=1}\^n
\\Sum\_{j \\gt i}\^n {q_i q_j \\over \\sqrt{r\_{ij}\^2+b_i b_j
\\exp\\left({-r\_{ij}\^2 \\over 4 b_i b_j}\\right)} } \\tag{3.149}\\\]
]{.math}

在GROMCAS中, 我们引入了代换\[73\]:

[ \\\[c_i={1\\over \\sqrt{b_i} } \\tag{3.150}\\\] ]{.math}

这样当计算每项相互作用时, 可以引入新变量 [ \\(x\\) ]{.math} 的简单变换:

[ \\\[x={r\_{ij} \\over \\sqrt{b_i b_j} }=r\_{ij} c_i c_j
\\tag{3.151}\\\] ]{.math}

最后, 改写后3.149的完整的公式如下:

[ \\\[G\_\\text{pol}=\\left(1-{1\\over\\e}\\right)\\Sum\_{i=1}\^n
\\Sum\_{j \\lt i}\^n {q_i q_j \\over \\sqrt{b_i b_j} }
\\x(x)=\\left(1-{1\\over\\e}\\right)\\Sum\_{i=1}\^n q_i c_i \\Sum\_{j
\\lt i}\^n q_j c_j \\x(x) \\tag{3.152}\\\] ]{.math}

方程3.148的非极化部分( [ \\(G\_\\text{np}\\) ]{.math}
)直接根据每个原子的Born半径计算,
计算时使用了Schaefer等人提出的简单ACE类型近似\[74\],
并包含了对所有原子的一个简单循环. 这只需要一个额外的溶剂化参数,
与原子类型无关, 但三种Born半径模型之间有稍微的差别.

::: footnotes

------------------------------------------------------------------------

1.  ::: {#fn:1}
    注意, 在一些推导, 会使用另一种符号 [ \\(\\x\_{\\text{alt}
    }=v\_\\x=p\_\\x/Q\\) ]{.math} .
    [↩](#fnref:1 "return to article"){.reversefootnote}
    :::

2.  ::: {#fn:2}
    GROMACS中的盒矩阵表示 [ \\(\\bi b\\) ]{.math}
    对应于Nose和Klein论文中盒矩阵表示 [ \\(\\bi h\\) ]{.math} 的转置.
    因此, 我们的一些方程看起来与原论文中的略有不同.
    [↩](#fnref:2 "return to article"){.reversefootnote}
    :::
:::

------------------------------------------------------------------------

------------------------------------------------------------------------

![](/jscss/molsimart.png){style="display:table;margin:0 auto;height:150px"}
[个](javascript:scroll(0,0)){#scrollTop}
:::
::: site-header
::: wrap




""
:::
:::

::: wrap
# GROMACS中文手册：第四章　相互作用函数和力场





为了能够使用一些流行力场中采用的势能函数(见4.10节),
GROMACS提供了一些势能函数, 包括非键相互作用以及二面角的相互作用.
我们将在适当的小节中对它们予以讨论.

势能函数可以被划分成三个部分:

1.  **非键项** : Lennard-Jones或Buckingham, 以及库仑或修正的库仑.
    非键相互作用的计算基于已移除了排除项的邻区列表(一定半径内非键原子的列表).

2.  **键合项** : 共价键伸缩, 键角弯曲, 反常二面角, 和正常二面角.
    这些项的计算是基于固定的列表.

3.  **约束项** : 位置约束, 角度约束, 距离约束, 方向约束和二面角约束,
    均基于固定的列表进行计算.

## 4.1 非键相互作用 {#41-非键相互作用}

GROMACS的非键相互作用是对势累加的(pair-additive), 并满足中心对称:

[ \\\[V(\\bi r_1, \\cdots \\bi r_N) = \\sum\_{i\< j} V\_{ij}(\\bi
r\_{ij}) \\tag{4.1}\\\] ]{.math}

[ \\\[\\bi F_i = - \\sum_j {dV\_{ij}(r\_{ij}) \\over dr\_{ij}} {\\bi
r\_{ij} \\over r\_{ij}} = - \\bi F_j \\tag{4.2}\\\] ]{.math}

非键相互作用包含排斥项, 色散项和库仑项.
组合起来的排斥项和色散项可以取Lennard-Jones(或6--12相互作用)或Buckingham(或exp--6势)形式.
此外, (部分)带电的原子之间的非键相互作用通过库仑项表达.

![图4.1: Lennard-Jones相互作用](/GMX/4.1.png)

### 4.1.1 Lennard-Jones相互作用 {#411-lennard-jones相互作用}

两个原子之间Lennard-Jones势 [ \\(V\_{LJ}(r\_{ij})\\) ]{.math} 等于:

[ \\\[V\_{LJ}(r\_{ij}) = {C\_{ij}\^{(12)} \\over r\_{ij}\^{12} } -
{C\_{ij}\^{(6)} \\over r\_{ij}\^6} \\tag{4.3}\\\] ]{.math}

其函数曲线如图4.1所示. 参数 [ \\(C\_{ij}\^{(12)}\\) ]{.math} 和 [
\\(C\_{ij}\^{(6)}\\) ]{.math} 取决于配对的 **原子类型** ;
因此来源于LJ-参数矩阵. 在Verlet截断方案中, 通过将势能移动一个恒量,
可使其在截断距离处为零.

此势能函数的力是:

[ \\\[\\bi F_i(\\bi r\_{ij}) = \\left(12{C\_{ij}\^{(12)} \\over
r\_{ij}\^{13}} - 6{C\_{ij}\^{(6)} \\over r\_{ij}\^7}\\right){\\bi
r\_{ij} \\over r\_{ij}} \\tag{4.4}\\\] ]{.math}

LJ势也可以写成以下形式:

[ \\\[V\_{LJ}(r\_{ij}) = 4 \\varepsilon\_{ij} \\left(
\\left({\\sigma\_{ij} \\over r\_{ij}} \\right)\^{12} -
\\left({\\sigma\_{ij} \\over r\_{ij}}\\right)\^6 \\right) \\tag{4.5}\\\]
]{.math}

在构造非键LJ-参数的参数矩阵时, GROMACS可使用两种不同的组合规则,
只采用几何平均值（力场文件输入部分的类型1）:

[ \\\[\\begin{split} C\_{ij}\^{(6)} &= \\left( C\_{ii}\^{(6)}
C\_{jj}\^{(6)} \\right)\^{1/2} \\\\ C\_{ij}\^{(12)} &=
\\left(C\_{ii}\^{(12)} C\_{jj}\^{(12)} \\right)\^{1/2} \\end{split}
\\tag{4.6}\\\] ]{.math}

或采用Lorentz-Berthelot规则. 此规则利用算术平均计算 [ \\(\\s\_{ij}\\)
]{.math} , 利用几何平均计算 [ \\(\\ve\_{ij}\\) ]{.math} （类型2）:

[ \\\[\\begin{split} \\sigma\_{ij} &= {1 \\over 2}(\\sigma\_{ii} +
\\sigma\_{jj}) \\\\ \\varepsilon\_{ij} &= (\\varepsilon\_{ii}
\\varepsilon\_{jj})\^{1/2} \\end{split} \\tag{4.7}\\\] ]{.math}

最后, 可以对两个参数都采用几何平均值（类型3）:

[ \\\[\\begin{split} \\sigma\_{ij} = (\\sigma\_{ii}
\\sigma\_{jj})\^{1/2} \\\\ \\varepsilon\_{ij} = (\\varepsilon\_{ii}
\\varepsilon\_{jj})\^{1/2} \\end{split} \\tag{4.8}\\\] ]{.math}

OPLS力场就采用这个规则.

![图4.2: Buckingham相互作用](/GMX/4.2.png)

### 4.1.2 Buckingham势 {#412-buckingham势}

与Lennard-Jones势相比, Buckingham势的排斥项更加灵活, 贴近实际,
但其计算也更昂贵. Buckingham势的形式是:

[ \\\[V\_{bh}(r\_{ij}) = A\_{ij} \\exp(-B\_{ij} r\_{ij}) - {C\_{ij}
\\over r\_{ij}\^6} \\tag{4.9}\\\] ]{.math}

请参见图4.2. 此势能函数的力为:

[ \\\[\\bi F_i(r\_{ij}) = \\left\[ A\_{ij} B\_{ij} \\exp(-B\_{ij}
r\_{ij}) - 6{C\_{ij} \\over r\_{ij}\^7} \\right\] {\\bi r\_{ij} \\over
r\_{ij}} \\tag{4.10}\\\] ]{.math}

### 4.1.3 库仑相互作用 {#413-库仑相互作用}

两个带电粒子之间的库仑相互作用由下式给出:

[ \\\[V_c(r\_{ij}) = f{q_i q_j \\over \\varepsilon_r r\_{ij}}
\\tag{4.11}\\\] ]{.math}

参见图4.3, 其中 [ \\(f={1 \\over 4\\p\\ve_0}=138.935 485\\) ]{.math}
（见第2章）

此势对应的力为:

[ \\\[\\bi F_i(r\_{ij}) = f{q_i q_j \\over \\varepsilon_r r\_{ij}\^2}
{\\bi r\_{ij} \\over r\_{ij}} \\tag{4.12}\\\] ]{.math}

<figure>
<img src="/GMX/4.3.png"
alt="图4.3: 反应场与非反应场的库仑相互作用（带同种电荷的粒子之间）. 在非反应场的情况下 $\ve_r$ 为1, $\ve_{rf}$ 为78, $r_c$ 为0.9纳米. 除相差一个常数外, 点划线与虚线完全相同. " />
<figcaption>图4.3:
反应场与非反应场的库仑相互作用（带同种电荷的粒子之间）.
在非反应场的情况下 <span class="math"> \(\ve_r\) </span> 为1, <span
class="math"> \(\ve_{rf}\) </span> 为78, <span class="math"> \(r_c\)
</span> 为0.9纳米. 除相差一个常数外, 点划线与虚线完全相同.</figcaption>
</figure>

使用普通的库仑相互作用时要么不能截断,
要么所有粒子对都处于截断半径范围内, 因为力在截断处存在跃变,
而且变化很大. 如果你确实需要使用截断,
可以将势能进行移动以使势能等于力的积分. 在基于组的截断方案中,
这种移动只适用于非排除对. 在Verlet截断方案中,
移动也适用于排除对和自相互作用, 这使得势能等同于 [ \\(\\ve\_{rf}=1\\)
]{.math} 的反应场（见下文）.

GROMACS中相对介电常数 [ \\(\\ve_r\\) ]{.math} 可在 ` grompp `
的输入中设置.

### 4.1.4 反应场库仑作用 {#414-反应场库仑作用}

对均相体系, 可通过假定截断半径 [ \\(r_c\\) ]{.math}
以外的粒子周围是介电常数为 [ \\(\\ve\_{rf}\\) ]{.math} 的恒定介电环境,
对库仑相互作用进行校正. 此时, 库仑相互作用可写为:

[ \\\[V\_{crf} = f{q_i q_j \\over \\varepsilon_r r\_{ij}} \\left\[ 1 +
{\\varepsilon\_{rf} - \\varepsilon_r \\over 2 \\varepsilon\_{rf} +
\\varepsilon_r } {r\_{ij}\^3 \\over r_c\^3} \\right\] - f {q_i q_j
\\over \\varepsilon_r r_c} {3 \\varepsilon\_{rf} \\over 2
\\varepsilon\_{rf} + \\varepsilon_r} \\tag{4.13}\\\] ]{.math}

上式右边的常量表达式使得在截断处势能为零. 对带电的截断球体,
上式对应于均匀背景电荷的中性化. 我们可以将方程4.13简写为

[ \\\[V\_{crf} = f{q_i q_j \\over \\varepsilon_r} \\left\[ {1 \\over
r\_{ij}} + k\_{rf} r\_{ij}\^2 - c\_{rf}\\right\] \\tag{4.14}\\\]
]{.math}

其中,

[ \\\[\\alg k\_{rf} &= {1 \\over r_c\^3} {\\varepsilon\_{rf} -
\\varepsilon_r \\over (2 \\varepsilon\_{rf} + \\varepsilon_r)}
\\tag{4.15} \\\\ c\_{rf} &= {1 \\over r_c} + k\_{rf} r_c\^2 = {1 \\over
r_c} {3\\varepsilon\_{rf} \\over (2 \\varepsilon\_{rf} +
\\varepsilon_r)} \\tag{4.16} \\ealg\\\] ]{.math}

对大的 [ \\(\\ve\_{rf}\\) ]{.math} , [ \\(k\_{rf}\\) ]{.math} 趋近 [
\\(r_c\^{-3}/2\\) ]{.math} , 而当 [ \\(\\ve\_{rf}=\\ve_r\\) ]{.math}
时校正消失. 图4.3中画出了校正的相互作用, 很显然, 对 [ \\(r\_{ij}\\)
]{.math} 的导数(即负的力)在截断距离处为零. 这种势函数对应的力为:

[ \\\[\\bi F_i(\\bi r\_{ij}) = f{q_i q_j \\over \\varepsilon_r} \\left\[
{1 \\over r\_{ij}\^2} - 2 k\_{rf} r\_{ij} \\right\]{\\bi r\_{ij} \\over
r\_{ij}} \\tag{4.17}\\\] ]{.math}

反应场校正也可以用于所有的排除原子对, 包括自身对, 在这种情况下,
方程4.13和4.17中不出现正常的库仑项.

Tironi等引入了更一般的反应场理论, 其截断半径 [ \\(r_c\\) ]{.math}
以外的电介质也具有离子强度 [ \\(I\\) ]{.math} \[75\]. 这种情况下,
我们可以利用逆Debye屏蔽长度 [ \\(\\kappa\\) ]{.math} , 将常数 [
\\(k\_{rf}\\) ]{.math} 和 [ \\(c\_{rf}\\) ]{.math} 重写为

[ \\\[\\alg \\kappa\^2 &= {2IF\^2 \\over \\varepsilon_0
\\varepsilon\_{rf}RT} = {F\^2 \\over \\varepsilon_0
\\varepsilon\_{rf}RT} \\sum\_{i=1}\^K c_i z_i\^2 \\tag{4.18} \\\\
k\_{rf} &= {1 \\over r_c\^3} {
(\\varepsilon\_{rf}-\\varepsilon_r)(1+\\kappa r_c) + {1 \\over
2}\\varepsilon\_{rf}(\\kappa r_c)\^2 \\over
(2\\varepsilon\_{rf}+\\varepsilon_r)(1+\\kappa r_c) +
\\varepsilon\_{rf}(\\kappa r_c)\^2} \\tag{4.19} \\\\ c\_{rf} &= {1
\\over r_c} {3 \\varepsilon\_{rf} (1+\\kappa r_c + {1\\over2}(\\kappa
r_c)\^2) \\over (2 \\varepsilon\_{rf} + \\varepsilon_r)(1+\\kappa r_c) +
\\varepsilon\_{rf}(\\kappa r_c)\^2} \\tag{4.20} \\ealg\\\] ]{.math}

其中, [ \\(F\\) ]{.math} 是法拉第常数, [ \\(R\\) ]{.math}
是理想气体常数, [ \\(T\\) ]{.math} 是绝对温度, [ \\(c_i\\) ]{.math}
是物种 [ \\(i\\) ]{.math} 的摩尔浓度, [ \\(z_i\\) ]{.math} 是物种 [
\\(i\\) ]{.math} 的电荷数, 共有 [ \\(K\\) ]{.math} 种不同的物种.
在离子强度为零的极限情况下,
方程4.19和4.20分别退化为简单形式的方程4.15和4.16.

### 4.1.5 修正的非键相互作用 {#415-修正的非键相互作用}

在GROMACS中, 可以利用移位函数对非键势能函数进行修改,
其目的在于用连续的力取代截断的力, 且使其在截断半径处具有连续的导数.
使用这种力时, 每步积分引入的误差更小, 且避免了一些复杂情况,
比如在截断过程中由偶极产生的电荷. 实际上, 使用移位力时,
不需要对电荷组创建邻近列表. 然而,
移位函数使库仑势产生了一个相当大的变形.
除非对"丢失"的远程势进行了正确的计算以及加和（通过使用PPPM,
Ewald或PME）, 否则必须仔细评估这些修改的效果.
对Lennard-Jones色散项和排斥项的修改较小,
但它确实消除了截断效应引起的噪声.

切换函数（将势能乘上一个函数）和移位函数（将势能或力加上一个函数）之间
**没有** 本质区别\[76\]. 切换函数是移位函数的一种特殊情况.
将切换函数应用于与粒子 [ \\(j\\) ]{.math} 作用在粒子 [ \\(i\\) ]{.math}
上的静电力或范德华力有关的 **力函数 [ \\(F(r)\\) ]{.math}** :

[ \\\[\\bi F_i = cF(r\_{ij}){\\bi r\_{ij} \\over r\_{ij}}
\\tag{4.21}\\\] ]{.math}

对于纯的库仑或Lennard-Jones相互作用, [ \\(F(r)= F\_\\a(r)=
r\^{-\\a+1}\\) ]{.math} . 移位力 [ \\(F_s(r)\\) ]{.math} 一般可写为:

[ \\(\\alg F_s(r) &= F\_\\a (r) & &r \< r_1 \\\\ F_s(r) &= F\_\\a (r) +
S(r) & &r_1 \\le r \\le r_c \\tag{4.22} \\\\ F_s(r) &= 0 & &r_c \\le r
\\ealg\\) ]{.math}

当 [ \\(r_1\\) ]{.math} =0 时, 这是一个通常的移动函数,
否则它就是一个切换函数. 相应的移位库仑势为:

[ \\\[V_s(r\_{ij}) = f \\F_s(r\_{ij}) q_i q_j \\tag{4.23}\\\] ]{.math}

其中, [ \\(\\F(r)\\) ]{.math} 是势函数

[ \\\[\\F_s(r) = \\int_r\^\\infty F_s(x)dx \\tag{4.24}\\\] ]{.math}

GROMACS的移位函数在边界处应该是平滑的, 因此移位函数应当满足以下边界条件:

[ \\(\\alg \\begin{split} S(r_1) &= 0 \\\\ S\'(r_1) &= 0 \\\\ S(r_c)
&= - F\_\\a (r_c) \\\\ S\'(r_c) &= - F\_\\a\'(r_c) \\end{split}
\\tag{4.25} \\ealg\\) ]{.math}

三阶多项式形式

[ \\\[S(r) = A(r - r_1)\^2 + B(r - r_1)\^3 \\tag{4.26}\\\] ]{.math}

即满足这些要求. 常数 [ \\(A\\) ]{.math} 和 [ \\(B\\) ]{.math} 可利用 [
\\(r_c\\) ]{.math} 处的边界条件求出

[ \\\[\\alg \\begin{split} A &= - {(\\a + 4)r_c - (\\a + 1)r_1 \\over
r_c\^{\\a+2}(r_c - r_1)\^2} \\\\ B &= {(\\a+3)r_c - (\\a+1)r_1 \\over
r_c\^{\\a+2} (r_c-r_1)\^3} \\end{split}\\tag{4.27} \\ealg\\\] ]{.math}

因此, 整个力函数为:

[ \\\[F_s(r) = {\\a \\over r\^{\\a+1}} + A(r-r_1)\^2 + B(r-r_1)\^3
\\tag{4.28}\\\] ]{.math}

相应的势函数为:

[ \\\[\\F(r) = {1 \\over r\^\\a} - {A \\over 3}(r - r_1)\^3 - {B \\over
4}(r - r_1)\^4 - C \\tag{4.29}\\\] ]{.math}

其中

[ \\\[C = {1 \\over r_c\^\\a } - {A \\over 3}(r_c - r_1)\^3 - {B \\over
4}(r_c - r_1)\^4 \\tag{4.30}\\\] ]{.math}

<figure>
<img src="/GMX/4.4.png"
alt="图4.4: 库仑力, 移位力与移位函数 $S(r)$, 其中 $r_1=2, r_c=4$. " />
<figcaption>图4.4: 库仑力, 移位力与移位函数 <span class="math"> \(S(r)\)
</span> , 其中 <span class="math"> \(r_1=2, r_c=4\) </span>
.</figcaption>
</figure>

当 [ \\(r_1\\) ]{.math} =0 时, 修正的库仑力函数

[ \\\[F_s(r) = {1 \\over r\^2} - {5 r\^2 \\over r_c\^4} + {4 r\^3 \\over
r_c\^5} \\tag{4.31}\\\] ]{.math}

与推荐使用的短程函数加上长程部分的泊松解是相同的\[77\].
修正的库仑势函数为:

[ \\\[\\F(r) = {1 \\over r} - {5 \\over 3r_c} + {5r\^3 \\over 3r_c\^4} -
{r\^4 \\over r_c\^5} \\tag{4.32}\\\] ]{.math}

参见图 4.4.

### 4.1.6 修改的Ewald求和短程相互作用 {#416-修改的ewald求和短程相互作用}

当利用Ewald求和方法或粒子网格Ewald方法计算长程相互作用时,
短程库仑势必须进行修改, 这与上面切换函数的情形类似. 在这种情况下,
短程势能由下式给出:

[ \\\[V(r) = f{\\text{erfc}(\\beta r\_{ij}) \\over r\_{ij}} q_i q_j
\\tag{4.33}\\\] ]{.math}

其中, [ \\(\\b\\) ]{.math}
参数用于决定直接空间和与倒易空间和之间的相对比重, [
\\(\\text{erfc}(x)\\) ]{.math} 是余误差函数.
关于长程静电相互作用的详细讨论见4.8节.

<figure>
<img src="/GMX/4.5.png"
alt="图4.5: 键伸缩的原理（左）以及键伸缩的势能（右）. " />
<figcaption>图4.5:
键伸缩的原理（左）以及键伸缩的势能（右）.</figcaption>
</figure>

## 4.2 键合相互作用 {#42-键合相互作用}

键合相互作用基于固定的原子列表. 它们不仅包括对相互作用(pair
interactions), 也包括三体和四体相互作用. 键合相互作用包括 **键伸缩**
(双体), **键角** (三体)和 **二面角** (四体)相互作用.
一种特殊类型的二面角相互作用(称为 **异常二面角**
)可用于将原子保持在同一平面上,
或是避免将分子转变为相反手性（镜像）的结构.

### 4.2.1 键伸缩 {#421-键伸缩}

**简谐势**

两个共价键合原子 [ \\(i\\) ]{.math} 和 [ \\(j\\) ]{.math}
之间的键伸缩可利用简谐势进行描述

[ \\\[V_b(r\_{ij}) = {1 \\over 2}k\_{ij}\^b (r\_{ij} - b\_{ij})\^2
\\tag{4.34}\\\] ]{.math}

参见图4.5, 相应的力如下:

[ \\\[\\bi F_i(\\bi r\_{ij}) = k\_{ij}\^b(r\_{ij} - b\_{ij}) {\\bi
r\_{ij} \\over r\_{ij}} \\tag{4.35}\\\] ]{.math}

**四次幂势**

在GROMOS--96力场\[78\]中, 为提高计算效率, 共价键势记为以下形式:

[ \\\[V_b(r\_{ij}) = {1 \\over 4}k\_{ij}\^b \\left( r\_{ij}\^2 -
b\_{ij}\^2 \\right)\^2 \\tag{4.36}\\\] ]{.math}

相应的力为:

[ \\\[\\bi F_i(\\bi r\_{ij}) = k\_{ij}\^b(r\_{ij}\^2 - b\_{ij}\^2) \\bi
r\_{ij} \\tag{4.37}\\\] ]{.math}

对这种形式的势函数, 其力常数与通常的简谐力常数 [
\\(k\^{b,\\text{harm}}\\) ]{.math} (4.2.1节) 存在如下关系

[ \\\[2k\^b b\_{ij}\^2 = k\^{b,\\text{harm}} \\tag{4.38}\\\] ]{.math}

力常数大多是由GROMOS--87使用的简谐力常数导出\[79\].
尽管计算时这种形式效率更高（因为不需要计算平方根）,
但它在概念上比较复杂. 它还存在一个特别的缺点, 由于不是简谐势形式,
单个键的平均能量不等于 [ \\({1\\over2}kT\\) ]{.math} ,
而在正常的简谐势情况下是 [ \\({1\\over2}kT\\) ]{.math} .

### 4.2.2 Morse势键伸缩 {#422-morse势键伸缩}

对需要非简谐键伸缩势的一些体系, GROMACS提供了两个原子 [ \\(i\\) ]{.math}
和 [ \\(j\\) ]{.math} 之间的Morse势\[80\].
这个势能函数与简谐势的不同在于, 它具有一个不对称的势阱,
且无限远处的力为零. 函数形式是:

[ \\\[V\_{morse}(r\_{ij}) = D\_{ij} \[1 - \\exp(-\\beta\_{ij}
(r\_{ij}-b\_{ij}))\]\^2 \\tag{4.39}\\\] ]{.math}

参见图4.6, 相应的力是:

[ \\\[\\bi F\_{morse}(\\bi r\_{ij}) = 2 D\_{ij} \\beta\_{ij} r\_{ij}
\\exp(-\\beta\_{ij}(r\_{ij}-b\_{ij}))\* \\\\ \[1 - \\exp(-\\beta\_{ij}
(r\_{ij}-b\_{ij}))\] {\\bi r\_{ij} \\over r\_{ij}} \\tag{4.40}\\\]
]{.math}

其中 [ \\(D\_{ij}\\) ]{.math} 是势阱深度, 以 [ \\(\\text{kJ/mol}\\)
]{.math} 为单位, [ \\(\\beta\_{ij}\\) ]{.math} 定义了势阱的陡度（以 [
\\(\\text{nm\^{-1}}\\) ]{.math} 为单位）, [ \\(b\_{ij}\\) ]{.math}
为平衡距离(以 [ \\(\\text{nm}\\) ]{.math} 为单位). 陡度参数 [
\\(\\beta\_{ij}\\) ]{.math} 可用原子 [ \\(i\\) ]{.math} 和 [ \\(j\\)
]{.math} 的约化质量、基本振动频率 [ \\(\\mu\_{ij}\\) ]{.math} 和势阱深度
[ \\(D\_{ij}\\) ]{.math} 表示:

[ \\\[\\beta\_{ij} = \\omega\_{ij} \\sqrt{\\mu\_{ij} \\over 2 D\_{ij} }
\\tag{4.41}\\\] ]{.math}

且因为 [ \\(\\omega = \\sqrt{k \\over \\mu}\\) ]{.math} , 可将 [
\\(\\beta\_{ij}\\) ]{.math} 改用简谐力常数 [ \\(k\_{ij}\\) ]{.math}
表示:

[ \\\[\\beta\_{ij} = \\sqrt{k\_{ij} \\over 2 D\_{ij}} \\tag{4.42}\\\]
]{.math}

对于小的偏差 [ \\((r\_{ij} - b\_{ij})\\) ]{.math} , 可利用泰勒展开,
取指数项的一阶近似:

[ \\\[\\exp(-x) \\approx 1 - x \\tag{4.43}\\\] ]{.math}

将方程 4.42和4.43代入到函数中:

[ \\\[\\alg V\_{morse}(r\_{ij}) &= D\_{ij} \[1 - \\exp(-\\beta\_{ij}
(r\_{ij}-b\_{ij}))\]\^2 \\\\ & = D\_{ij} \[1 - (1 - \\sqrt{k\_{ij}
\\over 2 D\_{ij}} (r\_{ij}-b\_{ij}))\]\^2 \\\\ & = {1 \\over 2} k\_{ij}
(r\_{ij} - b\_{ij})\^2 \\tag{4.44} \\ealg\\\] ]{.math}

就得到了简谐键伸缩势.

<figure>
<img src="/GMX/4.6.png" alt="图4.6: Morse势阱, 键长为0.15nm. " />
<figcaption>图4.6: Morse势阱, 键长为0.15nm.</figcaption>
</figure>

### 4.2.3 立方键伸缩势 {#423-立方键伸缩势}

另一种比Morse势稍简单的非简谐键伸缩势是在简单的简谐形式上增加了距离的一个立方项:

[ \\\[V_b(r\_{ij}) = k\_{ij}\^b (r\_{ij}-b\_{ij})\^2 + k\_{ij}\^b
k\_{ij}\^{cub} (r\_{ij}-b\_{ij})\^3 \\tag{4.45}\\\] ]{.math}

在Ferguson\[82\]发展的一个柔性水模型（基于SPC水模型\[81\]）中,
OH键使用了立方键伸缩势. 该模型给出了合理的红外光谱.
GROMACS库中提供了Ferguson水模型( ` flexwat-ferguson.itp ` ). 应当指出,
这种势函数是不对称的: 过分拉伸导致能量无限降低.
因此积分的时间步长被限制为1 fs.

该势对应的力为:

[ \\\[\\bi F_i(r\_{ij}) = 2k\_{ij}\^b (r\_{ij}-b\_{ij}) {\\bi r\_{ij}
\\over r\_{ij}} + 3k\_{ij}\^b k\_{ij}\^{cub} (r\_{ij}-b\_{ij})\^2 {\\bi
r\_{ij} \\over r\_{ij}} \\tag{4.46}\\\] ]{.math}

### 4.2.4 FENE键伸缩势 {#424-fene键伸缩势}

在聚合物的粗粒化模拟中, 珠子之间通常由FENE(finitely extensible nonlinear
elastic, 有限扩展非线弹性)势\[83\]连接:

[ \\\[V\_{\\text{FENE}}(r\_{ij}) = - {1 \\over 2} k\_{ij}\^b b\_{ij}\^2
\\log\\left( 1 - {r\_{ij}\^2 \\over b\_{ij}\^2} \\right) \\tag{4.47}\\\]
]{.math}

这种势能函数看起来很复杂, 但力的表达式更简单:

[ \\\[\\bi F\_{\\text{FENE}}(r\_{ij}) = - k\_{ij}\^b \\left( 1 -
{r\_{ij}\^2 \\over b\_{ij}\^2} \\right)\^{-1} \\bi r\_{ij}
\\tag{4.48}\\\] ]{.math}

在短距离处此势不对称地接近力常数为 [ \\(k\^b\\) ]{.math} 的简谐势,
而在距离为 [ \\(b\\) ]{.math} 时发散.

<figure>
<img src="/GMX/4.7.png" alt="图4.7: 角振动原理（左）和键角势（右）. " />
<figcaption>图4.7: 角振动原理（左）和键角势（右）.</figcaption>
</figure>

### 4.2.5 简谐角势 {#425-简谐角势}

三个原子 [ \\(i-j-k\\) ]{.math} 之间的键角振动也可以用键角 [
\\(\\theta\_{ijk}\\) ]{.math} 的简谐势描述

[ \\\[V_a (\\theta\_{ijk}) = {1 \\over 2} k\_{ijk}\^\\theta
(\\theta\_{ijk} - \\theta\_{ijk}\^0)\^2 \\tag{4.49}\\\] ]{.math}

由于键角的振动由简谐势描述, 其形式与键伸缩是一样的（图4.5）.

利用链式规则, 可得到力的方程:

[ \\\[\\alg \\bi F_i &= - {d V_a(\\theta\_{ijk}) \\over d \\bi r_i} \\\\
\\bi F_k &= - {d V_a(\\theta\_{ijk}) \\over d \\bi r_k} \\quad 其中
\\theta\_{ijk} = \\arccos{ (\\bi r\_{ij} \\cdot \\bi r\_{kj}) \\over
r\_{ij} r\_{kj} } \\tag{4.50} \\\\ \\bi F_j &= - \\bi F_i - \\bi F_k
\\ealg\\\] ]{.math}

编号 [ \\(i, j, k\\) ]{.math} 是共价键原子的序列. 原子 [ \\(j\\)
]{.math} 处于中间；原子 [ \\(i\\) ]{.math} 和 [ \\(k\\) ]{.math}
处于顶端（见图4.7）. 注意, 在拓扑文件的输入中, 键角以度为单位, 力常数以
[ \\(\\text{kJ/mol/{rad}\^2}\\) ]{.math} 为单位.

### 4.2.6 余弦键角势 {#426-余弦键角势}

GROMOS--96力场利用一个简化的函数表示角振动:

[ \\\[V_a(\\theta\_{ijk}) = {1 \\over 2} k\_{ijk}\^\\theta \\left(
\\cos(\\theta\_{ijk}) - \\cos(\\theta\_{ijk}\^0) \\right)\^2
\\tag{4.51}\\\] ]{.math}

其中

[ \\\[\\cos(\\theta\_{ijk}) = {\\bi r\_{ij} \\cdot \\bi r\_{kj} \\over
r\_{ij} r\_{kj} } \\tag{4.52}\\\] ]{.math}

相应的力可通过对原子位置的偏微分推导出来.
这个函数中的力常数与简谐势的力常数 [ \\(k\^{\\theta,\\text{harm}}\\)
]{.math} (4.2.5) 存在如下关系

[ \\\[k\^\\theta \\sin\^2(\\theta\_{ijk}\^0) = k\^{\\theta,\\text{harm}}
\\tag{4.53}\\\] ]{.math}

<figure>
<img src="/GMX/4.8.png"
alt="图4.8: 弯曲键角势: 余弦简谐（黑实线）, 简谐角（虚黑线）和限制弯曲（红色）, 三者具有相同的弯曲常数 $k_{\theta} = 85 \text{kJ mol}^{-1}$ 和平衡角 $\theta_0 = 130^{\circ}$. 橙色线表示余弦简谐($k = 50 \text{kJ mol}^{-1}$)与限制弯曲($k = 25 \text{kJ mol}^{-1}$)的和, 二者的 $\theta_0 = 130^{\circ}$. " />
<figcaption>图4.8: 弯曲键角势: 余弦简谐（黑实线）,
简谐角（虚黑线）和限制弯曲（红色）, 三者具有相同的弯曲常数 <span
class="math"> \(k_{\theta} = 85 \text{kJ mol}^{-1}\) </span> 和平衡角
<span class="math"> \(\theta_0 = 130^{\circ}\) </span> .
橙色线表示余弦简谐( <span class="math"> \(k = 50 \text{kJ mol}^{-1}\)
</span> )与限制弯曲( <span class="math"> \(k = 25 \text{kJ mol}^{-1}\)
</span> )的和, 二者的 <span class="math"> \(\theta_0 = 130^{\circ}\)
</span> .</figcaption>
</figure>

在GROMOS--96手册中有一个更加复杂的, 与温度相关的转换公式. 这些公式在0
K时是等效的, 300 K时的差异大约为0.1%到0.2%. **注意** 在拓扑文件的输入中,
角度的单位为度, 力常数的单位为kJ/mol.

### 4.2.7 受限弯曲势 {#427-受限弯曲势}

受限弯曲（ReB）势\[84\]可防止弯曲角度 [ \\(\\theta\\) ]{.math} 达到 [
\\(180\^{\\circ}\\) ]{.math} . 这样, 在进行粗粒分子动力学模拟时,
避免了计算扭转角和势能带来的数值不稳定性.

为了系统地防止弯曲角度达到 [ \\(180\^{\\circ}\\) ]{.math} ,
在弯曲势4.51的分母项中引入了 [ \\(\\sin\^2\\theta\\) ]{.math} 因子

[ \\\[V\_{\\text{ReB}}(\\theta_i)={1 \\over 2} k\_\\theta
{(\\cos\\theta_i-\\cos\\theta_0)\^2 \\over \\sin\^2\\theta_i}
\\tag{4.54}\\\] ]{.math}

图4.8显示了ReB势4.54和标准势4.51之间的比较. ReB势的壁垒在靠近 [
\\(180\^{\\circ}\\) ]{.math} 的区域非常排斥, 因此,
弯曲角能够保持在一定的安全区间内, 远离不稳定性. 之所以在分母中使用 [
\\(\\sin\\theta\\) ]{.math} 的二次方项是为了保证这种行为,
并且能给出优雅的微分表达式:

[ \\\[F\_{\\text{ReB}}(\\theta_i) = {2 k\_\\theta \\over
\\sin\^4\\theta_i}(\\cos\\theta_i-\\cos\\theta_0)(1-\\cos\\theta_i
\\cos\\theta_0){\\partial \\cos\\theta_i \\over \\partial \\vec r_k}
\\tag{4.55}\\\] ]{.math}

因其构造, 限制弯曲势不能用于平衡的 [ \\(\\theta_0\\) ]{.math} 值太接近 [
\\(0\^{\\circ}\\) ]{.math} 或 [ \\(180\^{\\circ}\\) ]{.math}
的情形（根据经验, 推荐至少有 [ \\(10\^{\\circ}\\) ]{.math} 的差异）.
重要的是, 在初始构型中, 所有的弯曲角度都必须处在安全的区间内,
以避免初始的不稳定性. 这种弯曲势可以与任何形式的扭转势联合使用.
使用它将总是能够避免三个连续的粒子变成共线结构, 因此,
任何扭转势都不会出现奇点. 也可以将它加入到标准的弯曲势中, 以处理约 [
\\(180\^{\\circ}\\) ]{.math} 的角,
但在极小点附近保持它的原始形式（参见图4.8中的橙色曲线）.

### 4.2.8 Urey-Bradley势 {#428-urey-bradley势}

三个原子 [ \\(i - j - k\\) ]{.math} 之间的Urey-Bradley键角振动用角 [
\\(\\theta\_{ijk}\\) ]{.math} 的简谐势和原子 [ \\(i\\) ]{.math} 和 [
\\(k\\) ]{.math} 之间的距离的简谐校正项来描述.
尽管可以很容易地将它写成两项的简单加和,
但方便的做法是把它作为拓扑文件中的单独一项,
并在在输出文件中作为单独的能量项. 这种势能主要用在CHARMM力场\[85\]中.
其能量由下式给出:

[
\\\[V_a(\\theta\_{ijk})={1\\over2}k\_{ijk}\^\\theta(\\theta\_{ijk}-\\theta\_{ijk}\^0)\^2 +
{1\\over2}k\_{ijk}\^{UB}(r\_{ik}-r\_{ik}\^0)\^2 \\tag{4.56}\\\] ]{.math}

力的方程可从4.2.1和4.2.5节推导出来.

### 4.2.9 键键交叉项 {#429-键键交叉项}

形成键 [ \\(i - j\\) ]{.math} 和 [ \\(k - j\\) ]{.math} 的三个粒子 [
\\(i,j,k\\) ]{.math} 之间的键键交叉项由下式给出\[86\]:

[ \\\[V\_{rr\'}=k\_{rr\'}(\\abs{\\bi r_i-\\bi r_j}-r\_{1e})(\\abs{\\bi
r_k-\\bi r_j}-r\_{2e}) \\tag{4.57}\\\] ]{.math}

其中 [ \\(k\_{rr\'}\\) ]{.math} 是力常数, [ \\(r\_{1e}\\) ]{.math} 和 [
\\(r\_{2e}\\) ]{.math} 分别是键 [ \\(i - j\\) ]{.math} 和 [ \\(j - k\\)
]{.math} 的平衡键长. 此势对应的粒子 [ \\(i\\) ]{.math} 受到的力是:

[ \\\[\\bi F_i=-k\_{rr\'}(\\abs{\\bi r_k-\\bi r_j}-r\_{2e}){\\bi
r_i-\\bi r_j \\over \\abs{\\bi r_i-\\bi r_j}} \\tag{4.58}\\\] ]{.math}

原子 [ \\(k\\) ]{.math} 受到的力可以通过交换上述方程中 [ \\(i\\)
]{.math} 和 [ \\(k\\) ]{.math} 得到. 最后, 原子 [ \\(j\\) ]{.math}
受到的力遵循内力之和应该为零的事实: [ \\(\\bi F_j = - \\bi F_i - \\bi
F_k\\) ]{.math} .

### 4.2.10 键-角交叉项 {#4210-键-角交叉项}

为形成键 [ \\(i - j\\) ]{.math} 和 [ \\(k - j\\) ]{.math} 的三个粒子 [
\\(i,j,k\\) ]{.math} 之间的键-角交叉项由下式给出\[86\]:

[ \\\[V\_{k\\theta}=k\_{r\\theta}(\\abs{\\bi r_i-\\bi
r_k}-r\_{3e})(\\abs{\\bi r_i-\\bi r_j}-r\_{1e}+\\abs{\\bi r_k-\\bi
r_j}-r\_{2e}) \\tag{4.59}\\\] ]{.math}

其中 [ \\(k\_{r\\theta}\\) ]{.math} 为力常数, [ \\(r\_{3e}\\) ]{.math}
为 [ \\(i - k\\) ]{.math} 之间的距离, 其他常数的含义与方程4.57中相同.
原子 [ \\(i\\) ]{.math} 受到的力为:

[ \\\[\\bi F_i = -k\_{r\\theta}\\left\[ (\\abs{\\bi r_i-\\bi
r_k}-r\_{3e}){\\bi r_i-\\bi r_j \\over \\abs{\\bi r_i-\\bi
r_j}}+(\\abs{\\bi r_i-\\bi r_j}-r\_{1e}+\\abs{\\bi r_k-\\bi
r_j}-r\_{2e}) {\\bi r_i-\\bi r_k \\over \\abs{\\bi r_i-\\bi r_k}}
\\right\] \\tag{4.60}\\\] ]{.math}

### 4.2.11 四次键角势 {#4211-四次键角势}

键角势可以使用四阶多项式以满足特殊目的

[ \\\[V_q(\\theta\_{ijk})=\\sum\_{n=0}\^5
C_n(\\theta\_{ijk}-\\theta\_{ijk}\^0)\^n \\tag{4.61}\\\] ]{.math}

<figure>
<img src="/GMX/4.9.png"
alt="图4.9: 异常二面角原理. 环的面外弯曲（左）, 环的取代（中）, 四面体偏离（右）. 在所有情况下, 异常二面角 $\x$ 被定义为平面 $(i,j,k)$ 和 $(j,k,l)$ 之间的夹角. " />
<figcaption>图4.9: 异常二面角原理. 环的面外弯曲（左）, 环的取代（中）,
四面体偏离（右）. 在所有情况下, 异常二面角 <span class="math"> \(\x\)
</span> 被定义为平面 <span class="math"> \((i,j,k)\) </span> 和 <span
class="math"> \((j,k,l)\) </span> 之间的夹角.</figcaption>
</figure>

### 4.2.12 异常二面角 {#4212-异常二面角}

异常二面角是为了保持平面基团（例如芳环）处于平面内,
或者为了防止分子翻转成其镜像分子, 见图4.9.

**异常二面角: 简谐型**

最简单的异常二面角势是简谐势, 曲线如图4.10.

[ \\\[V\_{id}(\\x\_{ijkl}) = {1\\over2}k\_\\x(\\x\_{ijkl}-\\x_0)\^2
\\tag{4.62}\\\] ]{.math}

简谐势函数不连续, 但由于不连续点选择在距离 [ \\(\\x_0\\) ]{.math} 为 [
\\(180\^{\\circ}\\) ]{.math} 的位置, 这种不连续性永远不会引出麻烦.
**注意** , 在拓扑输入文件中, 角度的单位为度, 而力常数的单位为 [
\\(\\text{kJ/mol/rad}\^2\\) ]{.math} .

**异常二面角: 周期型**

这种势函数等同于周期性的正常二面角（见下文）.
将此种二面角类型（类型4）单独分类只是为了在参数部分和输出中将异常二面角和正常二面角区分开来.

![图4.10: 异常二面角的势能](/GMX/4.10.png)

### 4.2.13 正常二面角 {#4213-正常二面角}

对于正常的二面角相互作用, 可以选择GROMOS的周期性函数或基于 [
\\(\\cos\\phi\\) ]{.math}
的幂的多项式展开函数（被称为Ryckaert-Bellemans势）.
这种选择使得二面角四个原子中的第一和第四个原子之间的特殊相互作用也被包含在内.

对周期性的GROMOS势, 必须包含特殊的1--4 LJ-相互作用；对 **烷烃**
的Ryckaert-Bellemans势, 1--4相互作用必须从非键列表中排除. **注意** :
Ryckaert-Bellemans势也可在OPLS等力场中与1--4相互作用联合使用. 因此,
在这种情况下你不应该修改 ` pdb2gmx ` 生成的拓扑文件.

**正常二面角: 周期型**

正常二面角的定义遵从IUPAC/IUB约定, 其中, [ \\(\\f\\) ]{.math} 是面 [
\\(ijk\\) ]{.math} 和面 [ \\(jkl\\) ]{.math} 之间的夹角, **零** 相应于
**顺式(cis)** 构型( [ \\(i\\) ]{.math} 和 [ \\(l\\) ]{.math}
处于面的同一侧). GROMACS拓扑文件中有两类二面角函数类型.
标准类型1的行为和其他的键相互作用类似. 对某些力场, 类型9很有用. 当在
` [dihedraltypes] ` 部分对同一原子类型定义了多个参数时,
类型9可使多个势能函数自动用于在 ` [dihedral] ` 部分的一个单一的二面角上.

这种类型的势函数为

[ \\\[V_d(\\phi\_{ijkl})=k\_\\phi(1+\\cos(n\\phi-\\phi_s))
\\tag{4.63}\\\] ]{.math}

**正常二面角: Ryckaert-Bellemans势函数**

对烷烃, 经常使用以下的正常二面角势（见图4.12）:

[ \\\[V\_{rb}(\\phi\_{ijkl})=\\sum\_{n=0}\^5 C_n(\\cos(\\psi))\^n
\\tag{4.64}\\\] ]{.math}

其中, [ \\(\\psi = \\phi - 180\^{\\circ}\\) ]{.math} .

**注意** : 从一个约定到另一个约定的转换可以通过将每个系数 [ \\(C_n\\)
]{.math} 乘上 [ \\({-1}\^n\\) ]{.math} .

常数C的一个示例在表4.1中给出.

![图4.11: 正常二面角的原理（左,
反式trans构型）和二面角势（右）](/GMX/4.11.png)

  ---------- ----------- ----------
   C0 9.28    C2 -13.12   C4 26.24
   C1 12.16   C3 -3.06    C5 -31.5
  ---------- ----------- ----------

  : 表4.1: Ryckaert-Bellemans势的常数值(\\(\\text{kJ mol}\^{-1}\\))

![图4.12: Ryckaert-Bellemans二面角势](/GMX/4.12.png)

( **注意** :
使用这种势函数意味着排除了组成二面角的第一个和最后一个原子之间的LJ相互作用,
并且 [ \\(\\psi\\) ]{.math} 的定义遵从"聚合物约定"( [ \\(\\psi\_{trans}
= 0\\) ]{.math} ).

RB二面角函数也可用于包含傅立叶二面角（见下文）:

[
\\\[V\_{rb}(\\phi\_{ijkl})={1\\over2}\[F_1(1+\\cos(\\phi))+F_2(1-\\cos(2\\phi))+F_3(1+\\cos(3\\phi))+F_4(1-\\cos(4\\phi))
\] \\tag{4.65}\\\] ]{.math}

由于存在等式 [ \\(\\cos(2\\phi)=2\\cos\^2(\\phi)-1,
\\cos(3\\phi)=4\\cos\^3(\\phi)-3\\cos(\\phi)\\) ]{.math} 和 [
\\(\\cos(4\\phi)=8\\cos\^4(\\phi)-8\\cos\^2(\\phi)+1\\) ]{.math} ,
可以利用下面的方程将OPLS参数变换为Ryckaert-Bellemans参数

[ \\\[\\begin{split} C_0 &= F_2 +{1\\over2}(F_1+F_3) \\\\ C_1 &=
{1\\over2}(-F_1+3F_3) \\\\ C_2 &= -F_2+4F_4 \\\\ C_3 &= -2F_3 \\\\ C_4
&= -4F_4 \\\\ C_5 &= 0 \\end{split} \\tag{4.66}\\\] ]{.math}

OPLS参数遵从蛋白质约定, 而RB参数遵从聚合物约定（这导致 [
\\(\\cos(\\phi)\\) ]{.math} 奇数次项前面的负号）.

**注意** : 记得将文献中OPLS和RB参数的单位 **[ \\(\\text{kcal
mol}\^{-1}\\) ]{.math}** 转化为GROMACS中的单位 **[ \\(\\text{kcal
mol}\^{-1}\\) ]{.math}** .

**正常二面角: 傅立叶函数**

OPLS势能函数为傅立叶级数的前三或四次余弦项\[87\]. GROMACS中, 四项函数为:

[ \\\[V_F(\\phi\_{ijkl})={1\\over2}\[C_1(1+\\cos(\\phi)) +
C_2(1-\\cos(2\\phi)) + C_3(1+\\cos(3\\phi)) + C_4(1+\\cos(4\\phi))\]
\\tag{4.67}\\\] ]{.math}

GROMACS在内部使用Ryckaert-Bellemans代码来计算傅立叶二面角（见上文）,
因为计算效率更高.

**注意** : 记得将文献中OPLS参数的单位 **[ \\(\\text{kcal mol}\^{-1}\\)
]{.math}** 转化为GROMACS中的单位 **[ \\(\\text{kcal mol}\^{-1}\\)
]{.math}** .

**正常二面角: 限制扭转势**

非常类似于限制弯曲势（见4.2.7）, 限制扭转/二面角势的函数为:

[ \\\[V\_{\\text{ReT}}(\\phi_i)={1\\over2}k\_\\phi
{(\\cos\\phi_i-\\cos\\phi_0)\^2 \\over \\sin\^2\\phi_i} \\tag{4.68}\\\]
]{.math}

这类函数具有 [ \\(\\cos\\phi\\) ]{.math} 函数的优点（对 [
\\(\\sin\\phi\\) ]{.math} 求导时不存在问题）,
并且能保持扭转角处于仅有的一个最小值. 在这种情况下, 因子 [
\\(\\sin\^2\\phi\\) ]{.math} 不会让二面角从\[ [ \\(-180\^{\\circ}:0\\)
]{.math} \]区间移到\[ [ \\(0:180\^{\\circ}\\) ]{.math} \]区间内, 即,
函数不能同时在 [ \\(-\\phi_0\\) ]{.math} 和 [ \\(+\\phi_0\\) ]{.math}
处取极大值, 而只能在其中之一取极大值. 由于这个原因,
初始构型中所有的二面角的角度值都必须处于所需的角度区间内, 并且平衡的 [
\\(\\phi_0\\) ]{.math}
值不应太靠近区间的端点（与4.2.7中所讲的限制弯曲势类似, 推荐至少 [
\\(10\^{\\circ}\\) ]{.math} 的差异）.

**正常二面角: 组合弯曲-扭转势**

当形成二面角的四个粒子共线时（这种情况永远不会发生在原子尺度的模拟中,
但可能出现在粗粒模拟中）, 扭转角及其势函数的计算会引起数值不稳定性.
避免这一问题的一种方法是使用限制弯曲势（见4.2.7）, 以防止二面角达到 [
\\(180\^{\\circ}\\) ]{.math} .

另一种方式是忽略二面角不合理定义时的任何效应,
通过将扭转势（余弦形式）与相邻弯曲角的弯曲势耦合为一个特殊形式,
保持二面角的力和势函数的计算在整个角度范围内连续:

[ \\\[V\_{\\text{CBT}}(\\theta\_{i-1},\\theta_i,\\phi_i)=k\_\\phi
\\sin\^3\\theta\_{i-1} \\sin\^3\\theta_i \\sum\_{n=0}\^4 a_n \\cos\^n
\\phi_i \\tag{4.69}\\\] ]{.math}

这种组合的弯曲扭转（combined bending-torsion,
CBT）势函数由文献\[88\]提出, 用于聚合物熔融的模拟.
文献\[84\]对此有详细的描述.

这种势函数有两个主要的优点:

-   它不仅取决于(第 [ \\(i-2, i-1, i\\) ]{.math} 和 [ \\(i+1\\) ]{.math}
    号珠子之间的)二面角 [ \\(\\phi_i\\) ]{.math} ,
    而且也取决于由三个相邻的珠子(分别是 [ \\(i-2, i-1, i\\) ]{.math} 和
    [ \\(i-1, i, i+1\\) ]{.math} )形成的弯曲角 [ \\(\\theta\_{i-1}\\)
    ]{.math} 和 [ \\(\\theta_i\\) ]{.math} .
    当两个弯曲角中的任意一个接近 [ \\(180\^{\\circ}\\) ]{.math} 时,
    由文献\[89\]尝试性地提出, 并由文献\[90\]从理论上进行了讨论的两个 [
    \\(\\sin\^3\\theta\\) ]{.math} 前因子抵消了扭转势和力.

-   通过表达为 [ \\(\\cos\\phi_i\\) ]{.math} 的多项式形式, 它也取决于 [
    \\(\\phi_i\\) ]{.math} , 这避免了 [ \\(\\phi = 0\^{\\circ}\\)
    ]{.math} 或 [ \\(\\phi = 180\^{\\circ}\\) ]{.math}
    时计算扭转力的奇异性.

这两种特性使得CBT势用于弯曲角存在弱约束的MD模拟时表现良好,
甚至对于弯曲角和扭转角变化剧烈的拉伸/非平衡MD模拟也是如此.
当使用CBT势时, 相邻的 [ \\(\\theta\_{i-1}\\) ]{.math} 和 [
\\(\\theta_i\\) ]{.math} 的弯曲势可以取任意形式,
也可完全省略这两个角弯曲项( [ \\(\\theta\_{i-1}\\) ]{.math} 和 [
\\(\\theta_i\\) ]{.math} ). 图4.13显示了包含和不含 [
\\(\\sin\^3\\theta\\) ]{.math}
因子（分别为蓝色和灰色的曲线）的扭转势之间的区别. 此外, [
\\(V\_{\\text{CBT}}\\) ]{.math} 对笛卡尔变量的导数直接易懂:

[ \\\[\\opar{V\_{\\text{CBT}}(\\theta\_{i-1},\\theta_i\\phi_i)}{\\vec
r_l} =
\\opar{V\_{\\text{CBT}}}{\\theta\_{i-1}}\\opar{\\theta\_{i-1}}{\\vec
r_l} + \\opar{V\_{\\text{CBT}}}{\\theta_i}\\opar{\\theta_i}{\\vec r_l} +
\\opar{V\_{\\text{CBT}}}{\\phi_i}\\opar{\\phi_i}{\\vec r_l}
\\tag{4.70}\\\] ]{.math}

CBT基于无多重性的余弦形式, 因此它只在 [ \\(0\^{\\circ}\\) ]{.math}
左右对称. 为获得一个不对称的二面角分布（如在\[ [
\\(-180\^{\\circ}:180\^{\\circ}\\) ]{.math} \]区间内只有一个最大值）,
应该使用标准的扭转势, 如简谐角势或周期性的余弦势来代替CBT势. 然而,
这两种形式对于力的微分（ [ \\(1/\\sin\\phi\\) ]{.math}
）和珠子的直线排列（ [ \\(\\theta_i\\) ]{.math} 或 [ \\(\\theta\_{i-1} =
0\^{\\circ}, 180\^{\\circ}\\) ]{.math} ）都不方便. 非 [ \\(\\cos\\phi\\)
]{.math} 势与 [ \\(\\sin\^3\\theta\\) ]{.math}
因子的耦合并不能提高模拟的稳定性, 因为在某些情况下 [ \\(\\theta\\)
]{.math} 和 [ \\(\\phi\\) ]{.math} 同时为 [ \\(180\^{\\circ}\\) ]{.math}
. 在此步的积分是可能的（由于扭转势的抵消）, 但下一步积分将是病态的（ [
\\(\\theta\\) ]{.math} 不是 [ \\(180\^{\\circ}\\) ]{.math} 而 [
\\(\\phi\\) ]{.math} 非常接近 [ \\(180\^{\\circ}\\) ]{.math} ）.

<figure>
<img src="/GMX/4.13.png"
alt="图4.13: 蓝色: 组合弯曲扭转势的表面图(方程4.69, 其中 $k=10 \text{kJ mol}^{-1},a_0 = 2.41, a_1 = -2.95, a_2 = 0.36, a_3 = 1.33$), 为简单起见, 弯曲角相同($\theta_1=\theta_2=\theta$). 灰色: 同样的扭转势函数但不含 $\sin^3\theta$ 项（Ryckaert-Bellemans型）. $\phi$ 为二面角. " />
<figcaption>图4.13: 蓝色: 组合弯曲扭转势的表面图(方程4.69, 其中 <span
class="math"> \(k=10 \text{kJ mol}^{-1},a_0 = 2.41, a_1 = -2.95, a_2 =
0.36, a_3 = 1.33\) </span> ), 为简单起见, 弯曲角相同( <span
class="math"> \(\theta_1=\theta_2=\theta\) </span> ). 灰色:
同样的扭转势函数但不含 <span class="math"> \(\sin^3\theta\) </span>
项（Ryckaert-Bellemans型）. <span class="math"> \(\phi\) </span>
为二面角.</figcaption>
</figure>

### 4.2.14 表格式键合相互作用 {#4214-表格式键合相互作用}

为了有充分的灵活性, 可通过用户提供的表格函数形式, 对键,
键角和二面角使用任何函数. 它们包括:

[ \\\[\\alg V_b(r\_{ij}) & =kf_n\^b(r\_{ij}) \\tag{4.71} \\\\
V_a(\\theta\_{ijk}) &= k f_n\^a(\\theta\_{ijk}) \\tag{4.72} \\\\
V_d(\\phi\_{ijkl}) &= k f_n\^d(\\phi\_{ijkl}) \\tag{4.73} \\ealg\\\]
]{.math}

其中, [ \\(k\\) ]{.math} 是以能量为单位的力常数, [ \\(f\\) ]{.math}
是三次样条函数；详细信息见6.10.1. 对每种相互作用, 在拓扑信息中指定力常数
[ \\(k\\) ]{.math} 和表格编号 [ \\(n\\) ]{.math} . 有两种不同类型的键,
一种产生排除（类型8）, 一种不产生排除（类型9）. 详情见表5.5.
表格文件会被提供给 ` mdrun ` 程序. 表格文件名和下划线后,
加入字母"b"表示键, "a"表示角或"d"表示二面角和表格编号. 例如, 对一个 [
\\(n = 0\\) ]{.math} 的键（并使用默认的表格文件名）, 将从文件
` table_b0.xvg ` 中读取表格. 如拓扑信息（表5.5）中具体介绍的那样,
可简单地通过使用不同的 [ \\(n\\) ]{.math} 值提供多个表格,
并应用到恰当的键. 表格文件的格式是分别为 [ \\(x, f(x), -f\'(x)\\)
]{.math} 的三列, 其中 [ \\(x\\) ]{.math} 必须是等间隔的.
拓扑信息的输入要求列于表5.5. 这些表格的设置如下:

**键** : [ \\(x\\) ]{.math} 是以纳米(nm)为单位的距离.
若模拟时距离超出表格长度, ` mdrun ` 将显示错误消息并退出.

**角度** : [ \\(x\\) ]{.math} 是以度为单位的角度.
表格应从0开始直到并包括180度；导数以度为单位.

**二面角** : [ \\(x\\) ]{.math} 是以度为单位的二面角.
表格应从--180直到并包括180度, 使用IUPAC/IUB约定, 即零为顺式,
导数以度为单位.

## 4.3 限制 {#43-限制}

可以使用一些特殊的势能函数对体系的运动施加限制,
这样可以避免模拟中出现灾难性的偏差, 或是可以包含来自实验数据的知识.
无论哪种情况, 限制都不是力场的一部分, 并且所用参数的合理性也不重要.
提到GROMACS中实现的势能形式只是为了保持完整性.
在GROMACS中限制和约束所用的算法差异很大.

### 4.3.1 位置限制 {#431-位置限制}

位置限制用于将粒子限制在固定的参考位置 [ \\(\\bi R_i\\) ]{.math} .
在平衡过程中可利用它们来避免体系关键部分的位置产生剧烈的变化(例如,
当溶剂还未达到平衡时, 蛋白质会受到来自溶剂分子的很大的力,
这时就可以限制蛋白质中的一些运行).
位置限制的另一个应用是将粒子限制在围绕某个区域的壳层中,
以便对此区域进行细致的模拟. 壳层只是近似的,
因为它们缺少由壳层外面缺失粒子引起的适当的相互作用.
位置限制只是为了维持体系内部的完整性. 对球形壳层,
更好的做法是让力常数随半径变化, 由内部边界从零开始增加,
一直达到外部边界上的很大值. 但这一功能尚未在GROMACS中实现.

位置限制使用下面的势能形式

[ \\\[V\_{pr}(\\bi r_i)={1\\over2} k\_{pr} \\left\| \\bi r_i-\\bi R_i
\\right\|\^2 \\tag{4.74}\\\] ]{.math}

此势能的图形见图4.14.

不失一般性, 可将势能改写为:

[ \\\[V\_{pr}(\\bi r_i)={1\\over2}\\left\[ k\_{pr}\^x(x_i-X_i)\^2 \\hat
x + k\_{pr}\^y (y_i-Y_i)\^2 \\hat y +k\_{pr}\^z (z_i-Z_i)\^2 \\hat z
\\right\] \\tag{4.75}\\\] ]{.math}

相应的力为

[ \\\[\\alg F_i\^x &=-k\_{pr}\^x (x_i-X_i) \\\\ F_i\^y &=-k\_{pr}\^y
(y_i-Y_i) \\\\ F_i\^z &=-k\_{pr}\^z (z_i-Z_i) \\\\ \\ealg\\tag{4.76}\\\]
]{.math}

使用三个不同的力常数就可以在每个空间方向上打开或关闭位置限制,
这意味着原子可以简谐地限制于平面或直线上.
位置限制施加于指定的固定原子列表上, 这一列表通常使用 ` pdb2gmx `
程序产生.

![图4.14: 位置限制势](/GMX/4.14.png)

![图4.15: 平底位置限制势. (A) 未反转, (B) 反转](/GMX/4.15.png)

### 4.3.2 平底位置限制势 {#432-平底位置限制势}

平底位置限制可用于将粒子限制在模拟体积的某一部分中.
在势能的平底区域中限制粒子不受力的作用,
但当粒子处于平底区域之外时会受到一个简谐力,
这个力会驱使粒子向平底区域运动.
对同一粒子可以同时施加常规的位置限制和平底的位置限制(但只用于相同的参考位置
[ \\(\\bi R_i\\) ]{.math} ). 平底位置限制使用下面的通用势能函数(图4.15
A):

[ \\\[V\_\\text{fb}(\\bi r_i)={1\\over2}k\_\\text{fb}\[ d_g(\\bi r_i;
\\bi R_i)-r\_\\text{fb}\]\^2 H\[d_g(\\bi r_i; \\bi R_i)-r\_\\text{fb}\]
\\tag{4.77}\\\] ]{.math}

其中 [ \\(\\bi R_i\\) ]{.math} 为参考位置, [ \\(r\_\\text{fb}\\)
]{.math} 为平势离中心的距离, [ \\(k\_\\text{fb}\\) ]{.math} 为力常数, [
\\(H\\) ]{.math} 为Heaviside阶梯函数. 到参考位置的距离 [ \\(d_g(\\bi
r_i; \\bi R_i)\\) ]{.math} 取决于平底势的几何构造 [ \\(g\\) ]{.math} .

对平底势, GROMACS支持下面几种几何构造:

**球** ( [ \\(g=1\\) ]{.math} ): 粒子被限制于给定半径的球中.
所受平底势的力指向球的中心, 距离的计算方法如下:

[ \\\[d_g(\\bi r_i; \\bi R_i)=\\left\| \\bi r_i- \\bi R_i \\right\|
\\tag{4.78}\\\] ]{.math}

**圆柱** ( [ \\(g=2\\) ]{.math} ): 粒子被限制于给定半径的圆柱中.
圆柱的轴平行于 [ \\(z\\) ]{.math} 轴, 所受平底势的力指向圆柱的轴, 力的 [
\\(z\\) ]{.math} 分量为零. 距离的计算方法如下:

[ \\\[d_g(\\bi r_i; \\bi R_i)=\\sqrt{(x_i-X_i)\^2+(y_i-Y_i)\^2}
\\tag{4.79}\\\] ]{.math}

**层** ( [ \\(g=3, 4,5\\) ]{.math} ): 粒子限制于层中.
层由其厚度与法线定义, 法线可平行于 [ \\(x\\) ]{.math} , [ \\(y\\)
]{.math} 或 [ \\(z\\) ]{.math} 轴, 作用力平行于层的法线.
距离的计算方法如下:

\$\$ d_g(\\bi r_i; \\bi R_i)=\\left\| x_i-X_i \\right\| \\;\\; 或
d_g(\\bi r_i; \\bi R_i)=\\left\| y_i-Y_i \\right\| \\;\\; d_g(\\bi r_i;
\\bi R_i)=\\left\| z_i-Z_i \\right\| \\tag{4.80}\$\$

对同一粒子可施加多个独立的, 具有不同几何构造的平底位置限制. 例如, 沿 [
\\(z\\) ]{.math} 方向同时施加圆柱和层限制可使粒子限制于一个圆盘中; 在 [
\\(x\\) ]{.math} , [ \\(y\\) ]{.math} , [ \\(z\\) ]{.math}
方向施加三个层限制可使粒子限制于立方体中.

此外, 可以反转限制区域和未限制区域, 这样得到的势能会使粒子处于 [ \\(\\bi
R_i\\) ]{.math} , [ \\(g\\) ]{.math} 和 [ \\(r\_\\text{fb}\\) ]{.math}
定义的体积之 **外** . 在拓扑中定义负值的 [ \\(r\_\\text{fb}\\) ]{.math}
可启用此功能, 使用下面的势能:

[ \\\[V\_\\text{fb}\^\\text{inv}={1\\over2}k\_\\text{fb}\[ d_g(\\bi r_i;
\\bi R_i)-\\left\|r\_\\text{fb}\\right\|\]\^2 H\[-(d_g(\\bi r_i; \\bi
R_i)-\\left\|r\_\\text{fb} \\right\|)\] \\tag{4.81}\\\] ]{.math}

### 4.3.3 角限制 {#433-角限制}

角限制用于限制两对粒子间或一对粒子与 [ \\(z\\) ]{.math} 轴之间的角度.
所用的函数形式类似于恰当二面角, 对两对原子之间的角:

[ \\\[V\_{ar}(\\bi r_i, \\bi r_j, \\bi r_k, \\bi
r_l)=k\_{ar}(1-\\cos(n(\\q-\\q_0))), \\;\\; \\q=\\arccos\\left( {\\bi
r_j-\\bi r_i \\over \\\| \\bi r_j-\\bi r_i \\\|} \\cdot {\\bi r_l-\\bi
r_k \\over \\\|\\bi r_l-\\bi r_k \\\|} \\right) \\tag{4.82}\\\] ]{.math}

对一对原子与 [ \\(z\\) ]{.math} 轴之间的角:

[ \\\[V\_{ar}(\\bi r_i, \\bi r_j)=k\_{ar}(1-\\cos(n(\\q-\\q_0))), \\;\\;
\\q =\\arccos\\left( {\\bi r_j-\\bi r_i \\over \\\| \\bi r_j-\\bi r_i
\\\|} \\cdot \\pmat 0 \\\\ 0 \\\\ 1 \\epmat \\right) \\tag{4.83}\\\]
]{.math}

当不需要区分平行与反平行向量时, 多重性 [ \\(n\\) ]{.math} 可设为2.
当多重性为1时, 平衡角度 [ \\(\\q\\) ]{.math} 应处于0度和180度之间;
当多重性为2时, [ \\(\\q\\) ]{.math} 应处于0度和90度之间.

### 4.3.4 二面角限制 {#434-二面角限制}

二面角限制用于限制由四个粒子定义的二面角, 如不当二面角(4.2.12节),
但使用了稍加修改的势能:

[ \\\[\\phi\'=(\\phi-\\phi_0)\\; \\text{MOD} \\; 2\\pi \\tag{4.84}\\\]
]{.math}

其中 [ \\(\\f_0\\) ]{.math} 为参考角度, 势能的定义为:

[ \\\[V\_{dihr}(\\f\')=\\begin{cases} {1\\over2}
k\_{dihr}(\\f\'-\\f_0-\\D \\f)\^2 &\\qquad 当\\; \\f\' \> \\D \\f \\\\ 0
&\\qquad 当\\; \\f\' \\le \\D \\f \\end{cases} \\tag{4.85}\\\] ]{.math}

其中 [ \\(\\D \\f\\) ]{.math} 为用户定义的角度, [ \\(k\_{dihr}\\)
]{.math} 为力常数. **注意** , 在拓扑文件的输入中, 角度的单位为度,
力常数的单位为kJ/mol/rad ^2^ .

### 4.3.5 距离限制 {#435-距离限制}

当指定的一对原子之间的距离超过一个阈值时,
距离限制会给势能增加一个惩罚项. 它们通常用于施加来自实验的限制,
例如核磁共振(NMR, nuclear magnetic resonance)实验中对体系运动的限制.
因此, MD可用于NMR数据的结构精修. 在GROAMCS中,
有三种方式对原子对施加距离限制:

-   简单的简谐限制: 使用 ` [ bonds ] ` 类型6. (见5.4节)
-   分段线性/简谐限制: ` [ bonds ] ` 类型10.
-   复杂的NMR距离限制, 可选的原子对, 时间和/或系综平均

下面将叙述后面两个选项.

当低于指定的下界或处于指定的两个上界之间时, 距离限制的势能形式为二次;
当超过最大边界时, 势能为线性(见图4.16).

[ \\\[V\_{dr}(r\_{ij})= \\begin{cases} {1\\over2}
k\_{dr}(r\_{ij}-r_0)\^2 &\\qquad 当\\; & \\phantom{r_0 \\le{} } r\_{ij}
\< r_0 \\\\ 0 &\\qquad 当\\; & r_0 \\le r\_{ij} \< r_1 \\\\ {1\\over2}
k\_{dr}(r\_{ij}-r_1)\^2 &\\qquad 当\\; & r_1 \\le r\_{ij} \< r_0 \\\\
{1\\over2} k\_{dr}(r_2-r_1)(2r\_{ij}-r_2-r_1) &\\qquad 当\\; & r_2 \\le
r\_{ij} \\end{cases} \\tag{4.86}\\\] ]{.math}

相应的力为

[ \\\[F_i = \\begin{cases} -k\_{dr}(r\_{ij}-r_0){\\bi r\_{ij} \\over
r\_{ij} } &\\qquad 当\\; & \\phantom{r_0 \\le{} } r\_{ij} \< r_0 \\\\ 0
&\\qquad 当\\; & r_0 \\le r\_{ij} \< r_1 \\\\ -k\_{dr}(r\_{ij}-r_1){\\bi
r\_{ij} \\over r\_{ij} } &\\qquad 当\\; & r_1 \\le r\_{ij} \< r_0 \\\\
-k\_{dr}(r_2-r_1){\\bi r\_{ij} \\over r\_{ij} } &\\qquad 当\\; & r_2
\\le r\_{ij} \\end{cases} \\tag{4.87}\\\] ]{.math}

对不是由NMR数据导出的限制, 这个函数通常足够了, ` [ bonds ] `
类型10的段可用于在原子对之间施加独立的限制, 见5.7.1节.
对由NMR测量导出的限制, 可能需要更复杂的函数, 这可通过
` [ distance_restraints ] ` 段提供, 具体将在下面论述.

![图4.16: 距离限制势](/GMX/4.16.png)

**时间平均**

基于瞬时距离的距离限制可能会显著地减弱分子内的涨落. 采用 **时间平均**
的限制距离可以解决这个问题\[91\]. 时间平均的力为

[ \\\[F_i = \\begin{cases} -k\_{dr}\^a (\\bar r\_{ij}-r_0){\\bi r\_{ij}
\\over r\_{ij} } &\\qquad 当\\; & \\phantom{r_0 \\le{} } \\bar r\_{ij}
\< r_0 \\\\ 0 &\\qquad 当\\; & r_0 \\le \\bar r\_{ij} \< r_1 \\\\
-k\_{dr}\^a (\\bar r\_{ij}-r_1){\\bi r\_{ij} \\over r\_{ij} } &\\qquad
当\\; & r_1 \\le \\bar r\_{ij} \< r_0 \\\\ -k\_{dr}\^a (r_2-r_1){\\bi
r\_{ij} \\over r\_{ij} } &\\qquad 当\\; & r_2 \\le \\bar r\_{ij}
\\end{cases} \\tag{4.88}\\\] ]{.math}

其中 [ \\(\\bar r\_{ij}\\) ]{.math} 由衰减时间为 [ \\(\\t\\) ]{.math}
的指数运行平均给出:

[ \\\[\\bar r\_{ij}=\\lt r\_{ij}\^{-3} \\gt\^{-1/3} \\tag{4.89}\\\]
]{.math}

缓慢打开力常数 [ \\(k\_{dr}\^a\\) ]{.math} ,
以弥补模拟开始时缺少历史数据的问题:

[ \\\[k\_{dr}\^a=k\_{dr} \\left(
1-\\exp\\left(-{t\\over\\t}\\right)\\right) \\tag{4.90}\\\] ]{.math}

由于时间平均, 我们无法再定义距离限制势了.

采用这种方式, 一个原子可以通过在两个位置之间移动 **平均地**
满足两个不兼容的距离限制. 例如围绕 [ \\(\\c\\) ]{.math}
二面角旋转的氨基酸支链会因此接近其他各种基团.
这样的活动支链可导致多个NOE, 不能由单一结构满足.

` mdrun ` 程序计算时间平均距离的方法如下:

[ \\\[\\begin{align} \\overline{r\^{-3} }\_{ij}(0) &= r\_{ij}(0)\^{-3}
\\\\ \\overline{r\^{-3} }\_{ij}(t) &=\\overline{r\^{-3} }\_{ij}(t-\\D t)
\\exp\\left(-{\\D t \\over
\\t}\\right)+r\_{ij}(t)\^{-3}\\left\[1-\\exp\\left(-{\\D t \\over
\\t}\\right)\\right\] \\end{align} \\tag{4.91}\\\] ]{.math}

当原子对处于边界之内时可能仍会受到力的作用,
因为时间平均的距离可能仍然超过了边界. 为防止质子彼此靠得太近,
可以使用一种混合的方法. 在这种方法中, 当瞬时距离处于边界之内时,
惩罚项为零, 在其他情况下惩罚项为瞬时偏离与时间平均偏离乘积的平方根:

[ \\\[\\bi F_i=\\begin{cases} k\_{dr}\^a \\sqrt{(r\_{ij}-r_0) (\\bar
r\_{ij}-r_0)} {\\bi r\_{ij} \\over r\_{ij} } & 当\\;\\; r\_{ij} \< r_0
\\;且\\; \\bar r\_{ij} \< r_0 \\\\ -k\_{dr}\^a
\\min\\left(\\sqrt{(r\_{ij}-r_1)(\\bar r\_{ij}-r_1)}, r_2-r_1 \\right)
{\\bi r\_{ij} \\over r\_{ij} } & 当\\;\\; r\_{ij}\>r_1 \\;且\\; \\bar
r\_{ij}\>r_1 \\\\ 0 & 其他情况 \\end{cases} \\tag{4.92}\\\] ]{.math}

**多对平均**

根据实验数据, 有时不清楚是哪些原子对导致了单个NOE, 在其他一些情况下,
由于体系的对称性, 很显然地有多余一对的原子有贡献,
例如含有三个质子的甲基. 对这样一个基团, 不可能区分不同的质子,
因此当计算此甲基与其他质子(或一组质子)之间的距离时,
所有三个质子都要考虑. 由于磁共振的物理本性,
NOE信号的强度与原子间距离的6次方成反比, 因此, 当联合原子对时, [ \\(N\\)
]{.math} 个限制的固定列表要放在一起, 表现出的"距离"为:

[ \\\[r_N(t)=\\left\[ \\Sum\_{n=1}\^N \\bar r_n(t)\^{-6}
\\right\]\^{-1/6} \\tag{4.93}\\\] ]{.math}

其中对 [ \\(\\bar r_n\\) ]{.math} 我们可以使用 [ \\(r\_{ij}\\) ]{.math}
或方程4.89. 瞬时距离和时间平均的距离 [ \\(r_N\\) ]{.math}
可以联合起来施加混合约束, 如上所述.
由于更多的质子对对相同的NOE信号有贡献, 其强度会增大, 由于是倒数加和,
累加的"距离"会小于距离的任何一个分量.

将力分布到原子对上时, 有两个选项. 对第一个守恒选项,
力定义为限制势对坐标的导数, 当不使用时间平均时, 得到的势能是守恒的.
分布到原子对上的力与 [ \\(r\^{-6}\\) ]{.math} 成正比,
这意味着互相靠近的原子对比互相远离的原子对受到更大的力,
这可能导致分子"过于刚性". 另一个选项是等力分配. 这种情况下,
每对原子受到的力为限制势对 [ \\(r_N\\) ]{.math} 导数的 [ \\(1/N\\)
]{.math} . 这种方法的优势在于可以对更多的构型进行抽样,
但不守恒的力可能导致对质子的局部加热.

也可以使用多个(蛋白质)分子的 **系综平均** . 在这种情况下, 界限应当降低:

[ \\\[\\begin{align} r_1 &= r_1\*M\^{-1/6} \\\\ r_2 &= r_2\*M\^{-1/6}
\\\\ \\end{align} \\tag{4.94}\\\] ]{.math}

其中 [ \\(M\\) ]{.math} 为分子数. 当给出适当的选项时, GROMACS预处理器
` grompp ` 可自动进行这些处理. 得到的"距离"用于计算标量力:

[ \\\[\\bi F_i=\\begin{cases} \\begin{array}{cl} 0 & r_N \< r_1 \\\\
k\_{dr}(r_N-r_1) {r\_{ij} \\over r\_{ij} } & r_1 \\le r_N \< r_2 \\\\
k\_{dr}(r_2-r_1) {r\_{ij} \\over r\_{ij} } & r_N \\ge r_2 \\end{array}
\\end{cases}\\tag{4.95}\\\] ]{.math}

其中 [ \\(i\\) ]{.math} , [ \\(j\\) ]{.math}
代表所有对NOE信号有贡献的原子对.

**使用距离限制**

在拓扑文件中可以将基于NOE数据的距离限制添加到分子定义中, 如下面的示例:

    [ distance_restraints ]
    ; ai    aj    type    index    type'    low    up1    up2    fac
      10    16       1        0        1    0.0    0.3    0.4    1.0
      10    28       1        1        1    0.0    0.3    0.4    1.0
      10    46       1        1        1    0.0    0.3    0.4    1.0
      16    22       1        2        1    0.0    0.3    0.4    2.5
      16    34       1        3        1    0.0    0.5    0.6    1.0

在这个例子中, 可以发现很多特性. ` ai ` 列与 ` aj `
列为限制粒子的原子编号. ` type ` 列总是为1. 如在4.3.5节解释的那样,
多个距离可以对单个NOE信号有贡献. 在拓扑中, 这可使用 ` index ` 列指定.
在我们的例子中, 限制10--28和10--64的索引都是1, 因此它们会被同时处理.
一起处理的一个额外要求是几个限制必须位于连续的行中, 中间不能有其他限制.
` type' ` 列通常为1, 但也可设为2,
以便不对距离限制进行时间平均与系综平均, 这适用于限制氢键. 列 ` low ` ,
` up1 ` 和 ` up2 ` 分别为方程4.86中的 [ \\(r_0\\) ]{.math} , [ \\(r_1\\)
]{.math} 和 [ \\(r_2\\) ]{.math} 值. 在一些情况下,
对一些限制使用不同的力常数可能有用, 这可通过 ` fac ` 列进行控制.
对每个限制, 参数文件中的力常数会乘上 ` fac ` 列中的值.

### 4.3.6 取向限制 {#436-取向限制}

本节论述在MD模拟中如何计算和限制向量间的取向, 如一些NMR实验中测量的.
这里论述的精修方法,
以及使用与不使用时间和系综平均对结果的影响已经发表\[92\].

**理论**

在NMR实验中,
当一个分子在溶剂中的翻滚并非完全各向同性时可测量矢量间的取向.
这种取向测量的两个例子是残基偶极耦合(两个原子核之间)或化学位移各向异性.
向量 [ \\(\\bi r\\) ]{.math} 的可观测量可写为:

[ \\\[\\d_i = {2\\over3}\\text{tr}(\\mathbf{SD}\_i) \\tag{4.96}\\\]
]{.math}

其中 [ \\(\\mathbf S\\) ]{.math} 为无量纲的分子序张量, 张量 [
\\(\\mathbf D_i\\) ]{.math} 为

[ \\\[\\mathbf D_i = {c_i \\over \\\|\\bi r_i\\\|\^\\alpha} \\pmat 3xx-1
& 3xy & 3xz \\\\ 3xy & 3yy-1 & 3yz \\\\ 3xz & 3yz & 3zz-1 \\\\ \\epmat
\\tag{4.97}\\\] ]{.math}

其中

[ \\\[x={r\_{i,x} \\over \\\|\\bi r_i \\\|}, y={r\_{i,y} \\over \\\|\\bi
r_i \\\|}, z={r\_{i,z} \\over \\\|\\bi r_i\\\|} \\tag{4.98}\\\] ]{.math}

对一个偶极耦合 [ \\(\\bi r_i\\) ]{.math} 为连接两个原子核间的向量, [
\\(\\a=3\\) ]{.math} , 常数 [ \\(c_i\\) ]{.math} 为:

[ \\\[c_i={\\m_0 \\over 4\\p} \\g_1\^i \\g_2\^i {\\hbar \\over 4\\p}
\\tag{4.99}\\\] ]{.math}

其中为 [ \\(\\g_1\^i\\) ]{.math} 和 [ \\(\\g_2\^i\\) ]{.math}
为两个核的旋磁比.

序张量是对称的, 迹为零. 使用旋转矩阵 [ \\(\\mathbf T\\) ]{.math}
可将其变换为下面的形式:

[ \\\[\\mathbf T\^T \\mathbf{ST}=s \\pmat -{1\\over2}(1-\\h) & 0 & 0
\\\\ 0 & -{1\\over2}(1+\\h) & 0 \\\\ 0 & 0 & 1 \\epmat \\tag{4.100}\\\]
]{.math}

其中 [ \\(-1 \\le s \\le 1\\) ]{.math} , [ \\(0 \\le \\h \\le 1\\)
]{.math} . [ \\(s\\) ]{.math} 称为序参数, [ \\(\\h\\) ]{.math}
称为序张量 [ \\(\\mathbf S\\) ]{.math} 的非对称性.
当分子在溶剂中的翻滚各向同性时, [ \\(s\\) ]{.math} 为零,
无法观测到取向效应, 因为所有的 [ \\(\\d_i\\) ]{.math} 都是零.

**模拟中取向的计算**

由于下面将要解释的原因, [ \\(\\mathbf D\\) ]{.math}
矩阵是相对于分子的参考取向计算的. 取向由旋转矩阵 [ \\(\\mathbf R\\)
]{.math} 定义,
计算它时需要使用最小二乘方法将选定的一组原子的当前坐标拟合到参考构型,
参考构型为模拟的初始构型. 对后面将要处理的系综平均,
参考结构来自第一个子体系. [ \\(\\mathbf D_i\^c\\) ]{.math}
矩阵的计算方法为:

[ \\\[\\mathbf D_i\^c(t)= \\mathbf R(t) \\mathbf D_i(t) \\mathbf R\^T(t)
\\tag{4.101}\\\] ]{.math}

向量 [ \\(i\\) ]{.math} 的取向为:

[ \\\[\\d_i\^c(t)={2\\over 3} \\text{tr}( \\mathbf S(t) \\mathbf
D_i\^c(t)) \\tag{4.102}\\\] ]{.math}

序张量 [ \\(\\mathbf S(t)\\) ]{.math} 通常是未知的,
对它的一个合理选择是能够使计算与观测到的取向的(加权)平均方差最小的张量:

[ \\\[MSD(t)=\\left( \\Sum\_{i=1}\^N w_i\\right)\^{-1} \\Sum\_{i=1}\^N
w_i(\\d_i\^c(t)-\\d_i\^{exp})\^2 \\tag{4.103}\\\] ]{.math}

为正确地联合不同类型的测量, [ \\(w_i\\) ]{.math}
的单位应使得所有项都是无量纲的. 这意味着 [ \\(w_i\\) ]{.math}
单位的次数为 [ \\(\\d_i\\) ]{.math} 单位的次数--2. **注意**
使用常数因子缩放所有 [ \\(w_i\\) ]{.math} 并不影响序张量.

**时间平均**

由于张量 [ \\(\\mathbf D\\) ]{.math} 随时间迅速涨落,
比能在实验中观测到的快得多, 在模拟中它们应当对时间进行平均. 然而,
在模拟中时间与分子数都是有限的, 通常不能得到对分子所有取向收敛的 [
\\(\\mathbf D_i\\) ]{.math} 张量的平均值. 如果假定分子内 [ \\(\\bi
r_i\\) ]{.math} 向量平均取向的收敛比分子的翻滚时间快得多,
这一张量可以在随分子旋转的坐标系中进行平均, 如方程4.101所示.
时间平均的张量使用指数衰减记忆函数进行计算:

[ \\\[\\mathbf D_i\^a(t) = {\\int\_{u=t_0}\^t \\mathbf
D_i\^c(u)\\exp\\left(-{t-u \\over \\t}\\right) \\rmd u \\over
\\int\_{u=t_0}\^t \\exp\\left(-{t-u \\over \\t}\\right) \\rmd u }
\\tag{4.104}\\\] ]{.math}

假定序张量 [ \\(\\mathbf S\\) ]{.math} 的涨落慢于 [ \\(\\mathbf D_i\\)
]{.math} , 时间平均的取向为:

[ \\\[\\d_i\^a(t)={2\\over3} \\text{tr}(\\mathbf S(t) \\mathbf
D_i\^a(t)) \\tag{4.105}\\\] ]{.math}

其中序张量 [ \\(\\mathbf S\\) ]{.math} 使用表达式4.103进行计算,
但将其中的 [ \\(\\d_i\^c(t)\\) ]{.math} 替换为 [ \\(\\d_i\^a(t)\\)
]{.math} .

**限制**

可以对模拟结构施加力进行限制, 施加的力正比于计算与实验取向之间差异.
无时间平均时, 恰当的势能可定义为:

[ \\\[V={1\\over2} k\\Sum\_{i=1}\^N w_i(\\d_i\^c(t)-\\d_i\^{exp})\^2
\\tag{4.106}\\\] ]{.math}

其中 [ \\(k\\) ]{.math} 的单位为能量单位, 这样限制 [ \\(i\\) ]{.math}
的有效力常数为 [ \\(kw_i\\) ]{.math} . 力是势能 [ \\(V\\) ]{.math}
的梯度的负值. 作用于向量 [ \\(\\bi r_i\\) ]{.math} 上的力 [ \\(\\bi
F_i\\) ]{.math} 为:

[ \\\[\\alg \\bi F_i(t) &= -{\\rmd V \\over \\rmd {\\bi r_i} } \\\\ &=
-k w_i(\\d_i\^c(t)-\\d_i\^{exp}) {\\rmd {\\d_i(t)} \\over \\rmd {\\bi
r_i} } \\\\ &= -k w_i(\\d_i\^c(t)-\\d_i\^{exp}) {2 c_i \\over \\\|\\bi
r\\\|\^{2+\\a} } \\left(2\\mathbf R\^T \\mathbf S \\mathbf R \\bi r_i -
{2 +\\a \\over \\\|\\bi r\\\|\^2} \\text{tr}(R\^T \\mathbf S \\mathbf R
\\bi r_i \\bi r_i\^T) \\bi r_i \\right) \\ealg\\\] ]{.math}

**系综平均**

系综平均可通过模拟一个具有 [ \\(M\\) ]{.math} 个子体系的体系来实现,
其中每个子体系包含了完全相同的取向限制.
体系只通过取向限制势进行相互作用:

[ \\\[V=M{1\\over2} k \\Sum\_{i=1}\^N w_i \<
\\d_i\^c(t)-\\d_i\^{exp}\>\^2 \\tag{4.107}\\\] ]{.math}

子体系 [ \\(m\\) ]{.math} 中向量 [ \\(\\bi r\_{i,m}\\) ]{.math}
上的力为:

[ \\\[\\bi F\_{i,m}(t)=-{\\rmd V \\over \\rmd {\\bi r\_{i,m} } }=-k w_i
\< \\d_i\^c(t)-\\d_i\^{exp} \> {\\rmd {\\d\_{i,m}\^c(t)} \\over \\rmd
{\\bi r\_{i,m} } } \\tag{4.108}\\\] ]{.math}

**时间平均**

当使用时间平均时, 无法定义势能. 但我们仍可以定义一个量,
它粗略地表示了限制的能量:

[ \\\[V=M{1\\over2} k\^a \\Sum\_{i=1}\^N w_i \<
\\d_i\^a(t)-\\d_i\^{exp}\>\^2 \\tag{4.109}\\\] ]{.math}

缓慢打开力常数 [ \\(k\^a\\) ]{.math} , 以弥补时间接近 [ \\(t_0\\)
]{.math} 时缺少历史数据的问题. 它精确地正比于已积累的平均量:

[ \\\[k\^a =k {1\\over \\t} \\int\_{u=t_0}\^t \\exp\\left(-{t-u \\over
\\t}\\right) \\rmd u \\tag{4.110}\\\] ]{.math}

真正关键的是力的定义, 它正比于时间平均与瞬时偏差乘积的平方根.
只使用时间平均的偏差会导致大的振荡. 力的计算方式如下:

[ \\\[\\bi F\_{i,m}(t)= \\begin{cases} 0 &当\\; ab \\le 0 \\\\ k\^a w_i
{a \\over \|a\|} \\sqrt{ab} {\\rmd {\\d\_{i,m}\^c(t)} \\over \\rmd {\\bi
r\_{i,m} } } &当\\; ab \> 0 \\\\ \\end{cases} \\tag{4.111} \\\\ a =\<
\\d_i\^a(t)-\\d_i\^{exp} \>\\\\ b =\< \\d_i\^c(t)-\\d_i\^{exp} \>\\\]
]{.math}

**使用取向限制**

在拓扑文件的 ` [ orientation_restraints ] `
段中可以将取向限制添加到分子的定义中. 这里我们给出一个示例段,
包含了五个N-H残基的偶极耦合限制:

    [ orientation_restraints ]
    ; ai   aj   type   exp.   label   alpha   const.   obs.   weight
    ;                                    Hz     nm^3     Hz    Hz^-2
      31   32      1      1       3       3    6.083  -6.73      1.0
      43   44      1      1       4       3    6.083  -7.87      1.0
      55   56      1      1       5       3    6.083  -7.13      1.0
      65   66      1      1       6       3    6.083  -2.57      1.0
      73   74      1      1       7       3    6.083  -2.10      1.0

观测量的单位为Hz, 但也可以选择任何其他单位. ` ai ` 列与 ` aj `
列为限制粒子的原子编号. ` type ` 列总是为1. ` exp. ` 列代表实验编号,
从1开始. 对每次实验, 会优化单独的序张量 [ \\(\\mathbf S\\) ]{.math} .
对每个限制, 其标签应为大于零的唯一数字. ` alpha `
列包含了方程4.97中用于计算取向的次数 [ \\(\\a\\) ]{.math} . ` const. `
列包含相同方程中使用的常数 [ \\(c_i\\) ]{.math} .
这些常数的单位应为观测量乘上 [ \\(\\text{nm}\^\\a\\) ]{.math} . ` obs. `
列包含了观测量, 单位任意. 最后一列包含权重 [ \\(w_i\\) ]{.math} ,
其单位为观测量单位平方的倒数.

取向限制的一些参数可在 ` grompp.mdp ` 文件中设定. 不同力常数,
平均时间和系综平均对结果的影响, 请参考论文\[92\].

## 4.4 极化 {#44-极化}

GROMACS可处理极化,
采用的方法是将壳层(Drude)粒子附着到原子和/或虚拟位点上.
然后在每个时间步对壳层粒子的能量进行最小化,
以维持体系处于Born-Oppenheimer势能面上.

### 4.4.1 简单极化 {#441-简单极化}

只是平衡距离为零的简谐势.

### 4.4.2 水极化 {#442-水极化}

用于水的特殊势能, 允许单个壳层粒子的各向异性极化\[43\].

### 4.4.3 Thole极化 {#443-thole极化}

基于Thole的早期工作\[93\], Roux及其合作者实现了对乙醇这样分子的势能\[94,
95, 96\]. 在这些分子中, 壳层粒子之间存在分子内的相互作用, 然而,
必须对这些相互作用进行屏蔽, 因为完全的库仑作用太强了. 两个壳层粒子 [
\\(i\\) ]{.math} 和 [ \\(j\\) ]{.math} 之间的势能为:

[ \\\[V\_{thole}={q_i q_j \\over r\_{ij} } \\left\[ 1-\\left(1+{\\bar
r\_{ij}\\over 2}\\right) \\exp(-\\bar r\_{ij}) \\right\]
\\tag{4.112}\\\] ]{.math}

**注意** , 在Noskov等人的文章中\[96\], 方程1有一个符号错误:

[ \\\[\\bar r\_{ij}=a {r\_{ij} \\over (\\a_i \\a_j)\^{1/6} }
\\tag{4.113}\\\] ]{.math}

其中 [ \\(a\\) ]{.math} 为一个魔术常数(无量纲), 通常取2.6\[96\]; [
\\(\\a_i\\) ]{.math} 和 [ \\(\\a_j\\) ]{.math} 分别为壳层粒子的极化率.

## 4.5 自由能相互作用 {#45-自由能相互作用}

本节叙述自由能计算中, 势能对 [ \\(\\l\\) ]{.math} 的依赖关系(见3.12节).
所有常见的势能类型与约束类型都可以在状态A( [ \\(\\l=0\\) ]{.math}
)和状态B( [ \\(\\l=1\\) ]{.math} )之间光滑地进行插值, 反之亦然.
所有键合相互作用都利用对相互作用参数的线性插值进行插值,
非键相互作用可以使用线性插值或软核相互作用.

从GROMACS4.6开始, [ \\(\\l\\) ]{.math} 是一个向量,
允许自由能转变的不同分量以不同速率进行. 库仑, Lennard-Jones,
键合和限制项都可以使用 ` .mdp ` 文件中的选项独立地进行控制.

**简谐势**

这里给出的例子针对键势能, 在GROMACS中使用的是简谐势. 然而,
这些方程也同样适用于键角势与不当二面角势.

[ \\(\\alg V_b &= {1\\over 2} \\left\[ (1-\\l) k_b\^A+\\l k_b\^B
\\right\] \\left\[b-(1-\\l)b_0\^A-\\l b_0\^B \\right\]\^2 \\tag{4.114}
\\\\ \\opar{V_B}{\\l} &= {1\\over 2} (k_b\^B-k_b\^A)\\left\[
b-(1-\\l)b_0\^A+\\l b_0\^B \\right\]\^2 + \\\\ & \\qquad (b_0\^A-b_0\^B)
\\left\[ b-(1-\\l)b_0\^A-\\l b_0\^B \\right\] \\left\[ (1-\\l)
k_b\^A+\\l k_b\^B \\right\] \\tag{4.115} \\ealg\\) ]{.math}

**GROMOS--96键和键角**

对四次键伸缩势与基于余弦的键角势,
通过对力常数与平衡位置的线性插值进行插值, 这里就不给出相应的公式了.

**恰当二面角**

对恰当二面角, 这些方程更复杂一些:

[ \\(\\alg V_d &= \\left\[ (1-\\l) k_d\^A+\\l k_d\^B \\right\]
\\left(1+\\cos\\left\[n\_\\f \\f -(1-\\l)\\f_s\^A-\\l \\f_s\^B \\right\]
\\right) \\tag{4.116} \\\\ \\opar{V_d}{\\l} &= (k_d\^B-k_d\^A)
\\left(1+\\cos\\left\[n\_\\f \\f-(1-\\l)b_s\^A-\\l \\f_s\^B \\right\]
\\right) + \\\\ & \\quad (\\f_s\^B-\\f_s\^A) \\left\[ (1-\\l)k_d\^A-\\l
k_d\^B \\right\] \\sin\\left\[n\_\\f \\f-(1-\\l) \\f_s\^A-\\l \\f_s\^B
\\right\] \\tag{4.117} \\ealg\\) ]{.math}

**注意** , 多重性 [ \\(n\_\\f\\) ]{.math} 不能参数化, 因为函数在 [
\\(\[0,2\\p\]\\) ]{.math} 区间内应当保持周期性.

**表格键相互作用**

对表格键合相互作用, 只对力常数进行插值:

[ \\(\\alg V &= \\left( (1-\\l)k\^A+\\l k\^B \\right)f \\tag{4.118} \\\\
\\opar V \\l &= (k\^B-k\^A)f \\tag{4.119} \\ealg\\) ]{.math}

**库仑相互作用**

对两个粒子之间的库仑相互作用, 粒子电荷随 [ \\(\\l\\) ]{.math}
的变化关系如下:

[ \\(\\alg V_c &= {f \\over \\ve\_{rf} r\_{ij} } \\left\[ (1-\\l) q_i\^A
q_j\^A +\\l q_i\^B q_j\^B \\right\] \\tag{4.120} \\\\ \\opar {V_c} \\l
&= {f \\over \\ve\_{rf} r\_{ij} } \\left\[-q_i\^A q_j\^A +\\l q_i\^B
q_j\^B \\right\] \\tag{4.121} \\ealg\\) ]{.math}

其中 [ \\(f={1\\over 4\\p\\ve_0}= 138.935\\ 485\\) ]{.math} (见第二章).

**反应场库仑相互作用**

对两个粒子间包含反应场的库仑相互作用, 粒子电荷随 [ \\(\\l\\) ]{.math}
的变化关系如下:

[ \\(\\alg V_c &= f\\left\[{1\\over r\_{ij} }+k\_{rf} r\_{ij}\^2-c\_{rf}
\\right\] \\left\[(1-\\l) q_i\^A q_j\^A +\\l q_i\^B q_j\^B \\right\]
\\tag{4.122} \\\\ \\opar {V_c} \\l &= f\\left\[ {1\\over r\_{ij} }
+k\_{rf}r\_{ij}\^2 -c\_{rf} \\right\] \\left\[-q_i\^A q_j\^A + q_i\^B
q_j\^B \\right\] \\tag{4.123} \\ealg\\) ]{.math}

**注意** , 常数 [ \\(k\_{rf}\\) ]{.math} 和 [ \\(c\_{rf}\\) ]{.math}
是利用介质的介电常数 [ \\(\\ve\_{rf}\\) ]{.math}
进行定义的(参看4.1.4节).

**Lennard-Jones相互作用**

对两个粒子间的Lennard-Jones相互作用, **原子类型** 随 [ \\(\\l\\)
]{.math} 的变化关系可写为:

[ \\(\\alg V\_{LJ} &= {(1-\\l) C\_{12}\^A + \\l C\_{12}\^B \\over
r\_{ij}\^{12} } - {(1-\\l)C_6\^A+\\l C_6\^B \\over r\_{ij}\^6}
\\tag{1.124} \\\\ \\opar{V\_{LJ} } \\l &= {C\_{12}\^B - C\_{12}\^A
\\over r\_{ij}\^{12} } - {C_6\^B-C_6\^A \\over r\_{ij}\^6} \\tag{1.125}
\\ealg\\) ]{.math}

应当指出, 从状态A到状态B的途径也可以利用 [ \\(\\s\\) ]{.math} 和 [
\\(\\e\\) ]{.math} 进行表达(见方程4.5). 看起来改变力场参数 [ \\(\\s\\)
]{.math} 和 [ \\(\\e\\) ]{.math} 而不是导出参数 [ \\(C\_{12}\\) ]{.math}
, [ \\(C_6\\) ]{.math} 物理上可能更合理,
但在参数空间中这两种途径之间的差别并不大, 而且自由能自身与途径无关,
因此我们使用了上面的简单公式.

**动能**

当粒子的质量改变时, 动能对自由能也有贡献(注意, 我们不能将动量 [ \\(\\bi
p\\) ]{.math} 写为 [ \\(m \\bi v\\) ]{.math} , 因为那样会导致 [
\\(\\opar {E_k} \\l\\) ]{.math} 的符号错误\[97\]):

[ \\(\\alg E_k &= {1\\over2} {\\bi p\^2 \\over (1-\\l)m\^A+\\l m\^B }
\\tag{4.126} \\\\ \\opar{E_k} \\l &= -{1\\over 2} {\\bi p\^2(m\^B-m\^A)
\\over((1-\\l)m\^A+\\l m\^B)\^2 } \\tag{4.127} \\ealg\\) ]{.math}

求导后, **可以** 代入 [ \\(\\bi p=m \\bi v\\) ]{.math} , 得到

[ \\\[\\opar {E_k} \\l = -{1\\over2} \\bi v\^2 (m\^B-m\^A)
\\tag{4.128}\\\] ]{.math}

**约束**

约束是哈密顿量正式的一部分, 因此对自由能也有贡献.
在GROMACS中这可以使用LINCS或SHAKE算法进行计算. 如果我们有一些约束方程 [
\\(g_k\\) ]{.math} :

[ \\\[g_k=\\bi r_k-d_k \\tag{4.129}\\\] ]{.math}

其中 [ \\(\\bi r_k\\) ]{.math} 为两粒子间的距离向量, [ \\(d_k\\)
]{.math} 为两粒子间的约束距离. 利用距离与 [ \\(\\l\\) ]{.math} 的关系,
我们可将方程改写为

[ \\\[g_k=\\bi r_k-\\left((1-\\l)d_k\^A+\\l d_k\^B \\right)
\\tag{4.130}\\\] ]{.math}

使用Lagrange乘子, [ \\(C\_\\l\\) ]{.math} 对哈密顿量的贡献

[ \\(\\alg C\_\\l &= \\Sum_k \\l_k g_k \\tag{4.131} \\\\ \\opar {C\_\\l}
\\l &= \\Sum_k \\l_k \\left(d_k\^B-d_k\^A \\right) \\tag{4.132}
\\ealg\\) ]{.math}

### 4.5.1 软核相互作用 {#451-软核相互作用}

在自由能计算中, 当有粒子出现或消失时,
对Lennard-Jones势和库仑势使用方程4.125和4.123中的简单线性插值,
可能收敛很差. 当粒子几乎消失或接近消失时( [ \\(\\l\\) ]{.math}
接近0或1), 相互作用能会变得足够弱, 粒子彼此可能非常接近, 致使得到的 [
\\(\\partial V/\\partial \\l\\) ]{.math}
值的涨落非常大(因为简单线性插值同时取决于 [ \\(\\l\\) ]{.math}
两端点的值).

<figure>
<img src="/GMX/4.17.png"
alt="图4.17: $\l=0.5$ 时的软核作用势, 其中 $p=2$, $C_6^A=C_{12}^A=C_6^B=C_{12}^B=1$." />
<figcaption>图4.17: <span class="math"> \(\l=0.5\) </span>
时的软核作用势, 其中 <span class="math"> \(p=2\) </span> , <span
class="math"> \(C_6^A=C_{12}^A=C_6^B=C_{12}^B=1\) </span> .</figcaption>
</figure>

为避免这些问题, 需要去除势能的奇异性.
这可以通过利用"软核"势修改常规的Lennard-Jones势和库仑势来实现,
软核势限制了 [ \\(\\l\\) ]{.math} 值处于0和1之间的能量和力, 但不改变 [
\\(\\l=0\\) ]{.math} 或1时的势能和力.

在GROMACS中, 软核势是常规势能的偏移,
因此势能及其导数的奇点完全不可能出现在 [ \\(r=0\\) ]{.math} 处:

[ \\(\\alg V\_{sc} &= (1-\\l)V\^A(r_A) + \\l V\^B(r_B) \\tag{4.133} \\\\
r_A &= \\left(\\a \\s_A\^6 \\l\^p+r\^6 \\right)\^{1\\over6} \\tag{4.134}
\\\\ r_B &= \\left(\\a \\s_B\^6(1-\\l)\^p+r\^6 \\right)\^{1\\over6}
\\tag{4.135} \\\\ \\ealg\\) ]{.math}

其中 [ \\(V\^A\\) ]{.math} 和 [ \\(V\^B\\) ]{.math} 分别为状态A( [
\\(\\l=0\\) ]{.math} )和状态B( [ \\(\\l=1\\) ]{.math} )中正常的"硬核"Van
der Waals势或静电势, [ \\(\\a\\) ]{.math} 为软核参数(在 ` .mdp `
文件中利用 ` sc_alpha ` 进行设置), [ \\(p\\) ]{.math} 为软核 [ \\(\\l\\)
]{.math} 的次数(使用 ` sc_power ` 进行设置), [ \\(\\s\\) ]{.math}
为相互作用半径, 其值为 [ \\((C\_{12}/C_6)\^{1/6}\\) ]{.math} , 当 [
\\(C_6\\) ]{.math} 或 [ \\(C\_{12}\\) ]{.math} 为零时, [ \\(\\s\\)
]{.math} 是一个输入参数(由 ` sc_sigma ` 设置).

对中等大小的 [ \\(\\l\\) ]{.math} , [ \\(r_A\\) ]{.math} 和 [ \\(r_B\\)
]{.math} 对 [ \\(r\>\\a\^{1/6}\\s\\) ]{.math} 范围的势能改变很小,
对更小的 [ \\(r\\) ]{.math}
它们可使软核相互作用快速地变为一个常数(图4.17). 相应的力为:

[ \\\[F\_{sc}(r) = -\\opar { V\_{sc}(r)} r
=(1-\\l)F\^A(r_A)\\left({r\\over r_A}\\right)\^5 +\\l F\^B(r_B)
\\left({r\\over r_B}\\right)\^5 \\tag{4.136}\\\] ]{.math}

其中 [ \\(F\^A\\) ]{.math} 和 [ \\(F\^B\\) ]{.math} 为"硬核"力.
对自由能导数的贡献为:

[ \\\[\\alg \\opar{V\_{sc}(r)} \\l &= V\^B(r_B)-V\^A(r_A)+(1-\\l)
\\opar{V\^A(r_A)} {r_A} \\opar{r_A} \\l + \\l \\opar{V\^B(r_B)}{r_B}
\\opar {r_B} \\l \\\\ &= V\^B(r_B)-V\^A(r_A) + \\\\ &\\quad {p\\a \\over
6} \\left\[ \\l F\^B(r_B) r_B\^{-5}
\\s_B\^6(1-\\l)\^{p-1}-(1-\\l)F\^A(r_A) r_A\^{-5} \\s_A\^6 \\l\^{p-1}
\\right\] \\tag{4.137} \\ealg\\\] ]{.math}

GROMACS原始的Lennard-Jones软核函数使用的 [ \\(p=2\\) ]{.math} , 但 [
\\(p=1\\) ]{.math} 给出的 [ \\(\\partial H/\\partial \\l\\) ]{.math}
曲线更光滑.

另一个应当考虑的事情是, 软核对那些无Lennard-Jones相互作用的氢原子的影响.
它们的软核参数 [ \\(\\s\\) ]{.math} 使用 ` .mdp ` 文件中的 ` sc-sigma `
选项设置. 对 [ \\(p=1\\) ]{.math} , 当 [ \\(\\l=0\\) ]{.math} 和/或1时,
或对 [ \\(p=2\\) ]{.math} , 当 [ \\(\\l\\) ]{.math} 接近0或1时,
这些氢原子会使 [ \\(\\partial H/\\partial \\l\\) ]{.math} 曲线产生峰值.
降低 ` sc-sigma ` 的值可减小这种效应, 但相对于软核状态中其他的相互作用,
这种做法会增加与氢原子的相互作用.

当选择软核势时(设置 ` sc-alpha ` \>0),
依次打开和关闭库仑和Lennard-Jones, 然后线性地关闭库仑相互作用,
而不使用软核相互作用, 在大多数情况下, 这种做法的统计噪声会更小.
可将mdp选项 ` sc-coul ` 设为 ` yes ` 来取消这种行为. 此外,
软核相互作用只用于当A或B状态具有零相互作用的情况.
若A和B状态都具有非零的相互作用势, 会使用上文所说的线性缩放方法.
当同时关闭库仑和Lennard-Jones相互作用时, 会使用软核势,
并引入或删除一个氢原子, 将sigma参数设置为 ` sc-sigma-min ` ,
其自身默认值为 ` sc-sigma-default ` .

最近, 有人推导了软核方法一个新公式, 与上面所述的标准软核途径相比,
在大多数情况下, 它给出的统计方差更低\[99, 100\].

[ \\(\\alg V\_{sc}(r) &= (1-\\l) v\^A(r_A)+\\l V\^B(r_B) \\tag{4.138}
\\\\ r_A &= \\left( \\a \\s_A\^{48} \\l\^p + r\^{48} \\right)\^{1\\over
48} \\tag{4.139} \\\\ r_B &= \\left( \\a \\s_B\^{48}(1-\\l)\^p + r\^{48}
\\right)\^{1\\over 48} \\tag{4.140} \\ealg\\) ]{.math}

GROMACS也实现了这种"1--1--48"途径. 注意对这种途径, 软核参数应满足 [
\\(0.001 \\lt \\a \\lt 0.003\\) ]{.math} , 而不是 [ \\(\\a \\approx
0.5\\) ]{.math} .

## 4.6 方法 {#46-方法}

### 4.6.1 排除和1--4相互作用 {#461-排除和14相互作用}

一个分子链中互相邻近的原子, 即那些以共价键结合,
或者通过一个或两个原子相连的原子分别被称为 **第一相邻原子** ,
**第二相邻原子** 和 **第三相邻原子** (见图4.18). 由于原子 **i** 与原子
**i+1** 和 **i+2** 之间的相互作用主要是量子力学的,
因此不能用Lennard-Jones势进行描述. 作为替代,
我们假定这些相互作用可以利用简谐键项或约束( **i** , **i+1**
)和简谐键角项( **i** , **i+2** )进行充分的描述. 因此,
将第一和第二相邻原子(原子 **i+1** , **i+2** ) 从原子 **i**
的Lennard-Jones相互作用列表中 **排除** . 原子 **i+1** , **i+2**
被称为原子 **i** 的排除原子.

![图4.18: 沿烷烃链的原子](/GMX/4.18.png)

对第三个相邻原子, 正常的Lennard-Jones排斥作用有时仍然过强,
这意味着当将其应用于分子时, 分子会因内部张力发生变形或者破碎,
对顺式构象的碳-碳相互作用情况尤其如此(如顺丁烷). 因此,
对一些这样的相互作用, , 其Lennard-Jones排斥在GROMACS力场中被减弱了,
这是通过维持一个单独的1--4作用列表和正常的Lennard-Jones参数列表实现的.
在其他力场中, 如OPLS\[101\], 标准的Lennard-Jones参数减少为原来的1/2,
但在这种情况下, 也会对色散(r ^-6^ )和库伦相互作用进行相应的缩放.
GROMACS可以使用这些方法中的任何一种.

### 4.6.2 电荷组 {#462-电荷组}

原则上, MD中力的计算复杂度是 [ \\(O(N\^2)\\) ]{.math} . 因此,
对非键力(NBF, non-bonded force)的计算我们使用了截断:
只有彼此间的距离在一定范围内的粒子才会相互作用.
这将NBF计算的复杂度减少为 [ \\(O(N)\\) ]{.math} (典型的是 [ \\(100N\\)
]{.math} 到 [ \\(200N\\) ]{.math} ), 但同时也引入了误差. 在大多数情况下,
误差是可以接受的, 除了使用截断会导致电荷产生时. 在这种情况下,
应该考虑使用GROMACS提供的格点加和方法.

让我们考虑水分子与另一个原子的相互作用.
如果在原子-原子的基础上使用普通的截断,
我们可能包括了原子和氧之间的相互作用(电荷为--0.82),
而没有包括质子的平衡电荷, 结果将导致体系中出现了一个很大的偶极矩. 因此,
我们必须保证原子组的总电荷为0. 这些组被称为 **电荷组** . 注意,
如果对长程静电相互作用使用了好的处理方法(如粒子网格Ewald方法,
见4.8.2节), 就不需要将电荷组维持在一起.

### 4.6.3 组方案中截断的处理 {#463-组方案中截断的处理}

GROMACS在处理截断时相当灵活, 这意味有大量的参数可供设置. 这些参数在
` grommp ` 的输入文件中设置. 影响到截断相互作用的参数有两类:
你可以选择在每种情况下使用哪种相互作用, 在邻区搜索中使用哪种截断.

对于库伦和范德华相互作用有相应的相互作用类型选择词( ` vdwtype ` 和
` coulombtype ` 项)和两个参数, 一共六个非键相互作用参数.
参见7.3节对这些参数的完整描述.

邻区搜索(NS, neighbor searching)可使用单程或双程方法进行.
由于前者只是后者的特例, 我们将只讨论更一般的双程方法. 在这种情况下,
NS会使用两个半径: ` rlist ` 和max( ` rcoulomb ` , ` rvdw ` ).
通常每10个时间步或每20 fs(参数 ` nstlist ` )重新构建一次邻区列表.
在邻区列表中, 会存储所有落在 ` rlist ` 范围内的相互作用对. 此外,
对于没有落在 ` rlist ` 范围内但落在max( ` rcoulomb ` , ` rvdw `
)范围内的粒子对, 它们之间的相互作用在邻区搜索过程中也会被计算.
力和能量会分开存储, 在连续的NS之间, 在每个积分步会将它们添加到短程力中.
如果 ` rlist ` = max( ` rcoulomb ` , ` rvdw ` ),
生成邻区列表时不会计算力. 根据短程力与长程力的总和来计算维里,
这意味着在非NS步中维里可能有稍微的不对称. 当使用混合精度的 ` mdrun ` 时,
维里几乎总是不对称的, 因为非对角元素与加和中的每个元素相差不大.
在大多数情况下, 这些都不是真正的问题,
因为维里的涨落可以比平均值大两个数量级.

除了普通截断, 由于需要使用电荷组,
表4.2中所有的相互作用函数都要求使用比为其形式指定的 [ \\(r_c\\) ]{.math}
更大的半径进行邻区搜索. 额外半径的典型值是0.25
nm(粗略地等于电荷组中两原子之间的最大距离加上电荷组在邻区列表更新中可扩散的距离).

   类型                       参数           
  ------ ---------- ------------------------ --
   库仑   普通截断     \\(r_c, \\ve_r\\)     
           反应场    \\(r_c, \\ve\_{rf}\\)   
          移位函数   \\(r_1, r_c, \\ve_r\\)  
          切换函数   \\(r_1, r_c, \\ve_r\\)  
   VdW    普通截断         \\(r_c\\)         
          移位函数       \\(r_1, r_c\\)      
          切换函数       \\(r_1, r_c\\)      

  : 表4.2: 非键相互作用不同函数形式的参数

## 4.7 虚拟相互作用位点 {#47-虚拟相互作用位点}

在GROMACS中可以各种方式使用虚拟相互作用位点(在GROMACS
3.3以前的版本中被称为哑原子). 我们将虚拟位点的位置 [ \\(\\bi r_s\\)
]{.math} 写为其他粒子位置 [ \\(\\bi r_i\\) ]{.math} 的函数: [ \\(\\bi
r_s = f(\\bi r_1..\\bi r_n)\\) ]{.math} ,
这样就可以在力的计算中使用虚拟位点了,
它可能带有电荷或者涉及其他相互作用.
作用于虚拟位点上的力必须以一种自洽的方式被重新分配到有质量的粒子上.
在参考文献\[102\]中可以找到一个较好的方. 我们可以将势能写为:

[ \\\[V = V (\\bi r_s, \\bi r_1,\...,\\bi r_n) = V\^\*(\\bi
r_1,\...,\\bi r_n) \\tag{4.141}\\\] ]{.math}

作用于粒子 [ \\(i\\) ]{.math} 上的力为:

[ \\\[\\bi F_i = - \\opar{V\^\*}{\\bi r_i} = -\\opar{V}{\\bi
r_i}-\\opar{V}{\\bi r_s} \\opar{\\bi r_s}{\\bi r_i} = \\bi
F_i\^{direct} + \\bi F_i\' \\tag{4.142}\\\] ]{.math}

第一项是正常的力, 第二项是因虚拟位点引起的作用于粒子 [ \\(i\\) ]{.math}
上的力, 可以将它写为张量形式:

[ \\\[\\bi F_i\'=\\bmat \\opar{x_s}{x_i} & \\opar{y_s}{x_i} &
\\opar{z_s}{x_i} \\\\ \\opar{x_s}{y_i} & \\opar{y_s}{y_i} &
\\opar{z_s}{y_i} \\\\ \\opar{x_s}{z_i} & \\opar{y_s}{z_i} &
\\opar{z_s}{z_i} \\\\ \\ebmat \\bi F_s \\tag{4.143}\\\] ]{.math}

其中 [ \\(\\bi F_s\\) ]{.math} 为虚拟位点上的力, [ \\(x_s\\) ]{.math} ,
[ \\(y_s\\) ]{.math} 和 [ \\(z_s\\) ]{.math} 为虚拟位点的坐标. 这样,
合力和总的力矩都是守恒的.

![图4.19: GROMACS中六种不同类型虚拟位点的构建方式. 黑色为构建原子,
灰色为虚拟位点.](/GMX/4.19.png)

当使用虚拟位点时, 维里的计算(方程3.24)并不简单.
由于维里涉及到所有原子的加和(而不仅虚拟位点), 在计算维里 **之前** ,
虚拟位点上的力必须被重新分配到原子上(使用方程4.143). 在一些特殊的情况下,
原子上的力可以写为虚拟位点上的力的线性组合(下面的类型2和类型3),
计算维里时是否重新分配力没有区别. 然而, 一般情况下,
应该首先进行力的重新分配.

在GROMACS中, 从周围原子构建虚拟位点的方法共有六种,
我们按构建原子的数目对其进行分类. **注意** ,
所有提到的位点类型都可以利用类型3fd(归一化的, 平面内)和3out(为归一化,
平面外)进行构造. 然而, 涉及到的计算量按列表顺序迅速增大,
因此我们强烈推荐使用第一个适合的虚拟位点类型, 只要它能满足一定的目的.
图4.19给出了6种可用的虚拟位点构建方式. 概念上最简单的构建类型是线性组合:

[ \\\[\\bi r_s = \\Sum\_{i=1}\^N \\w_i \\bi r_i \\tag{4.144}\\\]
]{.math}

使用相同的权重分重新分配力:

[ \\\[\\bi F_i\'=\\w_i \\bi F_s \\tag{4.145}\\\] ]{.math}

GROMACS支持的虚拟位点类型将在下面列出.
虚拟位点中的构建原子也可以是虚拟位点自身,
但仅当它们处于列表中的较高位置时,
即虚拟位点可以利用比虚拟位点简单的"粒子"进行构建.

**2.** 两个原子的线性组合(图4.19 2):

[ \\\[\\w_i = 1 - a, \\w_j = a \\tag{4.146}\\\] ]{.math}

这种情况下虚拟位点位于通过原子 [ \\(i\\) ]{.math} 和 [ \\(j\\) ]{.math}
的线上.

**3.** 三个原子的线性组合(图4.19 3):

[ \\\[\\w_i = 1 - a - b, \\w_j = a, \\w_k = b \\tag{4.147}\\\] ]{.math}

这种情况下虚拟位点位于另外三个原子构成的平面上.

**3fd.** 在三个原子构成的平面中, 具有固定的距离(图4.19 3fd):

[ \\\[\\bi r_s=\\bi r_i+b {\\bi r\_{ij}+a \\bi r\_{jk} \\over \\abs{\\bi
r\_{ij}+a\\bi r\_{jk}} } \\tag{4.148}\\\] ]{.math}

这种情况下虚拟位点位于其他三个粒子所构成的平面中, 与原子 [ \\(i\\)
]{.math} 的距离为 [ \\(\|b\|\\) ]{.math} . 由虚拟位点上的力引起的粒子 [
\\(i\\) ]{.math} , [ \\(j\\) ]{.math} 和 [ \\(k\\) ]{.math} 上的力为:

[ \\(\\alg \\bi F_i\' &= \\bi F_s - \\g(\\bi F_s-\\bi p)& \\\\ \\bi
F_j\' &= (1-a) \\g(\\bi F_s-\\bi p)& \\\\ \\bi F_k\' &= a\\g(\\bi
F_s-\\bi p)& \\\\ \\g & = {b \\over \|\\bi r\_{ij}+a\\bi r\_{jk} \|}
\\\\ \\bi p &= {\\bi r\_{is} \\cdot \\bi F_s \\over \\bi r\_{is} \\cdot
\\bi r\_{is} } \\bi r\_{is} \\ealg \\tag{4.149}\\) ]{.math}

**3fad.** 在三个原子所构成的平面中, 具有固定的角度和距离(图 4.19 3fad):

[ \\(\\alg \\bi r_s &=\\bi r_i+d\\cos\\q{\\bi r\_{ij} \\over \|\\bi
r\_{ij}\|} +d\\cos\\q{\\bi r\_\\bot \\over \|\\bi r\_\\bot\|} \\\\ \\bi
r\_\\bot &= \\bi r\_{jk}-{\\bi r\_{ij} \\cdot \\bi r\_{jk} \\over \\bi
r\_{ij} \\cdot \\bi r\_{ij} } \\bi r\_{ij} \\ealg \\tag{4.150}\\)
]{.math}

这种情况下虚拟位点位于其他三个粒子所构成的平面中, 与原子 [ \\(i\\)
]{.math} 的距离为 [ \\(\|d\|\\) ]{.math} , 与 [ \\(\\bi r\_{ij}\\)
]{.math} 所成的角度为 [ \\(\\a\\) ]{.math} . 原子 [ \\(k\\) ]{.math}
定义了平面以及角度的方向. **注意** , 在这种情况下必须明确指定 [ \\(b\\)
]{.math} 和 [ \\(\\a\\) ]{.math} 的, 以代替 [ \\(a\\) ]{.math} 和 [
\\(b\\) ]{.math} (也可参见5.2.2节). 由虚拟位点上的力引起的粒子 [ \\(i\\)
]{.math} , [ \\(j\\) ]{.math} 和 [ \\(k\\) ]{.math} 上的力为( [ \\(\\bi
r\_\\bot\\) ]{.math} 的定义如方程4.150):

[ \\(\\alg \\bi F_i\' &= \\bi F_s - &{d\\cos\\q \\over \|\\bi r\_{ij}\|}
\\bi F_1 + &{d \\sin\\q \\over \|\\bi r\_\\bot\|}\\left({\\bi r\_{ij}
\\cdot \\bi r\_{jk} \\over \\bi r\_{ij} \\cdot \\bi r\_{ij}} \\bi F_2 +
\\bi F_3\\right) \\\\ \\bi F_j\' &= &{d\\cos\\q \\over \|\\bi r\_{ij}\|}
\\bi F_1 - &{d \\sin\\q \\over \|\\bi r\_\\bot\|}\\left(\\bi F_2+{\\bi
r\_{ij} \\cdot \\bi r\_{jk} \\over \\bi r\_{ij} \\cdot \\bi r\_{ij}}
\\bi F_2 + \\bi F_3\\right) \\\\ \\bi F_k\' &= &{ } &{d \\sin\\q \\over
\|\\bi r\_\\bot\|}\\bi F_2 \\\\ \\bi F_1 &= \\bi F_s-{\\bi r\_{ij}
\\cdot \\bi F_s \\over \\bi r\_{ij} \\cdot \\bi r\_{ij} } \\bi r\_{ij}
\\\\ \\bi F_2 &= \\bi F_1-{\\bi r\_\\bot \\cdot \\bi F_s \\over \\bi
r\_\\bot \\cdot \\bi r\_\\bot } \\bi r\_\\bot \\\\ \\bi F_3 &= \\bi
{\\bi r\_{ij} \\cdot \\bi F_s \\over \\bi r\_{ij} \\cdot \\bi r\_{ij} }
\\bi r\_\\bot \\tag{4.151} \\ealg\\) ]{.math}

**3out.** 三个原子的非线性组合, 平面外(图4.19 3out):

[ \\\[\\bi r_s = \\bi r_i+a\\bi r\_{ij}+b\\bi r\_{ik}+c(\\bi r\_{ij}
\\times \\bi r\_{ik}) \\tag{4.152}\\\] ]{.math}

构建的虚拟位点位于其他原子构成的平面外. 由虚拟位点上的力引起的粒子 [
\\(i\\) ]{.math} , [ \\(j\\) ]{.math} 和 [ \\(k\\) ]{.math} 上的力为:

[ \\\[\\alg \\bi F_j\' &= \\bmat a & -cz\_{ik} & cy\_{ik} \\\\ cz\_{ik}
& a & -cx\_{ik} \\\\ -cy\_{ik} & cx\_{ik} & a \\ebmat \\bi F_s \\\\ \\bi
F_k\' &= \\bmat b & cz\_{ij} & -cy\_{ij} \\\\ -cz\_{ij} & b & cx\_{ij}
\\\\ cy\_{ij} & -cx\_{ij} & b \\ebmat \\bi F_s \\\\ \\bi F_i\' &= \\bi
F_s - \\bi F_j\' -\\bi F_k\' \\ealg \\tag{4.153}\\\] ]{.math}

![图4.20: 新的4fdn虚拟位点的构建方法.
即便所有构建原子都处于同一平面内时,
这种虚拟位点也是稳定的.](/GMX/4.20.png)

**4fdn.** 由四个原子构建, 具有固定的距离, 见图4.20. 这种构建有点复杂.
由于之前的构建类型(4fd)不稳定, 这迫使我们引入了这种更加复杂的构建:

[ \\(\\alg \\bi r\_{ja} &= a \\bi r\_{ik}-\\bi r\_{ij} = a(\\bi x_k-\\bi
x_i)-(\\bi x_j-\\bi x_i) \\\\ \\bi r\_{jb} &= b \\bi r\_{il}-\\bi
r\_{ij} = b(\\bi x_l-\\bi x_i)-(\\bi x_j-\\bi x_i) \\\\ \\bi r_m &= \\bi
r\_{ja} \\times \\bi r\_{jb} \\\\ \\bi x_s &= \\bi x_i+c{\\bi r_m \\over
\|\\bi r_m\|} \\tag{4.154} \\ealg\\) ]{.math}

这种情况下虚拟位点与原子 [ \\(i\\) ]{.math} 的距离为 [ \\(\|c\|\\)
]{.math} , [ \\(a\\) ]{.math} 和 [ \\(b\\) ]{.math} 是参数. **注意** ,
为节省浮点运算的时间, 没有对矢量 [ \\(\\bi r\_{ik}\\) ]{.math} 和 [
\\(\\bi r\_{ij}\\) ]{.math} 进行归一化. 由虚拟位点上的力引起的粒子 [
\\(i\\) ]{.math} , [ \\(j\\) ]{.math} 和 [ \\(k\\) ]{.math}
上的力可通过对构造表达式使用链式规则求导计算.
这种构建精确并保持能量守恒, 但确实导致了相对冗长的表达式,
在这里我们没有给出所有表达式(超过200次浮点运算). 感兴趣的读者可以阅读
` vsite.c ` 中的代码. 幸运的是, 这种虚拟位点类型通常只用于手性中心,
例如蛋白质中的 [ \\(C\_\\a\\) ]{.math} 原子.

新的4fdn构造在拓扑中的'type'识别值为2.
GROMACS内部依然支持以前的4fd类型('type'值为1), 但不应将其用于新的模拟.
所有目前的GROMACS程序都会自动创建4fdn类型作为替代.

**N.** [ \\(N\\) ]{.math} 个原子的线性组合, 相对权重为 [ \\(a_i\\)
]{.math} . 原子 [ \\(i\\) ]{.math} 的权重为:

[ \\\[\\w_i=a_i\\left(\\Sum\_{j=1}\^N a_j \\right)\^{-1}\\tag{4.155}\\\]
]{.math}

设置权重时有三个选项:

-   COG 几何中心: 等权重
-   COM 质量中心: [ \\(a_i\\) ]{.math} 为原子 [ \\(i\\) ]{.math} 的质量.
    在自由能模拟中, 原子的质量会改变, 只有A状态的质量会用于权重
-   COW 权重中心: [ \\(a_i\\) ]{.math} 由用户定义

## 4.8 长程静电作用 {#48-长程静电作用}

### 4.8.1 Ewald 加和 {#481-ewald-加和}

[ \\(N\\) ]{.math} 个粒子及其周期映象的总静电能由下式给出:

[ \\\[V={f \\over2}\\Sum\_{n_x}\\Sum\_{n_y}\\Sum\_{n\_{z\^\*} }
\\Sum_i\^N \\Sum_j\^N {q_i q_j \\over \\bi r\_{ij,\\bi n} }
\\tag{4.156}\\\] ]{.math}

[ \\((n_x,n_y,nz)=\\bi n\\) ]{.math} 为盒子的索引矢量, 星号表示当 [
\\((n_x,n_y,nz)=(0,0,0)\\) ]{.math} 时, 应忽略 [ \\(i=j\\) ]{.math} 项.
距离 [ \\(\\bi r\_{ij}\\) ]{.math} 为电荷之间的真实距离,
而不是最小映象之间的距离. 此加和条件收敛, 但收敛非常缓慢.

首次引入时, Ewald加和被用于计算晶体中周期映象的长程相互作用\[103\].
采取的方法是将方程4.156中收敛缓慢的单个加和转换为两个快速收敛的项与一个常数项:

[ \\(\\alg V &= V\_{\\text{dir} }+ V\_{\\text{rec} }+V_0 \\tag{4.157}
\\\\ V\_{\\text{dir} } &= {f \\over2}\\Sum\_{i,j}\^N
\\Sum\_{n_x}\\Sum\_{n_y}\\Sum\_{n\_{z\^\*} }q_i q_j {\\text{erfc}(\\b
r\_{ij,\\bi n}) \\over r\_{ij,\\bi n} } \\tag{4.158} \\\\
V\_{\\text{rec} } &= {f \\over2\\p V} \\Sum\_{i,j}\^N q_i q_j
\\Sum\_{m_x}\\Sum\_{m_y}\\Sum\_{m\_{z\^\*} } {\\exp(-(\\p \\bi
m/\\b)\^2+2\\p i \\bi m \\cdot (\\bi r_i-\\bi r_j)) \\over \\bi m\^2 }
\\tag{4.159} \\\\ V_0 &= -{f \\b \\over \\sqrt \\p} \\Sum_i\^N q_i\^2
\\tag{4.160} \\ealg\\) ]{.math}

其中 [ \\(\\b\\) ]{.math}
参数用于决定直接空间加和与倒易空间加和之间的相对权重, [ \\(\\bi
m=(m_x,m_y,m_z)\\) ]{.math} . 这样,
我们可以对直接空间加和使用较短的截断(数量级为1 nm),
对倒易空间加和也可以使用较短的截断(例如每个方向10个波矢). 不幸的是,
倒易空间加和的计算量以 [ \\(N_2\\) ]{.math} 增加(或 [ \\(N\^{3/2}\\)
]{.math} , 如果使用更好一点的算法), 因此用于大的体系是不现实的.

**使用Ewald方法**

不要使用Emald方法, 除非你绝对确定你需要使用. 几乎对所有的情况,
下面的PME方法表现都更好. 如果你依然坚持使用精度的Ewald加和方法, 在你的
` .mdp ` 文件中输入以下内容, 如果盒子的边长3 nm左右:

    coulombtype    = Ewald
    rvdw           = 0.9
    rlist          = 0.9
    rcoulomb       = 0.9
    fourierspacing = 0.6
    ewald-rtol     = 1e-5

盒子尺寸的比例和 ` fourierspacing ` 参数决定了每个方向使用的波矢 [
\\(m_x,m_y,m_z\\) ]{.math} 的最大振幅. 例子中对3
nm的立方盒子每个方向将使用11个波矢(从--5到5). ` ewald-rtol `
参数为在截断处静电相互作用的相对强度.
减少此值可以得到更加精确的直接空间加和, 但倒易空间加和的精度会略微降低.

### 4.8.2 PME {#482-pme}

Tom Darden提出的粒子网格Ewald方法\[12\]可提高倒易空间加和的计算速度.
这种方法不直接对波矢进行加和, 而是使用内插方法将电荷分配到网格上.
GROMACS实现的PME方法使用了基数B样条插值\[13\], 通常被称为平滑PME(SPME).
先使用3D FFT算法对格点进行傅里叶变换,
在k空间中利用对格点的单个加和就可以得到倒易空间的能量项.

格点上的势能可利用逆变换进行计算,
通过使用内插因子就可以得到每个原子上的力.

PME算法的复杂度为 [ \\(N\\log(N)\\) ]{.math} ,
对中等或大的体系计算速度远远高于普通的Ewald加和方法. 对非常小的体系,
使用Ewald方法可能更好, 因为可以避免建立格点和进行变换的过程.
PME的并行化可参见MPMD PME部分(3.17.5).

使用Verlet截断方案时, PME直接空间的势能被移动了一个常数,
使得在截断处的势能为零. 这种移动很小, 由于体系的电荷接近于零,
总的移动非常小, 这与Lennard-Jones势能的情况不同,
那种情况下所有的移动都会被累加起来. 我们使用了移动,
这样力是势能的精确积分.

**使用PME**

作为在GROMACS中使用PME加和方法的例子, 在你的 ` .mdp `
文件中指定如下几行:

    coulombtype    = PME
    rvdw           = 0.9
    rlist          = 0.9
    rcoulomb       = 0.9
    fourierspacing = 0.12
    pme-order      = 4
    ewald-rtol     = 1e-5

在这个例子中, ` fourierspacing ` 参数决定了FFT格点的最大间距(即,
格点数的最小值), ` pme-order ` 控制插值的阶数.
使用四阶(立方)内插与指定的间距, 静电能应该能精确到 [ \\(5 \\cdot
10\^-3\\) ]{.math} . 由于Lennard-Jones能量的精确度更低一些,
还可以轻微地增加间距.

PME可用于压力缩放, 但当心,
在一些体系中各项异性缩放可能会导致虚假的有序结构.

### 4.8.3 P3M-AD {#483-p3m-ad}

在GROMACS中,
也可使用Hockney和Eastwood发展的粒子-粒子粒子-网格方法来处理长程静电相互作用\[104\].
动力学计算中, 尽管P3M方法是第一个用于分子模拟的高效长程静电方法,
但在原子模拟中, P3M方法很大程度上已经被平滑PME方法(SPME)所取代.
原始P3M方法计算时有一个缺点: 它需要3次3D-FFT后变换来获得粒子上的力.
但P3M并不需要这样, 可以通过对势能进行数值微分得到所需的力,
像在PME中一样. 这样的方法被称为P3M-AD. P3M-AD和PME唯一的不同在于:
PME对晶格Green影响函数进行了优化以尽量减小误差. 然而,
在2012年有研究表明, 可以修改SPME影响函数得到P3M\[105\].
这意味着P3M-AD误差最小化的优点在PME中可以同样的计算代价和同样的代码获得,
只需增加几行代码修改影响函数. 然而, 对最佳参数设置,
P3M-AD误差最小化的效果小于10%. 对于隔行(也称为交错)的格点,
P3M-AD确实展现了很大的精度提升, 但GROMACS(目前)并不支持这种处理.

在GROMACS中使用P3M时, 所用的选项与PME完全相同,
只需要选择不同的静电类型即可.

    coulombtype = P3M-AD

### 4.8.4 优化傅里叶变换和PME计算 {#484-优化傅里叶变换和pme计算}

建议对计算静电相互作用的参数进行优化, 如PME格点尺寸和截断半径.
在运行长的模拟之前, 这尤其重要.

GROMACS中有一个特殊的工具, ` g_tune_pme ` ,
可用于自动选择格点的最佳大小和PME节点的数目.

## 4.9 长程范德华相互作用 {#49-长程范德华相互作用}

### 4.9.1 色散校正 {#491-色散校正}

在这一节中, 我们将推导长程校正,
这是由于对Lennard-Jones或Buckingham相互作用使用截断而引起的.
我们假定截断足够大以至于可以安全地忽略斥力项, 因此只须考虑色散项的校正.
由于色散相互作用的本质(我们截断了一个正比于 -r ^-6^ 的势能),
能量和压力的校正都是负的. 尽管能量的校正通常很小,
对自由能计算却可能很重要, 因计算时需要考虑两种不同哈密顿量之间的差异.
与此相反, 压力的校正很大, 当需要正确的压力时, 在任何情况下都不能忽略,
尤其是对于NPT模拟.
虽然原则上在力场参数化时可以不经校正就使得压力接近期望的实验值,
但这种方法使得参数依赖于截断, 因此不够理想.

**能量**

如果我们假定超出截断距离 [ \\(r_c\\) ]{.math} 后体系变为均相,
色散相互作用对维里的长程贡献就能够解析得到. 两个粒子之间的色散能可写为

[ \\\[V\_(r\_{ij})= -C_6 r\_{ij}\^{-6} \\tag{4.161}\\\] ]{.math}

相应的力为:

[ \\\[\\bi F\_{ij} = -6 C_6 r\_{ij}\^{-8} \\bi r\_{ij} \\tag{4.162}\\\]
]{.math}

在周期性体系中计算全部的势能并不容易, 所以通常会使用间断的或光滑的截断.
记截断处的势能和力分别为 [ \\(V_c\\) ]{.math} 和 [ \\(\\bi F_c\\)
]{.math} , 对含有 [ \\(N\\) ]{.math} 个粒子, 粒子密度 [ \\(\\r=N/V\\)
]{.math} 的体系, 色散能的长程贡献为:

[ \\\[V\_{lr}={1\\over2}N\\r \\int_0\^\\infty 4\\p r\^2
g(r)(V(r)-V_c(r)) \\rmd r \\tag{4.163}\\\] ]{.math}

我们将使用移位函数对上式进行积分, 它是GROMACS中VdW相互作用的最一般形式.
从0至 [ \\(r_1\\) ]{.math} , 移位函数具有恒定的差值 [ \\(S\\) ]{.math} ,
超过截断距离 [ \\(r_c\\) ]{.math} 后, 移位函数为零. 积分方程4.163,
并假定在半径为 [ \\(r_1\\) ]{.math} 的球体内, 粒子密度等于整体密度,
径向分布函数 [ \\(g(r)\\) ]{.math} 在 [ \\(r\\) ]{.math} 超过 [
\\(r_1\\) ]{.math} 后为1:

[ \\(\\alg V\_{lr} &= {1\\over2} N \\left(\\r \\int_0\^{r_1} 4\\p r\^2
g(r) C_6 S \\rmd r +\\r \\int\_{r_1}\^{r_c} 4 \\p r\^2(V(r)-V_c(r))\\rmd
r + \\r \\int\_{r_c}\^\\infty 4\\p r\^2V(r) \\rmd r \\right) \\\\
&={1\\over2} N\\left(\\left({4\\over3}\\p \\r r_1\^3-1\\right)C_6 S +\\r
\\int\_{r_1}\^{r_c}4 \\p r\^2(V(r)-V_c(r))\\rmd r -{4\\over3}\\p N\\r
C_6 r_c\^{-3} \\right)\\tag{4.164} \\ealg\\) ]{.math}

其中, --1项为自相互作用的校正, 对普通截断, 我们只需要假定超过 [
\\(r_c\\) ]{.math} 后 [ \\(g(r)\\) ]{.math} 等于1,
这样校正可化简为\[106\]:

[ \\\[V\_{lr}=-{2\\over3}\\p N \\r C_6 r_c\^{-3} \\tag{4.165}\\\]
]{.math}

举例来说, 如果我们考虑一个只含水分子的模拟盒子, 截断半径为0.9 nm,
密度为1 g cm ^-3^ , 上面的校正对每个水分子大约是--0.75 kJ mol ^-1^ .

对均相的混合物, 我们需要定义一个 **平均色散常数**

[ \\\[\\left \< C_6\\right \>={2\\over N(N-1)} \\Sum_i\^N \\Sum\_{j \\gt
i}\^N C_6(i,j) \\tag{4.166}\\\] ]{.math}

在GROMACS中, 计算此平均值时不考虑被排除的原子对.

对非均相模拟体系, 如脂质界面系统, 若两部分的 [ \\(\\left\< C_6\\right
\>\\) ]{.math} 比较接近, 能量校正也可以适用

**维里和压力**

体系的标量维里可通过两粒子 [ \\(i\\) ]{.math} 和 [ \\(j\\) ]{.math}
之间的色散相互作用计算:

[ \\\[\\X={1\\over2} \\bi r\_{ij} \\cdot \\bi F\_{ij} = 3 C_6
r\_{ij}\^{-6} \\tag{4.167}\\\] ]{.math}

相应的压力由下式给出:

[ \\\[P={2\\over3V}(E\_{kin}-\\X) \\tag{4.168}\\\] ]{.math}

对维里的长程校正为:

[ \\\[\\X\_{lr}={1\\over2}N\\r \\int_0\^\\infty 4\\p r\^2
g(r)(\\X-\\X_c) \\rmd r \\tag{4.169}\\\] ]{.math}

假定超过 [ \\(r_1\\) ]{.math} 后 [ \\(g(r)\\) ]{.math} 为1,
积分得到维里的长程校正:

[ \\(\\alg \\X\_{lr} &={1\\over2}N\\r\\left(\\int\_{r_1}\^{r_c} 4\\p
r\^2(\\X-\\X_c) \\rmd r + \\int\_{r_c}\^\\infty 4\\p r\^2 3 C_6
r\_{ij}\^{-6} \\rmd r \\right) \\\\
&={1\\over2}N\\r\\left(\\int\_{r_1}\^{r_c} 4\\p r\^2(\\X-\\X_c) \\rmd
r + 4\\p C_6 r_c\^{-3} \\right) \\tag{4.170} \\ealg\\) ]{.math}

对普通截断, 压力的校正值为:

[ \\\[P\_{lr}=-{4\\over3}\\p C_6 \\r\^2r_c\^{-3} \\tag{4.171}\\\]
]{.math}

对前面水盒子的例子, 每个分子的维里校正是0.75 kJ mol ^-1^ ,
对SPC水模型相应的压力校正大约是--280 bar.

对于均相混合物, 我们同样可以使用平均色散常数 [ \\(\\left\< C6\\right
\>\\) ]{.math} (方程4.166):

[ \\\[P\_{lr}=-{4\\over3}\\p \\left\< C_6\\right \> \\r\^2 r_c\^{-3}
\\tag{4.172}\\\] ]{.math}

对于非均相体系, 使用方程4.172时的限制与在能量的情况下相同(参见4.9.1节).

### 4.9.2 Lennard-Jones PME {#492-lennard-jones-pme}

为了利用Lennard-Jones势能处理截断以外非均相的体系,
我们可以使用粒子网格Ewald方法, 像上面对静电的讨论一样.
在这种情况下修改的Ewald方程变为:

[ \\(\\alg V &= V\_{\\text{dir} }+ V\_{\\text{rec} }+V_0 \\tag{4.173}
\\\\ V\_{\\text{dir} } &= {1\\over2}\\Sum\_{i,j}\^N
\\Sum\_{n_x}\\Sum\_{n_y}\\Sum\_{n\_{z\^\*} } {C_6\^{ij} g(\\b
r\_{ij,\\bi n}) \\over r\_{ij,\\bi n}\^6 } \\tag{4.174} \\\\
V\_{\\text{rec} } &= {\\p\^{3\\over2} \\b\^3 \\over 2V}
\\Sum\_{m_x}\\Sum\_{m_y}\\Sum\_{m\_{z\^\*} } f(\\p \|\\bi m\|/\\b)
\\times \\Sum\_{i,j}\^N C_6\^{ij} \\exp\[-2\\p i \\bi m \\cdot (\\bi
r_i-\\bi r_j)\] \\tag{4.175} \\\\ V_0 &= -{\\b\^6 \\over 12} \\Sum_i\^N
C_6\^{ij} \\tag{4.176} \\ealg\\) ]{.math}

[ \\\[\\tag{4.1}\\\] ]{.math}

其中 [ \\(\\bi m=(m_x,m_y,m_z)\\) ]{.math} , 参数 [ \\(\\b\\) ]{.math}
决定了直接空间和倒易空间的权重, [ \\(C\^{ij}\_6\\) ]{.math} 为粒子 [
\\(i\\) ]{.math} 和 [ \\(j\\) ]{.math} 的组合色散参数. 星号表示当 [
\\((n_x,n_y,n_z)=(0,0,0)\\) ]{.math} 时, 应忽略 [ \\(i=j\\) ]{.math}
的项. [ \\(\\bi r\_{ij,\\bi n}\\) ]{.math} 为粒子之间的真实距离.
根据Essmann的推导\[13\], 上面引入的函数 [ \\(f\\) ]{.math} 和 [ \\(g\\)
]{.math} 的定义为:

[ \\(\\alg f(x) &=1/3\\left\[(1-2x\^2) \\exp(-x\^2) + 2x\^3 \\sqrt \\p
\\text{erfc}(x) \\right\] \\tag{4.177} \\\\ g(x) &=
\\exp(-x\^2)(1+x\^2+{x\^4 \\over 2}) \\tag{4.178} \\ealg\\) ]{.math}

只要色散参数可以像静电电荷一样按几何规则进行组合(方程4.6),
上面的方法就适用

[ \\\[C\_{6,\\text{geom} }\^{ij} \\left(C_6\^{ii}C_6\^{jj} \\right)
\\tag{4.179}\\\] ]{.math}

对Lorentz-Berthelot组合规则(方程4.7), 倒易部分的加和必须计算七次,
因为色散参数的拆分如下:

[ \\\[C\_{6,\\text{L-B} }\^{ij}=(\\s_i+\\s_j)\^6=\\Sum\_{n=0}\^6
P_n\\s_i\^n \\s_j\^{(6-n)} \\tag{4.180}\\\] ]{.math}

[ \\(P_n\\) ]{.math} 为Pascal三角系数. 对倒易部分,
这导致了不可忽略计算代价, 需要七个独立的FFT,
因此这成为了以前实现LJ-PME的限制因素. 解决这个问题的一个方法是,
使用几何组合规则计算势能倒易部分的近似的相互作用参数, 得到总的相互作用:

[ \\(\\alg V(r \< r_c) &= \\underbrace{C_6\^{\\text{dir} } g(\\b
r)r\^{-6} }\_{\\text{直接空间} } + \\underbrace{C\_{6,\\text{geom}
}\^{\\text{recip} }\[1-g(\\b r)\] r\^{-6} }\_{倒易空间} \\\\ &=
C\_{6,\\text{geom} }\^{\\text{recip} } r\^{-6} +
\\left(C_6\^{\\text{dir} }-C\_{6,\\text{geom} }\^{\\text{recip} }
\\right) g(\\b r) r\^{-6} \\tag{4.181} \\\\ V(r \> r_c) &=
\\underbrace{C\_{6,\\text{geom} }\^{\\text{recip} }\[1-g(\\b r)\]
r\^{-6} }\_{倒易空间} \\tag{4.182} \\ealg\\) ]{.math}

这样可以很好的定义哈密顿量, 且可以显著提高模拟速度.
这个近似确实引入了一些误差, 但由于差异在于倒易空间中计算的相互作用,
与总的相互作用能相比, 影响非常小. 在双脂层模拟中, 使用1.0 nm的截断,
总色散能的相对误差小于0.5%. 更完整的的讨论可参看\[107\].

在GROMACS中, 我们现在已经能够正确地计算这项相互作用,
方法是从直接空间相互作用中减去倒易空间中使用的近似势能的贡献:

[ \\\[V\_{\\text{dir} }=C_6\^{\\text{dir} } r\^{-6}-C_6\^{\\text{recip}
}\[1-g(\\b r)\] r\^{-6} \\tag{4.183}\\\] ]{.math}

当 [ \\(C_6\^{\\text{dir} }=C_6\^{\\text{recip} }\\) ]{.math} 时,
这项势能将简化为方程4.174中的表达式, 总的相互作用为:

[ \\(\\alg V(r \< r_c) &= \\underbrace{C_6\^{\\text{dir} } r\^{-6}
-C_6\^{\\text{recip} }\[1-g(\\b r)\] r\^{-6} }\_{\\text{直接空间} } +
\\underbrace{C_6\^{\\text{recip} }\[1-g(\\b r)\] r\^{-6} }\_{倒易空间}
\\\\ &= C_6\^{\\text{dir} } r\^{-6} \\tag{4.184} \\\\ V(r \> r_c) &=
C_6\^{\\text{recip} }\[1-g(\\b r)\] r\^{-6} \\tag{4.185} \\ealg\\)
]{.math}

当 [ \\(C_6\^{\\text{dir} } \\ne C_6\^{\\text{recip} }\\) ]{.math} 时,
直到截断处都会存在未经修改的LJ力,
误差比模拟时直接空间相互作用未考虑倒易空间中使用的近似而导致的误差小一个数量级.
当采用移位的范德华相互作用时, 常数

[ \\\[\\left(-C_6\^{\\text{dir} }+C_6\^{\\text{recip} }\[1-g(\\b r_c)\]
\\right)r_c\^{-6} \\tag{4.1}\\\] ]{.math}

会加到方程4.184中以确保势能在截断处连续. 注意, 当 [ \\(C_6\^{\\text{dir}
}=C_6\^{\\text{recip} }\\) ]{.math} 时上式退化为预期的 [ \\(-C_6 g(\\b
r_c)r_c\^{-6}\\) ]{.math} , 如方程4.183类似. 除此之外,
可以利用长程色散校正来校正在倒易空间中使用组合规则导致的近似.
这种校正假定, 对截断LJ势能, 粒子分布是均匀的.
但由于组合规则近似导致的误差非常小, 在大多数情况下,
没有必要进行长程校正. 同样注意, 这样的均相校正并不能校正表面张力,
它是非均相性质.

**使用LJ-PME**

作为在GROMACS中使用使用粒子网格Ewald加和方法计算Lennard-Jones相互作用的例子,
在你的 ` .mdp ` 文件中指定如下几行:

    vdwtype          = PME
    rvdw             = 0.9
    vdw-modifier     = Potential-Shift
    rlist            = 0.9
    rcoulomb         = 0.9
    fourierspacing   = 0.12
    pme-order        = 4
    ewald-rtol-lj    = 0.001
    lj-pme-comb-rule = geometric

如果同时启用LJ-PME和静电PME, 应使用同样的傅里叶格点和插值阶数, 因此
` fourierspacing ` 和 ` pme-order ` 的设置对二者相同. ` ewald-rtol-lj `
控制直接空间和倒易空间之间的划分, 方式与 ` ewald-rtol ` 相同. 除此之外,
倒易空间使用的组合规则由 ` lj-pme-comb-rule ` 决定.
如果当前的力场使用Lorentz-Berthelot组合规则, 设置
` lj-pme-comb-rule = geometric ` 可获得显著的性能提升,
同时精度会略微降低. 有关此方法的细节可在前面的章节中找到.

注意, 使用完全的长程色散校正意味着, 当与库伦PME联用时, ` rvdw `
是一个自由参数, 而不必受限于力场的参数化方案. 这样,
为了提高精度和计算速度, 可以对截断, 间距, 阶数和容差项进行优化.

自然, 使用LJ-PME而不是LJ截断会增加倒易空间部分的计算和通信. 因此,
为了使用单纯PME队列并行模拟的最佳负载均衡, 应该使用更多的队列.
这可能改进 ` mdrun ` 使用的自动负载均衡.

## 4.10 力场 {#410-力场}

一个力场由两个明显不同的两部分组成:

-   用于产生势能及其导数, 也即力的方程组(称为s).
    这些在前边的章节已有详细的论述.
-   用于方程组的参数. 本手册未给出这些参数,
    但可以在GROMACS程序的相关数据文件中找到.

在一组方程之内, 可使用各种不同的参数集. 必须当心,
方程与参数的组合应自洽. 一般来说, 后验地改变一些参数是很危险的,
因为对总力的各种贡献是相互关联的. 这意味着原则上在使用之前,
应该记录每一项改动, 通过与实验数据比较进行验证, 发表在预审的杂志上.

GROMACS 5.0.2包括了一些力场, 网上还有额外的一些力场可供使用.
如果你不清楚应该选择哪个力场, 我们推荐GROMOS--96用于联合原子设置,
OPLS-AA/L用于全原子参数. 我们将对可用的选项进行详细描述.

**全氢力场**

基于GROMOS--87的全氢力场几乎等同于正常的GROMOS--87力场,
因为额外的氢原子没有Lennard-Jones相互作用并且电荷为零.
唯一的区别在于键角项和异常二面角项.
此力场仅仅适用于需要精确的氢原子位置的情况, 例如来自NMR测量的距离限制.
当要使用此力场时, 请阅读前面的段落.

### 4.10.1 GROMOS--96 {#4101-gromos96}

GROMACS支持GROMOS--96力场\[78\], 并包含了43A1, 43A2(发展,
改进了烷烃二面角), 45A3, 53A5和53A6参数集中的所有参数.
此外还包括了所有的标准构建单元, 并可以利用 ` pdb2gmx ` 程序自动创建拓扑.

GROMOS--96力场是GROMOS--87力场的进一步发展,
对GROMOS--87力场的蛋白质和小分子进行了改进. **注意** ,
53A6中的糖类参数确实对应于2004年发表的参数\[108\], 与45A4中的不同,
GROMACS此次为包含这些参数. 45A4参数集对应于这些参数的后一个版本. 然而,
我们不推荐将GROMOS--96力场用于长的烷烃与脂类分子.
GROMOS--96力场与GROMOS--87力场的不同之处在于:

-   力场参数
-   键合相互作用参数并未与原子类型相关联
-   四次键伸缩势(4.2.1)
-   基于键角余弦的键角势(4.2.6)

GROMACS和GROMOS--96的实现有两个不同, 当使用两个程序来模拟同样的体系时,
这可能导致结果有少许的不同:

-   GROMOS--96中对溶剂的邻区搜索根据溶剂分子的第一个原子进行.
    GROMACS没有使用这种方法, 但使用电荷组中心进行搜索产生的差别很小
-   GROMOS--96中的维里是基于分子的. GROMACS没有使用这种方法,
    而是使用了原子的维里

GROMOS--96力场参数化时对Lennard-Jones使用的截断值为1.4 nm,
因此请确保使用的Lennard-Jones截断( ` rvdw ` )至少为1.4.
也可以使用更大的截断, 因为超多1.4 nm后Lennard-Jones势能和力几乎为零.

**GROMOS--96文件**

GROMACS可以读写GROMOS--96的坐标文件和轨迹文件. 这些文件的扩展名应为
` .g96 ` , 文件可以是GROMOS--96的初始/最终构型文件,
坐标轨迹文件或二者的结合. 文件是固定格式的, 所有浮点数的输出格式为15.9,
因而文件可能会变得非常大. 按给定的顺序, GROMACS支持以下的数据块:

-   Header block 文件头数据块:

    ` TITLE (mandatory) ` 标题(必需)

-   Frame blocks 帧数据块:

    ` TIMESTEP (optional) ` 时间步(可选)\
    ` POSITION/POSITIONRED (mandatory) ` 位置(必需)\
    ` VELOCITY/VELOCITYRED (optional) ` 速度(可选)\
    ` BOX (optional) ` 盒子(可选)

参看GROMOS--96手册中对数据块的详细描述\[78\]. **注意**
所有GROMACS程序都可以读取压缩(.Z)或gzip压缩(.gz)的文件.

### 4.10.2 OPLS/AA {#4102-oplsaa}

### 4.10.3 AMBER {#4103-amber}

GROMACS原生支持以下AMBER力场:

-   AMBER94 \[109\]
-   AMBER96 \[110\]
-   AMBER99 \[111\]
-   AMBER99SB \[112\]
-   AMBER99SB-ILDN \[113\]
-   AMBER03 \[114\]
-   AMBERGS \[115\]

### 4.10.4 CHARMM {#4104-charmm}

GROMACS支持CHARMM力场, 这些力场可用于蛋白质\[116, 117\],
脂类\[118\]和核酸\[119, 120\].
其中的蛋白质参数(一定程度上的脂类和核酸参数)进行过彻底的验证, 验证时,
会计算势能并将其与利用CHARMM分子模拟包中的标准参数集计算的势能进行比较,
也会考察蛋白质力场在GROMACS特定技术中的表现,
如虚拟位点(支持较大的时间步长)和最近实现的快速隐式溶剂\[73\].
验证的细节及其结果可参看Bjelkmar等人的论文\[121\].
核酸及HEME相关参数的转换和测试由Michel Cuendet完成.

当在 ` pdb2gmx ` 中选择CHARMM力场时,
默认的选项是使用CMAP(用于扭转校正映射). 若想排除CMAP, 请使用 ` -nocmap `
选项. GROMACS中实现的CMAP项的基本形式为骨架扭转角 [ \\(\\f\\) ]{.math}
和 [ \\(\\y\\) ]{.math} 的函数. CMAP项在 ` .rtp ` 文件中定义,
对每个支持CMAP的残基, 在结尾处使用 ` [ cmap ] ` 语句定义CMAP.
接着的五个原子名称定义了两个扭转角. 原子1--4定义 [ \\(\\f\\) ]{.math} ,
原子2--5定义 [ \\(\\y\\) ]{.math} . 相应的原子类型会被匹配到
` cmap.itp ` 文件中正确的CMAP类型, 它们包含了校正映射.

GROMACS中使用的CHARMM36力场可在
<http://mackerell.umaryland.edu/charmm_ff.shtml#gromacs> 找到.

### 4.10.5 粗粒化力场 {#4105-粗粒化力场}

粗粒化是减少体系自由度数的一种系统方法. 为此,
典型的做法是以单个珠子代表整个原子组,
粗粒化的力场用于描述珠子之间的有效相互作用. 根据参数化方法的选择,
这些相互作用的函数形式可以很复杂, 且通常使用表格势能.

粗粒模型被设计用于重现参考体系的某些性质,
可以是全原子模型的性质甚至是实验数据. 依据重现的性质,
可使用不同的方法来得到这样的力场. 以下是各种方法的一个不完全列表:

-   守恒自由能
    -   单纯形方法
    -   MARTINI力场(参看下一节)
-   守恒分布(如径向分布函数), 所谓的基于结构的粗粒化
    -   (迭代)Boltzmann逆
    -   逆Monte Carlo
-   守恒力
    -   力匹配

注意, 粗粒势能依赖于状态(例如温度, 密度等),
应该根据体系的特点和模拟条件进行重新参数化. 你可以利用, 例如Versatile
Object-oriented Toolkit for Coarse-Graining Applications(VOTCA)\[122\],
来进行重新参数化. 这个软件包被设计用于协助进行系统的粗粒化,
实现了上面提到的大多数算法, 并且具有经过充分测试的GROMACS界面.
它是开源软件, 更多信息请浏览 [www.votca.org](http://www.votca.org/) .

### 4.10.6 MARTINI {#4106-martini}

MARTINI力场是一组粗粒化参数, 可用于构建许多体系, 包括蛋白质和膜.

### 4.10.7 PLUM {#4107-plum}

PLUM力场\[123\]无溶剂蛋白-膜模型的一个例子,
其中的膜由基于结构的粗粒化导出\[124\]. 可以在
[code.google.com/p/plumx](http://code.google.com/p/plumx/)
找到GROMACS的实现.

------------------------------------------------------------------------

------------------------------------------------------------------------

![](/jscss/molsimart.png){style="display:table;margin:0 auto;height:150px"}
[个](javascript:scroll(0,0)){#scrollTop}
:::
::: site-header
::: wrap




""
:::
:::

::: wrap
# GROMACS中文手册：第五章　拓扑文件





## 5.1 简介 {#51-简介}

GROMACS运行时需要知道哪些原子及其组合对势能函数有贡献(参见第四章). 此外,
它还需要知道对于不同函数必需的参数. 所有这些都利用 **拓扑文件**
` *.top ` 进行描述, 它列出了每个原子的 **固定属性** .
原子类型比元素种类多得多, 但力场只对存在于生物系统中的原子类型,
外加一些金属, 离子和硅进行了参数化.
键合相互作用和一些特殊的相互作用由拓扑文件中的固定配对所决定,
必须排除某些非键相互作用(第一和第二近邻),
因为它们已经在键合相互作用中处理过了. 另外, 原子还具有 **动态属性** ,
如位置, 速度和力. 严格地说, 这些不属于分子拓扑, 而是存储在坐标文件
` *.gro ` (位置和速度)或轨迹文件 ` *.trr ` (位置, 速度, 力).

本章将描述拓扑文件, ` *.top ` 文件和数据库文件的设置: 各个参数代表什么,
如果需要如何/到哪里修改它们. 首先, 会解释了所有的文件格式. 然后,
在5.8.1小节说明在每个力场的文件组织形式.

**注意** : 如果你创建了自己的拓扑文件,
我们诚挚地希望你能够将其上传到位于
[www.gromacs.org](http://www.gromacs.org/) 的拓扑文件存档. 想一想,
如果在开始计算之前, 那里就已经存有你需要的拓扑文件了,
你肯定会感谢那些贡献的人. 如果你创建了新的力场或者对标准力场进行了修改,
我们同样希望你能够将其上传到力场存档.

## 5.2 粒子类型 {#52-粒子类型}

在GROMACS中, 共有三种类型的粒子, 参见表 5.1.
GROMACS只使用了常规原子和虚拟相互作用位点, 壳层只对极化模型,
如壳层水模型, 才是需要的\[43\].

         粒子          符号
  ------------------ --------
         原子           A
         壳层           S
   虚拟相互作用位点   V(或D)

  : 表 5.1: GROMACS的粒子类型

### 5.2.1 原子类型 {#521-原子类型}

每个力场都定义了一组原子类型, 它们具有特征名称或编号,
质量(以a.m.u为单位). 这些原子类型的列表可以在 ` atomtypes.atp ` (.atp =
**a** tom **t** ype **p** arameter, 原子类型参数)文件中找到. 因此,
你可以从这个文件开始修改和/或增加原子类型. 下面的示例原子类型来自于
` gromos43a1.ff ` 力场

      O 15.99940 ;   carbonyl oxygen (C=O)
     OM 15.99940 ;   carboxyl oxygen (CO-)
     OA 15.99940 ;   hydroxyl, sugar or ester oxygen
     OW 15.99940 ;   water oxygen
      N 14.00670 ;   peptide nitrogen (N or NH)
     NT 14.00670 ;   terminal nitrogen (NH2)
     NL 14.00670 ;   terminal nitrogen (NH3)
     NR 14.00670 ;   aromatic nitrogen
     NZ 14.00670 ;   Arg NH (NH2)
     NE 14.00670 ;   Arg NE (NH)
      C 12.01100 ;   bare carbon
    CH1 13.01900 ;   aliphatic or sugar CH-group
    CH2 14.02700 ;   aliphatic or sugar CH2-group
    CH3 15.03500 ;   aliphatic CH3-group

**注意** : GROMACS以名称来使用原子类型, 而不是编号(参考GROMOS的例子)

### 5.2.2 虚拟位点 {#522-虚拟位点}

一些力场会使用虚拟相互作用位点(由其他粒子的位置构建的相互作用位点),
并为这些位点设置一些相互作用(例如, 对苯环可产生正确的四极矩),
这些将在4.7中详细介绍.

为了在你的体系中生成虚位点, 你需要在拓扑文件中包含
` [ virtual_sites? ] ` 段(为向后兼容也可以使用老版本中的名称
` [ dummmies? ] ` ), 其中 ` ? ` 代表构成虚拟位点的粒子数目, 对类型2为
` 2 ` , 对类型3, 3fd, 3fad和3out为 ` 3 ` , 对类型4fdn为 ` 4 ` .
类型4fdn取代了旧的4fd类型('type'值为1), 因为它有时会不稳定.
尽管程序内部仍然支持4fd类型, 不过最好不要在新的输入文件中使用.
不同类型将在4.7节解释.

类型2的参数看起来应该像这样:

    [ virtual_sites2 ]
    ; Site  from    funct    a
    5       1 2     1        0.7439756

类型3的像这样:

    [ virtual_sites3 ]
    ; Site  from    funct    a          b
    5       1 2 3   1        0.7439756  0.128012

类型3fd的像这样:

    [ virtual_sites3 ]
    ; Site  from    funct   a        d
    5       1 2 3   2       0.5      -0.105

类型3afd的像这样:

    [ virtual_sites3 ]
    ; Site  from     funct    theta    d
    5       1 2 3    3        120      0.5

类型3out的像这样:

    ; Site  from    funct    a        b        c
    5       1 2 3   4        -0.4     -0.4     6.9281

类型4fdn的像这样:

    [ virtual_sites4 ]
    ; Site  from        funct    a        b        c
    5       1 2 3 4     2        1.0      0.9      0.105

这就构成了虚拟位点, 编号5(第一列 ` Site ` )基于其他原子的位置,
这些原子的索引号为1和2, 或者1, 2和3, 或者1, 2, 3和4(接下来的第2, 3或4列
` from ` ), 构建时所遵循的规则由函数类型编号(下一列 ` func `
)以及具体的参数(最后1, 2或3列 ` a b.. ` )决定\`. 显然,
原子数目(包括虚拟位点数)取决于分子.
研究一下GROMCAS自带的TIP4P或TIP5P水模型的拓扑文件对理解这些可能很有帮助.

**注意** , 如果在虚拟位点和/或普通原子之间定义了任何固定的键合相互作用,
` grompp ` 命令将会移除它们(除非使用 ` -normvsbds ` 选项).
键合相互作用的移除是在生成排除之后,
因为生成排除是以"化学"的键相互作用为基础.

可以使用更普遍的方法构建虚拟位点, 利用的指令是 ` [ virtual_sustesn ] ` .
所需要的参数列在表5.5中.
下面是将一组给定原子的几何中心定义为虚拟位点的例子:

    [ virtual_sitesn ]
    ; Site  funct    from
    5       1        1 2 3 4

    性质       符号       单位
  --------- ----------- --------
    类型        \-         \-
    质量         m       a.m.u
    电荷         q         e
   epsilon   \\(\\e\\)   kJ/mol
    sigma    \\(\\s\\)     nm

  : 表 5.2: GROMACS中的静态原子类型性质

## 5.3 参数文件 {#53-参数文件}

### 5.3.1 原子 {#531-原子}

原子类型 **静态性质** (参见表 5.2)的指定基于几个地方的数据. 质量来源于
` atomtypes.apt ` 文件(参见5.2.1节), 电荷来源于 ` *.rtp ` (.rtp = **r**
esidue **t** opology **p** arameter, 残基拓扑参数, 参见5.6.1节)文件.
这就意味着只对构建氨基酸, 核酸的基本单元定义了电荷, 对其他的分子,
用户需要自己定义电荷. 当使用 ` pdb2gmx ` 程序生成一个拓扑文件( ` *.top `
)时, 来自这些文件的信息将被整合在一起.

### 5.3.2 非键参数 {#532-非键参数}

非键参数包括van der Waals参数V( ` c6 ` 或 [ \\(\\s\\) ]{.math} ,
由组合规则决定)和W( ` c12 ` 或 [ \\(\\e\\) ]{.math} ), 它们列在
` ffnonbonded.itp ` 文件中, 其中的 ` ptype ` 是粒子类型(参见表 5.1).
` [ *type ] ` 指令中的条目和键合参数会被应用它们在拓扑文件中的相应部分.
除了将在5.3.4节中提到的那些, 缺少参数将导致警告.

    [ atomtypes ]
    ;name    at.num        mass    charge    ptype          V(c6)         W(c12)
        O         8    15.99940     0.000        A    0.22617E-02    0.74158E-06
       OM         8    15.99940     0.000        A    0.22617E-02    0.74158E-06
      .....

    [ nonbond_params ]
    ; i    j    func          V(c6)         W(c12)
      O    O       1    0.22617E-02    0.74158E-06
      O   OA       1    0.22617E-02    0.13807E-05
     .....

**注意** : GROMACS所包含的大部分力场也带有 ` at.num. ` 列,
但相同的信息位于OPLS_AA ` bond_type ` 列. 参数V与W的含义取决于拓扑文件
` [ defaults ] ` 段中选择的组合规则(参见5.7.1节).

对组合规则1:

[ \\\[\\begin{split} V\_{ii} &= C_i\^{(6)} &= 4 \\e_i \\s_i\^6 &
\\text{\[ kJ mol}\^{-1} \\text{nm}\^6 \\ \\text \] \\\\ W\_{ii} &=
C_i\^{(12)} &= 4 \\e_i \\s_i\^{12} & \\text{\[ kJ mol}\^{-1}
\\text{nm}\^{12} \\ \\text \] \\end{split} \\tag{5.1}\\\] ]{.math}

对组合规则2和3:

[ \\\[\\begin{split} V\_{ii} &= \\s_i &\\text{\[ nm \]} \\\\ W\_{ii} &=
\\e_i &\\text{\[ kJ mol}\^{-1} \\ \\text \] \\end{split} \\tag{5.2}\\\]
]{.math}

对不同原子类型间的一些或所有组合都可以在 ` [ nonbond_params ] ` 段给出,
参数V与W的定义同上. 对于其他没有给出的任何原子组合, 将根据组合原则,
利用相应原子类型的参数进行计算.

对组合规则1和3:

[ \\\[\\alg C\_{ij}\^{(6)} &= \\sqrt{C_i\^{(6)} C_j\^6} \\\\
C\_{ij}\^{(12)} &= \\sqrt{C_i\^{(12)} C_j\^12} \\ealg \\tag{5.3}\\\]
]{.math}

对组合规则2:

[ \\\[\\alg \\s\_{ij} &= {1 \\over 2}(\\s_i+\\s_j) \\\\ \\e\_{ij} &=
\\sqrt{\\e_i \\e_j} \\ealg \\tag{5.4}\\\] ]{.math}

当需要提供 [ \\(\\s\\) ]{.math} 和 [ \\(\\e\\) ]{.math} 时(规则2和3),
看起来不可能使用非零的 [ \\(C\^{12}\\) ]{.math} 与零值的 [ \\(C\^6\\)
]{.math} 参数进行组合. 然而, 提供负值的 [ \\(\\s\\) ]{.math}
恰好会这样做, [ \\(C\^6\\) ]{.math} 被设为零, [ \\(C\^{12}\\) ]{.math}
正常计算. 这只是代表了读入 [ \\(\\s\\) ]{.math} 值的一种特殊情况,
没有其他的.

对Buckingham势只有一种组合规则:

[ \\\[\\alg A\_{ij} &= \\sqrt{A\_{ii} A\_{jj}} \\\\ B\_{ij} &= 2/({1
\\over B\_{ii}}+{1\\over B\_{jj}}) \\\\ C\_{ij} &= \\sqrt{C\_{ii}
C\_{jj}} \\ealg \\tag{5.5}\\\] ]{.math}

### 5.5.3 键参数 {#553-键参数}

键参数(如, 键长, 键角, 异常/正常二面角)都列在 ` ffbonded.itp ` 文件中.
这个数据库中的条目分别给出了相互作用的原子类型, 相互作用的类型,
与相互作用有关的参数. 在处理拓扑文件时, ` grompp ` 程序会读取这些参数,
然后应用到相关的键参数中. 例如将 ` bondtypes ` 应用到 ` [ bonds ] `
指令中的条目, 等等. 从相关的 ` [ *type ] `
指令中缺失的任何键参数都会导致致命错误. 相互作用的类型列于表 5.5.
下面是从这些文件中摘录的例子:

    [ bondtypes ]
    ; i   j    func         b0         kb
      C   O       1    0.12300    502080.
      C  OM       1    0.12500    418400.
     ......

    [ angletypes ]
    ; i    j    k    func        th0        cth
     HO   OA    C       1    109.500    397.480
     HO   OA  CH1       1    109.500    397.480
     ......

    [ dihedraltypes ]
    ;  i     l    func       q0         cq
    NR5*   NR5       2    0.000    167.360
    NR5*  NR5*       2    0.000    167.360
    ......

    [ dihedraltypes ]
    ; j    k    func       phi0        cp    mult
      C   OA       1    180.000    16.736       2
      C    N       1    180.000    33.472       2
     ......

    [ dihedraltypes ]
    ;
    ; Ryckaert-Bellemans Dihedrals
    ;
    ; aj   ak  funct
     CP2  CP2      3    9.2789  12.156  -13.120  -3.0597  26.240  -31.495

在 ` ffbonded.itp ` 文件中, 你可以添加键参数.
如果你想为新的原子类型增加参数, 请确保你已经在 ` atometypes.atp `
中定义了它们.

### 5.3.4 分子内的对相互作用 {#534-分子内的对相互作用}

分子中原子对之间额外的Lennard-Jones和静电相互作用可以添加到分子定义部分的
` [ pairs ] ` 段中.
这些相互作用的参数可以独立于非键相互作用参数进行设置. 在GROMOS力场中,
` [ pairs ] `
仅仅用于修改1--4相互作用(相隔3条键的两个原子之间的相互作用).
在这些力场中, 1--4相互作用并不包括在非键相互作用中(参见5.4节).

    [ pairtypes ]
    ; i    j  func            cs6           cs12 ; THESE ARE 1-4 INTERACTIONS
      O    O     1    0.22617E-02    0.74158E-06
      O   OM     1    0.22617E-02    0.74158E-06
     .....

` ffnonbonded.itp ` 文件中原子类型的对相互作用参数位于 ` [ pairtypes ] `
段. GROMOS力场显式地列出了所有这些相互作用的参数,
但对于OPLS这样的力场这一段可能是空的,
因为这些力场通过统一地缩放参数来计算1--4相互作用. 对于那些不在
` [ pairtypes ] ` 段出现的对参数, 只能当 ` forcefield.itp ` 文件中
` [ defaults ] ` 指令的 ` gen-pair ` 设置为"yes"时才能生成(参见5.7.1节).
当 ` gen-pairs ` 设置为"no"时, ` grompp `
程序会对每个未设定参数的对类型产生警告.

普通对相互作用和1--4相互作用的函数类型为1. 函数类型2和 ` [ pairs_nb ] `
特别用于自由能模拟. 当计算水合自由能时, 需要将溶质与溶剂去耦合.
这可通过添加一个B-状态拓扑(参见3.12节)实现, 其中所有溶质的非键参数,
即电荷和LJ参数, 都被设置为0. 然而,
A状态和B状态之间自由能的差值并不是总的水合自由能.
我们必须通过重新引入真空中溶质分子内部的库伦和LJ相互作用来增加自由能.
当溶质内的库伦和LJ相互作用未修改时, 第二步可以与第一步结合起来. 为此,
引入了对函数类型2, 它与函数类型1完全相同,
除了B状态参数与A状态参数始终相同.

在 ` [ pairtypes ] ` 段搜索参数, 函数类型1和2之间并没有什么差别.
对相互作用段 ` [ pair_nb ] ` 用于取代非键相互作用.
它使用未缩放的电荷与非键LJ参数, 并只使用A状态的参数. **注意** 要为
` [ pairs_nb ] ` 中列出的所有原子对添加排除,
否则这些原子对也将在正常的邻区列表中结束.

作为替代, 通过使用 ` couple-moltype ` , ` couple-lambda0 ` ,
` couple-lambda1 ` , 和 ` couple-intramol ` 关键字,
我们可以不修改拓扑文件而获得同样的行为. 具体请参考3.12节和6.1节.

所有这三种对类型全都使用普通的库伦作用, 即便当使用反应场, PME,
Ewald或移位库伦相互作用来计算非键相互作用时.
类型1和2的能量会写入能量和日志文件,
其中每个能量组对都有单独的"LJ--14"和"Coulomb--14"项. ` [ paisr_nb ] `
的能量会添加到"LJ-(SR)"和"Coulomb-(SR)"项中.

### 5.3.5 隐式溶剂化模型 {#535-隐式溶剂化模型}

GROMACS自4.5版本起开始支持隐式溶剂.
拓扑文件中引入了一个节段用于列出相关参数:

    [ implicit_genborn_params ]
    ; Atomtype    sar      st    pi      gbr       hct
      NH1         0.155    1     1.028   0.17063   0.79 ; N
      N           0.155    1     1       0.155     0.79 ; Proline backbone N
      H           0.1      1     1       0.115     0.85 ; H
      CT1         0.180    1     1.276   0.190     0.72 ; C

在上面的例子中, 先列出了原子类型, 后面有5个数字和注释(分号后面).

目前并未使用1-3列的值. 它们与更精细的表面积算法,
特别是Qiu等提出的一个算法有关\[70\]. 第4列为原子的范德华半径,
用于计算Born半径. 电介质偏移值在 ` *.mdp ` 文件中指定,
对不同的计算Born半径的方法, 程序会将输入的范德华半径减去此偏移值,
见Onufriev等的说明\[72\]. 第5列是HCT和OBC模型的缩放因子,
数值来源于Tinker程序实现的HCT成对缩放方法\[71\]. 这种方法经过修改,
缩放因子调整后使得解析的表面积和使用HCT算法计算的GB表面积之间的偏差最小.
根据Hawkins\[71\]等的建议, 缩放不适用于成对的, 而只能基于每个原子,
因此对它们进行了进一步的修正.

## 5.4 排除 {#54-排除}

` grompp ` 程序会对相邻直到一定数目键的原子生成非键相互作用的排除,
如在拓扑文件的 ` [ moleculetype ] ` 段中定义的那样(参见5.7.1节).
当彼此之间以"化学"键( ` [ bonds ] ` 类型1到5, 7或8)或约束(
` [ constraints ] ` 类型1)连接时, 粒子被认为是键合在一起的. 类型5
` [ bonds ] ` 可用于创建两个原子之间无相互作用的连接.
有一种不通过化学键连接原子的简谐相互作用( ` [ bonds ] ` 类型6),
也有一种不通过化学键连接原子而固定距离的第二类约束类型(
` [ constraints ] ` 类型2). 所有这些相互作用的完整列表见表 5.5.

分子内额外的排除可以手动在 ` [ exclusions ] ` 段中添加.
每行必须以一个原子编号开始, 后面跟着一个或多个原子编号.
第一个原子和其他原子之间的所有非键相互作用都会被排除.

当需要排除原子组内部或彼此之间的非键相互作用时,
使用能量监测组排除会更方便和高效(参见3.3节).

## 5.5 约束算法 {#55-约束算法}

约束的定义在 ` [ constraints ] ` 段中, 其格式为两个原子编号,
后面跟着函数类型和约束距离. 函数类型可以为1或2, 它们之间的唯一区别在于,
类型1用于产生排除而类型2不产生排除(参见5.4节). 距离是通过在 ` *.mdp `
文件中选择的LINCS或SHAKE算法进行约束的. 在自由能计算中,
通过增加第二个约束距离, 这两种类型的约束都可以进行微扰(参见5.7.5节).
` grompp ` 程序可自动将一些类型的键或键角(参见表 5.5)转变为约束, 在
` *.mdp ` 文件中有很多相关的选项.

我们也实现了SETTLE算法\[45\], 它对SHAKE进行解析求解, 只用于水.
可以在拓扑文件中选择SETTLE. 例如, 请参看SPC水分子的定义:

    [ moleculetype ]
    ; molname    nrexcl
      SOL        1

    [ atoms ]
    ; nr    at type    res nr    ren nm    at nm    cg nr    charge
      1     OW         1         SOL       OW1      1        -0.82
      2     HW         1         SOL       HW2      1         0.41
      3     HW         1         SOL       HW3      1         0.41

    [ settles ]
    ; OW    funct    doh    dhh
      1     1        0.1    0.16333

    [ exclusions ]
    1    2    3
    2    1    3
    3    1    2

` [ settles ] ` 指令定义了水分子的第一个原子, SETTLE函数类型始终为1,
必须给出O-H和H-H之间的距离. **注意** ,
SETTLE算法也可用于TIP3P和TIP4P水分子模型\[125\]. TIP3P具有另一个构型,
TIP4P具有一个虚拟位点, 但由于是生成的, 不需要抖动(或扰动).

## 输入文件

GROMACS的 ` pdb2gmx ` 程序可以根据输入的坐标文件产生拓扑文件,
它支持几种不同格式的坐标文件, 但 ` *.pdb ` 是最常用的(也因此程序名称为
` pdb2gmx ` ). ` pdb2gmx ` 程序运行时会在GROMACS ` share/top `
目录的子目录和你的工作目录中搜索力场, 并根据扩展名为 ` .ff ` 的目录中的
` forcefield.itp ` 文件识别力场. 目录中可能存在 ` forcefield.doc ` 文件,
如果存在, ` pbd2gmx ` 会将此文件的第一行作为力场的简单描述显示给用户,
以帮助用户选择力场. 否则, 用户可以使用 ` pdb2gmx ` 的命令行参数
` -ff xxx ` 来选择力场, 所选的力场将位于 ` xxx.ff ` 目录. 搜索力场时,
` pdb2gmx ` 会首先搜索工作目录, 然后再搜索GROMACS的 ` share/top ` 目录,
并使用找到的第一个匹配 ` xxx.ff ` 的目录.

` pdb2gmx ` 会读入两个通用文件: 位于力场目录的原子类型文件(扩展名为
` .atp ` , 参见5.2.1节), 位于工作目录或GROMACS ` share/top ` 目录的
` residuetypes.dat ` 文件. ` residuetypes.dat `
文件决定了哪些残基名称将被视为蛋白质, DNA, RNA, 水和离子.

对不同类型的分子, ` pdb2gmx ` 可以读入一个或多个数据库及拓扑信息.
属于同一个数据库的一组文件应具有相同的基准名称(basename),
基准名称最好能够对分子类型有所说明(如, 氨基酸, rna, dna).
可能的文件如下:

-   ` <basename>.rtp `
-   ` <basename>.r2b ` (可选)
-   ` <basename>.arn ` (可选)
-   ` <basename>.hdb ` (可选)
-   ` <basename>.n.tdb ` (可选)
-   ` <basename>.c.tdb ` (可选)

只有包含了构建单元拓扑信息的 ` .rtp ` 文件是必需的,
来自于其他文件的信息只用于具有相同基准名的 ` .rtp ` 文件中的构建单元.
通过在工作目录中放置具有相同基准名的额外文件,
用户也可以为力场添加新的构建单元. 默认只能定义一个额外的构建单元, 但使用
` -rtpo ` 选项调用 ` pdb2gmx ` 程序时,
可以使用本地文件中的构建单元来代替力场中默认的构建单元.

### 5.6.1 残基数据库 {#561-残基数据库}

残基数据库文件的扩展名为 ` .rtp ` .
这个文件原本包含蛋白质的构建单元(氨基酸), 是GROMACS对GROMOS
` rt37c4.dat ` 文件的解释说明,
因此残基数据库文件包含常用构建单元的信息(键, 电荷, 电荷组, 异常二面角).
最好 **不** 要更改这个文件, 因为它是 ` pdb2gmx ` 的标准输入.
但如果确实需要修改, 请修改工作目录中的 ` *.top ` 文件(参见5.7.1节), 或
` .rtp ` 文件, 像5.6节解释的那样. 通过直接包含 ` *.itp `
拓扑文件定义一个新的小分子的拓扑可能更容易一些, 具体作法将在5.7.2节讨论.
当添加新的蛋白质残基到数据库中时, 别忘了将残基名称添加到
` residuetypes.dat ` 文件中, 这样 ` grompp ` , ` make_ndx `
和分析程序才能将残基识别为蛋白质残基(参见8.1.1节).

` .rtp ` 文件只会被 ` pdb2gmx ` 程序使用. 如前面提到的, ` pdb2gmx `
程序仅仅从 ` .rtp ` 数据库中读入键, 原子电荷,
电荷组和异常二面角这些额外信息, 其余的信息是从坐标输入文件读入的.
一些蛋白质的坐标文件中包含非标准氨基酸.
你必须为这些"陌生"残基创建构建单元, 否则你将无法得到\`\*.top'文件.
对坐标文件中的一些分子, 如配体, 多原子离子, 晶格化溶剂分子等, 也是一样.
残基数据库可以根据以下方法创建:

    [ bondedtypes ] ; mandatory 必需
    ; bonds    angles    dihedrals    impropers
         1         1            1            2 ; mandatory 必需

    [ GLY ] ; mandatory 必需

    [ atoms ] ; mandatory 必需
    ; name    type    charge    chargegroup
         N       N    -0.280       0
         H       H     0.280       0
        CA     CH2     0.000       1
         C       C     0.380       2
         O       O    -0.380       2

    [ bonds ] ; optional 可选
    ;atom1    atom2    b0    kb
         N        H
         N       CA
        CA        C
         C        O
        -C        N

    [ exclusions ] ; optional 可选
    ;atom1    atom2

    [ angles ] ; optional 可选
    ;atom1    atom2    atom3    th0    cth

    [ dihedrals ] ; optional 可选
    ;atom1    atom2    atom3    atom4    phi0    cp    mult

    [ impropers ] ; optional 可选
    ;atom1    atom2    atom3    atom4    q0    cq
         N       -C       CA        H
        -C      -CA        N       -O

    [ ZN ]

    [ atoms ]
       ZN    ZN    2.000    0

文件是自由格式, 唯一的限制是每行最多一个条目. 文件中的第一个域为
` [ bondedtypes ] ` , 后面跟着四个数字, 分别代表键, 键角,
二面角和异常二面角的相互作用类型. 文件中的残基条目包含原子和(可选的)键,
键角, 二面角, 异常二面角. 电荷组代码代表电荷组的编号,
相同电荷组的原子应该始终按顺序排列. 当使用 ` pdb2gmx `
程序及氢数据库添加缺失的氢原子时(参见5.6.4), ` .rtp `
条目中定义的原子名称应该精确地对应于氢数据库中使用的名称约定.
键相互作用中的原子名称前可添加减号或加号,
分别代表原子处于残基之前或残基之后. 添加到键, 键角,
二面角和异常二面角的显式参数会覆盖 ` .itp ` 文件中的标准参数,
但只能用于特殊情况. 除参数外, 也可为每个键相互作用添加字符串.
GROMOS--96的 ` .rtp ` 文件就是这样. 这些字符串会被复制到拓扑文件,
通过使用 ` grompp ` C预处理器的 ` #define ` 语句,
可用力场参数替换这些字符串.

` pdb2gmx ` 程序会自动生成所有的键角, 这意味着对大多数力场
` [ angles ] ` 域仅用于覆盖 ` .itp ` 参数.
对GROMOS--96力场必须指定所有键角的相互作用编号.

` pdb2gmx ` 程序会自动为每个旋转键生成一个正常二面角, 倾向位于重原子上.
当使用 ` [ dihedrals ] ` 域时, 不会为对应于指定二面角的键生成其他二面角.
可以为一条旋转键指定多个二面角函数. 对CHARMM27力场, 使用 ` pdb2gmx `
程序默认的 ` -cmap ` 选项可为二面角增加校正图. 详细信息请参考4.10.4节.

` pdb2gmx ` 会设置排除数为3,
这意味着最多以3条键连接的原子之间的相互作用都被排除了.
程序会为相隔三条键的所有原子对生成对相互作用(氢原子除外).
当需要排除更多的相互作用, 或不需要生成一些对相互作用时, 可添加
` [ exclusions ] ` 域, 后面跟着位于不同行上的原子名称对,
这些原子之间的所有非键和对相互作用都将被排除.

### 5.6.2 残基构建单元数据库 {#562-残基构建单元数据库}

每个力场对残基都有自己的命名约定. 大部分残基都具有一致的命名,
但有一些残基, 特别是那些具有不同质子化状态的残基,
可能具有许多不同的名称. ` .r2b `
文件可用于将标准的残基名称转换为力场构建单元名称.

   简写                                        英文名称                                                                       含义
  ------ ------------------------------------------------------------------------------------- -------------------------------------------------------------------
   ARG                                    protonated arginine                                                             质子化精氨酸
   ARGN                                    neutral arginine                                                                中性精氨酸
   ASP                             negatively charged aspartic acid                                                     带负电的天冬氨酸
   ASPH                                  neutral aspartic acid                                                            中性天冬氨酸
   CYS                                     neutral cysteine                                                               中性半胱氨酸
   CYS2                cysteine with sulfur bound to another cysteine or a heme                           通过硫与另一个半胱氨酸或血红素结合的半胱氨酸
   GLU                             negatively charged glutamic acid                                                      带负电的谷氨酸
   GLUH                                  neutral glutamic acid                                                             中性谷氨酸
   HISD                  neutral histidine with \\(\\text N\_\\d\\) protonated                               \\(\\text N\_\\d\\) 质子化的中性组氨酸
   HISE                  neutral histidine with \\(\\text N\_\\e\\) protonated                               \\(\\text N\_\\e\\) 质子化的中性组氨酸
   HISH   positive histidine with both \\(\\text N\_\\d\\) and \\(\\text N\_\\e\\) protonated   \\(\\text N\_\\d\\) 和 \\(\\text N\_\\e\\) 质子化的带正电的组氨酸
   HIS1                                histidine bound to a heme                                                      结合到血红素的组氨酸
   LYSN                                     neutral lysine                                                                 中性赖氨酸
   LYS                                     protonated lysine                                                              质子化赖氨酸
   HEME                                          heme                                                                        血红素

  : 表 5.3 GROMACS内部的残基名称约定

如果力场目录中不存在 ` .r2b ` 文件, 或残基未被列出,
会假定构建单元的名称与残基名称相同. ` .r2b ` 文件可包含2或5列.
2列格式为, 第一列为残基名称, 第二列为构建单元名称. 5列格式具有3个附加列,
分别为出现在N端, C端和同时出现在两个末端的残基(单个残基分子)的构建单元.
这对一些力场有用, 例如AMBER力场. 如果不存在一个或多个末端,
应在相应的列中输入短划线.

对残基, 存在GROMACS的命名约定, 此约定仅通过 ` .r2b ` 文件和
` specbond.dat ` 文件显现出来(除 ` pdb2gmx ` 代码外).
只有当你添加残基类型到 ` .rtp ` 文件时, 这个约定是才变得重要.
此约定列在表5.3中. 对于特殊的键, 如与血红素基团相连的键,
GROMACS命名约定通过 ` specbond.dat ` 引入(参见5.6.7节), 如果需要,
此约定随后可以利用 ` .r2b ` 文件进行翻译.

### 5.6.3 原子重命名数据库 {#563-原子重命名数据库}

力场中使用的原子名称经常不遵​​循IUPAC或PDB约定. ` .arn `
数据库用于将坐标文件中的原子名称转换为力场中的名称.
未列出的原子会保持原有名称. ` .arn ` 文件有三列, 分别为构建单元名称,
旧的原子名称和新的原子名称. 残基名称支持问号通配符, 用以匹配单个字符.

` share/top ` 目录下还存在一个通用的原子重命名文件 ` xlateat.dat ` ,
可以将坐标文件中常见的非标​​准原子名称转换为IUPAC/PDB约定名称. 因此,
当编写力场文件时, 你可以使用标准的原子名称, 除了将其翻译为力场名称外,
不需要进一步的翻译.

### 5.6.4 氢数据库 {#564-氢数据库}

氢数据库储存在 ` .hdb ` 文件中, 它包含了关于 ` pdb2gmx `
程序如何将氢原子连接到已有原子的信息. 在GROMACS 3.3版本以前的数据库中,
根据连接的原子对氢原子进行命名: 把连接原子名称的首字母用'H'代替.
从3.3版本开始, 必须明确列出氢原子, 因为以前的做法仅适用于蛋白质,
因而不能推广用于其它分子. 如果有一个以上的氢原子连接到相同的原子,
氢原子名称的末尾将添加一个数字. 例如, 添加两个氢原子到 ` ND2 `
(天冬酰胺), 氢原子将被命名为 ` HD21 ` 和 ` HD22 ` . 这很重要, 因为
` .rtp ` 文件(参见5.6.1节)中的命名必须相同. 氢数据库的格式如下:

    ; res    # additions
             # H add type    H    i    j    k
    ALA      1
             1       1       H    N    -C   CA
    ARG      4
             1       2       H    N    CA   C
             1       1       HE   NE   CD   CZ
             2       3       HH1  NH1  CZ   NE
             2       3       HH2  NH2  CZ   NE

第一行为残基名称(ALA或ARG)以及氢原子的类型数,
这些氢原子可根据氢数据库添加到残基中.
后面的行每行对应于一个氢原子的添加:

-   添加的氢原子数

-   添加氢原子的方法, 可能的方法如下:

    1 **单个平面氢原子, 如环或肽键**\
    产生一个氢原子(n), 置于原子(i,j,k)形成的平面内,
    位于角(j-i-k)的平分线上, 距离原子i 0.1 nm,
    并使角(n-i-j)和(n-i-k)大于90度.

    2 **单个氢原子, 例如羟基**\
    产生一个氢原子(n), 距离原子i 0.1 nm, 并使角(n-i-j)为109.5度,
    二面角(n-i-j-k)为反式.

    3 **两个平面氢原子, 如乙烯 -C=CH ~2~ 或酰胺 -C(=O)NH ~2~**\
    产生两个氢原子(n1,n2), 距离原子i 0.1 nm,
    并使角(n1-i-j)与(n2-i-j)为120度, 二面角(n1-i-j-k)为顺式,
    (n2-i-j-k)为反式, 这样命名符合IUPAC标准\[126\].

    4 **两个或三个四面体氢原子, 例如-CH ~3~**\
    产生三个(n1,n2,n3)或两个(n1,n2)氢原子, 距离原子i 0.1 nm,
    并使角(n1-i-j), (n2-i-j), (n3-i-j)都为109.47度,
    二面角(n1-i-j-k)为反式, (n2-i-j-k)为反式+120度,
    (n3-i-j-k)=反式+240度.

    5 **单个四面体氢原子, 例如C ~3~ CH**\
    产生一个氢原子(n'), 距离原子i 0.1 nm, 处于四面体构型, 角(n'-i-j),
    (n'-i-k)和(n'-i-l)都为109.47度.

    6 **两个四面体氢原子, 如C-CH ~2~ -C**\
    产生两个氢原子(n1,n2), 距离原子i 0.1 nm, 处于四面体构型,
    位于平分角j-i-k的平面上, 并且角(n1-i-n2),
    (n1-i-j)和(n1-ik)都为109.47度.

    7 **两个水中的氢原子**\
    根据SPC\[81\]水模型的几何构型在原子i周围产生两个氢原子.
    对称轴交替位于三个坐标轴两个方向之间.

    10 **三个水中的"氢原子"**\
    根据SPC\[81\]水模型的几何构型在原子i周围产生两个氢原子.
    对称轴交替位于三个坐标轴两个方向之间. 此外,
    在氧原子位置产生一个额外的粒子, 并将其名称的第一个字母以'M'替代.
    此方法用于四位点的水模型, 如TIP4P\[125\].

    11 **四个水中的"氢原子"**\
    同上, 但会在氧原子位置产生两个额外的粒子, 名字分别为'LP1'和'LP2'.
    此方法用于五位点的水模型, 如TIP5P\[127\].

-   新的氢原子的名称(或其前缀, 如 ` HD2 ` , 对前面天冬酰胺的例子).

-   三或四个控制原子(i,j,k,l), 其中的第一个始终为与氢原子相连的原子,
    另外两个或三个取决于所选的代码. 对于水, 只有一个控制原子.

对一些非常特殊的情况, 可以利用上面的方法近似地解决,
并进行适当的能量最小化, 这样得到的构型用于MD模拟的初始构型已经足够好了.
例如对仲胺氢,
亚硝酰基氢(C=NH)甚至乙炔氢都可利用上面方法2羟基氢进行近似的添加.

### 5.6.5 末端数据库 {#565-末端数据库}

末端数据库储存在 ` aminoacids.n.tdb ` 和 ` aminoacids.c.tdb ` 文件中,
分别对应于N端和C端. 文件包含了关于 ` pdb2gmx `
程序如何将原子连接到已有原子, 应该删除或更改哪些原子,
应该添加哪些键相互作用的信息. 文件的格式如下(来源于
` gromos43a1.ff/aminoacids.c.tdb ` ):

    [ None ]

    [ COO- ]
    [ replace ]
    C      C    C    12.011      0.27
    O      O1   OM   15.9994    -0.635
    OXT    O2   OM   15.9994    -0.635
    [ add ]
    2   8   O   C   CA   N
    OM     15.9994  -0.635
    [ bonds ]
    C  O1  gb_5
    C  O2  gb_5
    [ angles ]
    O1  C  O2  ga_37
    CA  C  O1  ga_21
    CA  C  O2  ga_21
    [ dihedrals ]
    N   CA   C   O2   gd_20
    [ impropers ]
    C   CA   O2   O1   gi_1

该文件以块为组织, 每块的标题指定了块的名称.
这些块对应于可添加到分子的不同类型的末端. 在本例中 ` [ COO- ] `
为第一块, 对应于将末端碳原子更改为去质子化的羧基. ` [ None ] `
为第二末端类型, 对应于维持分子原样的末端. 块名称不能取以下的任何一种:
` replace ` , ` add ` , ` delete ` , ` bonds ` , ` angles ` ,
` dihedrals ` , ` impropers ` . 否则会干扰块的参数,
并可能令读者十分迷惑.

每个块可使用以下选项:

-   ` [ replace ] `

    将一个已有原子替换为具有不同原子类型, 原子名称, 电荷和/或质量的原子.
    此项可用于替换输入坐标文件和 ` .rtp ` 数据库中的原子,
    但也可用于仅仅重命名输入坐标中的原子, 以使它匹配力场中的名称.
    对后一种情况, 也应该存在相应的 ` [ add ] ` 段,
    用于指示如何添加相同的原子, 这样才能知道序列中的位置和成键.
    这种原子可出现在输入坐标中并保持, 或不出现在输入坐标中而是通过
    ` pdb2gmx ` 程序构建. 对于每一个要替换的原子,
    应该输入具有以下域的一行:

    -   要替换原子的名称
    -   新的原子名称(可选)
    -   新的原子类型
    -   新的质量
    -   新的电荷

-   ` [ add ] `

    添加新的原子. 对于每一个(组)要添加的原子需要两行输入.
    第一行包含与氢数据库相同的域(新原子的名称, 原子数目, 添加类型,
    控制原子, 参见5.6.4节), 但增加了两个只用于C端的添加类型

    8 **双羧基氧原子, -COO ^-^**\
    根据规则3产生两个氧原子(n1,n2), 距离原子i 0.136 nm,
    角(n1-i-j)和(n2-i-j)为117度

    9 **羧基氧原子和氢原子, -COOH**\
    根据规则3产生两个氧原子(n1,n2), n1和n2分别距离原子i 0.123 nm和0.125
    nm, 角(n1-i-j)为121度, (n2-i-j)为115度.
    根据规则2在n2周围产生一个氢原子(n'),
    其中n'-n2-i和n'-n2-i-j应分别对应于n-i-j和n-i-j-k.

    此行之后, 下面的一行指定了添加原子的细节, 与替换原子的方式相同, 即:

    -   原子类型
    -   质量
    -   电荷
    -   电荷组(可选)

    如氢数据库(参见5.6.1节)一样, 当一个以上的原子连接到一个已有原子时,
    原子名称的末尾会追加一个数字. **注意** , 像在氢数据库中一样,
    原子名称现在与控制原子处于同一行, 而在GROMACS
    3.3版本之前它位于第二行的开始. 当电荷组域空白时,
    添加的原子和它连接的原子将具有相同的电荷组编号.

-   ` [ delete ] `

    删除已有的原子. 每个原子名称一行.

-   ` [ bonds ] ` , ` [ angles ] ` , ` [ dihedrals ] ` 和
    ` [ impropers ] `

    添加额外的键参数. 格式与 ` *.rtp ` 文件中使用的相同, 参见5.6.1节.

### 5.6.6 虚拟位点数据库 {#566-虚拟位点数据库}

由于不能依赖输入文件中氢的位置,
我们需要一个特殊的输入文件以确定要添加的虚拟氢位点的几何构型和参数.
为创建更复杂的虚拟位点(例如当保持整个芳香侧链刚性时),
我们还需要关于平衡键长和侧链中所有原子角度的信息. 对每个力场, 这些信息在
` .vsd ` 文件中指定. 与末端类似, 对 ` .rtp `
文件中每个残基类型都有一个这样的文件.

虚拟位点数据库真的不是一个非常简单的信息列表. 它开始的两段指定了用于CH
~3~ , NH ~3~ 和NH ~2~ 基团的质量中心(通常称为MCH ~3~ /MNH ~3~ ).
根据氢原子和重原子之间的平衡键长和键角,
我们需要在这些质量中心之间施加略有不同的约束距离. **注意** , 我们 **不**
需要指定实际的参数(会自动生成), 而只需要指定使用的质量中心类型. 为此,
有三个段名称 ` [ CH3 ] ` , ` [ NH3 ] ` 和 ` [ NH2 ] ` .
对每个段我们需要三列. 第一列为连接到2/3氢原子的原子类型,
第二列为连接的下一个重原子的类型, 第三列为使用的质量中心类型.
作为一种特殊情况, 在 ` [ NH2 ] ` 段的第二列也可以指定为 ` planar ` ,
代表将使用不同的构造方法, 而不使用质量中心. 对于NH ~2~ 基团是否应为平面,
目前的一些力场观点不一, 但我们力图保持力场默认的平衡参数.

虚拟位点数据库的第二部分明确地包含芳香族侧链的原子对/三联组的平衡键长和键角.
目前, 虚拟位点生成代码的特定例程会读入这些项, 因此如果你想扩展它,
如扩展到核酸, 你需要编写新的代码. 这些段根据氨基酸的短名称进行命名(
` [ PHE ] ` , ` [ TYR ] ` , ` [ TRP ] ` , ` [ HID ] ` , ` [ HIE ] ` ,
` [ HIP ] ` ), 简单地包含2或3列原子名称,
接着是指定键长(以nm为单位)或键角(以度为单位)的数字. **注意** ,
对整个分子的平衡几何构型有所近似, 如果分子未处于自然状态,
其单个键长/键角的值可能与平衡值不同.

### 5.6.7 特殊键 {#567-特殊键}

` pdb2gmx ` 程序生成残基间化学键时使用的主要机制为,
从头到尾连接不同残基中的骨架原子进而形成大分子. 在某些情况下(如二硫键,
血红素基团, 支化聚合物), 有必要创建非骨架残基间的化学键.
` specbond.dat ` 文件即用于此功能. 残基必须属于相同的
` [ moleculetype ] ` . 当操纵不同链之间的特殊残基间的化学键时,
` pdb2gmx ` 程序的 ` -merge ` 和 ` -chainsep ` 功能很有用.

` specbond.dat ` 文件的第一行表示文件中的条目数.
如果你添加了一个新的条目, 请确保增加此数字.
文件的其余行提供创建键的具体说明. 行的格式如下:

` resA atomA nbondsA resB atomB nbondsB length newresA newresB `

分别代表:

1.  ` resA ` 参与成键的残基A的名称.
2.  ` atomA ` 残基A中形成键的原子的名称.
3.  ` nbondsA ` ` atomA ` 可以形成的键的总数.
4.  ` resB ` 参与成键的残基B的名称.
5.  ` atomB ` 残基B中形成键的原子的名称.
6.  ` nbondsB ` ` atomB ` 可以形成的键的总数.
7.  ` length ` 键的参考长度. 在提供给 ` pdb2gmx ` 程序的坐标文件中, 若
    ` atomA ` 和 ` atomB ` 之间的距离不在 ` length ` ±10%范围内,
    它们之间不会形成键.
8.  ` newresA ` 残基A的新名称, 如果必要.
    有些力场对与二硫键或血红素相连的半胱氨酸使用了CYS2之类的名称.
9.  ` newresb ` 残基B的新名称, 同上.

## 5.7 文件格式 {#57-文件格式}

### 5.7.1 拓扑文件 {#571-拓扑文件}

拓扑文件是根据GROMACS对分子拓扑的具体说明建立的. 可利用 ` pdb2gmx `
程序生成 ` *.top ` 文件. 拓扑文件中所有可能的输入项都列于表 5.4和表
5.5中. 表中还列有: 所有参数的单位, 哪些相互作用可被微扰以用于自由能计算,
` grompp ` 可使用哪些键合相互作用生成排除, ` grompp `
可将哪些键合相互作用转化为约束.

+:---------:+:---------:+:---------:+:---------:+:---------:+:---------:+
| ##        |           |           |           |           |           |
| #### 参数 |           |           |           |           |           |
+-----------+-----------+-----------+-----------+-----------+-----------+
| 相互      | 指令      | 原子数    | 函数类型  | 参数      | 自由能    |
| 作用类型  |           |           |           |           |           |
+-----------+-----------+-----------+-----------+-----------+-----------+
| 必需      | ` d       |           |           | 非键      |           |
|           | efaults ` |           |           | 函数类型; |           |
|           |           |           |           | 组合规则  |           |
|           |           |           |           | ^cr^ ;    |           |
|           |           |           |           | 生成对    |           |
|           |           |           |           | (no/yes); |           |
|           |           |           |           | fudge     |           |
|           |           |           |           | LJ();     |           |
|           |           |           |           | fudge     |           |
|           |           |           |           | QQ()      |           |
+-----------+-----------+-----------+-----------+-----------+-----------+
| 必需      | ` at      |           |           | 原子类型; |           |
|           | omtypes ` |           |           | 质量m(u); |           |
|           |           |           |           | 电荷q(e); |           |
|           |           |           |           | 粒子类型; |           |
|           |           |           |           | V ^cr^ ;  |           |
|           |           |           |           | W ^cr^    |           |
+-----------+-----------+-----------+-----------+-----------+-----------+
|           | ` bo      | (参考表   |           |           |           |
|           | ndtypes ` | 5.5       |           |           |           |
|           |           | ` bonds ` |           |           |           |
|           |           | 指令)     |           |           |           |
+-----------+-----------+-----------+-----------+-----------+-----------+
|           | ` pa      | (参考表   |           |           |           |
|           | irtypes ` | 5.5       |           |           |           |
|           |           | ` pairs ` |           |           |           |
|           |           | 指令)     |           |           |           |
+-----------+-----------+-----------+-----------+-----------+-----------+
|           | ` ang     | (参考表   |           |           |           |
|           | letypes ` | 5.5       |           |           |           |
|           |           | `         |           |           |           |
|           |           |  angles ` |           |           |           |
|           |           | 指令)     |           |           |           |
+-----------+-----------+-----------+-----------+-----------+-----------+
|           | ` dihedr  | (参考表   |           |           |           |
|           | altypes ` | 5.5       |           |           |           |
|           | ^\*^      | ` di      |           |           |           |
|           |           | hedrals ` |           |           |           |
|           |           | 指令)     |           |           |           |
+-----------+-----------+-----------+-----------+-----------+-----------+
|           | `         | (参考表   |           |           |           |
|           |  constrai | 5.5       |           |           |           |
|           | nttypes ` | ` cons    |           |           |           |
|           |           | traints ` |           |           |           |
|           |           | 指令)     |           |           |           |
+-----------+-----------+-----------+-----------+-----------+-----------+
| LJ        | ` nonbond | 2         | 1         | V ^cr^ ;  |           |
|           | _params ` |           |           | W ^cr^    |           |
+-----------+-----------+-----------+-----------+-----------+-----------+
| B         | ` nonbond | 2         | 2         | a(kJ mol  |           |
| uckingham | _params ` |           |           | ^-1^ );   |           |
|           |           |           |           | b(nm ^-1^ |           |
|           |           |           |           | ); c6(kJ  |           |
|           |           |           |           | mol ^-1^  |           |
|           |           |           |           | nm ^6^ )  |           |
+-----------+-----------+-----------+-----------+-----------+-----------+
| ######    |           |           |           |           |           |
|  分子定义 |           |           |           |           |           |
+-----------+-----------+-----------+-----------+-----------+-----------+
| 相互      | 指令      | 原子数    | 函数类型  | 参数      | 自由能    |
| 作用类型  |           |           |           |           |           |
+-----------+-----------+-----------+-----------+-----------+-----------+
| 必需      | ` molec   |           |           | 分子名称; |           |
|           | uletype ` |           |           | n ~ex~    |           |
|           |           |           |           | ^nrexcl^  |           |
+-----------+-----------+-----------+-----------+-----------+-----------+
| 必需      | ` atoms ` | 1         |           | 原子类型; | 类型, q,  |
|           |           |           |           | 残基编号; | m         |
|           |           |           |           | 残基名称; |           |
|           |           |           |           | 原子名称; |           |
|           |           |           |           | 电        |           |
|           |           |           |           | 荷组编号; |           |
|           |           |           |           | 电荷q(e); |           |
|           |           |           |           | 质量m(u)  |           |
+-----------+-----------+-----------+-----------+-----------+-----------+
| 分子内相  |           |           |           |           |           |
| 互作用和  |           |           |           |           |           |
| 几何构型  |           |           |           |           |           |
| 定义见表  |           |           |           |           |           |
| 5.5       |           |           |           |           |           |
+-----------+-----------+-----------+-----------+-----------+-----------+
| ##        |           |           |           |           |           |
| #### 系统 |           |           |           |           |           |
+-----------+-----------+-----------+-----------+-----------+-----------+
| 相互      | 指令      | 原子数    | 函数类型  | 参数      | 自由能    |
| 作用类型  |           |           |           |           |           |
+-----------+-----------+-----------+-----------+-----------+-----------+
| 必需      | `         |           |           | 系统名称  |           |
|           |  system ` |           |           |           |           |
+-----------+-----------+-----------+-----------+-----------+-----------+
| 必需      | ` mo      |           |           | 分子名称; |           |
|           | lecules ` |           |           | 分子数    |           |
+-----------+-----------+-----------+-----------+-----------+-----------+

: 表5.4: 拓扑( ` *.top ` )文件

-   原子数: 对每个指令需要的原子类型的数目
-   函数类型: 要选择的函数类型
-   自由能: 表示自由能计算时这种相互作用的哪些参数可以进行插值
-   \^cr\^: 组合规则确定LJ参数的类型, 参见5.3.2节
-   \^\*\^: 对 ` dihedraltypes `
    可指定4个原子或两个内原子(对异常二面角则设定两个外原子)
-   \^nrexcl\^: 对非键相互作用, 排除相邻的n ~ex~ 个键
-   对于自由能计算, 在正常参数之后, 类型,
    电荷q和质量m或无参数添加到同一行上的拓扑'B'(λ=1).

         相互作用名称                拓扑文件指令          原子数 ^\*^   函数类型 ^†^                                                     参数顺序及其单位                                                     用于自由能计算? ^‡^   交叉参考(节)
  -------------------------- ---------------------------- ------------- -------------- ---------------------------------------------------------------------------------------------------------------------- --------------------- ---------------
              键                   ` bonds ` ^§,¶^              2             1                                           \\(b_0\\)(nm); \\(k_b\\) (kJ mol ^-1^ nm ^-2^ )                                             所有               4.2.1
            G96键                  ` bonds ` ^§,¶^              2             2                                            \\(b_0\\)(nm); \\(k_b\\)(kJ mol ^-1^ nm ^-4^ )                                             所有               4.2.1
           Morse键                 ` bonds ` ^§,¶^              2             3                                      \\(b_0\\)(nm); \\(D\\)(kJ mol ^-1^ ); \\(\\b\\)(nm ^-1^ )                                        所有               4.2.2
            立方键                 ` bonds ` ^§,¶^              2             4                                        \\(b_0\\)(nm); \\(C\_{i=2,3}\\)(kJ mol ^-1^ nm ^-i^ )                                                             4.2.3
             连接                   ` bonds ` ^§^               2             5                                                                                                                                                           5.4
            简谐势                    ` bonds `                 2             6                                           \\(b_0\\)(nm); \\(k_b\\) (kJ mol ^-1^ nm ^-2^ )                                             所有            4.2.1, 5.4
            FENE键                  ` bonds ` ^§^               2             7                                           \\(b_m\\)(nm); \\(k_b\\) (kJ mol ^-1^ nm ^-2^ )                                                                4.2.4
            表格键                  ` bonds ` ^§^               2             8                                                   表号(≥0); \\(k\\)(kJ mol ^-1^ )                                                    \\(k\\)            4.2.14
    表格键\\(\^\\lVert\\)             ` bonds `                 2             9                                                   表号(≥0); \\(k\\)(kJ mol ^-1^ )                                                    \\(k\\)          4.2.14, 5.4
            约束势                    ` bonds `                 2             10                                     下限,上限1,上限2(nm); \\(k\_{dr}\\)(kJ mol ^-1^ nm ^-2^ )                                        所有               4.3.5
         额外LJ或库仑                 ` pairs `                 2             1                                                         V ^\*\*^ ; W ^\*\*^                                                           所有               5.3.4
         额外LJ或库仑                 ` pairs `                 2             2                                          fudge QQ(); q ~i~ , q ~j~ (e); V ^\*\*^ ; W ^\*\*^                                                              5.3.4
         额外LJ或库仑                ` pairs_nb `               2             1                                                q ~i~ , q ~j~ (e); V ^\*\*^ ; W ^\*\*^                                                                    5.3.4
             键角                   ` angles ` ^¶^              3             1                                        \\(\\q_0\\)(deg); \\(k\_\\q\\)(kJ mol ^-1^ rad ^-2^ )                                          所有               4.2.5
           G96键角                  ` angles ` ^¶^              3             2                                             \\(\\q_0\\)(deg); \\(k\_\\q\\)(kJ mol ^-1^ )                                              所有               4.2.6
         键-键交叉项                  ` angles `                3             3                                   \\(r\_{1e},r\_{2e}\\)(nm); \\(k\_{rr\'}\\)(kJ mol ^-1^ nm ^-2^ )                                                       4.2.9
         键-角交叉项                  ` angles `                3             4                               \\(r\_{1e},r\_{2e},r\_{3e}\\)(nm); \\(k\_{r\\q}\\)(kJ mol ^-1^ nm ^-2^ )                                                  4.2.10
       Urey-Bradley键角             ` angles ` ^¶^              3             5         \\(\\q_0\\)(deg); \\(k\_\\q\\)(kJ mol ^-1^ rad ^-2^ ); \\(r\_{13}\\)(nm); \</br\>\\(k\_{UB}\\)(kJ mol ^-1^ nm ^-2^ )          所有               4.2.8
           四次键角                 ` angles ` ^¶^              3             6                                   \\(\\q_0\\)(deg); \\(C\_{i=0,1,2,3,4}\\)(kJ mol ^-1^ rad ^-i^ )                                                       4.2.11
            表格角                    ` angles `                3             8                                                   表号(≥0); \\(k\\)(kJ mol ^-1^ )                                                    \\(k\\)            4.2.14
          限制弯曲势                  ` angles `                3             10                                            \\(\\q_0\\)(deg); \\(k\_\\q\\)(kJ mol ^-1^ )                                                                 4.2.7
          正常二面角                ` dihedrals `               4             1                                         \\(\\f_s\\)(deg); \\(k\_\\f\\)(kJ mol ^-1^ ); 多重数                                       \\(\\f,k\\)          4.2.13
          异常二面角                ` dihedrals `               4             2                                        \\(\\x_0\\)(deg); \\(k\_\\x\\)(kJ mol ^-1^ rad ^-2^ )                                          所有              4.2.12
   Ryckaert-Bellemans二面角         ` dihedrals `               4             3                                           \\(C_0, C_1, C_2, C_3, C_4, C_5\\)(kJ mol ^-1^ )                                            所有              4.2.13
        周期异常二面角              ` dihedrals `               4             4                                         \\(\\f_s\\)(deg); \\(k\_\\f\\)(kJ mol ^-1^ ); 多重数                                       \\(\\f,k\\)          4.2.12
         傅立叶二面角               ` dihedrals `               4             5                                             \\(C_0, C_1, C_2, C_3, C_4\\)(kJ mol ^-1^ )                                               所有              4.2.13
          表格二面角                ` dihedrals `               4             8                                                   表号(≥0); \\(k\\)(kJ mol ^-1^ )                                                    \\(k\\)            4.2.14
       正常二面角(多重)             ` dihedrals `               4             9                                         \\(\\f_s\\)(deg); \\(k\_\\f\\)(kJ mol ^-1^ ); 多重数                                       \\(\\f,k\\)          4.2.13
          限制二面角                ` dihedrals `               4             11                                            \\(\\f_0\\)(deg); \\(k\_\\f\\)(kJ mol ^-1^ )                                                                4.2.13
        结合弯区扭转势              ` dihedrals `               4             10                                            \\(a_0, a_1, a_2, a_3, a_4\\)(kJ mol ^-1^ )                                                                 4.2.13
             排除                   ` exclusions `              1                                                                       一个或多个原子索引号                                                                              5.4
             约束                ` constraints ` ^§^            2             1                                                            \\(b_0\\)(nm)                                                              所有             4.5, 5.5
     约束\\(\^\\lVert\\)           ` constraints `              2             2                                                            \\(b_0\\)(nm)                                                              所有           4.5, 5.5, 5.4
            SETTLE                   ` settles `                1             1                                              \\(d\_{\\text{oh}}, d\_{\\text{HH}}\\)(nm)                                                               3.6.1, 5.5
         二体虚拟站点             ` virtual_sites2 `            3             1                                                              \\(a\\)()                                                                                    4.7
         三体虚拟站点             ` virtual_sites3 `            4             1                                                             \\(a,b\\)()                                                                                   4.7
       三体虚拟站点(fd)           ` virtual_sites3 `            4             2                                                        \\(a\\)(); \\(d\\)(nm)                                                                             4.7
      三体虚拟站点(fad)           ` virtual_sites3 `            4             3                                                     \\(\\q\\)(deg); \\(d\\)(nm)                                                                           4.7
      三体虚拟站点(out)           ` virtual_sites3 `            4             4                                                    \\(a,b\\)(); \\(c\\)(nm ^-1^ )                                                                         4.7
      四体虚拟站点(fdn)           ` virtual_sites4 `            5             2                                                       \\(a,b\\)(); \\(c\\)(nm)                                                                            4.7
       N体虚拟站点(COG)           ` virtual_sitesn `            1             1                                                       一个或多个构建原子索引号                                                                            4.7
       N体虚拟站点(COM)           ` virtual_sitesn `            1             2                                                       一个或多个构建原子索引号                                                                            4.7
       N体虚拟站点(COW)           ` virtual_sitesn `            1             3                                                   一对或多对构建原子的索引号与权重                                                                        4.7
           位置约束            ` position_restraints `          1             1                                               \\(k_x,k_y,k_z\\)(kJ mol ^-1^ nm ^-2^ )                                                 所有               4.3.1
         平底位置约束          ` position_restraints `          1             2                                             \\(g,r\\)(nm), \\(k\\)(kJ mol ^-1^ nm ^-2^ )                                                                 4.3.2
           距离约束            ` distance_restraints `          2             1                                              类型; 标签; 下限, 上限1, 上限2(nm); 权重()                                                                  4.3.5
          二面角约束           ` dihedral_restraints `          4             1                                                 \\(\\f_0\\)(deg); \\(\\D\\f\\)(deg);                                                  所有               4.3.4
           方向约束           ` orientation_restraints `        2             1                              exp.; 标签; \\(\\a\\); \\(c\\)(U nm ^\\(\\a\\)^ ); obs.(U); 权重(U ^-1^ )                                                   4.3.6
           角度约束              ` angle_restraints `           4             1                                          \\(\\q_0\\)(deg); \\(k_c\\)(kJ mol ^-1^ ); 多重数                                         \\(\\q,k\\)           4.3.3
         角度约束(z)            ` angle_restraints_z `          2             1                                          \\(\\q_0\\)(deg); \\(k_c\\)(kJ mol ^-1^ ); 多重数                                         \\(\\q,k\\)           4.3.3

  : 表 5.5: ` [ moleculetype ] ` 指令详解

-   \*: 指令所需的原子数目
-   †: 用于选择的函数类型编号
-   ‡: 表示自由能计算时这种相互作用的哪些参数可以进行插值
-   §: ` grompp ` 会利用这种相互作用类型产生排除
-   ¶: ` grompp ` 会将这种相互作用类型转换为约束
-   \*\*: 组合规则确定LJ参数的类型, 参见5.3.2节
-   [ \\(\\lVert\\) ]{.math} : 无连接, 因此不会为这种相互作用产生排除

文件布局说明:

-   分号( ` ; ` )和换行符之间为注释

-   忽略 ` \ ` 后的换行符, 即 ` \ ` 为续行符

-   ` [ ` 和 ` ] ` 之间为指令

-   拓扑等级(必须遵循)包含三个层次:

    -   参数级别, 定义了一些力场的设定(见表 5.4)
    -   分子级别, 应包含一个或多个分子的定义(见表 5.5)
    -   体系级别, 只包含体系的特定信息( ` [ system ] ` 及
        ` [ molecules ] ` )

-   每一项应用空格或制表符分格, 而不是逗号

-   分子中的原子应从1开始连续编号

-   相同电荷组中的原子必须连续列出

-   文件只解析一次, 这意味着不会处理向前引用: 每一项在使用前必须进行定义

-   可以从键生成排除, 或手动覆盖

-   可以从原子类型生成键合力的类型, 或对每条键覆盖

-   在同一个原子上可以使用多个相同类型的键合相互作用

-   强烈推荐使用描述性的注释行和空行

-   自GROMACS 3.1.3版本开始, 参数级别的所有指令可使用多次,
    并且没有顺序限制, 除了在其它参数定义中, 原子类型在使用前需要进行定义

-   对相同的原子类型组合, 如果某个相互作用的参数被定义了多次,
    会使用最后定义的参数; 自GROMACS 3.1.3版本开始,
    参数若存在不同值的重定义, ` grompp ` 会生成警告

-   在 ` [ moleculetype ] ` 之前使用 ` [ atoms ] ` , ` [ bonds ] ` ,
    ` [ pairs ] ` , ` [ angles ] ` 等指令毫无意义, 会导致警告

-   在 ` [ system ] ` 之前使用 ` [ molecules ] ` 指令毫无意义,
    会导致警告

-   在 ` [ system ] ` 之后唯一可以使用的指令是 ` [ molecules ] `

-   在 ` [ ] ` 中使用未知的字符串会导致直到下一个指令的所有数据被忽略,
    并产生警告

下面是拓扑文件的一个例子, ` urea.top ` :

    ;
    ;       Example topology file
    ;
    ; The force-field files to be included
    #include "amber99.ff/forcefield.itp"

    [ moleculetype ]
    ; name nrexcl
    Urea        3

    [ atoms ]
       1  C  1  URE    C    1     0.880229    12.01000    ; amber C type
       2  O  1  URE    O    2    -0.613359    16.00000    ; amber O type
       3  N  1  URE   N1    3    -0.923545    14.01000    ; amber N type
       4  H  1  URE  H11    4     0.395055     1.00800    ; amber H type
       5  H  1  URE  H12    5     0.395055     1.00800    ; amber H type
       6  N  1  URE   N2    6    -0.923545    14.01000    ; amber N type
       7  H  1  URE  H21    7     0.395055     1.00800    ; amber H type
       8  H  1  URE  H22    8     0.395055     1.00800    ; amber H type

    [ bonds ]
        1 2
        1 3
        1 6
        3 4
        3 5
        6 7
        6 8

    [ dihedrals ]
    ;   ai    aj    ak    al    funct definition
         2     1     3     4      9
         2     1     3     5      9
         2     1     6     7      9
         2     1     6     8      9
         3     1     6     7      9
         3     1     6     8      9
         6     1     3     4      9
         6     1     3     5      9

    [ dihedrals ]
         3     6     1     2      4
         1     4     3     5      4
         1     7     6     8      4

    [ position_restraints ]
    ; you wouldn't normally use this for a molecule like Urea,
    ; but we include it here for didactic purposes
    ; ai    funct    fc
       1      1     1000  1000  1000    ; Restrain to a point
       2      1     1000     0  1000    ; Restrain to a line (Y-axis)
       3      1     1000     0     0    ; Restrain to a plane (Y-Z-plane)

    [ dihedral_restraints ]
    ; ai  aj  ak  al  type  label  phi  dphi  kfac  power
       3   6   1   2     1      1  180     0     1     2
       1   4   3   5     1      1  180     0     1     2

    ; Include TIP3P water topology
    #include "amber99/tip3p.itp"

    [ system ]
    Urea in Water

    [ molecules ]
    ;molecule name    nr.
    Urea              1
    SOL               1000

下面是此文件的解释说明.

` #include "amber99.ff/forcefield.itp" ` : 包含你正使用的力场的信息,
包括键和非键参数. 本例使用了AMBER99力场, 但你进行模拟时可使用不同的力场.
` grompp ` 会自动找到这个文件并复制粘贴它的内容. 你可以在
` share/top/amber99.ff/forcefield.itp ` 文件中看到它的内容

    #define _FF_AMBER
    #define _FF_AMBER99

    [ defaults ]
    ; nbfunc    comb-rule    gen-pairs    fudgeLJ    fudgeQQ
    1           2            yes          0.5        0.8333

    #include "ffnonbonded.itp"
    #include "ffbonded.itp"
    #include "gbsa.itp"

两个 ` #define ` 语句设置了条件,
这样拓扑文件后面的部分可以知道使用了AMBER 99力场.

` [ defaults ] ` :

-   ` nbfunc ` 为非键函数类型, 取1(Lennard-Jones)或2(Buckingham)
-   ` comb-rule ` 为组合规则的编号(参见5.3.2节).
-   ` gen-pairs ` 用于对的生成. 默认为'no',
    即得到对类型列表的1--4的参数. 当列表中不存在参数时,
    会导致致命错误并停止运行. 设置为'yes'会根据使用 ` fudgeLJ `
    的正常Lennard-Jones参数, 生成不存在于配对列表中的1--4参数
-   ` fudgeLJ ` 为Lennard-Jones 1--4相互作用的修正因子, 默认为1
-   ` fudgeQQ ` 为静电1--4相互作用的修正因子, 默认为1
-   N为6-N势中排斥项的次数(只用于非键Lennard-Jones), 自GROMACS
    4.5版本开始, ` mdrun ` 会读取和使用N, 当N不等于12时,
    使用表格相互作用函数(在旧版本中,
    你必须使用用户自定义的表格相互作用).

**注意** , ` gen-pairs ` , ` fudgeLJ ` , ` fudgeQQ ` 和N是可选的. 仅当
` gen-pairs ` 被设置为'yes'时才会使用 ` fudgeLJ ` , 而总会使用
` fudgeQQ ` . 然而, 如果你想指定N, 你也需要给出其他参数的值.

后面的其他一些 ` #include ` 语句用于添加描述力场其余部分所需的大量数据.
我们将跳过这些并回到 ` urea.top ` 文件. 在那里, 我们会看到

` [ moleculetype ] ` : 定义此 ` *.top ` 文件中分子的名称,
nrexcl=3代表排除不远于三条键的原子之间的非键相互作用.

` [ atoms ] ` : 定义分子, 其中 ` nr ` 和 ` type ` 是固定的,
其余的由用户自定义. 因此 ` atom ` 可以随意命名, ` cgnr `
可大可小(如果可能, 一个电荷组的总电荷应为零), 这里的电荷也可以更改.

` [ bonds ] ` : 不注释.

` [ pairs ] ` : LJ和库仑的1--4相互作用

` [ angles ] ` : 不注释.

` [ dihedrals ] ` : 在此情况下, 有9个正常二面角(funct=1),
3个异常二面角(funct=4), 没有Ryckaert-Bellemans型的二面角.
如果你想在拓扑文件中包含Ryckaert-Bellemans型的二面角,
请遵照下列的示例(例如, 对癸烷):

\[ dihedrals \] ; ai aj ak al funct c0 c1 c2 1 2 3 4 3 2 3 4 5 3

在烷烃势能的原始实现中\[128\], 没有使用1--4相互作用,
这意味着为了使用这个特定的力场, 你需要从拓扑文件的 ` [ pairs ] `
段中移除1--4相互作用. 对大多数的现代力场, 如OPLS/AA或Amber,
其规则是不同的,
Ryckaert-Bellemans势是作为余弦序列与1--4相互作用一起使用的.

` [ position_restraints ] ` :
利用简谐势将选中的粒子约束在参考位置(参见4.3.1节). ` grompp `
会从由单独的坐标文件中读取参考位置.

` [ dihedral_restraints ] ` : 将选定的二面角约束在参考值.
二面角约束的实现方法参见本手册4.3.4节的论述. ` [ dihedral_restraints ] `
指令中设定的参数如下:

-   ` type ` 只有一个可能的值, 1

-   ` label ` 未使用, 并被从代码删除.

-   ` phi ` 为本手册方程4.84和4.85中的 [ \\(\\f_0\\) ]{.math} 值.

-   ` dphi ` 为本手册方程4.85中的 [ \\(\\D \\f\\) ]{.math} 值.

-   ` kfac ` 类似于距离约束中的 ` fac ` , 是力常数的修正因子. 通过它,
    可以利用不同的力常数维持不同的约束.

-   ` power ` 未使用, 并被从代码删除.

` #include "tip3p.itp" ` : 包括一个已经构建好的拓扑文件(参见5.7.2节).

` [ system ] ` : 体系的标题, 用户自定义

` [ molecules ] ` : 定义体系中分子(亚分子)的总数, 这些分子已经在此
` *.top ` 中进行了定义. 在这个示例文件中,
它代表1个尿素分子溶于1000个水分子中. 分子类型SOL是在 ` tip3p.itp `
文件中定义的. 这里的每个名称必须对应于拓扑文件前面的
` [ moleculetype ] ` 中给出的名称. 分子类型块的顺序,
这些分子的数目必须与坐标文件匹配, 坐标文件和拓扑文件会一起提供给
` grompp ` . 分子块不需要连续, 但某些工具(如 ` genion `
)可能只对一个特定分子类型的第一或最后一块起作用. 另外,
这些块与组的定义无关(参见3.3节和8.1节).

### 5.7.2 Molecule.itp文件 {#572-moleculeitp文件}

如果你构建了一个拓扑文件并且经常使用(像水分子, 已经构建好的
` tip3p.itp ` ), 将它做成 ` molecule.itp ` 文件更好一些.
此文件中只列出了一个特定分子的信息, 你可以在多个体系中重用
` [ moleculetype ] ` , 而无需重新调用 ` pdb2gmx ` 或手动复制粘贴. 例子
` urea.itp ` 如下:

    [ moleculetype ]
    ; molname nrexcl
    URE 3

    [ atoms ]
       1  C  1  URE    C    1  0.880229  12.01000  ; amber C type
    ...
       8  H  1  URE  H22    8  0.395055   1.00800  ; amber H type

    [ bonds ]
        1 2
    ...
        6 8

    [ dihedrals ]
    ;   ai  aj  ak  al  funct  definition
         2   1   3   4    9
    ...
         6   1   3   5    9

    [ dihedrals ]
         3   6   1   2    4
         1   4   3   5    4
         1   7   6   8    4

使用 ` *.itp ` 文件会使 ` *.top ` 文件明显变短:

    ;       Example topology file
    ;
    ; The force field files to be included
    #include "amber99.ff/forcefield.itp"

    #include "urea.itp"

    ; Include TIP3P water topology
    #include "amber99/tip3p.itp"

    [ system ]
    Urea in Water

    [ molecules ]
    ;molecule name    nr.
    Urea              1
    SOL               1000

### 5.7.3 ifdef语句 {#573-ifdef语句}

GROMACS有一个非常强大的功能, 你可以在 ` *.top ` 文件中使用 ` #ifdef `
语句. 通过使用这条语句以及相关的 ` #define ` 语句, 像在前面的
` amber99.ff/forcefield.itp ` 文件中那样, 在同一个 ` *.top `
文件中可以为分子使用不同的参数. 下面给出TFE的一个例子,
其中的一个选项对原子使用了不同的电荷: De Loof等人给出的电荷\[129\]或Van
Buuren和Berendsen给出的电荷\[130\]. 实际上, 你可以使用C预处理器 ` cpp `
的许多功能, 因为 ` grompp ` 包含了类似的预处理函数以扫描文件. 使用
` #ifdef ` 选项的方式如下:

-   在 ` *.mdp ` 文件(包含 ` grompp ` 输入参数)中使用选项
    ` define = -DDeLoof ` , 或在 ` *.top ` 中早些使用 ` #define DeLoof `
    , 并且

-   将 ` #ifdef ` 语句放在 ` *.top ` 中, 如所示:

        ...

        [ atoms ]
        ; nr type resnr residu atom cgnr charge mass
        #ifdef DeLoof
        ; Use Charges from DeLoof
           1        C        1        TFE    C    1     0.74
           2        F        1        TFE    F    1    -0.25
           3        F        1        TFE    F    1    -0.25
           4        F        1        TFE    F    1    -0.25
           5      CH2        1        TFE  CH2    1     0.25
           6       OA        1        TFE   OA    1    -0.65
           7       HO        1        TFE   HO    1     0.41
        #else
        ; Use Charges from VanBuuren
           1        C        1        TFE    C    1      0.59
           2        F        1        TFE    F    1     -0.2
           3        F        1        TFE    F    1     -0.2
           4        F        1        TFE    F    1     -0.2
           5      CH2        1        TFE  CH2    1      0.26
           6       OA        1        TFE   OA    1     -0.55
           7       HO        1        TFE   HO    1      0.3
        #endif

        [ bonds ]
        ;  ai    aj  funct           c0           c1
            6     7      1 1.000000e-01 3.138000e+05
            1     2      1 1.360000e-01 4.184000e+05
            1     3      1 1.360000e-01 4.184000e+05
            1     4      1 1.360000e-01 4.184000e+05
            1     5      1 1.530000e-01 3.347000e+05
            5     6      1 1.430000e-01 3.347000e+05
        ...

` pdb2gmx ` 使用这个机制来实现可选的位置约束(4.3.1节), 具体是通过使用
` #include ` 包含 ` .itp ` 文件, 而此文件的只有设置了特定的 ` #define `
(并且拼写正确!)时才有意义.

### 5.7.4 用于自由能计算的拓扑文件 {#574-用于自由能计算的拓扑文件}

两个体系A和B之间的自由能差值, 其计算方法见3.12节的论述.
描述体系A和B的拓扑具有相同数目的分子, 分子的原子数也相同. 通过在
` [ atoms ] ` 指令下添加B参数, 可以对质量和非键相互作用进行微扰.
键合相互作用的微扰可以通过添加B参数到键合类型或键合相互作用来完成.
能够进行微扰的参数列于表 5.4和表 5.5. 相互作用的 [ \\(\\l\\) ]{.math}
依赖性见4.5节的论述. 使用的键参数(位于定义键相互作用的行,
或通过对键合类型列表的原子类型进行查找得到)在表 5.6中进行了解释.
大多数情况下, 处理方式都很直观.
当键合相互作用中A和B的原子类型不完全相同, 且B状态的参数不存在时,
无论是位于行还是键合类型, ` grompp ` 都会使用A状态的参数, 并发出警告.
对自由能计算, 拓扑B( [ \\(\\l= 1\\) ]{.math}
)的所有参数或者添加在同一行, 或者不添加, 添加时位于正常参数之后,
顺序与正常参数相同. 自GROMACS 4.6版本起, 如果 [ \\(\\l\\) ]{.math}
被视为矢量, 那么 ` bonded-lambdas `
分量控制所有未明确标记为约束的键合项. 约束项通过 ` restraint-lambdas `
分量控制.

   B状态与A状态的原子类型完全相同?                               行参数\</br\>A　B                                                     A原子类型的键合类型参数\</br\>A　B                                          B原子类型的键合类型参数\</br\> A　B                                                   信息
  --------------------------------- ---------------------------------------------------------------------------- ------------------------------------------------------------------------------ -------------------------------------------------------------------------- ----------------------------------------------------------------
                 yes                            +AB　-\</br\>+A　+B\</br\>-　-\</br\>-　-\</br\>-　-                          x　x\</br\>x　x\</br\>-　-\</br\>+AB　-\</br\>+A　+B                                                                                                                       错误
                 no                  +AB　-\</br\>+A　+B\</br\>-　-\</br\>-　-\</br\>-　-\</br\>-　-\</br\>-　-   x　x\</br\>x　x\</br\>-　-\</br\>+AB　-\</br\>+A　+B\</br\>+A　x\</br\>+A　x   x　x\</br\>x　x\</br\>x　x\</br\>-　-\</br\>-　-\</br\>+B　-\</br\>+　+B   警告\</br\>　\</br\>错误\</br\>警告\</br\>警告\</br\>　\</br\>

  : 表 5.6: 用于自由能拓扑的键合参数, 位于定义键合相互作用的行,
  或基于原子类型在键类型中查找. A和B表示分别用于状态A和B的参数,
  +和-表示拓扑中(不)存在的参数, x表示存在没有影响.

下面是一个拓扑文件的例子, 将200个丙醇分子转变为200个戊烷分子,
使用了GROMOS--96力场.

    ; Include force field parameters
    #include "gromos43a1.ff/forcefield.itp"
    [ moleculetype ]
    ; Name     nrexcl
    PropPent   3

    [ atoms ]
    ; nr    type  resnr  residue  atom  cgnr  charge    mass    typeB   chargeB   massB
      1       H     1      PROP     PH     1   0.398    1.008    CH3       0.0   15.035
      2      OA     1      PROP     PO     1  -0.548  15.9994    CH2       0.0   14.027
      3     CH2     1      PROP    PC1     1   0.150   14.027    CH2       0.0   14.027
      4     CH2     1      PROP    PC2     2   0.000   14.027
      5     CH3     1      PROP    PC3     2   0.000   15.035

    [ bonds ]
    ; ai    aj    funct    par_A    par_B
       1     2        2    gb_1     gb_26
       2     3        2    gb_17    gb_26
       3     4        2    gb_26    gb_26
       4     5        2    gb_26

    [ pairs ]
    ; ai    aj     funct
       1     4         1
       2     5         1

    [ angles ]
    ; ai    aj    ak    funct    par_A    par_B
       1     2     3        2    ga_11    ga_14
       2     3     4        2    ga_14    ga_14
       3     4     5        2    ga_14    ga_14

    [ dihedrals ]
    ; ai    aj    ak    al    funct    par_A    par_B
       1     2     3     4        1    gd_12    gd_17
       2     3     4     5        1    gd_17    gd_17

    [ system ]
    ; Name
    Propanol to Pentane

    [ molecules ]
    ; Compound    #mols
    PropPent      200

未微扰的 ` PC2 ` 和 ` PC3 ` 原子不需要指定B状态参数,
因为所用B参数将从A参数复制得来.
原子间不微扰的键合相互作用不需要指定B参数, 如示例拓扑中的最后一条键.
使用OPLS/AA力场的拓扑根本不需要键合参数, 因为A和B参数都由原子类型决定.
涉及一个或两个微扰原子的非键相互作用将使用自由能微扰函数形式,
两个非微扰原子间的非键相互作用使用正常的函数形式. 这意味着, 例如,
当只对粒子的电荷进行微扰时, 若lambda不等于0或1,
其Lennard-Jones相互作用也会受到影响.

**注意** , 此拓扑文件使用了GROMOS--96力场,
其中的键合相互作用不是由原子类型决定的.
键合相互作用的字符串由C预处理器转换而来. 力场参数文件包含这样的行:

    #define  gb_26    0.1530    7.1500e+06

    #define  gd_17    0.000     5.86         3

### 5.7.5 约束力 {#575-约束力}

一个分子中两个原子之间的约束力, 可以使用自由能微扰代码进行计算,
计算时在两个原子之间添加约束, 约束对拓扑A和B具有不同长度.
当B的长度比A大1 nm时, lambda保持为零, 哈密顿量对lambda的导数就是约束力.
对分子之间的约束, 可以使用拉扯代码, 参见6.4节. 下面是一个具体的例子,
通过组合两个甲烷成一个"分子", 计算水中的两个甲烷分子距离0.7
nm时的约束力. **注意** ,
GROMACS中"分子"的定义不一定对应于分子的化学定义. 在GROMACS中,
一个"分子"可被定义为希望同时考虑的任意一组原子. 添加的约束函数类型为2,
意味着它不被用于生成排除(参见5.4节). 注意约束自由能项被包含在导数项中,
并且具体被包含在 ` bonded-lambdas ` 部分中. 然而, 改变约束的自由能
**没有** 被包含在用于BAR和MBAR的势能差值中,
因为这需要对每个约束分量重新计算能量. 我们计划在以后的版本中实现此功能.

    ; Include force-field parameters
    #include "gromos43a1.ff/forcefield.itp"

    [ moleculetype ]
    ; Name           nrexcl
    Methanes              1

    [ atoms ]
    ; nr    type    resnr    residu    atom cgnr charge    mass
       1     CH4      1       CH4       C1    1      0    16.043
       2     CH4      1       CH4       C2    2      0    16.043
    [ constraints ]
    ; ai      aj  funct    length_A    length_B
       1       2      2         0.7         1.7

    #include "gromos43a1.ff/spc.itp"
    [ system ]
    ; Name
    Methanes in Water

    [ molecules ]
    ; Compound    #mols
    Methanes          1
    SOL            2002

### 5.7.6 坐标文件 {#576-坐标文件}

扩展名为 ` .gro ` 的文件包含了GROMOS--87格式的分子结构.
这种文件的一个示例片段如下:

    MD of 2 waters, reformat step, PA aug-91
        6
        1WATER  OW1    1   0.126   1.624   1.679   0.1227  -0.0580   0.0434
        1WATER  HW2    2   0.190   1.661   1.747   0.8085   0.3191  -0.7791
        1WATER  HW3    3   0.177   1.568   1.613  -0.9045  -2.6469   1.3180
        2WATER  OW1    4   1.275   0.053   0.622   0.2519   0.3140  -0.1734
        2WATER  HW2    5   1.337   0.002   0.680  -1.0641  -1.1349   0.0257
        2WATER  HW3    6   1.326   0.120   0.568   1.9427  -0.8216  -0.0244
       1.82060 1.82060 1.82060

格式是固定, 即, 所有列的位置都固定.
如果你想在自己的程序中读取这样的文件, 而不使用GROMACS库,
你可以使用以下格式:

**C格式** : ` "%5i%5s%5s%5i%8.3f%8.3f%8.3f%8.4f%8.4f%8.4f" `

或更准确一点, 包含标题等内容, 应该像这样:

    "%s\n", Title
    "%5d\n", natoms
    for (i=0; (i<natoms); i++) {
      "%5d%-5s%5s%5d%8.3f%8.3f%8.3f%8.4f%8.4f%8.4f\n",
      residuenr, residuename, atomname, atomnr, x, y, z, vx, vy, vz
    }
    "%10.5f%10.5f%10.5f%10.5f%10.5f%10.5f%10.5f%10.5f%10.5f\n",
      box[X][X], box[Y][Y], box[Z][Z],
      box[X][Y], box[X][Z], box[Y][X], box[Y][Z], box[Z][X], box[Z][Y]

**Fortran格式** : ` (i5, 2a5, i5, 3f8.3, 3f8.4) `

因此 ` confin.gro ` 是GROMACS坐标文件,
几乎与GROMOS--87文件(对GROMOS用户: 当使用 ` ntx=7 ` 时)相同.
唯一的区别是, GROMACS对盒子使用了张量, 而不是向量.

## 5.8 力场的组织 {#58-力场的组织}

### 5.8.1 力场文件 {#581-力场文件}

默认提供了许多力场, 并根据 ` <name>.ff ` 目录的存在进行检测, 位于
` $GMXLIB/share/gromacs/top ` 的子目录和/或工作目录中. ` pdb2gmx `
会打印出力场文件的位置信息, 因此你可以很容易地知道调用了哪个版本的力场,
以防你在一个或另一个位置进行了修改. GROMACS包含了以下力场:

-   AMBER03蛋白质, 核酸 AMBER94(Duan et al., *J. Comp. Chem.* 24,
    1999--2012, **2003** )
-   AMBER94力场(Cornell et al., *JACS* 117, 5179--5197, **1995** )
-   AMBER96蛋白质, 核酸AMBER94(Kollman et al., *Acc. Chem. Res.* 29,
    461--469, **1996** )
-   AMBER99蛋白质, 核酸AMBER94((Wang et al., *J. Comp. Chem. 21* ,
    1049--1074, **2000** )
-   AMBER99SB蛋白质, 核酸AMBER94(Hornak et al., *Proteins* 65, 712--725,
    **2006** )
-   AMBER99SB-ILDN蛋白质, 核酸AMBER94(Lindorff-Larsen et al., *Proteins
    78* , 1950--58, **2010** )
-   AMBERGS力场(Garcia & Sanbonmatsu, *PNAS* 99, 2782--2787, **2002** )
-   CHARMM27全原子力场(CHARM22与CMAP的蛋白质力场)
-   GROMOS96 43a1力场
-   GROMOS96 43a2力场(改进了烷烃二面角)
-   GROMOS96 45a3力场((Schuler *JCC* **2001** 22 1205)
-   GROMOS96 53a5力场( *JCC* **2004** vol 25 pag 1656)
-   GROMOS96 53a6力场( *JCC* **2004** vol 25 pag 1656)
-   GROMOS96 54a7力场( *Eur. Biophys. J.* ( **2011** ), 40, 843--856,
    DOI: 10.1007/s00249--011--0700--9)
-   OPLS-AA/L全原子力场(2001氨基酸二面角)

力场被包含在拓扑文件的开始, 使用 ` #include ` 语句, 后面跟着
` <name>.ff/forcefield.itp ` . 此语句包含力场文件, 反过来,
被包含的力场文件也可包含其它力场文件. 所有的力场以同样方式进行组织.
力场的一个例子 ` amber99.ff/forcefield.itp ` 见5.7.1节.

对每个力场, 有一些文件只被 ` pdb2gmx ` 使用. 它们是: 残基数据库(
` .rtp ` , 参见5.6.1节), 氢数据库( ` .hdb ` , 参见5.6.4节),
两个末端数据库( ` .n.tdb ` 和 ` .c.tdb ` , 参见5.6.5节),
只包含质量的原子类型数据库( ` .atp ` , 参见5.2.1节).
其他可选的文件参见5.6节的论述.

### 5.8.2 改变力场参数 {#582-改变力场参数}

如果你想更改分子中少量的键相互作用的参数, 最容易的方法是, 直接在
` *.top ` 文件 ` [ moleculetype ] `
段(参见5.7.1节的格式和单位说明)的键相互作用的定义之后输入参数.
如果想更改一种相互作用所有实例中的参数, 你可以在力场文件更改,
或者在包含力场之后添加一个新的 ` [ ???types ] ` 段.
如果一种相互作用参数被定义了多次, 会使用最后的定义. 对GROMACS 3.1.3版本,
当使用不同的值重定义参数时, 会导致警告.
建议不要更改原子类型的Lennard-Jones参数,
因为在GROMOS力场中一些原子类型组合的Lennard-Jones参数并不是根据标准组合规则生成的.
这些组合(以及其他可能遵循组合规则的)在 ` [ nonbond_params ] `
段进行定义, 更改原子类型的Lennard-Jones参数对这些组合没有影响.

### 5.8.3 添加原子类型 {#583-添加原子类型}

对GROMACS 3.1.3版本, 在包含正常力场之后, 可以使用额外的
` [ atomtypes ] ` 段添加原子类型. 在新的原子类型定义之后,
可以定义另外的非键参数和对参数. 对3.1.3版本以前的GROMACS,
新的原子类型需要添加到力场文件的 ` [ atomtypes ] ` 段, 因为在最后的
` [ atomtypes ] ` 段之上的所有非键参数都会使用标准的组合规则覆盖.

------------------------------------------------------------------------

------------------------------------------------------------------------

![](/jscss/molsimart.png){style="display:table;margin:0 auto;height:150px"}
[个](javascript:scroll(0,0)){#scrollTop}
:::
::: site-header
::: wrap




""
:::
:::

::: wrap
# GROMACS中文手册：第六章　专题





## 6.1 自由能计算的实现 {#61-自由能计算的实现}

计算自由能时, 必须指定两个条件: 结束状态以及连接结束状态的途径.
指定结束状态的方式有两种, 最直接的方法是在拓扑中指定结束状态.
大多数势能函数形式既支持A状态也支持B状态. 每当指定两种状态时,
A状态对应于初始自由能态, 而B状态对应于最终的状态.

在一些情况下, 也可以仅仅通过 ` .mdp ` 文件来定义结束状态,
而无须改变拓扑, 这可以通过使用 ` couple-moltype ` , ` couple-lambda0 ` ,
` couple-lambda1 ` , ` couple-intramol ` 等mdp关键词完成.
` couple-moltype `
所选定的任何分子类型会自动获得一个B状态(与一个重新定义的A状态),
B状态是根据 ` couple-lambda ` 关键词隐式地构建的, ` couple-lambda0 ` 和
` couple-lambda1 ` 定义了出现于A状态( ` couple-lambda0 ` )和B状态(
` couple-lambda1 ` )中的非键参数, 可用选项有'q', 'vdw'和'vdw-q',
它们分别代表了库仑, van der Waals或二者的参数,
这些参数在各自的状态中可以被关闭.

一旦定义了结束状态, 就必须定义结束状态之间的途径,
途径只需要在.mdp文件中定义. 从4.6版本开始, [ \\(\\l\\) ]{.math}
是一个向量, 它的库仑, van der Waals, 键合, 约束,
质量分量都可以独立地进行调整.
这样我们在同一模拟中就可以线性地关闭库仑项, 然后是使用软核势的van der
Waals项. 对于副本交换或扩展系综模拟, 这尤其有用. 因为对这两种模拟,
为改进采样, 在同一模拟中对相互作用从有到无的所有途径进行采样非常重要.

` fep-lambdas ` 是 [ \\(\\l\\) ]{.math} 的默认数组, 其值的范围从0到1.
如果没有指定, 其他所有 [ \\(\\l\\) ]{.math} 数组都会使用此数组中的值.
以前使用单个 [ \\(\\l\\) ]{.math} 变量控制途径的做法, 可以通过仅使用
` fep-lambdas ` 定义途径的方法.

例如, 如果你想首先改变库仑项, 然后是van der Waals项, 同时以与van der
Waals项同样的速率改变键合项, 并在整个模拟的前三分之二改变约束项,
那么你可以使用下面的 [ \\(\\l\\) ]{.math} 向量:

    coul-lambdas      = 0.0  0.2  0.5  1.0  1.0  1.0  1.0  1.0  1.0  1.0
    vdw-lambdas       = 0.0  0.0  0.0  0.0  0.4  0.5  0.6  0.7  0.8  1.0
    bonded-lambdas    = 0.0  0.0  0.0  0.0  0.4  0.5  0.6  0.7  0.8  1.0
    restraint-lambdas = 0.0  0.0  0.1  0.2  0.3  0.5  0.7  1.0  1.0  1.0

这等价于下面的设置:

    fep-lambdas       = 0.0  0.0  0.0  0.0  0.4  0.5  0.6  0.7  0.8  1.0
    coul-lambdas      = 0.0  0.2  0.5  1.0  1.0  1.0  1.0  1.0  1.0  1.0
    restraint-lambdas = 0.0  0.0  0.1  0.2  0.3  0.5  0.7  1.0  1.0  1.0

在这种情况下, ` fep-lambda ` 数组作为默认值被填充到键合与van der
Waals相互作用的 [ \\(\\l\\) ]{.math} 数组中. 通常,
最好时明确列出所有的数组, 以确保进行了正确的赋值.

如果你只想打开从A到B的约束, 那么可以使用下面的设置:

    restraint-lambdas = 0.0 0.1 0.2 0.4 0.6 1.0

这样, [ \\(\\l\\) ]{.math} 向量的其他所有分量都将保持A状态的值.

使用热力学积分计算与向量 [ \\(\\l\\) ]{.math} 对应的自由能时,
TI方程变为矢量方程:

[ \\\[\\D F=\\int \\left\< \\nabla H \\right\> \\centerdot \\rmd{\\vec
\\l} \\tag{6.1}\\\] ]{.math}

或对有限差分有:

[ \\\[\\D F \\approx \\int \\sum \\left\< \\nabla H \\right\>
\\centerdot \\rmd{\\l} \\tag{6.2}\\\] ]{.math}

从 <https://SimTK.org/home/pymbar> 下载的外部脚本 ` pymbar `
可以计算根据GROMACS的dhdl.xvg输出自动计算此积分.

## 6.2 平均力势 {#62-平均力势}

平均力势(PMF, potential of mean
force)是对构型系综的平均力进行积分得到的势能. 在GROMACS中,
有几种不同的方法可用于计算平均力. 每一种方法都有其局限性, 如下所述.

-   **牵引代码** : 用于分子或分子组质心之间.
-   **使用简谐键或约束的自由能代码** : 单个原子之间.
-   **位置约束的自由能代码** : 改变相对不动原子组的构型.
-   **有限情况的牵引代码** : 原子组之间, 它们是较大分子的一部分,
    其中的键使用了SHAKE或LINCS约束. 如果牵引组较大, 会使用牵引代码.

下面两节中更详细地讨论牵引和自由能代码.

**熵效应**

当两个原子或两个组的质心之间的距离被约束或束缚时, 由于两个组的旋转,
PMF会含有单纯由熵引起贡献\[131\]. 对于有两个非相互作用质量的体系,
平均力势为:

[ \\\[V\_{pmf}(r)=-(n_c-1)k_B T \\log(r) \\tag{6.3}\\\] ]{.math}

其中 [ \\(n_c\\) ]{.math} 为约束的维数(例如: 对正常的约束 [ \\(n_c=3\\)
]{.math} , 仅在 [ \\(z\\) ]{.math} 方向存在约束时, [ \\(n_c=1\\)
]{.math} ). 是否需要校正这一贡献取决于你需要的PMF.
当你想要将底物牵引到蛋白质中时, 这个熵对应的项确实对要做的功有贡献.
但当计算溶剂中两个溶质之间的PMF以便用于无溶剂的模拟时, 应该移除熵的贡献.
**注意** , 此项可能显著; 300 K时, 若距离减半, 贡献为3.5 kJ mol ^-1^ .

## 6.3 非均衡牵引 {#63-非均衡牵引}

当连续改变两个组之间的距离时, 会对体系做功,
这意味着体系不再处于平衡状态. 尽管在缓慢牵引的极限情况下,
体系会处于平衡状态, 但对于许多体系,
这种极限情况在可行的计算时间内部无法达到. 然而,
使用Jarzynski关系\[132\], 从两个距离之间的许多非平衡模拟,
可以得到平衡的自由能变化 [ \\(\\D G\\) ]{.math}

[ \\\[\\D G\_{AB}=-k_B T\\log \\left\< e\^{-\\b W\_{AB}} \\right\>\_A
\\tag{6.4}\\\] ]{.math}

其中 [ \\(W\_{AB}\\) ]{.math}
为强制体系从状态A沿某路径到达状态B所需的功,
尖括号表示对初始状态A的正则系综进行平均, [ \\(\\b=1/k_BT\\) ]{.math} .

## 6.4 牵引代码 {#64-牵引代码}

牵引代码会在一对或多对原子组的质量的中心之间施加力或约束.
每个牵引的反应坐标被称为"坐标", 它作用于两个牵引组.
一个牵引组可以是一个或多个牵引坐标的一部分. 此外,
坐标还可以作用于单个组或空间中的绝对参考位置. 两个组之间的距离可根据1,
2或3个维度来计算, 或者沿着用户定义的向量进行计算. 参考距离可以是恒定的,
或者可以随时间线性变化. 正常情况下, 所有的原子都根据质量进行加权,
但也可以使用额外的加权因子.

<figure>
<img src="/GMX/6.1.png"
alt="图6.1: 使用伞形牵引将脂分子拉出双脂层的示意图. $V_{rup}$ 为弹簧是收缩速度, $Z_{link}$ 为弹簧附着的原子, $Z_{spring}$ 为弹簧的位置." />
<figcaption>图6.1: 使用伞形牵引将脂分子拉出双脂层的示意图. <span
class="math"> \(V_{rup}\) </span> 为弹簧是收缩速度, <span class="math">
\(Z_{link}\) </span> 为弹簧附着的原子, <span class="math">
\(Z_{spring}\) </span> 为弹簧的位置.</figcaption>
</figure>

GMX支持三种不同类型的牵引计算, 对所有类型的牵引, 参考距离可以是恒定,
或是随时间线性变化.

1.  **伞形牵引** 在两个组的质心之间施加简谐势. 因此, 力正比于位移.
2.  **约束牵引** 约束两组质心之间的距离. 约束力可以写入到文件中.
    此方法使用SHAKE算法, 但当仅约束两个组时, 为精确只需要1次迭代.
3.  **恒力牵引** 在两个质心之间施加恒定的力. 因此, 势能是线性的.
    在这种情况下, 牵引速度没有参考距离.

**质量中心的定义**

在GROMACS中, 有三种方法来定义的一组原子的质量中心.
标准方式是使用"普通"质心, 可能带有附加的权重因子. 使用周期性边界条件时,
就无法再唯一地定义一组原子的质量中心. 因此, 会使用一个参考原子.
为确定质量中心, 对于组中其他所有的原子, 会使用到参考原子最近的周期影象.
这样唯一地定义了质量中心. 默认情况下,
会使用中间的原子(根据拓扑中的顺序)作为参考原子,
但用户也可以选择使用任何其原子, 如果它更接近于组的中心.

对于多层系统, 例如双脂层, 可能需要计算脂分子的PMF,
它是脂分子到整个双层的距离的函数. 在这种情况下, 整个双层可作为参考组,
但也可以为PMF定义更局部的反应坐标. ` .mdp ` 选项
` pull_geometry = cylinder ` 并不使用参考组中的所有原子,
而是动态地仅仅使用那些位于圆柱内的原子. 圆柱的半径为 ` r_1 ` ,
围绕着通过牵引组的牵引向量. 这仅适用于一维定义的距离,
并且圆柱的长轴沿着定义距离的方向. 也可以使用 ` r_0 ` 定义第二个圆柱,
并且使用一个线性切换函数对距离位于 ` r_0 ` 和 ` r_1 `
之间的原子进行加权. 这可以平滑原子进出圆柱的的影响(导致牵引力出现跃变).

<figure>
<img src="/GMX/6.2.png"
alt="图6.2: 比较普通质心参考组和用于界面体系的圆柱参考组. C为参考组. 圆圈代表两个组的质心加上参考组, $d_c$ 为参考距离." />
<figcaption>图6.2: 比较普通质心参考组和用于界面体系的圆柱参考组.
C为参考组. 圆圈代表两个组的质心加上参考组, <span class="math"> \(d_c\)
</span> 为参考距离.</figcaption>
</figure>

对周期性的体系中的一组分子, 可能无法明确地定义一个普通的参考组. 例如在 [
\\(x\\) ]{.math} 和 [ \\(y\\) ]{.math} 方向周期性相连, 但在 [ \\(z\\)
]{.math} 方向具有两个液-气界面的水板坯. 在这样的设置中,
水分子可以从液体中蒸发, 并穿过蒸汽, 通过周期性边界, 到达另一个界面.
这种体系固有的周期性使得我们无法合适地定义一个沿着 [ \\(z\\) ]{.math}
方向的"普通"质心.
一个合适的解决方法对参考组中的所有原子使用一个余弦形的加权剖面.
此剖面单元格胞中的单周期余弦, 并对其相位进行了优化,
使得能够给出权重的最大加和, 包括质量权重.
当所有原子都位于单元格胞长度一半的范围内时,
这种方法提供了唯一和连续的参考位置, 几乎等同于普通的质心位置.
请参看文献\[133\]了解详细信息.

当在计算过程中使用相对权重 [ \\(\\w_i\\) ]{.math} 时,
无论是输入中提供的权重, 还是因圆柱几何或余弦加权引入的权重,
都需要对权重进行缩放, 以保证动量守恒:

[ \\\[\\w_i\'= \\left. \\w_i \\Sum\_{j=1}\^N \\w_j m_j \\middle/
\\Sum\_{j=1}\^N \\w_j\^2 m_j \\right. \\tag{6.5}\\\] ]{.math}

其中 [ \\(m_i\\) ]{.math} 为组中原子 [ \\(j\\) ]{.math} 的质量.
计算约束力时所需要的组的质量为:

[ \\\[M=\\sum\_{i=1}\^N \\w_i\' m_i \\tag{6.6}\\\] ]{.math}

加权的质量中心的定义为:

[ \\\[\\bi r\_{com}=\\left. \\sum\_{i=1}\^N \\w_i\' m_i \\bi r_i
\\middle/ M \\right. \\tag{6.7}\\\] ]{.math}

根据质心, 可计算作用在每组上的AFM, 约束或伞形力 [ \\(\\bi F\_{com}\\)
]{.math} . 作用于组质心上的力会按下式重新分配到原子上:

[ \\\[\\bi F_i = {\\w_i\' m_i \\over M} \\bi F\_{com} \\tag{6.8}\\\]
]{.math}

**局限性**

有一个理论局限性: 严格的来说, 只能计算某些组之间的约束力,
这些组没有通过约束连接到体系的其余部分.
如果一个组包含的一部分分子的键长被约束,
应该同时迭代牵引约束和LINCS或SHAKE的键约束算法. GROMACS还无发做到这点.
这意味着, 若模拟时在 ` .mdp ` 文件中使用了 ` constraints = all-bonds `
选项, 严格地说, 牵引仅限于整个分子或分子组. 在一些情况下,
通过使用自由能代码可以避免此限制,参加6.7节. 在实践中,
当牵引组包含大量原子和/或牵引力很小时,
因不对两种约束算法同时进行迭代导致的误差可忽略不计. 在这些情况下,
相比于键长, 牵引组的约束校正唯一很小.

## 6.5 强制旋转 {#65-强制旋转}

这个模块可用于强制一组原子进行旋转, 例如一个蛋白质亚基的旋转.
有多种旋转势能, 其中复杂的类型,
在模拟过程中允许灵活地适应旋转亚基以及局部旋转轴.
一个示例应用可以在文献\[134\]中找到.

### 6.5.1 固定轴旋转 {#651-固定轴旋转}

**具有各向同性势的固定轴**

在固定轴方法中(参见图6.3 B), 对一组 [ \\(N\\) ]{.math} 个, 位置为 [
\\(\\bi x_i\\) ]{.math} 的原子(记为"旋转组"),
作用于其上的力矩是通过旋转一组参考原子位置-通常是他们的初始位置 [
\\(\\bi y_i\^0\\) ]{.math} -施加的, 旋转以恒定角速度 [ \\(\\w\\)
]{.math} 绕着由方向向量 [ \\(\\hat{\\bi v}\\) ]{.math} 和支点 [ \\(\\bi
u\\) ]{.math} 定义的轴线进行. 为此, 每个位置为 [ \\(\\bi x_i\\) ]{.math}
的原子利用"虚拟"弹簧势能附着到它移动的参考位置 [ \\(\\bi y_i=\\bi
\\W(t)(\\bi y\^0_i- \\bi u)\\) ]{.math} , 其中 [ \\(\\bi \\W(t)\\)
]{.math} 是一个矩阵, 描述了绕轴的旋转. 对最简单的情况,
"弹簧"是利用简谐势描述的,

[ \\\[V\^{\\text{iso} }= {k\\over2} \\Sum\_{i=1}\^N \\w_i \\left\[ \\bi
\\W(t)(\\bi y_i\^0-\\bi u)-(\\bi x_i-\\bi u) \\right\]\^2 \\tag{6.9}\\\]
]{.math}

并具有可选的质量加权前因子 [ \\(\\w_i = N m_i/M\\) ]{.math} , 总质量 [
\\(M=\\S\_{i=1}\^N m_i\\) ]{.math} . 旋转矩阵 [ \\(\\bi \\W(t)\\)
]{.math} 为

[ \\\[\\bi \\W(t)=\\pmat \\cos \\w t + v_x\^2\\x & v_x v_y\\x - v_z
\\sin \\w t & v_x v_z\\x + v_y \\sin \\w t \\\\ v_x v_y\\x + v_z \\sin
\\w t & \\cos \\w t + v_y\^2\\x & v_y v_z\\x - v_x \\sin \\w t \\\\ v_x
v_z\\x - v_y \\sin \\w t & v_y v_z\\x + v_x \\sin \\w t & \\cos \\w
t+v_z\^2\\x \\\\ \\epmat\\\] ]{.math}

<figure>
<img src="/GMX/6.3.png"
alt="图6.3: 固定轴旋转和柔性轴旋转的比较. A: 当使用固定转轴(虚线)时, 旋转白色管状空腔内的形状可产生假象. 更实际的, 形状会围绕成像一个轴承(灰色)内部的柔性的管道清洁器(虚线). B: 围绕轴 $\bi v$ 与由向量 $\bi u$ 指定的支点进行的固定旋转. C: 将旋转片段细分为板坯, 每个板坯具有独立的旋转轴($\uparrow$)和支点($\bullet$)以满足灵活性. 具有索引 $n$ 和 $n+1$ 的两个板坯之间的距离为 $\D x$." />
<figcaption>图6.3: 固定轴旋转和柔性轴旋转的比较. A:
当使用固定转轴(虚线)时, 旋转白色管状空腔内的形状可产生假象. 更实际的,
形状会围绕成像一个轴承(灰色)内部的柔性的管道清洁器(虚线). B: 围绕轴
<span class="math"> \(\bi v\) </span> 与由向量 <span class="math"> \(\bi
u\) </span> 指定的支点进行的固定旋转. C: 将旋转片段细分为板坯,
每个板坯具有独立的旋转轴( <span class="math"> \(\uparrow\) </span>
)和支点( <span class="math"> \(\bullet\) </span> )以满足灵活性. 具有索引
<span class="math"> \(n\) </span> 和 <span class="math"> \(n+1\) </span>
的两个板坯之间的距离为 <span class="math"> \(\D x\) </span>
.</figcaption>
</figure>

其中 [ \\(v_x, v_y, v_z\\) ]{.math} 为归一化的旋转向量 [ \\(\\hat v\\)
]{.math} 的分量, [ \\(\\x:= 1-\\cos(\\w t)\\) ]{.math} . 如图6.4A所示,
对单个原子 [ \\(j\\) ]{.math} , 旋转矩阵 [ \\(\\bi \\W(t)\\) ]{.math}
作用于 [ \\(t=t_0\\) ]{.math} 时刻原子 [ \\(j\\) ]{.math} 的初始参考位置
[ \\(\\bi y_j\^0=\\bi x_j(t_0)\\) ]{.math} . 在其后的时刻 [ \\(t\\)
]{.math} , 参考位置已旋转远离其初始位置(沿蓝色虚线), 从而产生力

[ \\\[\\bi F_j\^{\\text{iso}}=-\\nabla_j V\^{\\text{iso}}=k \\w_j
\\left\[\\bi \\W(t) (\\bi y_j\^0- \\bi u)-(\\bi x_j-\\bi u)\\right\]
\\tag{6.10}\\\] ]{.math}

此力指向参考位置.

**无支点各向同性势**

不使用固定的支点矢量 [ \\(\\bi u\\) ]{.math} ,
该势能使用旋转组的质量中心 [ \\(\\bi x_c\\) ]{.math} 作为旋转轴的支点,

[ \\\[\\bi x_c={1 \\over M}\\sum\_{i=1}\^N m_i \\bi x_i, \\;\\; \\bi
y_c\^0={1 \\over M}\\sum\_{i=1}\^N m_i \\bi y_i\^0 \\tag{6.11}\\\]
]{.math}

这就得到了了"无支点"的各向同性势

[ \\\[V\^{\\text{iso-pf}}={k\\over2} \\Sum\_{i=1}\^N \\w_i \\left\[\\bi
\\W(t)(\\bi y_i\^0-\\bi y_c\^0)-(\\bi x_i-\\bi x_c)\\right\]\^2
\\tag{6.12}\\\] ]{.math}

<figure>
<img src="/GMX/6.4.png"
alt="图6.4: 不同的旋转势的选择和符号的定义. 对位于 $\bi x_j(t)$ 的单个原子显示了所有四个势能函数 $V$(彩色编码). A: 各向同性势 $V^{\text{iso} }$, B: 径向运动势 $V^{\text{rm} }$ 和柔性势 $V^{\text{flex} }$, C-D: 径向运动二型势 $V^{\text{rm2} }$ 和柔性二型势 $V^{\text{flex2} }$, 其中 $\e&#39;$ 分布为0 nm2(C)和0.01 nm2(D). 旋转轴垂直于平面并标记为 $\otimes$. 浅灰色等值线表示 $\bi x_j$ 平面内的波尔兹曼因子 $e^{-V/(k_BT)}$, $T= 300$ K, $k$ = 200 kJ/(mol·nm2). 绿色箭头显示了作用于原子 $j$ 上的力 $\bi F_j$ 的方向; 蓝色虚线表示参考位置的运动." />
<figcaption>图6.4: 不同的旋转势的选择和符号的定义. 对位于 <span
class="math"> \(\bi x_j(t)\) </span> 的单个原子显示了所有四个势能函数
<span class="math"> \(V\) </span> (彩色编码). A: 各向同性势 <span
class="math"> \(V^{\text{iso} }\) </span> , B: 径向运动势 <span
class="math"> \(V^{\text{rm} }\) </span> 和柔性势 <span class="math">
\(V^{\text{flex} }\) </span> , C-D: 径向运动二型势 <span class="math">
\(V^{\text{rm2} }\) </span> 和柔性二型势 <span class="math">
\(V^{\text{flex2} }\) </span> , 其中 <span class="math"> \(\e'\) </span>
分布为0 nm <sup>2</sup> (C)和0.01 nm <sup>2</sup> (D).
旋转轴垂直于平面并标记为 <span class="math"> \(\otimes\) </span> .
浅灰色等值线表示 <span class="math"> \(\bi x_j\) </span>
平面内的波尔兹曼因子 <span class="math"> \(e^{-V/(k_BT)}\) </span> ,
<span class="math"> \(T= 300\) </span> K, <span class="math"> \(k\)
</span> = 200 kJ/(mol·nm <sup>2</sup> ). 绿色箭头显示了作用于原子 <span
class="math"> \(j\) </span> 上的力 <span class="math"> \(\bi F_j\)
</span> 的方向; 蓝色虚线表示参考位置的运动.</figcaption>
</figure>

相应的力为

[ \\\[F\^{\\text{iso-pf}}= k\\w_j \\left\[\\bi \\W(t)(\\bi y_j\^0-\\bi
y_c\^0)-(\\bi x_j-\\bi x_c)\\right\] \\tag{6.13}\\\] ]{.math}

如果不使用质量加权, 支点 [ \\(\\bi x_c\\) ]{.math} 为组的几何中心.

**平行运动势的变体**

由各​​向同性势产生的力(方程6.9和6.12)还含有平行于旋转轴的成分,
从而限制了沿整个旋转组(对 [ \\(V\^{\\text{iso} }\\) ]{.math}
)轴线或旋转组内(对 [ \\(V\^{\\text{iso-pf} }\\) ]{.math} )轴线的运动.
如果倾向于不限制沿轴线的运动,
我们已经通过消除势能所有平行于旋转轴的分量实现了"平行运动"的一种变体.
通过投影参考和实际位置之间的距离向量

[ \\\[\\bi r_i=\\bi \\W(t)(\\bi y_i\^0-\\bi u)-(\\bi x_i-\\bi u)
\\tag{6.14}\\\] ]{.math}

到垂直于旋转矢量的平面上,

[ \\\[\\bi r_i\^{\\bot} := \\bi r_i-(\\bi r_i \\cdot \\hat{\\bi v})
\\hat{\\bi v} \\tag{6.15}\\\] ]{.math}

得到

[ \\(\\alg V\^{\\text{pm} } &= {k \\over 2} \\Sum\_{i=1}\^N \\w_i(\\bi
r_i\^\\bot)\^2 \\\\ &= {k\\over2}\\Sum\_{i=1}\^N \\w_i \\{ \\bi
\\W(t)(\\bi y_i\^0-\\bi u)-(\\bi x_i-\\bi u) \\\\
&-\\left\\{\\left\[\\bi \\W(t)(\\bi y_i\^0-\\bi u)-(\\bi x_i-\\bi
u)\\right\] \\cdot \\hat{\\bi v} \\right\\} \\hat{\\bi v} \\}\^2
\\tag{6.16} \\ealg\\) ]{.math}

同样的

[ \\\[\\bi F_j\^{\\text{pm}}=k\\w_j \\bi r_j\^{\\bot} \\tag{6.17}\\\]
]{.math}

**无支点的平行运动势**

将方程6.16中的固定支点 [ \\(\\bi u\\) ]{.math} 替换为质量中心 [ \\(\\bi
x_c\\) ]{.math} 就得到了平行运动势无支点的变体形式. 对

[ \\\[\\bi s_i=\\bi \\W(t)(\\bi y_i\^0-\\bi y_c\^0)-(\\bi x_i-\\bi x_c)
\\tag{6.18}\\\] ]{.math}

各自的势能和力为

[ \\(\\alg V\^{\\text{pm-pf}} &={k\\over2}\\sum\_{i=1}\^N \\w_i(\\bi
s_i\^{\\bot})\^2 \\tag{6.19} \\\\ \\bi F_j\^{\\text{pm-pf}} &=k\\w_j
\\bi s_j\^{\\bot} \\tag{6.20} \\ealg\\) ]{.math}

**径向运动势**

在上述变体中, 转动势能的最小点位于参考位置 [ \\(\\bi y_i\\) ]{.math}
上的一个点(对各向同性势), 或者是通过 [ \\(\\bi y_i\\) ]{.math}
平行于旋转轴的一条线(对平行运动势). 结果, 径向力限制了原子的径向运动.
接下来的两类旋转势, [ \\(V\^{\\text{rm} }\\) ]{.math} 和 [
\\(V\^{\\text{rm2} }\\) ]{.math} , 大大减少甚至消除了这种效应.
第一类变体势, [ \\(V\^{\\text{rm} }\\) ]{.math} (图6.4B),
消除了所有平行于连接参考原子和旋转轴向量的力的分量,

[ \\\[V\^{\\text{rm}}={k\\over2}\\sum\_{i=1}\^N \\w_i\[ \\bi p_i \\cdot
(\\bi x_i-\\bi u)\]\^2 \\tag{6.21}\\\] ]{.math}

其中

[ \\\[\\bi p_i:={ \\hat{\\bi v} \\times \\bi \\W(t)(\\bi y_i\^0-\\bi u)
\\over \\\| \\hat{\\bi v} \\times \\bi \\W(t)(\\bi y_i\^0-\\bi u) \\\|}
\\tag{6.22}\\\] ]{.math}

该变体只取决于原子 [ \\(i\\) ]{.math} 到由 [ \\(\\hat{\\bi v}\\)
]{.math} 和 [ \\(\\bi \\W(t)(\\bi y_i\^0-\\bi u)\\) ]{.math}
张成的平面的距离 [ \\(\\bi p_i \\cdot(\\bi x_i - \\bi u)\\) ]{.math} .
相应的力为

[ \\\[\\bi F_j\^{\\text{rm}}=-k\\w_j \\left\[ \\bi p_j \\cdot (\\bi
x_j-\\bi u)\\right\] \\bi p_j \\tag{6.23}\\\] ]{.math}

**无支点的径向运动势**

类似于无支点的各向同性势, 我们可以得到上面势能无支点的形式. 对

[ \\\[\\bi q_i:={ \\hat{\\bi v} \\times \\bi \\W(t)(\\bi y_i\^0-\\bi u)
\\over \\\| \\hat{\\bi v} \\times \\bi \\W(t)(\\bi y_i\^0-\\bi u) \\\|}
\\tag{6.24}\\\] ]{.math}

对这种径向运动势无支点的变体形式, 势能和力分别为

[ \\(\\alg V\^{\\text{rm-pf}} &={k\\over2}\\sum\_{i=1}\^N \\w_i \[\\bi
q_i \\cdot (\\bi x_i-\\bi x_c)\]\^2 \\tag{6.25} \\\\ \\bi
F_j\^{\\text{rm-pf}} &= -k \\w_j \\left\[ \\bi q_j \\cdot (\\bi x_j-\\bi
x_c)\\right\] \\bi q_j +k{m_j\\over M}\\Sum\_{i=1}\^N \\w_i\[\\bi q_i
\\cdot (\\bi x_i -\\bi x_c)\] \\bi q_i \\tag{6.26} \\ealg\\) ]{.math}

**二型径向运动势**

如图6.4B, 由 [ \\(V\^{\\text{rm} }\\) ]{.math}
产生的力仍包含小的二阶径向分量. 大多数情况下, 这种扰动可以容忍;
如果不能容忍, 可以使用备选的势能函数 [ \\(V\^{\\text{rm2} }\\) ]{.math}
, 它完全消除了力径向部分的贡献, 如图6.4C所示,

[ \\\[V\^{\\text{rm2}} ={k\\over2} \\Sum\_{i=1}\^N \\w_i { \[
(\\hat{\\bi v} \\times (\\bi x_i-\\bi u) \\cdot \\bi \\W(t)(\\bi
y_i\^0-\\bi u)\]\^2 \\over \\\| \\hat{\\bi v} \\times (\\bi x_i-\\bi u)
\\\|\^2 +\\e\'} \\tag{6.27}\\\] ]{.math}

其中, 引入了小参数 [ \\(\\e\'\\) ]{.math} 以避免奇异性. 对 [
\\(\\e\'=0\\) ]{.math} nm ^2^ , 等势能平面由 [ \\(\\bi x_i-\\bi u\\)
]{.math} 和 [ \\(\\hat{\\bi v}\\) ]{.math} 张成, 得到的力垂直于 [
\\(\\bi x_i-\\bi u\\) ]{.math} ,
因此不会再压缩会扩展远离或朝向旋转轴的结构部分.

在方程6.27的分母中使用一个小的正值的 [ \\(e\'\\) ]{.math} (例如, [
\\(\\e\'= 0.01\\) ]{.math} nm ^2^ , 图6.4D)会得到一个定义良好的势能函数,
并且连续的力也靠近旋转轴, 但 [ \\(\\e\'=0\\) ]{.math} nm ^2^
时(图6.4C)不是这样. 对

[ \\(\\alg \\bi r_i &:=\\bi \\W(t)(\\bi y_i\^0-\\bi u) \\tag{6.28} \\\\
\\bi s_i &:={\\hat{\\bi v} \\times (\\bi x_i-\\bi u) \\over
\\\|\\hat{\\bi v} \\times (\\bi x_i-\\bi u)\\\|} \\equiv \\Y_i
\\hat{\\bi v} \\times (\\bi x_i-\\bi u) \\tag{6.29} \\\\ \\Y_i\^\* &:=
{1 \\over \\\|\\hat{\\bi v} \\times (\\bi x_i-\\bi u)\\\|\^2+\\e\'}
\\tag{6.30} \\ealg\\) ]{.math}

作用在原子 [ \\(j\\) ]{.math} 上的力为

[ \\\[\\bi F_j\^{\\text{rm2} }=-k \\left\\{ \\w_j(\\bi s_j \\cdot \\bi
r_j) \\left\[ {\\Y_j\^\* \\over \\Y_j} \\bi r_j-{\\Y_j\^{\*2} \\over
\\Y_j\^3} (\\bi s_j \\cdot \\bi r_j) \\bi s_j \\right\] \\right\\}
\\times \\hat{\\bi v} \\tag{6.31}\\\] ]{.math}

**二型无支点径向运动势**

上面势能的无支点变体形式为

[ \\\[V\^{\\text{rm2-pf} }={k \\over 2} \\Sum\_{i=1}\^N \\w_i {
\[(\\hat{\\bi v} \\times (\\bi x_i-\\bi x_c)) \\cdot \\bi \\W(t)(\\bi
y_i\^0-\\bi y_c)\]\^2 \\over \\\|\\hat{\\bi v} \\times (\\bi x_i-\\bi
x_c) \\\|\^2+ \\e\'} \\tag{6.32}\\\] ]{.math}

其中

[ \\(\\alg \\bi r_i &:= \\W(t)(\\bi y_i\^0-\\bi y_c) \\tag{6.33} \\\\
\\bi s_i &:= {\\hat{\\bi v} \\times (\\bi x_i-\\bi x_c) \\over
\\\|\\hat{\\bi v} \\times (\\bi x_i-\\bi x_c)\\\|} \\equiv \\Y_i
\\hat{\\bi v} \\times (\\bi x_i-\\bi x_c) \\tag{6.34} \\\\ \\Y_i\^\*
&:={1\\over \\\|\\hat{\\bi v} \\times (\\bi x_i-\\bi x_c) \\\|\^2+\\e\'}
\\tag{6.35} \\ealg\\) ]{.math}

作用于原子 [ \\(j\\) ]{.math} 上的力为

[ \\(\\alg \\bi F_j\^{\\text{rm2-pf} } = &-k\\left\\{ \\w_j (\\bi s_j
\\cdot \\bi r_j) \\left\[ {\\Y_j\^\* \\over \\Y_j} \\bi
r_j-{\\Y_j\^{\*2} \\over \\Y_j\^3} (\\bi s_j \\cdot \\bi r_j) \\bi
s_j\\right\]\\right\\} \\times \\hat{\\bi v} \\\\ &+k{m_j \\over M}
\\left\\{ \\Sum\_{i=1}\^N \\w_i (\\bi s_i \\cdot \\bi r_i) \\left\[
{\\Y_i\^\* \\over \\Y_i} \\bi r_i-{\\Y_i\^{\*2} \\over \\Y_i\^3} (\\bi
s_i \\cdot \\bi r_i) \\bi s_i\\right\]\\right\\} \\times \\hat{\\bi v}
\\tag{6.36} \\ealg\\) ]{.math}

### 6.5.2 柔性轴旋转 {#652-柔性轴旋转}

如图6.3A-B所示, 固定轴旋转方案的刚体行为对于许多应用而言是一个缺点.
特别是, 当平衡的原子位置直接依赖于参考位置时, 旋转组的变形会被抑制.
为避免这种限制, 现在将方程6.26和6.32推广到图6.3C示意的"柔性轴".
具体做法是将旋转组划分为一些列等间距的板坯, 每个板坯垂直于旋转向量,
并对每个板坯施加独立的旋转势. 图6.3C中点线表示板坯的中间平面,
大的黑点表示板坯的中心.

<figure>
<img src="/GMX/6.5.png"
alt="图6.5: 中心位于 $n \D x$ 的高斯函数 $g_n$, 板坯距离 $\D x=1.5$ nm, $n \ge -2$. 高斯函数 $g_0$ 以粗体突出显示; 虚线表示所显示的高斯函数的总和." />
<figcaption>图6.5: 中心位于 <span class="math"> \(n \D x\) </span>
的高斯函数 <span class="math"> \(g_n\) </span> , 板坯距离 <span
class="math"> \(\D x=1.5\) </span> nm, <span class="math"> \(n \ge -2\)
</span> . 高斯函数 <span class="math"> \(g_0\) </span> 以粗体突出显示;
虚线表示所显示的高斯函数的总和.</figcaption>
</figure>

为避免势能与力的不连续性, 我们定义了"软板坯", 根据每个板坯 [ \\(n\\)
]{.math} 对总势能函数 [ \\(V\^{\\text{flex} }\\) ]{.math}
的贡献进行加权, 加权时使用高斯函数

[ \\\[g_n(\\bi x_i)=\\G \\exp\\left(-{\\b_n\^2(\\bi x_i) \\over
2\\s\^2}\\right) \\tag{6.37}\\\] ]{.math}

其中心位于第 [ \\(n\\) ]{.math} 个板坯中间的平面上. 这里的 [ \\(\\s\\)
]{.math} 为高斯函数的宽度, [ \\(\\D x\\) ]{.math} 为相邻板坯间的距离,

[ \\\[\\b_n(\\bi x_i) := \\bi x_i \\cdot \\hat{\\bi v} - n \\D x
\\tag{6.38}\\\] ]{.math}

最方便的一个选择是 [ \\(\\s=0.7 \\D x\\) ]{.math} , 并且

[ \\\[1/\\G=\\Sum\_{n \\in Z} \\exp \\left(-{(n-{1\\over4})\^2 \\over 2
\\cdot 0.7\^2} \\right) \\approx 1.75464\\\] ]{.math}

这样得到的总和几乎是恒定的, 基本上与 [ \\(\\bi x_i\\) ]{.math}
无关(图6.5中虚线所示), 即

[ \\\[\\Sum\_{n\\in Z} g_n(\\bi x_i)=1+\\e(\\bi x_i) \\tag{6.39}\\\]
]{.math}

其中 [ \\(\\abs{\\e(\\bi x_i)} \<1.3 \\cdot 10\^{-4}\\) ]{.math} .
这一选择也意味着板坯对力的各自贡献加起来等于1,
这样就不再需要进一步的归一化了.

对每个板坯中心 [ \\(\\bi x_c\\) ]{.math} ,
所有原子的贡献来源于其高斯加权的(也可选择使用质量加权)位置向量 [
\\(g_n(\\bi x_i) \\bi x_i\\) ]{.math} . 瞬时板坯中心 [ \\(\\bi x_c\^n\\)
]{.math} 根据当前位置 [ \\(\\bi x_i\\) ]{.math} 进行计算

[ \\\[\\bi x_c\^n={\\S\_{i=1}\^N g_n(\\bi x_i) m_i \\bi x_i \\over
\\S\_{i=1}\^N g_n(\\bi x_i) m_i} \\tag{6.40}\\\] ]{.math}

而参考中心 [ \\(\\bi y_c\^n\\) ]{.math} 根据参考位置 [ \\(\\bi y_i\^0\\)
]{.math} 进行计算

[ \\\[\\bi y_c\^n ={\\S\_{i=1}\^N g_n(\\bi y_i\^0) m_i \\bi y_i\^0
\\over \\S\_{i=1}\^N g_n(\\bi y_i\^0) m_i} \\tag{6.41}\\\] ]{.math}

由于 [ \\(g_n\\) ]{.math} 衰减很快, 每个板坯将主要涉及距板坯中心 [
\\(\\approx 3\\D x\\) ]{.math} 内的原子的贡献.

**柔性轴势**

我们考虑两种柔性轴的变体. 在第一种变体中,
将高斯加权的板坯划分过程应用到径向运动势中(方程6.26/图6.4B)中,
就得到了板坯 [ \\(n\\) ]{.math} 的贡献

[ \\\[V\^n={k\\over2} \\Sum\_{i=1}\^N \\w_i g_n(\\bi x_i)\[ \\bi q_i\^n
\\cdot (\\bi x_i-\\bi x_c\^n)\]\^2\\\] ]{.math}

总的势能函数

[ \\\[V\^{\\text{flex} }=\\Sum_n V\^n \\tag{6.42}\\\] ]{.math}

注意, 方程6.26中使用的全局质心 [ \\(\\bi x_c\\) ]{.math} 现在被 [
\\(\\bi x_c\^n\\) ]{.math} 代替, 它是板坯的质心. 对

[ \\(\\alg \\bi q_i\^n &:={\\hat{\\bi v} \\times \\bi \\W(t)(\\bi
y_i\^0-\\bi y_c\^n) \\over \\\| \\hat{\\bi v} \\times \\bi \\W(t)(\\bi
y_i\^0-\\bi y_c\^n)\\\|} \\tag{6.43} \\\\ b_i\^n &:= \\bi q_i\^n \\cdot
(\\bi x_i-\\bi x_c\^n) \\tag{6.44} \\ealg\\) ]{.math}

作用在原子 [ \\(j\\) ]{.math} 上的力为

[ \\(\\alg \\bi F_j\^{\\text{flex} }= &-k \\w_j \\Sum_n g_n(\\bi x_j)
b_j\^n \\left\\{\\bi q_j\^n-b_j\^n {\\b_n(\\bi x_j) \\over 2\\s\^2}
\\hat{\\bi v} \\right\\} \\\\ &+k m_j \\Sum_n {g_n(\\bi x_j) \\over
\\S_h g_n(\\bi x_h)} \\Sum\_{i=1}\^N \\w_i g_n(\\bi x_i) b_i\^n
\\left\\{ \\bi q_i\^n- {\\b_n(\\bi x_j) \\over \\s\^2} \[\\bi q_i\^n
\\cdot (\\bi x_j-\\bi x_c\^n)\] \\hat{\\bi v} \\right\\} \\tag{6.45}
\\ealg\\) ]{.math}

注意, 对定义的 [ \\(V\^{\\text{flex} }\\) ]{.math} ,
板坯在空间中是固定的, 参考中心 [ \\(\\bi y_c\^n\\) ]{.math} 也一样.
如果在模拟中, 旋转组沿 [ \\(\\bi v\\) ]{.math} 方向移动得太远,
它可能会进入一个没有定义参考板坯中心的区域-由于缺少附近的参考位置-这样就不可能对势能进行计算.
因此, 对这个势能, 我们给出了一个略加修改的版本,
它能够避免前面所说的问题, 具体做法是将板坯 [ \\(n=0\\) ]{.math}
的中间平面附着到旋转组的中心, 这样得到的板坯会与旋转组一起移动.
通过从位置中减去组的质心 [ \\(\\bi x_c\\) ]{.math} ,

[ \\\[\\tilde{\\bi x}\_i=\\bi x_i-\\bi x_c, \\tilde{\\bi y}\_i\^0=\\bi
y_i\^0-\\bi y_c\^0 \\tag{6.46}\\\] ]{.math}

这样

[ \\\[V\^{\\text{flex2} }={k\\over2} \\Sum_n \\Sum\_{i=1}\^N \\w_i
g_n(\\tilde{\\bi x_i}) \\left\[ { (\\hat{\\bi v} \\times \\bi
\\W(t)(\\tilde{\\bi y}\_i\^0-\\tilde{\\bi y}\_c\^n) \\over
\\\|\\hat{\\bi v} \\times \\bi \\W(t)(\\tilde{\\bi y}\_i\^0-\\tilde{\\bi
y}\_c\^n)\\\|} \\cdot (\\tilde{\\bi x}\_i-\\tilde{\\bi x}\_c\^n)
\\right\]\^2 \\tag{6.47}\\\] ]{.math}

为了简化力的导数, 以及出于效率的考虑, 我们在这里假定 [ \\(\\bi x_c\\)
]{.math} 是恒定的, 因此 [ \\(\\partial \\bi x_c/\\partial x = \\partial
\\bi x_c/\\partial y=\\partial \\bi x_c/\\partial z=0\\) ]{.math} ,
这种得到的力误差很小(数量级为 [ \\(O(1/N)\\) ]{.math} 或 [
\\(O(m_j/M)\\) ]{.math} , 如果使用质量加权的话), 因此可以容忍.
利用这一假定, 力 [ \\(\\bi F\^{\\text{flex-t} }\\) ]{.math}
与方程6.45具有相同的形式.

**二型柔性轴势**

第二种变体是将势 [ \\(V\^{\\text{rm2} }\\) ]{.math}
(方程6.32)用于划分的板坯, 得到了无径向力贡献的柔性轴(图6.4C)

[ \\\[V\^{\\text{flex2} }={k\\over2} \\Sum\_{i=1}\^N \\Sum_n \\w_i
g_n(\\bi x_i) { \[(\\hat{\\bi v} \\times (\\bi x_i-\\bi x_c\^n)) \\cdot
\\bi \\W(t) (\\bi y_i\^0-\\bi y_c\^n)\]\^2 \\over \\\| \\hat{\\bi v}
\\times (\\bi x_i-\\bi x_c\^n) \\\|\^2+\\e\'} \\tag{6.48}\\\] ]{.math}

其中

[ \\(\\alg \\bi r_i\^n &:= \\bi \\W(t)(\\bi y_i\^0-\\bi y_c\^n)
\\tag{6.49} \\\\ \\bi s_i\^n &:= {\\hat{\\bi v} \\times (\\bi x_i-\\bi
x_c\^n) \\over \\\| \\hat{\\bi v} \\times (\\bi x_i-\\bi x_c\^n) \\\|}
\\equiv \\y_i \\hat{\\bi v} \\times (\\bi x_i-\\bi x_c\^n) \\tag{6.50}
\\\\ \\y_i\^\* &:={1 \\over \\\| \\hat{\\bi v} \\times (\\bi x_i-\\bi
x_c\^n)\\\|\^2+\\e\'} \\tag{6.51} \\\\ W_j\^n &:= {g_n(\\bi x_j) m_j
\\over \\s_h g_n(\\bi x_h) m_h } \\tag{6.52} \\\\ \\bi S\^n &:=
\\Sum\_{i=1}\^N \\w_i g_n(\\bi x_i)(\\bi s_i\^n \\cdot \\bi r_j\^n)
\\left\[ {\\y_i\^\* \\over \\y_i} \\bi r_i\^n-{\\y_i\^{\*2} \\over
\\y_i\^3}(\\bi s_i\^n \\cdot \\bi r_i\^n) \\bi s_i\^n \\right\]
\\tag{6.53} \\ealg\\) ]{.math}

作用于原子 [ \\(j\\) ]{.math} 上的力为

[ \\(\\alg \\bi F_j\^{\\text{flex2} } = & -k\\left\\{ \\Sum_n \\w_j
g_n(\\bi x_j) (\\bi s_j\^n \\cdot \\bi r_j\^n) \\left\[ {\\y_j\^\*
\\over \\y_j} \\bi r_j\^n-{\\y_j\^{\*2} \\over \\y_j\^3} (\\bi s_j\^n
\\cdot \\bi r_j\^n) \\bi s_j\^n\\right\] \\right\\} \\times \\hat{\\bi
v} \\\\ & +k\\left\\{ \\Sum_n W_j\^n \\bi S\^n \\right\\} \\times
\\hat{\\bi v} -k \\left\\{ \\Sum_n W_j\^n {\\b_n(\\bi x_j) \\over
\\s\^2} {1\\over \\y_j} \\bi s_j\^n \\cdot \\bi S\^n \\right\\}
\\hat{\\bi v} \\\\ & +{k \\over 2}\\left\\{ \\Sum_n \\w_j g_n(\\bi x_j)
{\\b_n(\\bi x_j) \\over \\s\^2} {\\y_j\^\* \\over \\y_j\^2} (\\bi s_j\^n
\\cdot \\bi r_j\^n)\^2 \\right\\} \\hat{\\bi v} \\tag{6.54} \\ealg\\)
]{.math}

应用变换(6.46)可得到二型柔性势"耐平动"的形式, [ \\(V\^{\\text{flex2-t}
}\\) ]{.math} . 再次, 假定 [ \\(\\partial \\bi x_c/\\partial x\\)
]{.math} , [ \\(\\partial \\bi x_c/\\partial y\\) ]{.math} , [
\\(\\partial \\bi x_c/\\partial z\\) ]{.math} 很小, 得到的方程 [
\\(V\^{\\text{flex2-t} }\\) ]{.math} 和 [ \\(\\bi F\^{\\text{flex2-t}
}\\) ]{.math} 分别类似于 [ \\(V\^{\\text{flex2} }\\) ]{.math} 和 [
\\(\\bi F\^{\\text{flex2} }\\) ]{.math} .

### 6.5.3 用法 {#653-用法}

为使用应用强制旋转, 可通过 ` .mdp ` 输入文件中的 ` rot_group0 ` ,
` rot_group1 ` 等索引组定义受到旋转势能作用的粒子 [ \\(i\\) ]{.math} .
参考位置 [ \\(\\bi y_i\^0\\) ]{.math} 由提供给 ` grompp ` 的特殊
` .trr ` 文件中读取. 如果发现发现这样的文件, 会使用 [ \\(\\bi
x_i(t=0)\\) ]{.math} 作为参考位置, 并写入 ` .trr ` ,
这样它们就可以用于随后的设置. 势能的所有参数, 如 [ \\(k\\) ]{.math} , [
\\(\\e\'\\) ]{.math} 等(表 6.1 ). 由 ` .mdp ` 参数提供; ` rot_type `
选择势能的类型. 选项 ` rot_massw ` 选择是否使用质量加权平均. 对柔性势能,
截断值 [ \\(g_n\^{\\text{min} }\\) ]{.math} (典型值为0.001),
可确保只计算对 [ \\(V\\) ]{.math} 和 [ \\(F\\) ]{.math}
有显著贡献的部分, 即那些 [ \\(g_n(\\bi x) \< g_n\^{\\text{min} }\\)
]{.math} 的项被省略. 表6.2总结了写入到附加输出文件的一些量,
将在下面讨论它们.

  -------------------------------------- -------- ---------------- --------------------- -------------- ----------- ------------- ------------- -------------------------- --
                   参数                               \\(k\\)       \\(\\hat{\\bi v}\\)   \\(\\bi u\\)   \\(\\w\\)   \\(\\e\'\\)   \\(\\D x\\)   \\(g_n\^{\\text{min}}\\)  
           ` .mdp ` 输入变量名                           k                  vec              pivot         rate          eps        slab_dist           min_gauss          
                   单位                            kJ mol nm ^-2^           \-                 nm         ^o^ /ps      nm ^2^          nm                   \-             
                                                                                                                                                                           
               固定轴势能:                 方程                                                                                                                            
     各向同性 \\(V\^{\\text{iso} }\\)     (6.9)          X                   X                 X             X           \-            \-                   \-             
    -无支点 \\(V\^{\\text{iso-pf} }\\)    (6.12)         X                   X                 \-            X           \-            \-                   \-             
     平行运动 \\(V\^{\\text{pm} }\\)      (6.16)         X                   X                 X             X           \-            \-                   \-             
    -无支点 \\(V\^{\\text{pm-pf} }\\)     (6.20)         X                   X                 \-            X           \-            \-                   \-             
     径向运动 \\(V\^{\\text{rm} }\\)      (6.21)         X                   X                 X             X           \-            \-                   \-             
    -无支点 \\(V\^{\\text{rm-pf} }\\)     (6.26)         X                   X                 \-            X           \-            \-                   \-             
     二型径向 \\(V\^{\\text{rm2} }\\)     (6.27)         X                   X                 X             X            X            \-                   \-             
    -无支点 \\(V\^{\\text{rm2-pf} }\\)    (6.32)         X                   X                 \-            X            X            \-                   \-             
                                                                                                                                                                           
               柔性轴势能:                 方程                                                                                                                            
      柔性 \\(V\^{\\text{flex} }\\)       (6.42)         X                   X                 \-            X           \-             X                   X              
    -耐平动 \\(V\^{\\text{flex-t} }\\)    (6.47)         X                   X                 \-            X           \-             X                   X              
   二型柔性势 \\(V\^{\\text{flex2} }\\)   (6.48)         X                   X                 \-            X            X             X                   X              
   -耐平动 \\(V\^{\\text{flex2-t} }\\)      \-           X                   X                 \-            X            X             X                   X              
  -------------------------------------- -------- ---------------- --------------------- -------------- ----------- ------------- ------------- -------------------------- --

  : 表6.1: 各种旋转势能所用的参数. X表示给定的势能实际使用的参数.

  物理量                                                    单位                   方程                     输出文件      固定   可变  
  ------------------------------------------------------- -------- ------------------------------------- --------------- ------ ------ --
  \\(V(t)\\)                                               kJ/mol                 参见6.1                 ` rotation `     X      X    
  \\(\\q\_{\\text{ref} }(t)\\)                               度     \\(\\q\_{\\text{ref} }(t)＝\\w t\\)   ` rotation `     X      X    
  \\(\\q\_{\\text{av} }(t)\\)                                度                   (6.55)                  ` rotation `     X      \-   
  \\(\\q\_{\\text{fit} }(t),\\q\_{\\text{fit} }(t,n)\\)      度                   (6.57)                  ` rotangles `    \-     X    
  \\(\\bi y_0(n),\\bi x_0(t,n)\\)                            nm                (6.40, 6.41)               ` rotslabs `     \-     X    
  \\(\\t(t)\\)                                             kJ/mol                 (6.58)                  ` rotation `     X      \-   
  \\(\\t(t, n)\\)                                          kJ/mol                 (6.58)                  ` rottorque `    \-     X    

  : 表 6.2: 强制旋转模拟时记录在输出文件中的物理量. 所有板坯数据每
  ` nstsout ` 步输出一次, 其他旋转数据每 ` nstrout ` 步输出一次.

**旋转组的角度: 固定轴**

对固定轴旋转, 组相对于参考组的平均角度 [ \\(\\q\_{\\text{av} }(t)\\)
]{.math} , 是通过所有旋转组原子到其参考位置的距离加权的角度偏差来确定的,

[ \\\[\\q\_{\\text{av} }=\\Sum\_{i=1}\^N r_i \\q_i/\\Sum\_{i=1}\^N r_i
\\tag{6.55}\\\] ]{.math}

这里 [ \\(r_i\\) ]{.math} 为参考位置到旋转轴的距离, 偏差角 [ \\(\\q_i\\)
]{.math} 由原子位置决定, 投射到垂直于旋转轴并通过支点 [ \\(\\bi u\\)
]{.math} 的平面(参考方程6.15中 [ \\(\\bot\\) ]{.math} 的定义),

[ \\\[\\cos\\q_i={ (\\bi y_i-\\bi u)\^\\bot \\cdot (\\bi x_i-\\bi
u)\^\\bot \\over \\\|(\\bi y_i-\\bi u)\^\\bot \\cdot (\\bi x_i-\\bi
u)\^\\bot \\\|} \\tag{6.56}\\\] ]{.math}

如果实际结构的旋转在参考前, [ \\(\\q\_{\\text{av} }\\) ]{.math}
的符号选择使得 [ \\(\\q\_{\\text{av} } \>0\\) ]{.math} .

**旋转组角度: 柔性轴**

对于柔性轴旋转, 会提供两个输出, 整个旋转组的角度和板坯中片段的分开角度.
确定整个旋转组的角度时, 会使用RMSD匹配将 [ \\(\\bi x_i\\) ]{.math}
匹配到 [ \\(t=0\\) ]{.math} 时刻的参考位置 [ \\(\\bi y_i\^0\\) ]{.math}
, 得到的 [ \\(\\q\_{\\text{fit} }\\) ]{.math} 是参考为达到最佳匹配必须绕
[ \\(\\hat v\\) ]{.math} 旋转的角度,

[ \\\[\\text{RMSD}(\\bi x_i, \\bi \\W(\\q\_{\\text{fit} }) \\bi
y_i\^0)\\overset{!}{=} \\text{min} \\tag{6.57}\\\] ]{.math}

为了确定每个板坯 [ \\(n\\) ]{.math} 的局部角度, 会使用板坯 [ \\(n\\)
]{.math} 的高斯函数对参考和实际位置进行加权, 方程6.57计算的 [
\\(\\q\_{\\text{fit} }(t,n)\\) ]{.math} 来自于高斯加权的位置.

对于所有的角度, ` .mdp ` 输入选项 ` rot_fit_method `
控制是进行正常的RMSD匹配, 还是在匹配时将每个位置 [ \\(\\bi x_i\\)
]{.math} 置于距旋转轴相同的距离作为其参考对应 [ \\(\\bi y\^0_i\\)
]{.math} . 对后一种情况, RMSD只测量了角度差异, 不包含径向部分.

**通过搜索最小能量确定角度**

作为替代方法, 对 ` rot_fit_method = potential ` ,
旋转组的角度取为旋转势能最小时对应的角度. 因此,
需要对围绕当前参考角度的一系列角度计算其对应的旋转势能. 在这种情况下,
` rotangles.log ` 输出文件包含了所选角度对应的旋转势能值,
` rotation.xvg ` 列出了最小势能对应的角度.

**力矩**

对固定轴转动, 旋转势对应的力矩 [ \\(\\bi \\t(t)\\) ]{.math} 如下

[ \\\[\\bi \\t(t)=\\Sum\_{i=1}\^{N} \\bi r_i(t) \\times \\bi
f_i\^\\bot(t) \\tag{6.58}\\\] ]{.math}

其中 [ \\(\\bi r_i(t)\\) ]{.math} 为旋转轴到 [ \\(\\bi x_i(t)\\)
]{.math} 的距离向量, [ \\(\\bi f_i\^\\bot(t)\\) ]{.math} 为垂直于 [
\\(\\bi r_i(t)\\) ]{.math} 和 [ \\(\\hat{\\bi v}\\) ]{.math} 的力分量.
对柔性轴旋转, 会使用板坯的局部旋转轴和高斯加权的位置计算每个板坯的 [
\\(\\bi \\t_n\\) ]{.math} .

## 6.6 计算电生理学 {#66-计算电生理学}

计算电生理学方法(CompEL, Computational
Electrophysiology)\[135\]可用于模拟穿过膜通道的离子流,
这些离子流是由跨膜电位或离子浓度梯度驱动的. 就像在真正细胞中那样,
CompEL中的跨膜电位是通过对穿过膜的电荷维持一个小的不平衡 [ \\(\\D q\\)
]{.math} 实现的. [ \\(\\D q\\) ]{.math} 和膜电容给出了电位差:

\$\$ \\Delta U=\\Delta q/C\_{membrane} \\tag{6.59}\$\$

跨膜电场与浓度梯度由 ` .mdp ` 选项控制, 允许用户设置膜每侧的参考离子数.
如果离子的实际数目与参考数目不同,
并且这种情况持续的时间超过了用户指定的时间,
程序会交换两侧的一些离子对或水对, 直至离子数目恢复到参考数目.
通过计算通道电导性与离子选择性, CompEL模拟也可用于确定通道的逆电位,
它是电生理实验中获得的重要表征参数.

<figure>
<img src="/GMX/6.6.png"
alt="图6.6: CompEL模拟双膜的典型设置(A, B). 图(C)显示了由选择的两侧之间的电荷不平衡 $\D q_{ref}$ 导致的电位差." />
<figcaption>图6.6: CompEL模拟双膜的典型设置(A, B).
图(C)显示了由选择的两侧之间的电荷不平衡 <span class="math"> \(\D
q_{ref}\) </span> 导致的电位差.</figcaption>
</figure>

设置CompEL时, 模拟体系被划分为两个部分, A和B, 它们的离子浓度是独立的,
互不相关. 构建体系的最好方法是利用两个双层体系,
每个都包含感兴趣的通道/孔(图6.6 A, B). 若它们通道的轴方向相同,
这样就可以在正电位和负电位情况下同时观察到通道中的离子流, 这对一些研究,
如通道整流非常重要.

使用 ` gmx potential ` 工具可以很容易地计算跨膜电位差 [ \\(\\D u\\)
]{.math} . 这样在模拟的每个时间段都可以精确地得到沿 [ \\(z\\) ]{.math}
轴或孔轴的电势降低(图6.6 C). 在模拟中, 穿过通道的电荷为 [ \\(q_i\\)
]{.math} 的离子 [ \\(i\\) ]{.math} 的类型与数目都会写入 ` swapions.xvg `
输出文件中. 利用此输出文件, 可确定在每个时间段 [ \\(\\D t\\) ]{.math}
内的平均通道电导值 [ \\(G\\) ]{.math}

[ \\\[G={\\S_i n_i q_i \\over \\Delta t \\Delta U} \\tag{6.60}\\\]
]{.math}

离子选择性可通过不同种类离子数流量的比值来计算. 要想得到最好的结果,
需要对许多重合时间段内的值进行平均.

逆电位的计算最好是利用一系列小的模拟,
每个模拟中使用较小但强度变化的离子不平衡来产生给定的跨膜浓度梯度. 例如,
若一侧含有1 M浓度的盐, 另一侧的浓度为0.1 M, 其余部分保持电荷中性, 可使用
[ \\(\\D q=0 e\\) ]{.math} , [ \\(\\D q=2 e\\) ]{.math} , [ \\(\\D
q=4e\\) ]{.math} 的一系列模拟. 对获得的零电流附近的所有 [ \\(I-U\\)
]{.math} 对, 利用电流电压关系进行线性拟合就可以得到 [ \\(U\_{rev}\\)
]{.math} .

### 6.6.1 使用 {#661-使用}

可利用如下的 ` .mdp ` 选项控制CompEL计算:

    swapcoords     = Z   ; 交换位置 Swap positions: no, X, Y, Z
    swap_frequency = 100 ; 尝试交换的频率 Swap attempt frequency

若你的膜位于 [ \\(xy\\) ]{.math} 平面内, 请选择 ` Z ` (图6.6 A, B).
这样两侧之间的离子交换只依赖于 [ \\(z\\) ]{.math} 的位置.
` swap_frequency ` 决定尝试交换的频繁程度,
进行交换时需要在并行队列之间通讯离子, 溶剂和交换组位置的信息,
若交换频率过高, 会降低运算速度.

    split_group0 = channel0 ; 定义一侧边界 Defines compartment boundary
    split_group1 = channel1 ; 定义另一侧边界 Defines other compartment boundary
    massw_split0 = no       ; 使用质量权重中心 use mass-weighted center?
    massw_split1 = no

` split_group0 ` 和 ` split_group1 ` 为两个索引组,
用于定义两侧之间的边界, 通常是通道的中心. 若 ` massw_split0 ` 或
` massw_split1 ` 设置为 ` yes ` , 会使用每个索引组的质心作为边界,
在这里是 [ \\(z\\) ]{.math} 方向的质心.
否则将使用几何中心(图6.6中A中的×). 如果像这里一样,
一个膜通道被选作划分组, 其中心将定义两侧之间的分隔平面(图中的虚横线).
所有索引组都必须在索引文件中进行定义.

    swap_group    = NA+_CL- ; 交换离子 Ions to be included in exchange
    solvent_group = SOL     ; 溶剂分子的组名称 Group name of solvent molecules
    cyl0_r        = 5.0     ; 划分组孔半径 Split cylinder 0: pore radius (nm)
    cyl0_up       = 0.75    ; 上面延伸 Split cylinder 0 upper extension (nm)
    cyl0_down     = 0.75    ; 下面延伸 Split cylinder 0 lower extension (nm)
    cyl1_r        = 5.0     ; 其他通道设置 same for other channel
    cyl1_up       = 0.75
    cyl1_down     = 0.75
    coupl_steps   = 10      ; 两次平均之间的交换次数 Average over these many swap steps
    threshold     = 1       ; 若小于此值不进行交换 Do not swap if < threshold

` swap_group ` 设置了流和交换循环中所涉及离子的索引组, ` solvent_group `
定义了与离子互换的溶剂组. 圆柱选项只影响离子的计数, 即,
穿过通道0或1的离子会被计数,
计数时依据(通道)圆柱相对于各个划分组位置的半径的定义, 上下扩展.
这并不影响实际的流和交换, 却能提供离子穿过每个通道的次数. 注意,
只有当一个离子在互换步骤中 **处于** 定义的划分圆柱范围内时,
才能认为离子通过了某个特定的通道, 若 ` swap_frequency ` 太高,
特定的离子可能在一个互换步骤中处于A侧, 在下一步骤中却处于B侧,
因此就无法清楚地确定离子到底是穿过了哪个通道.

` coupl_steps ` 设置了尝试互换的步骤数,
也就是每侧中实际离子数与参考离子数之间的差距,
在实际交换发生以前必须尝试的次数. 若 ` coupl_steps ` 设置为1,
那么离子交换与否由瞬时离子分布决定, 而 ` coupl_steps ` \>
1时则由尝试步骤过程中时间平均的离子分布决定. 这适用于一些情况, 例如,
当离子扩散至两侧的边界时, 会导致大量无效的离子交换, ` threshold `
为1意味着进行交换时一侧的平均离子数与设定值至少相差1.
更高的阈值将导致更大容许差距. 离子将交换直至达到设定的数目 [ \\(\\pm\\)
]{.math} 阈值.

    anionsA  = -1 ; A侧离子的参考数目 Reference count of anions in A
    cationsA = -1 ; ... of cations in A
    anionsB  = -1 ; ... of anions in B
    cationsB = -1 ; ... of cations in B

这些选项设定两侧需要的阴离子数与阳离子数. ` -1 `
意味着它们的数目由0时间步的值决定, 并保持不变, 注意,
这些数目应加到互换组的总离子数中.

注意, CompEL模拟的双层体系, 可以很容易地使用下列方法创建. 利用
` gmx editconf -translate 0 0 <l_z> ` 命令沿膜的法线方法(通常为 [
\\(z\\) ]{.math} )重复已有的膜/通道MD体系, 其中 ` l_z `
为重复方向的盒子长度. 如果你已经定义了单层体系通道的索引组, 使用
` gmx make_ndx -n index.ndx -twin ` 可得到双层体系的索引组.

为抑制膜沿互换方向的大的涨落,
采用伞形牵引(参见6.4节)在两个通道和/或双层中心之间施加简谐势(仅作用于交换方向),
可能会有帮助.

**多通道**

如果划分组包含的分子数大于1, 必须正确地选择所有分子相对于彼此的PBC映象,
这样才能正确地确定通道中心. GROMACS假定 ` .tpr `
文件中初始结构的PBC表示是正确的. 设定下面的环境变量可检查是否正确

-   ` GMX_COMPELDUMP ` : 分子完整后后将它的初始结构输出到 ` .pdb ` 文件.

## 6.7 使用自由能代码计算PMF {#67-使用自由能代码计算pmf}

自由能耦合参数方法(参见3.12节)提供了几种计算平均力势的方式.
通过使用简谐势或约束连接两个原子, 可计算它们之间的平均力势.
为达到这个目的, 一些特殊的势能函数可避免产生额外的排除, 参见5.4节.
当状态B中的最小或约束长度比状态A中的大1 nm时, 限制力或约束力为 [
\\(\\partial H/\\partial \\l\\) ]{.math} . 通过设置 ` .mdp ` 文件中的
` delta-lambda ` 可改变原子间的距离, 它是 [ \\(\\l\\) ]{.math}
和时间的函数.
所得到的结果应当与使用伞形抽样或约束抽样得到的结果完全相同(尽管由于实现方法不同数值上不可能完全相同).
与牵引代码不同, 自由能代码也可用于处理约束连接的原子.

也可利用位置限制来计算平均力势. 采用位置限制时,
原子连接到空间中的某一位置, 二者之间具有简谐势(参见4.3.1节).
这些位置可以是耦合参数 [ \\(\\l\\) ]{.math} 的函数. 可利用 ` grompp ` 的
` -r ` 和 ` -rb ` 选项分别设置A状态和B状态的位置.
可以利用这种方法进行靶向MD. 注意, 我们并不鼓励对蛋白质使用靶向MD.
将这些构象作为状态A和B的位置限制坐标,
就可以强制蛋白质从一个构型转换到另一个. 你可以在0和1之间缓慢地改变 [
\\(\\l\\) ]{.math} 的值. 这种方法的主要缺点在于,
蛋白质的构型自由度受到位置限制的严重制约, 而与从状态A到B的变化无关.
此外, 蛋白质由状态A到B的强制转变几乎处于一条直线上,
而实际的路径可能大为不同.
更适合这种方法的体系是固体体系或限制于边界或墙之间的液体.
你可以用这种方法来测量改变与边界或墙之间的距离时所需要的力.
因为边界(或墙)必须要固定. 位置限制并不会限制体系的抽样.

## 6.8 移除最快的自由度 {#68-移除最快的自由度}

MD模拟的最大时间步长由模拟体系中的最小振动周期决定.
键伸缩振动处于量子力学基态, 因此利用约束进行描述比简谐势更好.

对其余的自由度, 最短振动周期(模拟所得)是13 fs, 涉及氢原子键角的振动.
作为一项准则, 使用Verlet(蛙跳式)积分方案时, 对一个简谐振子,
每个周期内至少需要执行5次数值积分步才能达到合理的精度,
相应的最大时间步长约为3 fs. 忽略这些非常快的周期为13 fs的振动,
下一个最短的周期约为20 fs, 相应的最大时间步长约为4 fs.

从氢原子中移除键角自由度的最好方法是将它们定义为虚拟作用位点而不是常规原子.
常规原子通过键, 键角, 二面角连接到分子,
而虚拟位点的位置则根据已定义好的方式,
由三个邻近重原子的位置计算得到(参看4.7节). 对水, 羟基,
巯基或氨基中的氢原子, 不能移除其自由度, 因为需要保留旋转自由度.
除此之外, 唯一可降低这些快速运动的方法是增加氢原子的质量,
但同时也需要增加与氢原子相连的重原子的质量. 这会增大水分子, 羟基,
巯基或氨基的转动惯量, 但不会影响体系的平衡性质,
对体系动力学性质的影响也不会太大. 这些方法将在6.8.1节进行简短的讨论,
以前的论文中有详细的讨论\[136\].

使用虚拟位点并同时修改质量,
下一瓶颈可能是由不当二面角(用于维持分子基团的平面性或手性)和肽的二面角引起.
不可能更改肽的二面角而不影响蛋白质的物理行为.
维持平面性的不当二面角主要用于处理芳香残基, 这些残基中的键, 键角,
二面角也可以替换为稍复杂点的虚拟位点.

本节所讨论的所有修改都可以使用GROMACS的拓扑创建工具 ` pdb2gmx ` 来完成,
其中有单独的选项用于增加氢原子的质量,
虚拟化所有氢原子或虚拟化所有芳香残基. **注意** ,
当全部氢原子都被虚拟化后, 那些处于芳香残基内部的氢原子也将被虚拟化, 即,
对芳香残基中氢原子的处理各不相同, 而是取决于对芳香残基的处理.

当处理拓扑文件时, ` grompp `
会直接从力场参数(键长和键角)中获取氢原子虚拟位点的构建参数. 对芳香残基,
这些构建方法基于力场中结构的键长, 键角, 但这些参数是直接写入 ` pdb2gmx `
源代码中的, 因为对整个芳香基团的构建非常复杂.

### 6.8.1 氢原子的键-键角振动 {#681-氢原子的键-键角振动}

**构建虚拟位点**

将氢原子定义为虚拟位点的目的在于去除所有的高频自由度. 在一些情况下,
不应该去除所有的氢原子自由度,
例如对羟基或氨基应当保留氢原子的旋转自由度.
必须注意构建虚拟位点时不能引入不需要的相关,
例如构建原子间的键-键角振动可能会转变为氢原子的键振动. 另外,
由于虚拟位点没有质量, 根据定义, 为了维持体系的总质量守恒,
被视为虚拟位点的氢原子的质量应当加到与其相连接的重原子上.

<figure>
<img src="/GMX/6.7.png"
alt="图6.7: 氢原子不同类型虚拟位点的构建方式. 黑点为用于构建虚拟位点的原子, 灰点为虚拟位点, 氢原子小于重原子. A. 固定的键角, 注意这种情况下氢原子并不是虚拟位点; B. 位于三原子平面内, 距离固定; C. 位于三原子平面内, 键角与距离固定; D. 氨基的构建方法(-NH2或-NH3+), 详情见下文." />
<figcaption>图6.7: 氢原子不同类型虚拟位点的构建方式.
黑点为用于构建虚拟位点的原子, 灰点为虚拟位点, 氢原子小于重原子. A.
固定的键角, 注意这种情况下氢原子并不是虚拟位点; B. 位于三原子平面内,
距离固定; C. 位于三原子平面内, 键角与距离固定; D. 氨基的构建方法(-NH
<sub>2</sub> 或-NH <sub>3</sub> <sup>+</sup> ), 详情见下文.</figcaption>
</figure>

考虑到这些, 蛋白质中的氢原子可以自然地分为几类,
每一类需要不同的构建方法(参见图6.7).

-   **羟基(-OH)或巯基(-SH)氢原子** :
    羟基中唯一可约束的内部自由度为C-O-H键角.
    通过定义一个额外的具有适当长度的键可对此键角进行固定, 见图6.7 A.
    这样可以去除键角弯曲的高频振动, 同时保留了二面角的旋转自由度.
    对巯基情况相同. **注意** , 在这种情况下氢原子并不被视为虚拟位点.

-   **单个氨基或酰胺(-NH-)和芳香氢原子(-CH-)** :
    不能利用键矢量的线性组合来构建这些氢原子的位置,
    因为重原子之间具有柔性的键角. 作为替代,
    可将氢原子置于与重原子距离固定的位置,
    位于通过成键重原子与两个第二键合原子连线上一点的直线上, 见图6.7 B.

-   **平面氨基(-NH ~2~ )氢原子** :
    用于单个酰胺氢原子的方法用于平面氨基时效果不好,
    因为找不到两个合适的重原子来定义氢原子的方向. 作为替代,
    氢原子被置于距N原子一定距离的位置, 与C原子所成的键角固定,
    处于其他重原子定义的平面上, 键图6.7 C.

-   **氨基(伞形 -NH ~2~ 或-NH ~3~ ^+^ )氢原子** :
    不能由与其相连的重原子来构建具有旋转自由度的氨基氢原子的虚拟位点,
    因为这样做会失去氨基的旋转自由度.
    为保留旋转自由度同时去除氢原子的键-键角自由度, 可构建两个"哑质点",
    它们具有与氨基相同的总质量, 转动惯量(绕C-N键转动)和质心.
    这些哑质点原子与任何其他原子都不存在相互作用, 它们会彼此相连,
    且与碳原子相连, 形成刚性三角形. 由这三个粒子,
    可根据两个碳原子的矢量及其外积的线性组合来构建N和氢原子的位置,
    这样得到的氨基具有旋转自由度, 但不含其他内部自由度, 见图6.7 D.

![图6.8: 芳香残基不同类型虚拟位点的构建方法.
黑点为用于构建虚拟位点的原子, 灰点为虚拟位点, 氢原子小于重原子. A:
苯丙氨酸; B. 络氨酸(注意氢原子并不是虚拟位点); C. 色氨酸; D.
组氨酸](/GMX/6.8.png)

### 6.8.2 芳香基团的面外振动 {#682-芳香基团的面外振动}

芳香残基支链中的平面结构致使它自身就是一个完美的虚拟位点的构建方式,
具有完美的平面基团, 没有本质上不稳定的,
用于维持正常原子处于平面内所需要的约束.
构建的基本方法是定义三个原子或哑质点,
利用三者相互之间的约束来固定几何结构,
并将其余原子作为简单的虚拟位点类型(参见4.7节).
不同的芳香残基需要不同的方法:

-   **苯丙氨酸** : [ \\(\\text{C}\_\\g\\) ]{.math} , [
    \\(\\text{C}\_{\\e1}\\) ]{.math} , [ \\(\\text{C}\_{\\e2}\\)
    ]{.math} 作为正常原子, 但每个的质量为苯基的1/3, 见图6.8 A.
-   **络氨酸** : 对苯环的处理与苯丙氨酸相同. 另外, 在 [
    \\(\\text{C}\_{\\e1}\\) ]{.math} , [ \\(\\text{C}\_{\\e2}\\)
    ]{.math} 和 [ \\(\\text{C}\_\\h\\) ]{.math} 之间定义约束.
    原始的不当二面角可将两个三角形(一个为苯环的, 一个与 [
    \\(\\text{C}\_\\h\\) ]{.math} 有关)维持在平面内, 但由于转动惯量更大,
    约束更稳定. 羟基中的键-键角使用 [ \\(\\text{C}\_\\g\\) ]{.math} 和 [
    \\(\\text{C}\_\\h\\) ]{.math} 之间的约束进行约束. **注意** ,
    氢原子并不视为虚拟位点进行处理, 见图6.8 B.
-   **色氨酸** : 将 [ \\(\\text{C}\_\\b\\) ]{.math} 视为常规原子,
    在每个环的质心创建两个哑质点, 每个的质量等于相应环的总质量( [
    \\(\\text{C}\_{\\d2}\\) ]{.math} 和 [ \\(\\text{C}\_{\\e2}\\)
    ]{.math} 对每个环的贡献为1/2).
    这样做可以保持总质量和转动惯量几乎等于原本的值, 见图6.8 C.
-   **组氨酸** : 将 [ \\(\\text{C}\_\\g\\) ]{.math} , [
    \\(\\text{C}\_{\\e1}\\) ]{.math} , [ \\(\\text{N}\_{\\e2}\\)
    ]{.math} 视为正常原子, 但其质量会重新分配, 这样环的质心保持不变,
    见图6.8 D.

## 6.9 粘度计算 {#69-粘度计算}

剪切粘度是液体的一种性质, 实验上很容易测量. 它可用于力场的参数化,
因为它是一个动力学性质, 而用于力场参数化的大多数其他性质都是热力学性质.
粘度也是一种重要的性质, 因为它会影响液体中溶剂化分子的构象变化的速率.

利用爱因斯坦关系式可以从平衡模拟计算粘度:

[ \\\[\\h ={1\\over2} {V \\over k_BT} \\lim\_{x\\to \\infty} {\\rmd{}
\\over \\rmd t} \\left\\langle \\left( \\int\_{t_0}\^{t_0+t}
P\_{xz}(t\') \\rmd t\' \\right)\^2 \\right\\rangle\_{t_0}
\\tag{6.61}\\\] ]{.math}

这可以利用 ` g_energy ` 进行计算. 这种方法收敛十分缓慢\[137\],
用于确定粘度的精确值时, 即便是纳秒尺度的模拟也可能不够长. 此外,
计算结果非常依赖于对静电的处理.
使用(短的)截断会导致压力的非对角元素出现很大噪声,
可能使计算的粘度值增大一个数量级.

GROMACS也提供了计算粘度的非平衡方法\[137\]. 其原理基于以下事实,
通过外力输入体系的能量会通过粘性摩擦而耗散,
产生的热会通过耦合的热浴移除. 对牛顿流体, 施加一个小的力会导致速度梯度,
其方程如下:

\$\$ a_x(z)+{\\h \\over \\r} \\oppar{v_x(z)} z=0 \\tag{6.62}\$\$

这里我们在 [ \\(x\\) ]{.math} 方向施加了加速度 [ \\(a_x(z)\\) ]{.math} ,
它是坐标 [ \\(z\\) ]{.math} 的函数. 在GROMACS中加速的的剖面为:

[ \\\[a_x(z)=A\\cos \\left( {2\\p z \\over l_z}\\right) \\tag{6.63}\\\]
]{.math}

其中为 [ \\(l_z\\) ]{.math} 为盒子的高度. 产生的速度剖面为:

[ \\\[v_x(z)=V\\cos \\left({2\\p z \\over l_z} \\right) \\tag{6.64}\\\]
]{.math}

[ \\\[V=A {\\r \\over \\h} \\left( {l_z \\over 2\\p} \\right)\^2
\\tag{6.65}\\\] ]{.math}

可利用 [ \\(A\\) ]{.math} 和 [ \\(V\\) ]{.math} 来计算粘度:

[ \\\[\\h ={A \\over V}\\r \\left( {l_z \\over 2\\p} \\right)\^2
\\tag{6.66}\\\] ]{.math}

模拟中 [ \\(V\\) ]{.math} 的定义为

[ \\\[V={\\Sum\_{i=1}\^N m_i v\_{i,x}\^2\\cos \\left({2\\p z \\over l_z}
\\right) \\over \\Sum\_{i=1}\^N m_i } \\tag{6.67}\\\] ]{.math}

产生的速度剖面并不耦合到热浴. 此外计算体系动能时会排除速度剖面.
你可能希望使用尽可能大的 [ \\(V\\) ]{.math} 以得到好的统计,
但剪切速率不能太高, 以免使体系过远地远离平衡态. 当余弦为零时,
剪切速率最大,

[ \\\[\\text{sh}\_{\\max} =\\underset{z}{\\max} \\left\| \\opar{v_x(z)}
z \\right\|=A {\\r \\over \\h} {l_z \\over 2\\p} \\tag{6.68}\\\]
]{.math}

对 [ \\(\\h = 10\^{-3}\\) ]{.math} \[kg m ^-1^ s ^-1^ \], [
\\(\\r=10\^3\\) ]{.math} \[kg m\^--3\], [ \\(l_z = 2\\p\\) ]{.math}
\[nm\]的模拟, [ \\(\\text{sh}\_\\max=1\\) ]{.math} \[ps nm ^-1^ \] [
\\(A\\) ]{.math} . 这个剪切速率应小于体系中最长相关时间的倒数.
对大多数液体, 转动的相关时间最长, 大约为10 ps. 对上面的情况, [ \\(A\\)
]{.math} 应小于0.1 \[nm ps ^-2^ \]. 若剪切速率过高, 观察到的粘度会过低.
由于 [ \\(V\\) ]{.math} 正比于盒子高度的平方, 盒子最好沿 [ \\(z\\)
]{.math} 轴方向延伸. 一般而言, 要得到粘度的精确值, 100
ps的模拟长度足够了.

由粘性摩擦产生的热会被耦合热浴移除. 由于这种耦合并不是瞬时的,
液体的真正温度会稍稍低于观察到的温度. Berendsen推导了这种温度偏移\[30\],
它与剪切速率的关系为:

[ \\\[T_s={\\h \\t \\over 2 \\r C_v} \\text{sh}\_\\max\^2
\\tag{6.69}\\\] ]{.math}

其中 [ \\(\\t\\) ]{.math} 为Berendsen控温器的耦合时间, [ \\(C_v\\)
]{.math} 为热容. 使用上面例子中的值, [ \\(\\t=10\^{-13}\\) ]{.math}
\[s\], [ \\(C_v=2 \\cdot 10\^3\\) ]{.math} \[J kg ^-1^ K ^-1^ \], 可得到
[ \\(T_s=25\\) ]{.math} \[K ps ^-2^ \] [ \\(\\text{sh}\_\\max\^2\\)
]{.math} , 如果需要的剪切速率小于 [ \\(1/10\\) ]{.math} \[ps ^-1^ \], [
\\(T_s\\) ]{.math} 小于0.25 \[K\], 可忽略不计.

**注意** , 当从平衡态开始时, 体系必须要构建速度剖面,
构造所需时间的数量级与液体的相关时间一致.

根据方程6.66得到的 [ \\(V\\) ]{.math} 和 [ \\(1/\\h\\) ]{.math}
这两个量及其平均值与涨落会写入到能量文件.

## 6.10 表格相互作用函数 {#610-表格相互作用函数}

### 6.10.1 势能三次样条插值 {#6101-势能三次样条插值}

在GROMACS的一些内部循环中, 计算势能与力时会使用查表的方法,
并利用三次样条算法对这些表格进行插值. 对静电, 色散,
排斥相互作用会使用独立的表格, 但为了提高缓存性能,
这些项被合并到一个单一的数组中. 对 [ \\(x_i \\le x \\lt x\_{i+1}\\)
]{.math} 的三次样条插值为:

[ \\\[V_s(x)=A_0+A_1 \\e +A_2 \\e\^2+A_3 \\e\^3 \\tag{6.70}\\\] ]{.math}

其中表格间距 [ \\(h\\) ]{.math} 与分数 [ \\(\\e\\) ]{.math} 为:

[ \\\[\\alg h &=x\_{i+1}-x_i \\tag{6.71} \\\\ \\e &= (x-x_i)/h
\\tag{6.72} \\ealg\\\] ]{.math}

因此 [ \\(0 \\le \\e \\lt 1\\) ]{.math} . 由此, 我们可以计算导数得到力:

[ \\\[-V_s\'(x)=- {\\rmd {V_s(x)} \\over \\rmd \\e} {\\rmd \\e \\over
\\rmd x}=-(A_1+2A_2 \\e+3 A_3\\e\^2)/h \\tag{6.73}\\\] ]{.math}

四个系数可以从四个条件得到: [ \\(V_s\\) ]{.math} 和 [ \\(-V_s\'\\)
]{.math} 在每个区间的两端应精确地等于势能 [ \\(V\\) ]{.math} 与力 [
\\(-V\'\\) ]{.math} 的值. 这样得到了每个区间上的误差

[ \\\[\\alg \|V_s-V\|\_\\max &=V\'\'\'\' {h\^4 \\over 384}+O(h\^5)
\\tag{6.74} \\\\ \|V_s\'-V\'\|\_\\max &=V\'\'\'\' {h\^3 \\over 72 \\sqrt
3} +O(h\^4) \\tag{6.75} \\\\ \|V_s\'\'-V\'\'\|\_\\max &=V\'\'\'\' {h\^2
\\over 12}+O(h\^3) \\tag{6.76} \\ealg\\\] ]{.math}

[ \\(V\\) ]{.math} 和 [ \\(V\'\\) ]{.math} 连续, 但 [ \\(V\'\'\\)
]{.math} 一阶不连续. 对混合精度与双精度的GROMACS,
每纳米的点数分别为500和2000.
这意味着势能与力的误差通常小于混合精度的精确度.

GROMACS会存储 [ \\(A_0\\) ]{.math} , [ \\(A1\\) ]{.math} , [ \\(A_2\\)
]{.math} 和 [ \\(A_3\\) ]{.math} .
计算力的子程序会获得一个具有这些参数与缩放因子 [ \\(s\\) ]{.math}
2的表格, [ \\(s\\) ]{.math} 等于每nm的点数( **注意** [ \\(h\\) ]{.math}
的单位为 [ \\(s\^{-1}\\) ]{.math} ). 算法的过程大致如下:

1.  计算距离向量( [ \\(\\bi r\_{ij}\\) ]{.math} )与距离 [ \\(r\_{ij}\\)
    ]{.math}
2.  将 [ \\(r\_{ij}\\) ]{.math} 乘上 [ \\(s\\) ]{.math} , 截断到整数值 [
    \\(n_0\\) ]{.math} 以获得表格中的索引号
3.  计算分数部分( [ \\(\\e=s r\_{ij}-n_0\\) ]{.math} )与 [ \\(\\e\^2\\)
    ]{.math}
4.  利用插值计算势能 [ \\(V\\) ]{.math} 与标量力 [ \\(f\\) ]{.math}
5.  将 [ \\(f\\) ]{.math} 乘上 [ \\(\\bi r\_{ij}\\) ]{.math} ,
    得到矢量力 [ \\(\\bi F\\) ]{.math}

**注意** 查表明显 **慢于** 大部分Lennard-Jones与库仑相互作用的计算.
然而, 它比PPPM方法中使用的移位库仑函数要快很多. 最后,
修改一个势能的表格(得到它的图形表示)要比修改MD程序中的内部循环简单得多.

### 6.10.2 用户自定义势能函数 {#6102-用户自定义势能函数}

你也可以使用自己的势能函数而无需编辑GROMACS的源代码.
势能函数应符合下面的方程

[ \\\[V(r\_{ij})={q_i q_j \\over 4\\p \\e_0} f(r\_{ij})+C_6
g(r\_{ij})+C\_{12} h(r\_{ij}) \\tag{6.77}\\\] ]{.math}

其中 [ \\(f\\) ]{.math} , [ \\(g\\) ]{.math} , [ \\(h\\) ]{.math}
为用户自定义的函数. **注意** 若 [ \\(g\\) ]{.math}
代表正常的色散相互作用, [ \\(g(r)\\) ]{.math} 应 \<0. [ \\(C_6\\)
]{.math} , [ \\(C\_{12}\\) ]{.math} 和电荷由拓扑读入.
也要注意组合规则只支持Lennard-Jones与Buckingham势能函数,
你的表格应匹配二进制拓扑中的参数.

当在你的 ` .mdp ` 文件中添加下面的行时,

    rlist       = 1.0
    coulombtype = User
    rcoulomb    = 1.0
    vdwtype     = User
    rvdw        = 1.0

` mdrun ` 将将读入一个非键相互作用表格文件, 若设置了 ` energygrp-table `
则将读入多个非键相互作用文件(参见下面的说明). 文件的名称可使用 ` mdrun `
的选项 ` -table ` 设置. 表格文件应包含7列用于查询的数据, 依次为: [
\\(x\\) ]{.math} , [ \\(f(x)\\) ]{.math} , [ \\(-f\'(x)\\) ]{.math} , [
\\(g(x)\\) ]{.math} , [ \\(-g\'(x)\\) ]{.math} , [ \\(h(x)\\) ]{.math} ,
[ \\(-f\'(x)\\) ]{.math} . [ \\(x\\) ]{.math} 的范围从0到 [ \\(r_c+1\\)
]{.math} ( ` table_extension ` 的值可在 ` .mdp ` 文件中更改).
可以选择你喜欢的间距. 对标准表格,
GROMACS对混合精度与双精度分别使用了0.002与0.0005 nm. 在这里, [ \\(r_c\\)
]{.math} 表示两个截断 ` rvdw ` 和 ` rcoulomb ` 的最大值(参见上文).
这些变量不需要相同(也不需要为1.0). 一些用作势能的函数在 [ \\(x=0\\)
]{.math} 处存在奇点, 但由于原子彼此之间的距离通常不会小于0.1 nm, [
\\(x=0\\) ]{.math} 处的函数值并不重要. 最后,
也可以将标准的库仑和修改的LJ势组合在一起(反之亦然), 只须指定, 例如
` coulombtype = Cut-off ` 或 ` coulombtype = PME ` , ` vdwtype = User `
. 但表格文件必须始终包含7列, 并且所有列中必须为有意义的数据(不能为零).
你可以在 ` GMXLIB ` 目录中找到一些创建好的表格文件, 它们可用于6--8,
6--9, 6--10, 6--11和6--12 Lennard-Jones势, 并使用了正常的库仑相互作用.

如果想对不同原子组使用不同的函数形式, 可利用能量组进行设置. 利用
` .mdp ` 的 ` energygrp-table `
选项(参见7.3节)可以对不同的两个能量组之间的非键相互作用使用不同的表格.
具有不同相互作用势的原子应放于不同能量组中. 对于列于 ` energygrp-table `
中的能量组对, 会使用正常的表格.
当需要对许多原子类型使用不同的函数形式时, 这种作法更简单一些,

## 6.11 混合量子经典模拟技术 {#611-混合量子经典模拟技术}

在分子力学(MM)力场中电子的影响是利用经验参数进行描述的.
这些参数是基于实验数据得到的, 或是基于高水平的量子化学计算得到的,
对给定共价结构的基态适用. MM近似对基态过程通常足够精确,
在这些过程中原子间所有的键合连接都不会改变.
然而对那些键合连接会改变的过程, 例如化学反应过程或涉及多个量子态的过程,
如光化学转换, 不可忽略电子, 因此需要利用量子力学描述体系,
或是至少需要对体系中反应的那部分用量子力学进行描述.

模拟溶液中或酶中化学反应的一种方法是将量子力学(QM)与分子力学(MM)组合起来,
反应部分使用量子力学方法描述, 同时其余部分以力场描述.
目前的GROMACS版本中提供了几个流行量子化学程序的接口(MOPAC\[138\],
GAMESS-UK\[139\], Gaussian\[140\] and CPMD\[141\]).

在GROMACS中两个体系之间的相互作用可以Field等人的方法\[142\]或Morokuma及其合作者的QM/MM方法\[143,
144\]进行描述.

### 6.11.1 概述 {#6111-概述}

在本版本的GROMACS中可采用两种方法描述QM和MM两子体系之间的相互作用:

1.  **电子嵌入** QM子体系的哈密顿量包含了QM区域的电子与MM原子之间,
    QM原子核与MM原子之间的静电相互作用:

    [ \\\[H\^{QM/MM}=H_e\^{QM}-\\Sum_i\^n \\Sum_J\^M {e\^2 Q_J \\over
    4\\p \\e_0 r\_{iJ} }+\\Sum_A\^N \\Sum_J\^M {e\^2 Z_A Q_J \\over e
    \\p \\e_0 R\_{AJ} } \\tag{6.78}\\\] ]{.math}

    其中 [ \\(n\\) ]{.math} 和 [ \\(N\\) ]{.math}
    分别为QM区域中的电子数与原子核数, [ \\(M\\) ]{.math}
    为带电的MM原子数. 上式右边的第一项为孤立QM体系原始的哈密顿量.
    两个加和项的第一个为QM电子与MM原子之间总的静电相互作用,
    第二个为QM原子核与MM原子之间总的静电相互作用.
    QM原子与MM原子之间的键合相互作用在MM水平以合适的力场项进行描述.
    连接两个子体系之间的化学键使用氢原子进行封端,
    以保证QM区域的原子价层完整. 这类原子上的力只出现于QM区域,
    但会分配到成键的两个原子上. 封端原子通常被称为链接原子.

2.  **ONIOM** 在这种方法中,
    首先会以需要的从头算水平计算孤立QM子体系的能量与梯度,
    接下来会使用MM力场方法计算包含QM区域在内的整个体系的能量与力,
    并将其加到前一步计算得到的能量与力中. 最后,
    因为对QM区域内的相互作用考虑了两次, 为进行校正,
    会使用分子力学对孤立的QM子体系进行计算,
    并从上一步的结果中减去所得的能量与力.
    总的QM/MM能量的计算表达式如下(梯度类似):

    [ \\\[E\_{tot}=E_I\^{QM}+E\_{I+II}\^{MM}-E_I\^{MM} \\tag{6.79}\\\]
    ]{.math}

    其中下标I和II分别代表QM和MM子体系. 上标代表了计算能量的水平.
    ONIOM方案的优点在于它并不限于两层QM/MM描述, 而是很容易推广到多层,
    每一层都可以使用不同水平的方法进行描述.

### 6.11.2 使用方法 {#6112-使用方法}

要使用GROMACS的QM/MM功能, 你需要:

1.  如果需要, 引入QM/MM边界上的链接原子;
2.  指定哪些原子需要在QM水平进行处理;
3.  指定QM水平, 基组, QM界面的类型等等.

**添加链接原子**

对连接QM和MM子体系的键需要引入链接原子. 在GROMACS中,
链接原子具有特殊的原子类型, LA. 在QM计算中,
LA原子类型被当作氢原子进行处理, 在力场计算中则被视为虚拟位点.
如果存在链接原子, 它们是体系的一部分, 但与其他任何原子都没有相互作用,
除了作用于其上的力会分配到成键的两个原子上. 在拓扑中,
链接原子(LA)因此被定义为虚拟位点原子.

    [ virtual_sites2 ]
    LA QMatom MMatom 1 0.65

关于虚拟位点的处理细节请参看5.2.2节. 在模拟的每一步, 链接原子会被取代.

另外, 键本身也会被约束代替:

    [ constraints ]
    QMatom MMatom 2 0.153

**注意** , 因为在我们的体系中, QM/MM键是碳碳键(0.153 nm),
我们使用的约束长度为0.153 nm, 哑位置为0.65.
后者为理想碳氢键长与理想碳碳键长之间的比例. 采用这一比例,
链接原子始终距离 ` QMatom ` 0.1 nm, 与碳氢键长相符.
如果QM和MM子体系由不同类型的键相连接,
需要使用与键类型匹配的不同约束与哑位置.

**指定QM原子**

需要在QM水平处理的原子, 包括链接原子, 要添加到索引文件中. 此外,
QM区域中原子之间的化学键需要在拓扑文件中定义为连接键(键类型5):

    [ bonds ]
    QMatom1 QMatom2 5
    QMatom2 QMatom3 5

**指定QM/MM模拟参数**

在 ` .mdp ` 文件中下列参数控制QM/MM模拟的运行.

` QMMM = no `\
如果设为 ` yes ` , 进行QM/MM模拟.
可以使用不同水平的QM单独对几个组进行描述, 在 ` QMMM-grps `
域中指定这些组, 彼此之间以空格隔开. 各个组使用的从头算方法的水平在
` QMmethod ` 和 ` QMbasis ` 域中指定.
使用不同水平的方法对组进行描述只能与ONIOM QM/MM一起使用, 由
` QMMMscheme ` 指定.

` QMMM-grps = ` :\
使用QM水平描述的组

` QMMMscheme = normal `\
可用选项为 ` normal ` 和 ` ONIOM ` , 用于选择QM/MM接口. ` normal `
意味着QM子体系电子化的嵌入MM子体系中, 只能对一个 ` QMMM-grps `
使用从头算方法进行描述, 方法的水平通过 ` QMmethod ` 和 ` QMbasis ` 指定.
体系的其余部分处于MM水平. QM和MM两个子体系的相互作用如下:
MM部分的点电荷包含在QM部分的单电子哈密顿量中,
所有的Lennard-Jones相互作用都在MM水平进行描述. 如果选择 ` ONIOM ` ,
使用Morokuma及其同事发展的ONIOM方法对子体系之间的相互作用进行描述.
可以有一个以上的 ` QMMM-grps ` , 每个组可以使用不同级别的QM(
` QMmethod ` 和 ` QMbasis ` )进行描述.

` QMmethod = `\
用于计算QM原子的能量和梯度的方法. 可用的方法包括AM1, PM3, RHF, UHF, DFT,
B3LYP, MP2, CASSCF, MMVB和CPMD. 对CASSCF, 电子数和活化空间的轨道数分别由
` CASelectrons ` 和 ` CASorbitals ` 指定. 对CPMD, 平面波截断由关键词
` planewavecutoff ` 指定.

` QMbasis = `\
用于展开电子波函数的高斯基组. 目前只可使用高斯基组, 即STO--3G, 3--21G,
3--21G *, 3--21+G* , 6--21G, 6--31G, 6--31G *, 6--31+G* 和6--311G.
CPMD使用平面波展开而不是以原子为中心的基函数, ` planewavecutoff `
关键词控制平面波展开.

` QMcharge = `\
` QMMM-grps ` 的总电荷数, 以 ` e ` 为单位. 在有一个以上 ` QMMM-grps `
的情况下, 需要单独指定每个ONIOM层的总电荷.

` QMmult = `\
` QMMM-grps ` 的多重度. 在有一个以上 ` QMMM-grps ` 的情况下,
需要单独指定每个ONIOM层的多重度.

` CASorbitals = `\
进行CASSCF计算时包含在活化空间中的轨道数.

` CASelectrons = `\
进行CASSCF计算时包含在活化空间中的电子数.

` SH = no `\
若设为 ` yes ` , 在激发态势能面进行QM/MM的MD模拟, 在模拟过程中,
当体系碰到锥形交叉线时, 强制非绝热跳跃到基态.
此选项只能与CASSCF方法联合使用.

### 6.11.3 输出 {#6113-输出}

QM计算所得的能量与力会加到GROMACS计算的能量与力中, 在 ` .edr `
文件中会有总QM能量的选择项.

### 6.11.4 未来发展 {#6114-未来发展}

为增加QM/MM接口的精度, 一些功能目前正在开发中.
其中的一个功能是在QM计算中使用离域化的MM电荷.
使用这种模糊电荷的最大好处是库仑势在原子间距离时具有有限值.
在点电荷表示中, 靠近QM区域的部分带电的MM原子倾向于"过极化"QM体系,
在计算中会导致假象.

此外, 还需要发展一个过渡态优化方法.

## 6.12 自适应分辨率方案 {#612-自适应分辨率方案}

自适应分辨率方案(AdResS)\[145,
146\]采用力插值方法将不同分辨率的两个部分耦合起来.
与前一节的混合经典量子模拟技术相反, 在AdResS中, 高分辨粒子的数目不固定,
可随着模拟时间而变化..

下面我们讨论的AdResS对相同体系采用双分辨描述(原子与粗粒), 示意图见图6.9.
本节的详细实现细节已发表于\[147, 148\].

每个分子需要一个定义良好的映射点(通常为质心),
但也可以使用粒子坐标的任何其他线性组合. 在拓扑中映射点被定义为虚拟位点.
粗粒化区域的力只是映射点位置的函数. 在这个实现中,
利用电荷组或电荷组的集合对分子进行建模,
这实际上允许一个分子有多个映射点. 对更大的分子, 如聚合物,
这种方法可能会有帮助. 在那种情况下,
必须扩展AdResS以描述键合相互作用\[149\].
将来的GROMACS版本中会实现这种功能.

![图6.9: 水分子AdResS方法的示意图](/GMX/6.9.png)

两个分子间的力为\[145\] [\[1\]](#fn:1 "see footnote"){#fnref:1
.footnote} :

[ \\\[\\vec F\_{\\a\\b} =w\_\\a w\_\\b \\vec
F\_{\\a\\b}\^\\text{ex,mol}+\[1-w\_\\a w\_\\b\] \\vec
F\_{\\a\\b}\^\\text{cg,mol} \\tag{6.80}\\\] ]{.math}

其中 [ \\(\\a\\) ]{.math} 和 [ \\(\\b\\) ]{.math} 标记两个分子, [
\\(w\_\\a\\) ]{.math} , [ \\(w\_\\b\\) ]{.math} 为两个分子的自适应权重.

上式第一部分代表了分子显式的相互作用, 可写为

[ \\\[\\vec F\_{\\a\\b}\^\\text{ex,mol}=\\Sum\_{i\\in \\a}
\\Sum\_{i\\in\\b} \\vec F\_{ij}\^\\text{ex} \\tag{6.81}\\\] ]{.math}

其中 [ \\(\\vec F\_{ij}\^\\text{ex}\\) ]{.math} 为第 [ \\(\\a\\)
]{.math} 个分子中的第 [ \\(i\\) ]{.math} 个原子与第 [ \\(\\b\\) ]{.math}
个分子中第 [ \\(j\\) ]{.math} 个原子之间的力, 由显式的力场给出.
方程6.80的第二部分来自分子的粗粒化相互作用. GROMACS中的实现稍有扩展:

[ \\\[\\vec F\_{\\a\\b}=\\Sum\_{i\\in \\a} \\Sum\_{i\\in\\b} w_i w_j
\\vec F\_{ij}\^\\text{ex} +\[1-w\_\\a w\_\\b\] \\vec
F\_{\\a\\b}\^\\text{cg,mol} \\tag{6.82}\\\] ]{.math}

其中 [ \\(w_i\\) ]{.math} 和 [ \\(w_j\\) ]{.math} 为基于原子的权重, 由
` adress-site ` 选项决定. 若 ` adress-site ` 为质心, 原子 [ \\(i\\)
]{.math} 具有其 **电荷组** 质量中心的权重, 分子 [ \\(\\a\\) ]{.math}
的权重 [ \\(w\_\\a\\) ]{.math} 由粗粒化粒子的位置决定,
而粗粒化粒子由拓扑中指定的原子化粒子的虚拟位点构建.
这种推广可以实现各种AdResS方法,
同时普通的方法可利用拓扑中的质心虚拟位点, 设定 ` adress-site=COM `
并把一个分子的所有原子(除代表粗粒化相互作用的虚拟位点外)放于同一电荷组来实现.
对大的分子, 使用基于原子的权重有时更好, 这可利用设置
` adress-site=atomperatom `
或将每个原子置于独立的电荷组(一个原子的电荷组质心为其自身)来实现.

粗粒化力场 [ \\(\\vec F\^\\text{cg}\\) ]{.math}
通常利用基于结构的粗粒化方法由原子化体系导出(参见4.10.5节).
为指定哪些原子属于一个粗粒化表示, 可使用能量组.
每个粗粒化相互作用必须与单独的能量组相联系,
这就是代表粗粒相互作用的虚拟位点也必须处于不同电荷组的原因.
被视为粗粒化相互作用进行处理的电荷组, 列于 ` adress_cg_grp_names ` .
插值的最重要内容(参见方程6.80和方程6.82)是自适应权重函数(示意图见图6.9):

[ \\\[w(x)=\\begin{cases} \\begin{array}{cl} 1 & :
\\text{原子化/显式区域 atomistic/explicit region} \\\\ 0 \\lt w \\lt 1 &
: \\text{杂合区域 hydrid region} \\\\ 0 & : \\text{粗粒化区域
coarse-grained region} \\end{array} \\end{cases} \\tag{6.83}\\\]
]{.math}

它的值处于0和1之间. [ \\(w\\) ]{.math} 的定义在显式区域是纯的显式力,
在粗粒化区域则是单纯的粗粒化力,
因此方程6.80中基本上只在杂合区域具有混合的相互作用,
这在标准模拟中是不会出现的. 在GROMACS中, 类似于cos ^2^
函数被用于权重函数:

[ \\\[w(x)=\\begin{cases} \\begin{array}{ccl} 0 &:
&\\phantom{d\_\\text{ex}+d\_\\text{hy}\>{} }
x\>d\_\\text{ex}+d\_\\text{hy} \\\\ \\cos\^2 \\left({\\p\\over
2d\_\\text{hy} }(x-d\_\\text{ex})\\right) &:
&d\_\\text{ex}+d\_\\text{hy} \>x\>d\_\\text{ex} \\\\ 1 &:
&\\phantom{d\_\\text{ex}+{} }d\_\\text{ex} \>x \\end{array} \\end{cases}
\\tag{6.84}\\\] ]{.math}

其中 [ \\(d\_\\text{ex}\\) ]{.math} 和 [ \\(d\_\\text{hy}\\) ]{.math}
分别为显式与杂合区域的大小. 根据研究体系的物理特点,
你也可以使用其他函数, 只要它们满足下面的边界条件: 1) 连续, 2) 单调, 3)
边界处导数为零. 已经实现了对模拟盒子的球形划分和一维划分(
` adress-type ` 选项), 取决于此选项, 到显式中心的距离 [ \\(x\\) ]{.math}
的计算方法为:

[ \\\[x=\\begin{cases} \\begin{array}{cl} \|(\\vec R\_\\a - \\vec
R\_\\text{ct}) \\cdot \\hat e\| &: 沿\\hat e方向划分\\; \\text{splitting
in}\\ \\hat e\\ \\text{direction} \\\\ \|\\vec R\_\\a - \\vec
R\_\\text{ct}\| &: 球形划分\\ \\text{spherical splitting} \\end{array}
\\end{cases} \\tag{6.85}\\\] ]{.math}

其中 [ \\(R\_\\text{ct}\\) ]{.math} 为显式区域的中心(由
` adress-reference-coords ` 选项定义), [ \\(\\vec R\_\\a\\) ]{.math}
为第 [ \\(\\a\\) ]{.math} 个分子的映射点. 对质心映射,

[ \\\[R\_\\a ={\\sum\_{i\\in \\a} m_i r_i \\over \\sum\_{i\\in \\a} m_i}
\\tag{6.86}\\\] ]{.math}

注意, 权重函数的值唯一地取决于分子的映射.
力的插值(见方程6.82)可导致密度的非均匀性并影响杂合区域的体系结构.

减小密度不均匀性的一种方法是使用所谓的热力学力(TF, thermodynamic
force)\[151\]. 这个力包含了空间相关的外场,
施加到杂合区域中每个分子的粗粒化位点上.
可以为体系中的每个物种指定这种力.
TF补偿了在均相密度剖面中出现的压力剖面\[152\],
因此可以校正杂合区域中的局部密度不均匀性,
并允许原子化和粗粒化的部分之间相互耦合,
它们在构建时在目标密度具有不同的压力. 场的强度可以使用迭代过程确定,
详细说明见VOTCA软件包的
[手册](http://code.google.com/p/votca/downloads/list?&q=manual) \[122\].
将 ` adress-interface-correction ` 设为 ` thermoforce ` 可启用TF校正,
` adress-tf-grp-names ` 定义了校正作用的能量值.

### 6.12.1 例: 水的自适应分辨率模拟 {#6121-例-水的自适应分辨率模拟}

本节将解释说明水的自适应分辨率模拟的设置,
模拟时原子化的SPC水模型\[181\]和它的粗粒化表示进行了耦合(如\[152\]中所用的).
为进行模拟需要下面一些步骤:

-   执行参考的全原子模拟
-   创建粗粒化表示并保存为表格相互作用函数
-   创建SPC水的杂合拓扑
-   修改原子坐标文件以包含粗粒化表示
-   在 ` grompp ` 输入文件中定义分辨率模拟的构型
-   创建索引文件

相互作用粗粒化表示被存储为表格相互作用函数, 这种函数的说明见6.10.2节.
约定是使用 [ \\(C\^{(12)\\) ]{.math} 列, 且系数 [ \\(C\^(12)\\) ]{.math}
设为1, 其他所有列都为零.
VOTCA手册中关于如何使用各种技术对SPC水进行粗粒化有详细的说明及教程.
这里, 我们将粗粒化相互作用命名为CG, 因此相应的表格文件为
` table_CG_CG.xvg ` . 要创建拓扑文件, 你可以从原子的拓扑文件开始,(例如
` share/gromacs/top/oplsaa.ff/spc.itp ` ). 我们在这里假定使用刚性水模型.
在VOTCA教程中文件被命名为 ` hybrid_spc.itp ` .
与原子化拓扑的唯一不同在于额外的粗粒化虚拟位点:

    [ moleculetype ]
    ; molname     nrexcl
    SOL           2

    [ atoms ]
    ; nr   type    resnr  residue  atom  cgnr  charge  mass
       1  opls_116     1     SOL     OW     1   -0.82
       2  opls_117     1     SOL    HW1     1    0.41
       3  opls_117     1     SOL    HW2     1    0.41
       4     CG        1     SOL     CG     2    0

    [ settles ]
    ; OW   funct   doh   dhh
    1      1       0.1   0.16330

    [ exclusions ]
    1  2  3
    2  1  3
    3  1  2

    [ virtual_sites3 ]
    ; Site from funct a d
    4  1 2 3  1  0.05595E+00 0.05595E+00

根据虚拟位点类型3及指定的系数, 虚拟位点位于分子的质心(对大分子必须使用
` virtual sitesn ` ). 我们现在需要在拓扑文件中包含修改后的水模型并定义
` CG ` 类型, 在 ` topol.top ` 中:

    #include "ffoplsaa.itp"
    [ atomtypes ]
    ;name    mass        charge    ptype     sigma     epsilon
     CG      0.00000     0.0000    V         1         0.25

    #include "hybrid_spc.itp"

    [ system ]
    Adaptive water

    [ molecules ]
    SOL 8507

[ \\(\\s\\) ]{.math} 和 [ \\(\\e\\) ]{.math} 的值分别对应于 [
\\(C_6=1\\) ]{.math} 和 [ \\(C\_{12}=1\\) ]{.math} , 因此表格文件应该在
[ \\(C_6\\) ]{.math} 或 [ \\(C\_{12}\\) ]{.math} 列包含粗粒相互作用.
在此列中我们使用了OPLS力场, 并指定了 [ \\(\\e\\) ]{.math} 和 [ \\(\\s\\)
]{.math} . 注意, 对那些直接使用 [ \\(C_6\\) ]{.math} 和 [ \\(C\_{12}\\)
]{.math} 项定义原子类型的力场, 可以简单地设置 [ \\(C_6=0\\) ]{.math} 和
[ \\(C\_{12}=0\\) ]{.math} . 关于表格相互作用的更多细节请参考6.10.2节.
由于水分子具有一个虚拟位点, 坐标文件也需要包括虚拟位点.

    adaptive water coordinates
    34028
        1SOL     OW    1   0.283   0.886   0.647
        1SOL    HW1    2   0.359   0.884   0.711
        1SOL    HW2    3   0.308   0.938   0.566
        1SOL     CG    4   0.289   0.889   0.646
        1SOL     OW    5   1.848   0.918   0.082
        1SOL    HW1    6   1.760   0.930   0.129
        1SOL    HW2    7   1.921   0.912   0.150
        1SOL     CG    8   1.847   0.918   0.088
        (...)

此文件可手动创建或使用VOTCA工具 ` csg_map ` 的 ` --hybrid ` 选项创建.

在 ` grompp ` 输入文件中, 需要启用AdRess功能, 并定义构型.

    (...)
    ; AdResS relevant options
    energygrps                  = CG
    energygrp_table             = CG CG
    ; Method for doing Van der Waals
    vdw-type                    = user
    adress                      = yes
    adress_type                 = xsplit
    adress_ex_width             = 1.5
    adress_hy_width             = 1.5
    adress_interface_correction = off
    adress_reference_coords     = 8 0 0
    adress_cg_grp_names         = CG

在这里我们定义了能量组 ` CG ` , 它包含了粗粒化的虚拟位点. 如前所述,
粗粒化相互作用通常使用表格, 这就要求将 ` vdw-type ` 设置为 ` user ` .
若对多组分体系进行粗粒化, 必须为每一个组分定义一个能量组. 注意,
定义粗粒化表示的所有能量组, 都必须列于 ` adress_cg_grp_names ` 中,
以便与常规能量组区分开来.

必须更新索引文件, 并添加CG组, 其中包含所有粗粒化虚拟位点,
使用GROAMCS的工具 ` make_ndx ` 很容易完成.

## 6.13 VMD插件用于轨迹文件输入/输出 {#613-vmd插件用于轨迹文件输入输出}

GROMACS可以使用已经安装的 [VMD](http://www.ks.uiuc.edu/Research/vmd)
插件来读写非GROMACS格式的轨迹文件. 例如, 你可以将AMBER
DCD格式的轨迹文件直接提供给GROMACS工具.

要使用上述功能, VMD的版本不能低于1.8, 还需要你的系统提供dlopen函数,
这样才能在运行时确定存在哪些插件, 构建GROMACS时是否构建了共享库.
CMake将会在你的路径下查找VMD可执行程序, 根据这个路径,
或者在配置或运行时的环境变量 ` VMDDIR ` 来定位插件. 作为替代,
运行时可利用 ` VMD_PLUGIN_PATH ` 来指定插件的路径. 注意,
这些插件是二进制形式的, 格式必须匹配插件所在机器的架构.

## 6.14 交互式分子动力学 {#614-交互式分子动力学}

GROMACS支持交互式的分子动力学(IMD, interactive molecular dynamics)协议,
[VMD](http://www.ks.uiuc.edu/Research/vmd)
可利用此协议控制NAMD中运行的模拟.
IMD允许从VMD客户端监测正在运行的GROMACS模拟, 此外,
通过使用鼠标或力反馈设备拉扯原子, 残基或片段, 用户可以与模拟进行互动.
关于GROMACS实现及示例GROMACS IMD系统的额外的信息可以在这个
[主页](http://www.mpibpc.mpg.de/grubmueller/interactivemd) 上找到.

### 6.14.1 准备模拟输入 {#6141-准备模拟输入}

GROMACS的实现只允许与运行模拟的一部分进行传送与交互, 例如,
当没有水分子被传送或牵引的情况下. 通常使用 ` .mdp ` 文件的 ` IMD-group `
选项指定组. 当 ` IMD-group ` 为空时, IMD协议被禁用, 不能通过 ` mdrun `
的开关来启用. 要与整个体系进行互动, ` IMD-group ` 可设为 ` System ` .
当使用 ` grompp ` 时, 作为VMD输入的 ` .gro ` 文件会写出( ` grompp ` 的
` -imd ` 开关).

### 6.14.2 启动模拟 {#6142-启动模拟}

VMD与GROMACS之间的通讯可利用TCP套接字完成,
因而可控制本地机器或远程集群上的 ` mdrun ` . 可利用 ` mdrun ` 的
` -imdport ` 选项指定连接端口, 默认为8888. 如果指定的端口号为0或更小,
GROMACS会自动为IMD分配一个可用的端口.

` mdrun ` 客户端每 [ \\(N\\) ]{.math} 步接收一次VMD中的力,
并将新的位置发送到客户端. VMD允许以交互方式增加或减小通讯频率.
默认情况下, 即使没有连接IMD客户端, 模拟也会启动并运行. 这种行为可利用
` mdrun ` 的 ` -imdwait ` 开关选项更改. 启动后, 每当客户端断开连接时,
积分会停止直至重新连接客户端. 当使用 ` -imdterm ` 开关时,
可以通过按下VMD中的stop按钮来终止模拟, 默认未启用此功能. 最后,
为了与模拟进行互动, (即从VMD中牵引)必须使用 ` -imdpull ` 选项. 因此,
当未设置 ` -imdwait ` , ` -imdterm ` 或 ` -imdpull ` 时, 只可以监测模拟,
而不能从VMD客户端影响模拟. 然而, 由于IMD协议无须认证,
在不安全环境直接可连的主机上运行模拟是不明智的.
TCP的安全shell转发可用于连接不能从活动主机直接可达的模拟. 注意,
` mdrun ` 的IMD命令行开关默认是隐藏的, 只有使用 ` gmx mdrun -h -hidden `
才能显示于帮助文本中.

### 6.14.3 从VMD中连接 {#6143-从vmd中连接}

在VMD中, 首先必须加载与IMD组对应的结构(File → New Molecule),
然后必须使用IMD的连接窗口((Extensions → Simulation → IMD Connect
(NAMD)). 在IMD连接窗口中, 必须指定主机名与端口, 并点按下 **connect**
按钮, **Detach Sim** 允许断开连接, 同时不中断模拟, **Stop Sim**
会在下一次近邻搜索前终止模拟(若 ` -imdterm ` 运行).

时间步传输速率用于调整模拟与IMD客户端之间的通讯频率. 当接收到新的帧时,
设置保持速率每 [ \\(N\\) ]{.math} 帧加载到VMD一次而不是忽略它们.
显示的能量单位是国际单位, 与NAMD不同.

::: footnotes

------------------------------------------------------------------------

1.  ::: {#fn:1}
    注意, 此方程服从牛顿第三定律, 而其他一些实现方案未必服从\[150\].
    [↩](#fnref:1 "return to article"){.reversefootnote}
    :::
:::

------------------------------------------------------------------------

------------------------------------------------------------------------

![](/jscss/molsimart.png){style="display:table;margin:0 auto;height:150px"}
[个](javascript:scroll(0,0)){#scrollTop}
:::
::: site-header
::: wrap




""
:::
:::

::: wrap
# GROMACS中文手册：第七章　运行参数和程序





## 7.1 在线和HTML手册 {#71-在线和html手册}

本章所有的信息都可以在GROMACS数据目录下的HTML文件中找到.
文件的路径取决于文件的安装位置, 默认位置是
` /usr/local/gromacs/share/gromacs/html/online.html ` .
如果你使用Linux安装包进行安装, 通常可以在
` /usr/share/gromacs/html/online.html ` 找到.
你也可以使用GROMACS网站的在线手册, 其网址为
<http://manual.gromacs.org/current> .

此外, 我们为所有程序都安装了标准的UNIX手册页. 如果你用 ` source `
命令执行了主机上GROMACS二进制目录下的 ` GMXRC ` 脚本,
这些手册页应该已经出现在 ` MANPATH ` 环境变量中了,
而且你应该能够通过键入如 ` man gmx-grompp ` 之类的命令进行查看.
你也可以通过在命令行中使用 ` -h ` 标识(如 ` gmx grompp -h `
)看到同样的信息, 你还可以使用 ` gmx help grompp ` 之类的命令.
所有程序的列表可从 ` gmx help ` 获得.

## 7.2 文件类型 {#72-文件类型}

表7.1列出了GROMACS使用的文件类型及其简短说明,
你可以在HTML参考手册或其在线版本中找到每类文件更加详细的说明.
如果系统的XDR库中存在配置脚本, GROMACS
1.6或更高版本可在任何架构上读取XDR格式的GROMACS文件,
这些文件应该永远存放于UNIX系统下, 因为它们必须要有NFS的支持.

   默认名称.扩展名   类型   默认选项                    说明
  ----------------- ------ ---------- -----------------------------------------
     atomtp.atp      Asc                      pdb2gm使用的原子类型文件
      eiwit.brk      Asc       -f               Brookhaven资料库文件
      state.cpt      xdr                             检查点文件
     nnnice.dat      Asc                            通用数据文件
      user.dlg       Asc                           ngmx对话框数据
       sam.edi       Asc                             ED抽样输入
       sam.edo       Asc                             ED抽样输出
      ener.edr                                    通用能量: edr ene
      ener.edr       xdr                        便携xdr格式的能量文件
      ener.ene       Bin                              能量文件
      eiwit.ent      Asc       -f                 蛋白质数据库条目
      plot.eps       Asc                             EPS(tm)文件
      conf.esp       Asc       -c              ESPResSo格式的坐标文件
      conf.g96       Asc       -c              Gromos-96格式的坐标文件
      conf.gro       Asc       -c              Gromos-87格式的坐标文件
      conf.gro                 -c         结构: gro g96 pdb esp tpr tpb tpa
       out.gro                 -o              结构: gro g96 pdb esp\`
      polar.hdb      Asc                              氢数据库
     topinc.itp      Asc                           拓扑结构头文件
       run.log       Asc       -l                     日志文件
       ps.m2p        Asc                           mat2ps输入文件
       ss.map        Asc                      矩阵数据到颜色的映射文件
       ss.mat        Asc                            矩阵数据文件
     grompp.mdp      Asc       -f             含MD参数的grompp输入文件
     hessian.mtx     Bin       -m                    Hessian矩阵
      index.ndx      Asc       -n                     索引文件
      hello.out      Asc       -o                   通用输出文件
      eiwit.pdb      Asc       -f                 蛋白质数据库文件
     residue.rtp     Asc                      pdb2gmx使用的残基类型文件
       doc.tex       Asc       -o                     LaTex文件
      topol.top      Asc       -p                   拓扑结构文件
      topol.tpb      Bin       -s               二进制运行的输入文件
      topol.tpr                -s           通用运行输入文件: tpr tpb tpa
      topol.tpr                -s      结构+质量(db): tpr tpb tpa gro g96 pdb
      topol.tpr      xdr       -s               便携式xdr运行输入文件
      traj.trj       Bin                     轨迹文件(特定机器架构下的)
      traj.trr                                 全精度轨迹: trr trj cpt
      traj.trr       xdr                          便携xdr格式的轨迹
      root.xpm       Asc                       X PixMap兼容的矩阵文件
      traj.xtc                 -f      轨迹, 输入: xtc trr trj cpt gro g96 pdb
      traj.xtc                 -f        轨迹, 输出: xtc trr trj gro g96 pdb
      traj.xtc       xdr                       压缩的轨迹(便携xdr格式)
      graph.xvg      Asc       -o                   xvgr/xmgr文件

  : 表7.1: GROMACS的文件类型

## 7.3 运行参数 {#73-运行参数}

### 7.3.1 通用参数 {#731-通用参数}

参数的默认值在括号中给出. 列表中的第一个选项始终是默认选项.
单位在方括号中给出, 破折号和下划线没有区别. 有一份示例的 ` .mdp ` 文件,
可用于开始一个正常的模拟. 你也可以编辑它以满足特定需求.

### 7.3.2 预处理 {#732-预处理}

` include ` :\
在你的拓扑信息中包含特定的目录.\
格式: ` -I/home/john/mylib -I../otherlib `

` define ` :\
传递给预处理器的预定义, 默认不存在预定义.
你可以在自己定制的拓扑文件中使用任何定义来控制选项.
有以下默认可用的选项:

-   ` -DFLEXIBLE `\
    告诉 ` grompp ` 在拓扑信息中使用柔性的水模型而不是刚性的水模型,
    对简正模式分析有用.

-   ` -DPOSRES `\
    告诉 ` grompp ` 在拓扑信息中包括 ` posre.itp ` , 用于位置限制.

### 7.3.3 运行控制 {#733-运行控制}

` integerator ` : (尽管名字的意思是积分方法,
但此参数包括了实际上不属于积分的算法. ` steep `
及其下的所有条目都属于此类)

-   ` md `\
    蛙跳式算法积分牛顿运动方程.

-   ` md-vv `\
    速度Verlet算法积分牛顿运动方程. 对从同样轨迹的对应点开始的恒NVE模拟,
    此选项将产生与 ` md ` 选项解析等同的轨迹, 但不是二进制完全等同.
    由于动能是从整个积分步的速度计算所得, 因此会稍微过高.
    这种积分方法的优点是更精确,
    使用了基于Trotter展开的可逆的Nose-Hoover和Parrinello-Rahman耦合积分,
    以及(略过小)整步的速度输出. 这些优点的代价是额外的计算量,
    特别是当使用约束和并行的额外通讯时. 注意, 对几乎所有的模拟 ` md `
    积分方法都足够精确.

-   ` md-vv-avek `\
    等同于 ` md-vv ` 的速度Verlet算法, 除了动能是由 ` md `
    积分方法的两半步动能的平均值决定以外, 因而此方法更精确.
    当与Nose-Hoover和/或Parrinello-Rahman耦合联用时,
    此选项会略微增加计算成本.

-   ` sd `\
    准确, 高效的蛙跳式随机动力学积分方法. 使用约束时, 在每积分步,
    坐标需要被约束两次. 取决于力的计算成本,
    这可能会占用模拟的大部分时间. 一组或多组原子( ` tc-grps `
    )的温度可通过 ` ref-t ` \[K\]设定, 每组的逆摩擦常数通过 ` tau-t `
    \[ps\]设定. 参数 ` tcoupl ` 被忽略. 随机数发生器使用 ` ld-seed `
    初始化. 当作为恒温器使用时, 2 ps是 ` tau-t ` 的一个适当值,
    因为这时的摩擦比水的内摩擦低, 同时摩擦也高到足以除去多余的热量.
    **注意** : 温度偏差的衰减要比使用相同 ` tau-t `
    的Berendsen恒温器快一倍.

-   ` sd2 `\
    曾经是默认的SD积分方法, 但现在已过时.
    每个坐标每一步需要四个高斯随机数. 使用约束时, 温度会稍微过高.

-   ` bd `\
    Brown或位置Langevin动力学的欧拉积分方法, 粒子速度为所受力与摩擦系数(
    ` bd-fric ` \[amu ps ^-1^ \])的比值, 再加上随机热噪声( ` ref-t ` ).
    当 ` bd-fric=0 ` 时, 每个粒子的摩擦系数由mass/ ` tau-t ` 计算, 与
    ` sd ` 积分方法类似. 随机发生器利用 ` ld-seed ` 初始化.

-   ` steep `\
    能量最小化的最陡下降算法. 最大步长为 ` emstep ` \[nm\], 容差为
    ` emtol ` \[kJ mol ^-1^ nm ^-1^ \].

-   ` cg `\
    能量最小化的共轭梯度算法, 容差为 ` emtol ` \[kJ mol ^-1^ nm ^-1^ \].
    当由 ` nstcgsteep ` 决定的最速下降步骤完成后, 使用CG会更高效.
    简正模式分析前进行的最小化需要非常高的精度, 为此,
    编译GROMACS时应使用双精度.

-   ` l-bfgs `\
    能量最小化的准牛顿算法,
    基于低内存需求的Broyden-Fletcher-Goldfarb-Shanno方法, 在实用中,
    似乎比共轭梯度法收敛更快, 但是由于必须的校正步骤,
    此方法(暂且)不能并行.

-   ` nm `\
    对 ` tpr ` 文件中的结构进行简正模式分析.
    应该使用双精度编译的GROMACS.

-   ` tpi `\
    测试粒子插入. 拓扑结构中的最后一个分子是测试粒子. 需要 ` mdrun ` 的
    ` -rerun ` 选项并提供一条轨迹. 这条轨迹不能包含待插入的分子.
    每帧中会进行 ` nsteps ` 次插入操作,
    插入时分子的位置和取向都是随机的. 当 ` nstlist ` 大于1时,
    围绕相同随机位置半径为 ` rtpi ` 的球体进行 ` nstlist ` 次插入,
    并使用相同的邻区列表(和相同的长程能量, 若 ` rvdw>rlist ` 或
    ` rcoulomb>rlist ` , 只适用于单原子分子). 因为构造邻区列表很昂贵,
    你可以使用同一个列表几乎免费地进行若干次额外的插入. 随机种子由
    ` ld-seed ` 设定. 玻尔兹曼加权的温度由 ` ref-t ` 设定,
    它应与原始轨迹的模拟温度匹配. tpi正确地考虑了色散校正.
    所有相关的量都会写入到由 ` mdrun ` 的 ` -tpi ` 选项指定的文件中.
    插入能量的分布会写入到由 ` mdrun ` 的 ` -tpid ` 选项指定的文件中.
    不产生轨迹或能量文件. 并行tpi与单节点tpi的结果完全相同.
    对于带电分子, 使用密格点的PME最准确, 也很有效,
    因为对每一帧系统的势能只需要计算一次.

-   ` tpic `\
    测试粒子插入到一个预定义的空腔位置. 步骤与tpi相同,
    除了需要从轨迹中读入一个额外的坐标, 作为插入位置.
    要被插入分子的中心应位于0,0,0. GROMACS不会为你完成这点,
    因为针对不同的情况, 采用不同的方式定心可能更好. 同时, ` rtpi `
    设置围绕此处球体的半径. 对每一帧只进行一次邻区搜索, 不会使用
    ` nstlist ` . 并行tpic与单节点tpic的结果完全相同.

` tinit ` : (0) \[ps\]\
运行的起始时间(只对 ` md ` , ` sd ` 和 ` bd ` 积分方法有意义)

` dt ` : (0.001) \[ps\]\
积分时间步长(只对 ` md ` , ` sd ` 和 ` bd ` 积分器有意义)

` nsteps ` : (0)\
积分或最小化的最大步数, --1意味着不限制步数

` init-step ` (0)\
起始步. 第i步的运行时间的计算公式为: t = ` tinit ` + ` dt ` \* (
` init-step ` + i). 自由能计算中lambda的计算公式为: lambda=
` init-lambda ` + ` delta-lambda ` \* ( ` init-step ` +i).
非平衡态MD的参数也依赖于步数. 因此, 为了准确的重新启动或重做部分模拟,
可能需要将 ` init-step ` 设置为重启帧的步数. ` gmx convert-tpr `
可自动执行此操作.

` comm-mode `

-   ` Linear `\
    去除质心的平动

-   ` Angular `\
    去除去质心的平动以及围绕质心的转动

-   ` None `\
    不限制质心的运动

` nstcomm ` : (100) \[步\]\
去除质心运行的频率

` comm-grps ` :\
需要去除质心运动的组, 默认是整个体系

### 7.3.4 Langevin动力学 {#734-langevin动力学}

` bd-fric ` : (0) \[amu ps ^-1^ \]\
Brown动力学摩擦系数. 当 ` bd-fric=0 ` 时, 每个粒子的摩擦系数为其质量与
` tau-t ` 的比值.

` ld-seed ` : (--1) \[整数\]\
用于初始化随机和Brown动力学的热噪声随机数发生器. 当 ` ld-seed `
设置为--1时, 将使用伪随机种子. 当在多个处理器上运行BD或SD时,
每个处理器使用的种子等于 ` ld-seed ` 加上处理器的编号.

### 7.3.5 能量最小化 {#735-能量最小化}

` emtol ` : (10.0) \[kJ mol ^-1^ nm ^-1^ \]\
当最大的力比这个值小时就认为最小化收敛

` emstep ` : (0.01) \[nm\]\
初始步长大小

` nstcgsteep ` : (1000) \[步\]\
用共轭梯度进行能量最小化时执行一步最速下降的频率

` nbfgscorr ` : (10)\
L-BFGS最小化的校正步数. 数值越高(至少理论上)越准确, 但速度更慢.

### 7.3.6 壳层分子动力学 {#736-壳层分子动力学}

当体系中存在壳层或柔性约束时,
会在每个时间步对壳层的的位置和柔性约束的长度进行优化,
直到在壳层和约束上的力的RMS值小于 ` emtol ` , 或达到迭代的最大次数(
` niter ` )

` emtol ` : (10.0) \[kJ mol ^-1^ nm ^-1^ \]\
当最大的力比这个值小时就认为最小化收敛. 对壳层MD这个值最大是1.0,
但由于此变量也用于能量最小化, 所以其默认值为10.0.

` niter ` : (20)\
优化壳层位置和柔性约束的最大迭代次数.

` fcstep ` : (0) \[ps ^2^ \]\
优化柔性约束的步长. 应设置为mu/(d ^2^ V/dq ^2^ ),
其中mu为柔性约束中两粒子的约化质量, d ^2^ V/dq ^2^
是势能在约束方向上的二阶导数. 这个数字对不同的柔性约束不要相差太大,
因为迭代次数进而运行时间对 ` fcstep ` 非常敏感. 多尝试几个值!

### 7.3.7 测试粒子插入 {#737-测试粒子插入}

` rtpi ` : (0.05) \[nm\]\
测试粒子插入半径, 请参考积分方法 ` tpi ` 和 ` tpic `

### 7.3.8 输出控制 {#738-输出控制}

` nstxout ` : (0) \[步\]\
将坐标写入输出轨迹文件的间隔步数, 最后一步的坐标始终会写入

` nstvout ` : (0) \[步\]\
将速度写入输出轨迹文件的间隔步数, 最后一步的速度始终会写入

` nstfout ` : (0) \[步\]\
将力写入输出轨迹文件的间隔步数

` nstlog ` : (1000) \[步\]\
将能量写入log文件的间隔步数, 最后一步的能量始终会写入

` nstcalcenergy ` : (100)\
两次能量计算之间的间隔步数, 0表示从不计算. 此选项仅与动力学有关.
使用双程截断时 ` nstcalcenergy ` 应等于 ` nstlist ` 或其倍数.
此选项会影响并行模拟的性能, 因为计算能量需要所有进程之间的全局通讯,
在高度并行的情况下, 这可能会成为计算瓶颈.

` nstenergy ` : (1000) \[步\]\
将能量写入能量文件的间隔步数, 最后一步的能量始终会写入, 应是
` nstcalcenergy ` 的倍数. 注意, 对所有MD步数与 ` nstcalcenergy ` 的模,
精确的能量总和及其涨落都存储在能量文件中, 所以当 ` nstenergy>1 ` 时,
` g_energy ` 仍可以给出精确的能量平均值及其涨落

` nstxout-compressed ` : (0) \[步\]\
利用有损压缩输出位置坐标的间隔步数

` compressed-x-precision ` : (1000) \[实数\]\
压缩轨迹文件的精度

` compressed-x-grps ` :\
写入到压缩轨迹文件的组, 默认写入整个体系(如果 ` nstxout-compressed `
\>0)

` energygrps ` :\
写入能量文件的组

### 7.3.9 邻区搜索 {#739-邻区搜索}

` cutoff-scheme ` :

-   ` Verlet `\
    利用缓冲生成粒子的配对列表. 缓冲区的大小会根据
    ` verlet-buffer-tolerance ` 自动进行设置, 除非将其设置为--1,
    在这种情况下会使用 ` rlist ` . 此选项在 ` rvdw=rcoulomb `
    处存在一个明显, 准确的截断. 目前仅支持截断, 反应场, PME静电和普通LJ.
    ` Verlet ` 方案不支持 ` mdrun ` 的一些功能, 但 ` grompp `
    会对此进行检查. 只有 ` Verlet ` 支持原生GPU加速.
    使用GPU加速的PME或单独的PME队列时, ` mdrun ` 会通过缩放 ` rcoulomb `
    和格点间距自动调整CPU/GPU负载平衡. 可以使用 ` -notunepme `
    关闭此功能. 当体系中不含水分子, 或 ` group `
    使用配对列表缓冲维持能量守恒时, ` Verlet ` 会比 ` group ` 快.

-   ` group `\
    为原子组生成配对列表. 这些组对应于拓扑信息中的电荷组.
    这是4.6版本之前唯一的截断处理方案. 配对列表没有显式的缓冲.
    这使得计算水的力时效率很高, 但只有显式地加入缓冲时, 能量才守恒.

` nstlist ` : (10) \[步\]

-   ` >0 `\
    更新邻区列表(以及远程力, 当使用双程截断时)的频率. 当该值为0时,
    邻区列表只生成一次. 对能量最小化, 当 ` nstlist>0 ` 时,
    每次计算能量都将更新邻区列表. 设置了 ` cutoff-scheme=Verlet ` 和
    ` verlet-buffer-tolerance ` , ` nstlist ` 实际是最小值且 ` mdrun `
    可能会增大它的值, 除非将其设置为1.
    对GPU上的并行模拟和(或)非键合力计算, 取20或40往往能得到最佳性能.\
    使用 ` cutoff-scheme=Group ` 和非准确的截断, ` nstlist `
    会影响模拟的精确性, 不能随意选择.

-   ` 0 `\
    邻区列表仅构建一次, 且不再更新. 这主要用于真空中模拟,
    这种情况下所有粒子彼此间都能看到对方.

-   ` -1 `\
    自动更新频率, 仅支持 ` cutoff-scheme=group ` . 此选项只能用于切换,
    移位或用户定制的势能函数, 其截断可以小于 ` rlist ` . 缓冲的大小为
    ` rlist ` 减去最长的截断值.
    以根据前一步的邻区搜索确定的电荷组几何中心开始,
    只有当一个或多个粒子移动的距离超过缓冲大小的一半时,
    邻区列表才会更新. 更新时会考虑因压力耦合或 ` deform `
    选项引起的坐标缩放. 此选项可确保没有截断虚假, 但对于较大的体系,
    计算成本可能会很高, 因为邻区列表的更新频率仅由一或两个粒子决定,
    它们移动的距离稍微超出缓冲长度的一半(这并不一定意味着邻区列表是无效的),
    而99.99%的粒子都不需要更新.

` nstcalclr ` : (--1) \[步\]\
使用组截断方案时, 控制远程力的计算周期.

-   ` 1 `\
    在每一步都计算长程力.
    当静电和范德华相互作用使用单独的带缓冲的邻区列表时, 此选项有用,
    特别地, 它支持范德华的截断距离大于静电的(例如与PME联用时有用). 然而,
    对这两种相互作用使用相同的长程截断值,
    并在每一步更新它们是没有意义的--此时将一切都放在短程列表中会稍快一些.

-   ` > 1 `\
    每 ` nstcalclr ` 步计算一次长程力,
    并使用多时间步积分方法将它们组合起来. 现在可以使用超过 ` nstlist `
    的频率进行计算, 因为会保存列表. 这可能是一个好主意, 例如,
    对于变化比静电慢的范德华相互作用.

-   ` -1 `\
    当进行邻区搜索时计算长程力. 虽然这是默认值,
    你可能要考虑更频繁地更新长程力.\
    注意, PP-PME负载均衡可能会自动导致双程力(twin-range force)的计算,
    这是为了维持所选择的范德华相互作用半径,
    即便负载均衡正在改变静电截断. 如果 ` .mdp `
    文件已经指定了双程相互作用(比如每2--3步使用比PME静电更长的截断计算Lennard-Jones相互作用),
    负载均衡对Lennard-Jones也会有小的影响,
    因为短程截断(在其内部每步都计算力)改变了.

` ns-type ` :

-   ` grid `\
    在盒子中生成格点, 且在每 ` nstlist `
    步构建新的邻区列表时才检查在相邻格点区域内的原子. 对大的体系,
    格点搜索比简单搜索快得多.

-   ` simple `\
    每 ` nstlist ` 步构建新的邻区列表时, 检查盒子中的每个原子(仅与
    ` cutoff-scheme=group ` 联用).

` pbc ` :

-   ` xyz `\
    在所有方向上使用周期性边界条件.

-   ` no `\
    不使用周期性边界条件, 忽略盒子. 不使用截断的模拟,
    可将所有的截断设为0, 并且 ` nstlist=0 ` . 对单个MPI队列,
    不使用截断时, 使用 ` nstlist=0 ` , ` ns-type=simple `
    可获得最佳性能.

-   ` xy `\
    只在x和y方向上使用周期性边界条件. 仅适用于 ` ns-type=grid ` , 可与
    ` walls ` 联用. 没有墙或只有一个墙时, 体系在z方向上大小是无限的,
    因此不能使用压力耦合或Ewald加和方法. 当使用两面墙时没有这些缺点.

` periodic-molecules ` :

-   ` no `\
    分子是有限的, 可以使用快速的分子PBC

-   ` yes `\
    用于含有通过周期性边界条件与自身耦合的分子的体系, 需要较慢的PBC算法,
    分子在输出中不保持完整

` verlet-buffer-tolerance ` : (0.005) \[kJ/mol/ps\]\
只对 ` cutoff-scheme=Verlet ` 有用.
此选项设置由Verlet缓冲引起的每个粒子配对相互作用的最大允许误差,
间接设置了 ` rlist ` . 若 ` nstlist `
和Verlet缓冲大小都固定(出于性能原因), 不在配对列表中的粒子对在
` nstlist ` --1步内能够不时地进入截断距离内. 这将导致非常小的能量跳跃.
对等温系综, 对于给定的截断和 ` rlist ` 可估算出这些非常小的能量跳跃.
估算时假定均相的粒子分布, 因此对多相体系可能会略微低估误差.
对于较长的配对列表寿命( ` nstlist ` --1)\*dt, 缓冲会被高估,
因为忽略了粒子之间的相互作用.\
由于误差抵消, 总能量的实际漂移幅度通常小一到两个数量级. 注意,
与基于简单粒子配对的列表相比,
GROMACS的配对列表设置导致漂移降低为原来的1/10,
生成的缓冲大小考虑了这一点影响. 不使用动力学(能量最小化等)时,
缓冲为截断的5%. 对NVE模拟, 会使用初始温度, 除非初始温度为零,
此时使用10%的缓冲.
对NVE模拟通常需要降低容差以便在纳秒的时间尺度达到适当能量守恒.
要覆盖自动缓冲设置, 可使用 ` verlet-buffer-tolerance=-1 ` , 并手动设置
` rlist ` .

` rlist ` : (1) \[nm\]\
短程邻区列表的截断距离. 使用 ` cutoff-scheme=Verlet ` 时, 默认由
` verlet-buffer-tolerance ` 选项设置, 并忽略 ` rlist ` 值.

` rlistlong ` : (--1) \[nm\]\
长程邻区列表的截断距离. 此参数仅适用于切换势的双程截断设置.
在这种情况下, 需要一个缓冲区域以考虑电荷组的大小. 在所有其他情况下,
该参数自动设置为最长的截断距离.

### 7.3.10 静电 {#7310-静电}

` coulombtype ` :

-   ` Cut-off `\
    双程截断, 其中邻区截断距离为 ` rlist ` , 库仑截断距离为 ` rcoulomb `
    , 且 ` rcoulomb≥rlist ` .

-   ` Ewald `\
    经典Ewald加和方法. 实空间的截断距离 ` rcoulomb ` 应等于 ` rlist ` .
    例如, 使用 ` rlist=0.9, rcoulomb=0.9 ` .
    倒易空间使用的波矢的最大振幅由 ` fourierspacing ` 控制.
    直接/倒易空间的相对精度由 ` ewald-rtol ` 控制.\
    注: Ewald算法的复杂度为O(N ^3/2^ ), 因此对于大的体系非常慢.
    包含这个方法主要是为了作为参考--在大多数情况下PME方法的性能都好得多.

-   ` PME `\
    快速平滑粒子网格Ewald(SPME)静电方法. 直接空间类似于Ewald加和方法,
    而倒易空间部分使用FFT进行计算. 格点尺寸由 ` fourierspacing ` 控制,
    内插的阶数由 ` pme-order ` 控制. 使用0.1 nm格点间距的三次内插方法时,
    静电力的计算精度为2--3\*10 ^-4^ . 由于VDW截断导致的误差大于此,
    你可以尝试使用0.15 nm的格点间距. 当并行运行时,
    内插的并行性能优于FFT, 因此可以试着减小格点尺寸, 同时增加内插.

-   ` P3M-AD `\
    粒子粒子粒子网格算法, 具有长程静电相互作用的解析梯度.
    除影响函数对格点进行了优化外, 方法和代码与SPME完全相同,
    优化使在计算精度略有提高.

-   ` Reaction-Field electrostatics `\
    库仑截断距离为 ` rcoulomb ` 的反应场, 其中 ` rcoulomb≥rlist ` .
    超过截断距离的介电常数为 ` epsilon-rf ` . 当 ` epsilon-rf=0 ` 时,
    介电常数无穷大.

-   ` Generalized-Reaction-Field `\
    库仑截断距离为 ` rcoulomb ` 的广义反应场, 其中 ` rcoulomb≥rlist ` .
    超过截断距离的介电常数为 ` epsilon-rf ` .
    离子强度由带电的(即非零电荷)电荷组计算. GRF势的温度通过 ` ref-t `
    \[K\]设定.

-   ` Reaction-Field-zero `\
    在GROMACS中, 使用 ` cutoff-scheme=group ` 时,
    正常的反应场静电方法会导致能量守恒性很差. ` Reaction-Field-zero `
    通过将超出截断距离的势能设为零解决了这个问题.
    这种方法只适用于介电常数无穷大( ` epsilon-rf=0 ` )的情况,
    因为只有这样力在截断距离处才能消失. ` rlist ` 应比 ` rcoulomb `
    大0.1至0.3 nm, 以考虑电荷组的大小已及更新邻区对时扩散的影响.
    这一点以及使用查表代替解析函数使得 ` Reaction-Field-zero `
    的计算比正常反应场更耗时.

-   ` Reaction-Field-nec `\
    与 ` Reaction-Field ` 相同, 但是GROMACS 3.3以前版本中的实现.
    没有使用反应场校正排除原子对和自身对的影响.
    使用反应场计算1--4相互作用.
    因排除不具有1--4相互作用的粒子对而缺少的校正达到总静电能的百分之几,
    并导致力和压力有微小的差别.

-   ` Shift `\
    类似于 ` vdwtype ` 的 ` Shift ` . 你可能想使用
    ` Reaction-Field-zero ` 代替, 它具有类似的势能形状, 但具有物理意义,
    并且含有排除校正项, 计算的能量更好.

-   ` Encad-Shift `\
    库仑势在整个范围内降低, 使用Encad模拟包中的定义

-   ` Switch `\
    类似于 ` vdwtype ` 的 ` Switch ` . 切换库仑势可导致严重的假象, 建议:
    使用 ` Reaction-Field-zero ` 代替.

-   ` User `\
    ` mdrun ` 需要使用文件 ` table.xvg ` , 里面包含用户定义的势能函数,
    包括排斥, 色散和库仑相互作用. 当存在对相互作用时, ` mdrun `
    也需要描述对相互作用的文件 ` tablep.xvg ` .
    当非键和对相互作用需要使用相同的相互作用时,
    用户可以为两个表格文件指定相同的文件名. 这些文件应包含7列: ` x ` 值,
    ` f(x) ` , ` -f'(x) ` , ` g(x) ` , ` -g'(x) ` , ` h(x) ` ,
    ` -h'(x) ` , 其中 ` f(x) ` 为库仑函数, ` g(x) ` 为色散函数, ` h(x) `
    为排斥函数. 当 ` vdwtype ` 不为 ` User ` 时, 会忽略 ` g ` , ` -g' `
    , ` h ` 和 ` -h' ` . 对非键相互作用, ` x `
    的取值应该从0到最大截断距离+ ` table-extension ` , 彼此的间距应均匀.
    对于对相互作用会使用文件中的表格长度. 当使用混合精度时,
    非用户自定义表格的最佳间距为 ` 0.002 ` \[nm\], 使用双精度时,
    最佳值为 ` 0.0005 ` \[nm\]. 在 ` x=0 ` 处的函数值并不重要.
    更多信息请参考印刷手册.

-   ` PME-Switch `\
    PME和对直接空间部分切换函数的组合(参见上文). ` rcoulomb ` 可以小于
    ` rlist ` .\
    主要用于等能量模拟(注意, ` PME ` 与 ` cutoff-scheme=Verlet `
    联用会更有效).

-   ` PME-User `\
    PME和用户表格的组合(参见上文). ` rcoulomb ` 可以小于 ` rlist ` .
    ` mdrun ` 会从用户表格中减去PME网格的贡献. 因为这个扣除,
    用户表格应包含大约10个十进制的位置.

-   ` PME-User-Switch `\
    PME-User和切换函数的组合(参见上文).
    对最终粒子之间的相互作用使用切换函数, 即,
    同时对用户提供的函数和PME网格校正部分使用切换函数.

` coulomb-modifier `

-   ` Potential-shift-Verlet `\
    选择 ` Potential-shift ` 与Verlet截断方案, 因为它(几乎)不增加计算量;
    选择 ` None ` 与组截断方案.

-   ` Potential-shift `\
    对库仑势进行固定的移位以使其在截断处为零.
    这使得势能可由力的积分得到. 注意这并不影响力或采样.

-   ` None `\
    使用未经修改的库仑势. 与组方案连用时, 这意味着没有使用准确的截断,
    会计算邻区列表中的所有粒子对之间的能量和力.

` rcoulomb-switch ` : (0) \[nm\]\
从何处开始切换库仑势, 只适用于应用力或势能的切换时.

` rcoulomb ` : (1) \[nm\]\
库伦截断距离

` epsilon-r ` : (1)\
相对介电常数. 为0时意味着无穷大.

` epsilon-rf ` : (0)\
反应场的相对介电常数, 仅与反应场静电方法一起使用. 为0时意味着无穷大.

### 7.3.11 VdW {#7311-vdw}

` vdwtype ` :

-   ` Cut-off `\
    双程截断, 邻区列表的截断距离为 ` rlist ` , VdW截断距离为 ` rvdw ` ,
    其中 ` rvdw≥rlist ` .

-   ` PME `\
    使用快速平滑粒子网格Ewald(SPME)方法计算VdW相互作用. 与静电计算类似,
    格点大小由 ` fourierspacing ` 控制. 内插的阶数由 ` pme-order ` 控制.
    直接/倒易空间的相对精度由 ` ewald-rtol-lj ` 控制,
    倒易程序部分使用的特定组合规则由 ` lj-pme-comb-rule ` 设置.

-   ` Shift `\
    此功能已废弃, 并被 ` vdw-modifier = Force-switch ` 取代.
    LJ(不包括Buckingham)势在整个范围内降低, 相应的力在 ` rvdw-switch `
    和 ` rvdw ` 之间平滑地衰减到零. 邻区搜索的截断距离 ` rlist ` 应该比
    ` rvdw ` 大0.1至0.3 nm以考虑电荷组大小及邻区列表更新时扩散的影响.

-   ` Switch `\
    此功能已废弃, 并被 ` vdw-modifier = Potential-switch ` 取代.
    LJ(不包括Buckingham)势在 ` rvdw-switch ` 之内是正常的,
    之后被逐渐降低, 并在 ` rvdw ` 处达到零. 势能和力函数都是连续平滑的.
    但需要注意, 所有的切换函数都会导致力的突起(增加,
    因为我们切换了势能). 邻区搜索的截断距离 ` rlist ` 应该比 ` rvdw `
    大0.1至0.3 nm以考虑电荷组大小及邻区列表更新时扩散的影响.

-   ` Encad-Shift `\
    LJ(不包括Buckingham)势在整个范围内降低, 使用Encad模拟包中的定义.

-   ` User `\
    参看 ` coulombtype ` 的 ` user ` 选项. ` x=0 ` 处的函数值并不重要.
    如果你想使用LJ校正, 请确保 ` rvdw ` 对应于用户定义函数的截断距离. 若
    ` coulombtype ` 没有设置为 ` User ` , 会忽略 ` f ` 和 ` -f' ` .

` vdw-modifier ` :

-   ` Potential-shift-Verlet `\
    选择 ` Potential-shift ` 与Verlet截断方案, 因为它(几乎)不增加计算量;
    选择 ` None ` 与组截断方案.

-   ` Potential-shift `\
    对VdW势进行固定的移位以使其在截断处为零. 这使得势能可由力的积分得到.
    注意这并不影响力或采样.

-   ` None `\
    使用未经修改的VdW势. 与组方案连用时, 这意味着没有使用准确的截断,
    会计算邻区列表中的所有粒子对之间的能量和力.

-   ` Force-switch `\
    在 ` rvdw-switch ` 和 ` rvdw ` 之间平滑地将力切换至零.
    这使得势能在整个范围内移位并在截断处切换至零, 注意,
    这种计算方法比普通截断方法更耗时, 并且不要求能量守恒, 因为
    ` Potential-shift ` 的能量守恒性也差不多.

-   ` Potential-switch `\
    在 ` rvdw-switch ` 和 ` rvdw ` 之间平滑地将势能切换至零. 注意,
    这会导致力的数值在切换区域产生很大的假象, 并且计算也更耗时.
    只有当你使用的力场要求使用时, 才能使用此选项.

` rvdw-switch ` : (0) \[nm\]\
从何处开始切换LJ力或势能, 只适用于应用力或势能的切换时.

` rvdw ` : (1) \[nm\]\
LJ或Buckingham的截断距离.

` DispCorr ` :

-   ` no `\
    不使用任何修正

-   ` EnerPres `\
    对能量和压力进行长程色散校正

-   ` Ener `\
    只对能量进行长程色散校正

### 7.3.12 表格 {#7312-表格}

` table-extension ` :: (1) \[nm\]\
非键势能函数查询表超出最大截断距离后的延伸长度.
该值应足够大以考虑电荷组大小及更新邻区列表时扩散的影响.
不使用用户定义势能时, 对1--4相互作用的查询表会使用相同的表格长度,
此长度与非键相互作用的表格无关. ` table-extension ` 的值决不可能影响
` rlist ` , ` rcoulomb ` 或 ` rvdw ` 的值.

` energygrp-table ` :\
当对静电和/或VdW使用用户表格时, 可以在这里列出能量组之间的配对,
这些配对可以使用单独的用户表格.
两个能量组的名称将被追加到表格的文件名中, 追加时按照它们在
` energygrps ` 中定义的顺序, 彼此之间以下划线隔开. 例如, 如果
` energygrps = Na Cl Sol ` , ` energygrp-table = Na Na Na Cl ` ,
除常规的 ` table.xvg ` 外, ` mdrun ` 还会读取 ` table_Na_Na.xvg ` 和
` table_Na_Cl.xvg ` , ` table.xvg ` 将被用于所有其它能量组配对.

### 7.3.13 Ewald {#7313-ewald}

` fourierspacing ` : (0.12) \[nm\]\
对普通的Ewald方法,
盒子尺寸和间距的比值决定了在每个(含符号)方向上使用的波矢数目的下限.
对PME和P3M, 该比率决定了沿每个轴使用的Fourier空间格点数目的下限.
在所有情况下, 每个方向上的数目都可通过非零的 ` fourier_n[xyz] `
重新进行设置. 为优化粒子-粒子相互作用计算和PME网格计算之间的相对负载,
知道下面的事实可能对你会有帮助,
当对库仑截断和PME格点间距使用相同的因子进行缩放时,
静电计算的精确度几乎保持不变.

` fourier-nx ` (0) ; ` fourier-ny ` (0) ; ` fourier-nz ` : (0)\
使用Ewald方法时, 倒易空间波矢的最高振幅. 使用PME或P3M时, 格点的大小.
这些值会覆盖每个方向的 ` fourierspacing ` 设置. 最佳的数值为2, 3,
5和7的幂, 避免使用大的素数.

` pme-order ` (4)\
PME内插的阶数. 4对应于立方内插. 当并行运行时, 你可以尝试6/8/10,
并同时减少格点尺寸.

` ewald-rtol ` (1e--5)\
Ewald移位的实空间势能在 ` rcoulomb ` 处的相对强度由 ` ewald-rtol ` 给出.
降低此值会得到更精确的实空间加和, 但计算倒易空间加和时需要更多的波矢.

` ewald-rtol-lj ` (1e--3)\
当使用PME计算VdW相互作用时, ` ewald-rtol-lj ` 用于控制 ` rvdw `
处色散能的相对强度, 与 ` ewald-rtol ` 控制静电能的方式类似.

` lj-pme-comb-rule ` (Geometric)\
LJ-PME倒易部分VdW参数的组合规则. 几何规则比Lorentz-Berthelot规则快得多,
因此通常建议优先选择几何规则,
即便力场的其余部分使用了Lorentz-Berthelot规则.

-   ` Geometric `\
    应用几何组合规则

-   ` Lorentz-Berthelot `\
    应用Lorentz-Berthelot组合规则

` ewald-geometry ` : (3d)

-   ` 3d `\
    在所有三个维度进行Ewald加和.

-   ` 3dC `\
    倒易部分的加和仍然以3D进行, 但对 ` z `
    方向的力和势能进行校正以产生伪二维的加和. 如果体系在 ` x-y `
    平面具有板状几何结构,
    你可以尝试增加盒子在z方向的长度(盒子的长度取为板高的3倍通常是可以的),
    并使用这个选项.

` epsilon-surface ` : (0)\
此选项控制3D Ewald加和的偶极校正. 默认值零意味着不进行校正.
将此值设置为围绕无穷大体系的假想表面的相对介电常数值, 即可进行校正.
小心, 如果你的体系含有自由移动的电荷, 你就不应该使用此选项.
这个值不影响长程校正的板状3DC方法.

### 7.3.14 温度耦合 {#7314-温度耦合}

` tcoupl: `

-   ` no `\
    不使用温度耦合.

-   ` berendsen `\
    通过Berendsen恒温器与温度为 ` ref-t ` \[K\]的热浴耦合, 时间常数
    ` tau-t ` \[ps\]. 多个组可以独立耦合, 这些组可在 ` tc-grps ` 中指定,
    彼此之间以空格分开.

-   ` nose-hoover `\
    使用扩展系综的Nose-Hoover温度耦合. 参考温度与耦合组的选择方法同上,
    但在这种情况下 ` tau-t ` \[ps\]控制的是平衡时温度涨落的周期,
    它与弛豫时间稍有不同. 对NVT模拟, 能量的守恒量会写入能量和日志文件.

-   ` andersen `\
    通过在每个时间步对一部分粒子随机化进行温度耦合.
    参考温度和耦合组的选择同上. ` tau-t `
    是每个分子两次随机化之间的平均时间间隔.
    此方法对粒子的动力学有一定的抑制作用, 但很少或不出现遍历问题.
    目前只能用于速度Verlet, 不能用于约束.

-   ` andersen-massive `\
    通过在不频繁的时间步对所有粒子随机化进行温度耦合.
    参考温度和耦合组的选择方法同上. ` tau-t `
    是所有分子两次随机化之间的时间间隔.
    此方法对粒子的动力学有一定的抑制作用, 但很少或不出现遍历问题.
    目前只能用于速度Verlet,

-   ` v-rescale `\
    通过速度缩放与随机项联用的方法进行温度耦合(JCP 126, 014101).
    此恒温器类似于Berendsen耦合, 使用相同的 ` tau-t ` 进行缩放,
    但随机项确保了能够产生正确的正则系综. 随机数种子通过 ` ld-seed `
    设置. 即便对 ` tau-t=0 ` 该恒温器也工作正常. 对于NVT模拟,
    能量的守恒量会写入能量和日志文件.

` nsttcouple: (-1) `\
与温度耦合的频率. 默认值--1表示 ` nsttcouple ` 与 ` nstlist ` 相等, 除非
` nstlist≤0 ` , 此时会使用10. 对速度Verlet积分方法, ` nsttcouple `
被设置为1.

` nh-chain-length ` (10)\
速度Verlet积分方法中Nose-Hoover恒温链的数目, 蛙跳式 ` md `
积分方法只支持1. Nose-Hoover链变量的数据不会输出到.edr, 但可使用环境变量
` GMX_NOSEHOOVER_CHAINS ` 设置输出.

` tc-grps ` :\
独立地耦合到温度浴的组

` tau-t ` : \[ps\]\
耦合的时间常数( ` tc-grps ` 中的每组一个值), --1意味着没有温度耦合

` ref-t ` : \[K\]\
耦合的参考温度( ` tc-grps ` 中的每组一个值)

### 7.3.15 压力耦合 {#7315-压力耦合}

` pcoupl ` :

-   ` no `\
    不使用压力耦合. 这意味着盒子的大小固定.

-   ` berendsen `\
    指数弛豫的压力耦合, 时间常数为 ` tau-p ` \[ps\].
    在每个时间步对盒子进行缩放. 有人认为, 这并不能得到正确的热力学系综,
    但在模拟的开始阶段这是缩放盒子的最有效方式.

-   ` Parrinello-Rahman `\
    扩展系综的压力耦合, 盒矢量服从运动方程.
    原子的运动方程也耦合到此方程. 没有瞬时的缩放.
    与Nose-Hoover温度耦合类似, 时间常数 ` tau-p `
    \[ps\]是平衡时压力的涨落周期.
    当你想要在数据收集过程中施加压力缩放时, 这可能是更好的方法,
    但需要当心, 如果从不同的压力开始模拟, 你可能会得到非常大的振荡.
    对那些精确涨落非常重要的NPT系综的模拟, 或者如果压力耦合时间非常短,
    这种方法可能不合适,
    因为前面时间步的压力会被GROMACS用于计算当前时间步的压力.

-   ` MTTK `\
    Martyna-Tuckerman-Tobias-Klein实现, 只用于 ` md-vv ` 或
    ` md-vv-avek ` , 非常类似于Parrinello-Rahman.
    与Nose-Hoover温度耦合类似, 时间常数 ` tau-p `
    \[ps\]是平衡时压力的涨落周期.
    当你想要在数据收集过程中施加压力缩放时, 这可能是更好的方法,
    但需要当心, 如果从不同的压力开始模拟, 你可能会得到非常大的振荡.
    目前仅支持各向同性缩放.

` pcoupltype ` :

-   ` isotropic `\
    各向同性压力耦合, 时间常数为 ` tau-p ` \[ps\].
    压缩系数和参考压力分布分别通过 ` compressibility ` \[bar ^-1^ \]和
    ` ref-p ` \[bar\] 进行设置, 都只需要一个值.

-   ` semiisotropic `\
    压力耦合在 ` x ` 和 ` y ` 方向各向同性, 但 ` z ` 方向上的不同.
    对膜模拟有用. 需要两个值, 分别对应于 ` x/y ` 方向和 ` z ` 方向.

-   ` anisotropic `\
    同上, 需要6个值, 分别是 ` xx ` , ` yy ` , ` zz ` , ` xy/yx ` ,
    ` xz/zx ` 和 ` yz/zy ` 分量. 当非对角线压缩系数为零时,
    长方体盒子在模拟中仍将保持为长方体. 要注意的是,
    各向异性缩放可能会导致模拟盒子的剧烈变形.

-   ` surface-tension `\
    表面张力耦合, 表面平行于xy平面. ` z ` 方向采用正常的压力耦合,
    表面张力耦合到盒子的 ` x/y ` 维度. ` ref-p `
    的第一个值是参考表面张力与表面数目的乘积, 单位为\[bar nm\],
    第二个值是参考的z-压力, 单位为\[bar\]. 两个 ` compressibility `
    的值(单位\[bar ^-1^ \])分别为 ` x/y ` 和 ` z ` 的方向的压缩系数.
    z方向压缩系数的值应该具有一定的准确度, 因为它会影响表面张力的收敛性,
    也可以将其设置为零以保持盒子的高度固定.

` nstpcouple ` : (--1)\
压力耦合的频率. 默认值为--1, 表示 ` nstpcouple ` 等于 ` nstlist ` , 除非
` nstlist≤0 ` , 此时使用10. 对速度Verlet积分方法, ` nstpcouple `
被设置为1.

` tau-p(1) ` : \[ps\]\
耦合的时间常数

` compressibility ` : \[bar ^-1^ \]\
压缩系数(注意: 现在真的是以bar ^-1^ 为单位了), 处于1个标准大气压, 300
K下的水其压缩系数为4.5e--5 \[bar ^-1^ \].

` ref-p ` : \[bar\]\
耦合的参考压力

` refcoord-scaling ` :

-   ` no `\
    不修改用于位置限制的参考坐标. 注意,
    使用该选项维里和压力将取决于参考坐标的绝对位置.

-   ` all `\
    利用压力耦合缩放矩阵对参考坐标进行缩放.

-   ` com `\
    利用压力耦合缩放矩阵对参考坐标的质心进行缩放.
    每个参考坐标到质心的矢量不进行缩放. 只使用一个质心,
    即便有多个分子存在位置限制. 在计算初始构型参考坐标的质心时,
    不考虑周期性边界条件.

### 7.3.16 模拟退火 {#7316-模拟退火}

在GROMACS中, 对每个温度组的模拟退火是分开控制的.
参考温度是一个分段线性函数, 对每个组可以使用任意数目的点,
并选择单一序列或周期性退火类型. 实际退火是通过动态地改变参考温度进行的,
由于选择的温控算法也使用该温度, 所以要记住,
体系通常不会瞬间达到参考温度!

` annealing ` :\
每个温度组的退火类型

-   ` no `\
    不进行模拟退火, 只耦合到参考温度.

-   ` single `\
    退火点的单一序列. 如果模拟时间比最后一点的时间还长,
    当退火序列达到最后的时间点后, 温度将耦合到最后一点的值并保持不变.

-   ` periodic `\
    一旦到达最后的参考时间, 退火将从第一个参考点重新开始.
    此过程不断重复, 直到模拟结束.

` annealing-npoints ` :\
退火参考/控制点数目的列表, 用于每个温度组. 对不退火的组使用0.
此项的数目应等于温度组的数目.

` annealing-time ` :\
退火参考/控制点的时间列表, 用于每个温度组.如果你正使用周期性退火类型,
时间将与最终值取模, 即, 如果时间为0, 5, 10和15, 耦合将会在15 ps, 30 ps,
45 ps等时间点后以0 ps时值重新启动. 此项的数目应该等于
` annealing-npoints ` 给出的数字的总和.

` annealing-temp ` :\
退火参考/控制点的温度列表, 用于每个温度组. 此项的数目应该等于
` annealing-npoints ` 给出的数字的总和.

很迷惑? 好吧, 让我们举个例子. 假设你有两个温度组, 组的选择设置为
` annealing = single periodic ` , 组的点数设置为
` annealing-npoints = 3 4 ` , 退火时间设置为
` annealing-time = 0 3 6 0 2 4 6 ` , 温度设置为
` annealing-temp = 298 280 270 298 320 320 298 ` . 在0
ps第一组将被耦合到298 K, 但参考温度在3 ps内将线性下降到280 K, 然后在3
ps到6 ps这段时间内, 温度将从280 K线性变化到270 K. 在这之后温度保持270
K不变. 0 ps时第二组被耦合到298 K, 在2 ps内温度线性增加到320 K,
并保持不变直到4 ps. 在4 ps和6 ps之间温度降低到298 K,
然后将以同样的方式重新开始, 即在6 ps和8 ps之间从298 K线性上升到320 K.
如果你不确定, 请检查 ` grompp ` 给出的汇总信息!

### 7.3.17 速度产生 {#7317-速度产生}

` gen-vel ` :

-   ` no `\
    不产生速度. 当输入结构文件中不存在速度时, 速度被设置为零.

-   ` yes `\
    ` grompp ` 根据温度为 ` gen-temp ` \[K\]的麦克斯韦分布产生速度,
    随机数种子为 ` gen-seed ` . 此选项只对 ` md ` 积分器有意义.

` gen-temp ` : (300) \[K\]\
麦克斯韦分布的温度

` gen-seed ` : (--1) \[整数\]\
用于初始化产生随机速度的随机数发生器, 当 ` gen-seed ` 设置为--1时,
将使用伪随机种子.

### 7.3.18 键约束 {#7318-键约束}

` constraints ` :

-   ` none `\
    除在拓扑中明确定义的键外, 不使用任何约束, 即,
    利用简谐(或其他)势或Morse势(取决于 ` morse ` 的设置)描述键,
    利用简谐(或其他)势描述键角.

-   ` h-bonds `\
    将含有氢原子的键转换为约束.

-   ` all-bonds `\
    将所有的键都转换为约束.

-   ` h-angles `\
    将所有涉及氢原子的键和键角都转换为键约束.

-   ` all-angles `\
    将所有的键和键角都转换为键约束.

` constraint-algorithm ` :

-   ` LINCS `\
    线性约束求解器(LINear Constraint Solver).
    区域分解会与并行版本的P-LINCS一起使用. 使用 ` lincs-order `
    设置精度, 同时也设置矩阵求逆展开中矩阵的数目. 经过矩阵求逆校正后,
    算法会执行一次迭代校正以补偿因旋转导致的增长. 这种迭代的次数可以通过
    ` lincs-iter ` 控制. 每 ` nstlog ` 步,
    相对约束的根均方偏差会打印到日志文件. 如果某根键在一步中的旋转超过了
    ` lincs-warnangle ` (度), 将打印警告到日志文件和 ` stderr ` .
    LINCS不能用于耦合键角约束.

-   ` SHAKE `\
    与LINCS相比, SHAKE方法稍慢, 且不太稳定, 但能用于键角约束. 相对容差由
    ` shake-tol ` 设置, 对"正常"的MD, 0.0001是合适的值.
    SHAKE不支持处于不同节点上的原子之间的约束,
    因此当存在电荷组之间的约束时, 它不能与区域分解一起使用.
    SHAKE不能用于能量最小化.

` continuation ` :\
此选项以前的名字为 ` unconstrained-start ` .

-   ` no `\
    对初始构型施加约束并复位壳层

-   ` yes `\
    不对初始构型施加约束, 不复位壳层, 对准确的延续和重新运行很有用.

` shake-tol ` : (0.0001)\
SHAKE相对容差

` lincs-order ` : (4)\
约束耦合矩阵展开的最高阶数. 当约束形成三角形时,
在这些三角形约束的正常展开之上会施加一个相同阶的展开.
对"正常"的MD模拟通常4阶就足够了;
对含有虚拟位点或BD并使用大时间步长的模拟, 需要使用6阶;
对精确的能量最小化, 可能需要使用8或更高的阶数. 与区域分解联用时,
原胞的大小由 ` lincs-order ` +1个约束张成的距离决定.
如果想进行超过此限制的缩放, 可以降低 ` lincs-order ` , 增加
` lincs-iter ` , 因为当(1+ ` lincs-iter ` )\* ` lincs-order `
保持不变时, 精度不会变差.

` lincs-iter ` : (1)\
LINCS中用于校正旋转增长的迭代次数. 对于正常的运行一步就足够了.
但对于NVE模拟, 如果需要精确的能量守恒或精确的能量最小化,
你可能需要将其增加到2.

` lincs-warnangle ` : (30) \[度\]\
LINCS失效前键能够旋转的最大角度.

` morse ` :

-   ` no `\
    使用简谐势描述键

-   ` yes `\
    使用Morse势描述键

### 7.3.19 能量组排除 {#7319-能量组排除}

` energygrp-excl ` :\
所有非键相互作用被排除在外的能量组对. 例如: 如果你有两个能量组
` Protein ` 和 ` SOL ` , 指定\
` energygrp-excl = Protein Protein SOL SOL `\
只会给出蛋白质和溶剂之间的非键相互作用. 对于加快 ` mdrun -rerun `
的能量计算, 排除冻结组之间的相互作用, 此选项特别有用.

### 7.3.20 墙 {#7320-墙}

` nwall ` : 0\
当设置为 ` 1 ` 时, 在 ` z=0 ` 处存在一面墙; 当设置为 ` 2 ` 时,
还存在一面位于 ` z=z-box ` 处的墙. 墙只能用于 ` pbc=xy ` . 当设置为
` 2 ` 时,
可以使用压力耦合与Ewald加和(通常最好是使用半各向同性的压力耦合, 并将
` x/y ` 的压缩率设置为0, 否则表面积会发生变化).
墙会与体系的其余部分进行相互作用, 其 ` atomtype ` 是可选的.
会自动增加能量组 ` wall0 ` 和 ` wall1 ` ( ` nwall=2 `
时)以监测能量组与每面墙之间的相互作用. Z方向的质心运动移除将被关闭.

` wall-atomtype ` :\
每面墙在力场中的原子类型名称.
通过(例如)在拓扑文件中定义一个特殊的墙原子类型及其组合规则,
可以独立地调整每个原子类型和墙的相互作用.

` wall-type ` :

-   ` 9-3 `\
    对墙后体积进行积分的LJ势: 9--3势

-   ` 10-4 `\
    对墙面进行积分的LJ势: 10--4势

-   ` 12-6 `\
    直接的LJ势, 由与墙的Z距离决定

-   ` table `\
    用户定义的势, 根据与墙的Z距离进行索引, 以类似于 ` energygrp-table `
    的选项读入, 其中的第一个名称为"正常"能量组, 第二名称为 ` wall0 ` 或
    ` wall1 ` , 只使用表中的色散和排斥列.

` wall-r-linpot ` : --1 \[nm\]\
与墙的距离在此值以下时, 势能线性连续, 因此力为常数. 当一些原子超过墙时,
将此选项设置为正值对平衡尤其有用. 当此值 [ \\(\\le 0\\) ]{.math} (对
` wall-type=table ` 则是\<0)时, 原子超过墙后会产生致命错误.

` wall-density ` : \[nm ^-3^ /nm ^-2^ \]\
每面墙的原子数密度, 适用于类型为9--3和10--4的墙

` wall-ewald-zfac ` : 3\
第三个盒矢量的缩放因子, 仅用于Ewald加和, 最小值为2. Ewald加和只能与
` nwall=2 ` 联用, 并需要使用 ` ewald-geometry=3dc ` .
盒子中真空层的作用是降低周期性映象之间不合实际的库仑相互作用.

### 7.3.21 质心牵引 {#7321-质心牵引}

` pull ` :

-   ` no `\
    不使用质心牵引. 以下所有的牵引选项都将被忽略(选项如果存在于 ` .mdp `
    文件中会导致警告)

-   ` umbrella `\
    使用参考组与一个或多个组之间的伞势牵引质心

-   ` constraint `\
    使用参考组与一个或多个组之间的约束牵引质心. 设置与 ` umbrella `
    完全相同, 除了使用的是刚性约束而不是简谐势.

-   ` constant-force `\
    使用线性势牵引质心, 拉力恒定. 此选项没有参考位置, 因此不会使用参数
    ` pull-init ` 和 ` pull-rate ` .

` pull-geometry ` :

-   ` distance `\
    沿着连接两组的矢量进行牵引. 可以使用 ` pull-dim ` 选择分量.

-   ` direction `\
    在 ` pull-vec ` 方向进行牵引.

-   ` direction-periodic `\
    与 ` direction ` 相同, 但允许距离超过盒长的一半. 使用这种几何设置,
    盒子在牵引维度不应该发生变化(例如, 无压力缩放),
    不会将拉力添加到维里.

-   ` cylinder `\
    用于相对于层的牵引, 参考质心由参考组的一个局部圆柱部分给出.
    牵引方向为 ` pull-vec ` . 使用两个半径从参考组中选择一个圆柱,
    圆柱围绕的轴以 ` pull-vec ` 方向通过牵引组. 半径 ` pull-r1 `
    之内的所有相对权重为1, ` pull-r1 ` 和 ` pull-r0 `
    之间的权重被切换到零. 也会使用质量权重. 注意,
    半径应小于盒子长度的一半. 对于倾斜圆柱, 半径应该比盒长一半更小,
    因为参考组中的原子与牵引组质心同时具有径向和轴向分量.

` pull-dim ` : (Y Y Y)\
与牵引几何设置 ` distance ` 联用的距离分量,
也会设置打印到输出文件的分量.

` pull-r1 ` : (1) \[nm\]\
牵引几何 ` cylinder ` 的圆柱内径

` pull-r0 ` : (1) \[nm\]\
牵引几何 ` cylinder ` 的圆柱外径

` pull-constr-tol ` : (1e--6)\
约束牵引的相对约束容差

` pull-start ` :

-   ` no `\
    不修改 ` pull-init `

-   ` yes `\
    将初始构型的质心距离添加到 ` pull-init `

` pull-print-reference ` : (10)

-   ` no `\
    不打印每个牵引坐标中第一组的质心

-   ` yes `\
    打印每个牵引坐标中第一组的质心

` pull-nstxout ` : (10)\
所有牵引组质心的输出频率

` pull-nstfout ` : (1)\
所有牵引组受力的输出频率

` pull-ngroups ` : (1)\
牵引组的数量, 使用时不包括绝对参考组.
牵引组可以在多个牵引坐标中重复使用. 下面只给出了第1组的牵引选项,
对其他组的选项, 只需简单地增加组编号即可.

` pull-ncoords ` : (1)\
牵引坐标的数目. 下面只给出了坐标1的牵引选项, 对其他其他坐标的选项,
只需简单地增加组编号即可.

` pull-group1-name ` :\
牵引组的名称, 在索引文件或默认组中查找, 以获得涉及的原子.

` pull-group1-weights ` :\
可选的相对权重, 原子质量乘以此值给出质心的总权重. 此值应为0,
意味着所有原子的相对权重为1, 或牵引组中原子的数目.

` pull-group1-pbcatom ` : (0)\
处理组内周期性边界条件的参考原子(不影响组间PBC的处理).
此选项仅当牵引组的直径超过最短盒矢量长度的一半时才重要. 为了确定质心,
组中所有原子被置于其最接近 ` pull-group1-pbcatom ` 的周期性映象.
此值为0时意味着使用中间原子(编号顺序). 此参数不能用于牵引几何
` cylinder ` . 此值为--1时启用余弦加权,
这对周期性的体系中的一组分子有用, 例如, 水的平板(参考 Engin et al. J.
Chem. Phys. B 2010).

` pull-coord1-groups ` :\
给出牵引坐标作用的两个组的编号. 第一个编号可以是0, 在这种情况下使用
` pull-coord1-origin ` 的绝对参考. 使用绝对参考时体系不再具有平移不变性,
你应该考虑如何处理质心的运动.

` pull-coord1-origin ` : (0.0 0.0 0.0)\
使用绝对参考时牵引的参考位置.

` pull-coord1-vec ` : (0.0 0.0 0.0)\
牵引方向. ` grompp ` 会对此矢量进行归一化.

` pull-coord1-init: ` : (0.0) \[nm\]\
t=0时刻的基准距离.

` pull-coord1-rate ` : (0) \[nm/ps\]\
基准位置的变化速率.

` pull-coord1-k ` : (0) \[kJ mol ^-1^ nm ^-2^ / kJ mol ^-1^ nm ^-1^ \]\
力常数. 对于伞势牵引, 此值为简谐力常数\[kJ mol ^-1^ nm ^-2^ \].
对于恒力牵引, 此值为线性势的力常数, 因而为力常数\[kJ mol ^-1^ nm ^-1^
\]的负值(!).

` pull-coord1-kB ` : (pull-k1) \[kJ mol ^-1^ nm ^-2^ / kJ mol ^-1^ nm
^-1^ \]\
与 ` pull-coord1-k ` 类似, 但用于状态B. 仅当启用 ` free-energy `
时才使用. 力常数为 (1-lambda) *` pull-coord1-k ` +lambda*
` pull-coord1-kB ` .

### 7.3.22 NMR精修 {#7322-nmr精修}

` disre ` :

-   ` no `\
    忽略拓扑文件中的距离约束信息

-   ` simple `\
    简单(每分子)的距离约束.

-   ` ensemble `\
    一个模拟盒中分子系综的距离约束. 正常情况下,
    需要对多个子体系进行系综平均, 每个系综处于单独的盒子中, 使用
    ` mdrun -multi ` 提供包含不同坐标和/或速度的 ` topol0.tpr ` ,
    ` topol1.tpr ` ,... 环境变量 ` GMX_DISRE_ENSEMBLE_-SIZE `
    设置每个系综中体系的数目(通常等于 ` mdrun -multi ` 的值).

` disre-weighting ` :

-   ` equal ` (默认)\
    将约束力平分到约束中的所有原子对上

-   ` conservative `\
    约束力为约束势的导数, 将导致原子对的权重为r ^-7^ . 当 ` disre-tau `
    为零时力是守恒的.

` disre-mixed `

-   ` no `\
    计算约束力时使用时间平均的违反

-   ` yes `\
    计算约束力时使用时间平均违反与瞬时违反乘积的平方根

` disre-fc ` : (1000) \[kJ mol ^-1^ nm ^-2^ \]\
距离约束的力常数, 对每个约束乘以一个(可能)不同的因子,
约束在拓扑文件中相互作用的 ` fac ` 列给出.

` disre-tau: ` (0) \[ps\]\
进行距离约束平均的时间常数. 零值关闭时间平均.

` nstdisreout ` : (100) \[步\]\
进行时间平均的间隔步数,
也是约束中涉及的所有原子对之间的瞬时距离写入到能量文件的间隔步数(会使能量文件变得非常大)

` orire ` :

-   ` no `\
    忽略拓扑文件中的取向约束信息

-   ` yes `\
    使用取向约束, 可以利用 ` mdrun -multi ` 进行系综平均

` orire-fc ` : (0) \[kJ mol\]\
取向约束的力常数, 对每个约束乘以一个(可能)不同的权重因子.
可设置为零以获得自由模拟的取向.

` orire-tau ` : (0) \[ps\]\
对取向约束进行时间平均的时间常数. 零值关闭时间平均.

` orire-fitgrp ` :\
取向约束的叠合组. 此原子组用于确定体系相对于参考取向的旋转矩阵 ` R ` .
参考取向为第一个子体系的初始构型. 对蛋白质, 主链是合理的选择.

` nstorireout ` : (100) \[步\]\
进行时间平均的间隔步数,
也是所有约束的瞬时取向和分子序张量写入到能量文件的间隔步数(会使能量文件变得非常大)

### 7.3.23 自由能计算 {#7323-自由能计算}

` free-energy ` :

-   ` no `\
    只使用拓扑A.

-   ` yes `\
    在拓扑A(lambda=0)和拓扑B(lambda=1)之间进行内插,
    并将哈密顿量对lambda(由 ` dhdl-derivatives `
    指定)的导数或哈密顿量对其他lambda值(由 ` foreign-lambda `
    指定)的差值写入到能量文件和/或 ` dhdl.xvg ` . 这些文件可用诸如
    ` g_bar ` 等程序进行处理. 对势能, 键长,
    键角进行线性内插的的方法见本手册中的说明. 当 ` sc-alpha ` 大于零时,
    对LJ和库仑相互作用使用软核势.

-   ` expanded `\
    启用扩展系综模拟, 其中转化状态变为动力学变量,
    允许不同哈密顿之间的跳跃. 请参考扩展系综的选项,
    这些选项控制了如何进行扩展系综模拟.
    扩展系综模拟中使用的不同哈密顿由其他自由能选项定义.

` init-lambda ` : (--1) \[浮点数\]\
lambda的起始值. 通常, 只能用于慢增长方法(即 ` delta-lambda ` 非零).
在其他情况下, 应指定 ` init-lambda-state ` 来代替. 必须大于或等于0.

` delta-lambda ` : (0)\
每个时间步lambda的增量

` init-lambda-state ` : (--1) \[整数\]\
lambda状态的起始值. 指定应使用lambda向量( ` coul-lambdas ` ,
` vdw-lambdas ` , ` bonded-lambdas ` , ` restraint-lambdas ` ,
` mass-lambdas ` , ` temperature-lambdas ` , ` fep-lambdas ` )哪一列.
这是一个从零开始的索引: ` init-lambda-state ` 0表示第一列, 依此类推.

` fep-lambdas ` : ()\
零, 一个或更多lambda值, 会计算与其相应的哈密顿差值, 并每隔 ` nstdhdl `
步写入到dhdl.xvg文件. 值必须处于0和1之间.
不同lambda值之间的自由能差值可以利用 ` g_bar ` 进行计算. ` fep-lambdas `
不同于其他-lambdas关键词, 因为所有未指定的lambda向量的分量都将使用
` fep-lambdas ` (包括约束的lambdas, 因而也包括牵引代码约束).

` coul-lambdas ` : ()\
零, 一个或更多lambda值, 会计算与其相应的哈密顿差值, 并每隔 ` nstdhdl `
步写入到dhdl.xvg文件. 值必须处于0和1之间.
只有静电相互作用由此lambda向量的分量控制(并且仅当lambda=0和lambda=1的状态具有不同的静电相互作用时).

` vdw-lambdas ` : ()\
零, 一个或更多lambda值, 会计算与其相应的哈密顿差值, 并每隔 ` nstdhdl `
步写入到dhdl.xvg文件. 值必须处于0和1之间. 只有van der
Waals相互作用由此lambda向量的分量控制.

` bonded-lambdas ` : ()\
零, 一个或更多lambda值, 会计算与其相应的哈密顿差值, 并每隔 ` nstdhdl `
步写入到dhdl.xvg文件. 值必须处于0和1之间.
只有键合相互作用由此lambda向量的分量控制.

` restraint-lambdas ` : ()\
零, 一个或更多lambda值, 会计算与其相应的哈密顿差值, 并每隔 ` nstdhdl `
步写入到dhdl.xvg文件. 值必须处于0和1之间. 只有约束相互作用:
二面角约束和牵引代码约束由此lambda向量的分量控制.

` mass-lambdas ` : ()\
零, 一个或更多lambda值, 会计算与其相应的哈密顿差值, 并每隔 ` nstdhdl `
步写入到dhdl.xvg文件. 值必须处于0和1之间.
只有粒子质量由此lambda向量的分量控制.

` temperature-lambdas ` : ()\
零, 一个或更多lambda值, 会计算与其相应的哈密顿差值, 并每隔 ` nstdhdl `
步写入到dhdl.xvg文件. 值必须处于0和1之间.
只有温度由此lambda向量的分量控制. 注意这些lambda不能用于副本交换,
只能用于模拟回火.

` calc-lambda-neighbors ` (1)\
如果设置了 ` init-lambda-state ` , 此选项控制lambda值的数目,
会计算相应的哈密顿差值并输出. 正值将lambda点的数目限制为只计算到
` init-lambda-state ` 的第n个邻居. 例如, 若 ` init-lambda-state ` 为5,
此参数值为2, 会计算lambda点3--7的能量并输出.
此值为--1意味着会输出所有lambda. 对正常的BAR如g_bar, 此值取1就足够了,
而对于MBAR应该使用--1.

` sc-alpha ` : (0)\
软核势的α参数, 为0时对LJ和库仑相互作用进行线性内插

` sc-r-power ` : (6)\
软核势方程中径向项的次数. 可能的值为6和48. 6更标准一些, 为默认值.
当使用48时, ` sc-alpha ` 一般应更小一些(0.001至0.003).

` sc-coul ` : (no)\
是否对分子的库仑相互作用使用软核自由能相互作用变换. 默认是不使用,
因为在禁用van der Waals相互作用前线性地禁用库仑相互作用通常更有效.

` sc-power ` : (0)\
软核函数中lambda的次数, 只支持1和2

` sc-sigma ` : (0.3) \[nm\]\
软核势的sigma值, 用于那些C6或C12参数为零, 或sigma小于 ` sc-sigma `
的粒子

` couple-moltype ` :\
这里可以设置计算溶剂化或耦合自由能的分子类型(在拓扑中定义). 特殊选项
` system ` 用于耦合体系中的所有分子类型,
这对于平衡由(几乎)随机坐标开始的体系有用. 必须启用 ` free-energy ` 选项.
此分子类型的Van der
Waals相互作用和/或电荷在lambda=0和lambda=1之间可以启用或关闭, 取决于
` couple-lambda0 ` 和 ` couple-lambda1 ` 的设置.
如果想对分子多个副本中的一个去耦合,
你需要在拓扑中复制并重命名分子的定义.

` couple-lambda0 ` :

-   ` vdw-q `\
    在lambda=0开启所有相互作用

-   ` vdw `\
    在lambda=0电荷为零(无库仑相互作用)

-   ` q `\
    在lambda=0开启Van der Waals相互作用. 需要使用软核相互作用避免奇点

-   ` none `\
    在lambda=0关闭Van der Waals相互作用, 并且电荷为零.
    需要使用软核相互作用避免奇点

` couple-lambda1 ` :\
类似于 ` couple-lambda1 ` , 但用于lambda=1

` couple-intramol ` :

-   ` no `\
    对于分子类型 ` couple-moltype ` , 分子内的所有非键相互作用都被排除,
    或以显式的对相互作用代替. 以这种方式,
    分子的去耦合状态对应于无周期效应的适当真空状态.

-   ` yes `\
    也启用/关闭分子内的Van der Waals和库仑相互作用.
    用于较大分子的配分自由能,
    这种情况下分子内的非键相互作用可能导致分子被动力学地局限于真空中的构型.
    不会关闭1--4对相互作用.

` nstdhdl ` : (100)\
输出dH/dlambda和可能的哈密顿差值到dhdl.xvg文件的频率, 0表示不输出,
此值应为 ` nstcalcenergy ` 的倍数.

` dhdl-derivatives ` : (yes)\
如果为yes(默认值), 每 ` nstdhdl ` 步会输出哈密顿对lambda的导数. 使用
` g_bar ` (尽管使用正确的 ` foreign-lambda ` 设置也可以做到,
但可能不够灵活)或热力学积分对线性能量差值进行内插时需要这些导数值.

` dhdl-print-energy ` : (no)\
在dhdl文件中包含总能量会势能. 可用选项有'no', 'potential'或'total'.
如果感兴趣的状态处于不同的温度, 后面进行自由能分析时需要这些信息.
如果所有状态的温度都相同, 不需要这些信息. 当使用 ` mdrun -rerun ` 产生
` dhdl.xvg ` 文件时, 'potential'选项非常有用. 当从已有轨迹重新运行时,
动能经常是不正确的, 因此必须单独使用势能来计算残余的自由能,
并解析地计算动能分量.

` separate-dhdl-file ` : (yes)

-   ` yes `\
    计算出的自由能(在 ` foreign-lambda ` 和 ` dhdl-derivatives `
    中设置)写入到一个单独的文件, 默认文件名为 ` dhdl.xvg ` . ` g_bar `
    可直接使用此文件.

-   ` no `\
    自由能写入到能量输出文件( ` ener.edr ` , 以累积块的形式, 每
    ` nstenergy ` 步一次), 可使用 ` g_energy ` 或直接使用 ` g_bar `
    来提取.

` dh-hist-size ` : (0)\
如果为非零值, 指定分格哈密顿差值( ` foreign-lambda `
指定)或导数dH/dl值的直方图的大小, 并写入ener.edr. 当计算自由能差值时,
这样做可以节省磁盘空间. 每个 ` foreign lambda ` 输出一个直方图,
每个dH/dl输出两个直方图, 每 ` nstenergy ` 步一次. 记住,
不正确的直方图设置(尺寸过小或分格太宽)可引入错误. 不要使用直方图,
除非你确定自己需要它.

` dh-hist-spacing ` : (0.1)\
指定直方图的分格宽度, 以能量为单位. 与 ` dh-hist-size ` 结合使用.
此大小限制了自由能计算的精度. 不要使用直方图, 除非你确定自己需要它.

### 7.3.24 扩展系综计算 {#7324-扩展系综计算}

` nstexpanded `\
在扩展系综模拟中, 尝试移动之间的积分步数, 移动时会改变体系的哈密顿量.
必须为 ` nstcalcenergy ` 的倍数, 但可以大于或小于 ` nstdhdl ` .

` lmc-stats: ` :

-   ` no `\
    不在状态空间中进行Monte Carlo.

-   ` metropolis-transition `\
    使用 ` Metropolis ` 权重更新每个状态的扩展系综权重. Min1,
    exp(-(beta_new u_new - beta_old u_old))

-   ` barker-transition `\
    使用Barker转移判据更新每个状态i的扩展系综权重, 定义为exp(-beta_new
    u_new)/\[exp(-beta_new u_new)+exp(-beta_old u_old)\]

-   ` wang-landau `\
    使用Wang-Landau算法(在状态空间, 而不是能量空间)来更新扩展系综的权重.

-   ` min-variance `\
    使用Escobedo等人的最小方差更新方法来更新扩展系综的权重.
    权重将不再是自由能, 但更重视那些需要更多采样以给出不确定度的状态.

` lmc-mc-move ` :

-   ` no `\
    不在状态空间中进行Monte Carlo.

-   ` metropolis-transition `\
    随机选择一个新的状态, 向上或向下,
    然后使用Metropolis判据来决定接受还是拒绝: Min1, exp(-(beta_new
    u_new - beta_old u_old))

-   ` barker-transition `\
    随机选择一个新的状态, 向上或向下,
    然后使用Barker转移判据来决定接受还是拒绝: exp(-beta_new
    u_new)/\[exp(-beta_new u_new)+exp(-beta_old u_old)\]

-   ` gibbs `\
    使用给定坐标状态的条件权重 (exp(-beta_i u_i)/sum_k exp(beta_i u_i)
    决定转移到哪个状态.

-   ` metropolized-gibbs `\
    使用给定坐标状态的条件权重 (exp(-beta_i u_i)/sum_k exp(beta_i u_i)
    决定转移到哪个状态, **排除** 当前状态, 然后使用拒绝步骤保证细致平衡.
    总是比Gibbs方法高效, 尽管在许多情况下只略微高效一点,
    例如只有当最近的邻区有明显的相空间重叠时.

` lmc-seed ` : (--1)\
在状态空间进行Monte Carlo移动时使用的随机数种子. 当 ` lmc-seed `
设置为--1时, 将使用伪随机数种子.

` mc-temperature ` :\
用于接受/拒绝Monte Carlo移动的温度. 如果未指定, 会使用在第一组 ` ref_t `
中指定的模拟温度.

` wl-ratio ` : (0.8)\
要重置的状态占据数直方图的截断值, 自由能增量重置为delta-\>delta\*
` wl-scale ` . 如果我们定义Nratio =
(每个直方区间的采样数)/(每个直方区间的平均采样数), ` wl-ratio `
的值为0.8意味着, 只有当所有Nratio\>0.8 **并且** 同时所有1/Nratio\>0.8时.
直方图才被认为时平坦的.

` wl-scale ` : (0.8)\
每当直方图被认为很平时, 自由能Wang-Landau增量的当前值会乘以 ` wl-scale `
. 此值必须介于0和1之间.

` init-wl-delta ` : (1.0)\
Wang-Landau增量的初始值, 以kT为单位. 接近1 kT的值通常最有效,
尽管有时2--3 kT的值更好, 如果自由能差值较大的话.

` wl-oneovert ` : (no)\
在大量采样极限情况下, 设置Wang-Landau增量的缩放为模拟时间的倒数.
有确切证据表明,
这里使用的状态空间中标准的Wang-Landau算法可导致自由能'燃烧'到不正确的值,
且依赖于初始状态. 当 ` wl-oneovert ` 为yes时, 若增量小于1/N,
其中N为收集的样本数(因此正比于数据收集时间, '1/t'),
则将Wang-Lambda增量设设置为1/N, 每步降低. 一旦发生这种情况, 将忽略
` wl-ratio ` , 但当达到 ` lmc-weights-equil ` 设置的平衡判据后,
权重仍将停止更新.

` lmc-repeats ` : (1)\
控制每次迭代中执行每个Monte Carlo交换类型的次数. 在大量Monte
Carlo重复的极限情况下, 所有方法都收敛到Gibbs采样方法.
此值通常不需要不同于1.

` lmc-gibbsdelta ` : (--1)\
限制Gibbs采样到选定的相邻状态数. 对于Gibbs采样方法,
对所有定义的状态都进行采样有时效率比较低. ` lmc-gibbsdelta `
取正值意味着只有加或减 ` lmc-gibbsdelta ` 的状态才能进行上下交换.
值为--1意味着所有状态都可交换. 当状态数少于100时,
包括所有的状态可能并没有那么耗时.

` lmc-forced-nstart ` : (0)\
强制在初始状态空间进行采样以产生权重. 为得到合理的初始权重,
此设置允许模拟从开始到最后的lambda状态进行驱动, 在每个状态,
移动到下一lambda状态前进行 ` lmc-forced-nstart ` 步. 如果
` lmc-forced-nstart ` 足够长(几千步, 也许), 权重就会接近正确值. 然而,
在大多数情况下, 简单地使用标准的权重平衡算法可能更好.

` nst-transition-matrix ` : (--1)\
输出扩展系综转移矩阵的频率. 负值表示只在模拟的最后输出.

` symmetrized-transition-matrix ` : (no)\
是否对称化经验转移矩阵. 在极限情况下, 矩阵将是对称的,
但在短的时间尺度内由于统计噪声会变得不对称. 通过使用矩阵T_sym = 1/2 (T +
transpose(T))强制对称化, 可以避免一些问题, 如(振幅很小的)负本征值.

` mininum-var-min ` : (100)\
如果选择了 ` min-variance ` 策略( ` lmc-stats ` 的选项仅适用于大量采样,
如果在每个状态使用的样本太少会被卡住.) ` mininum-var-min ` 为每个状态在
` min-variance ` 策略被激活之前允许的最小采样数.

` init-lambda-weights ` :\
用于扩展系综状态的初始权重(自由能). 默认为零权重向量. 格式类似于
` fep-lambda ` 设置的lambda向量, 但权重可以为任意浮点数. 单位为kT.
长度必须匹配lambda向量的长度.

` lmc-weights-equil ` : (no)

-   ` no `\
    在整个模拟中连续更新扩展系综权重.

-   ` yes `\
    输入的扩展系综权重被视为平衡值, 在整个模拟过程中不更新.

-   ` wl-delta `\
    当Wang-Landau增量低于 ` weight-equil-wl-delta ` 指定的值时,
    停止更新扩展系综权重.

-   ` number-all-lambda `\
    当所有lambda状态的采样数都大于 ` weight-equil-number-all-lambda `
    指定的值时, 停止更新扩展系综权重.

-   ` number-steps `\
    当步数大于 ` weight-equil-number-steps ` 指定的值时,
    停止更新扩展系综权重.

-   ` number-samples `\
    当所有lambda状态的总采样数大于 ` weight-equil-number-samples `
    指定的值时, 停止更新扩展系综权重.

-   ` count-ratio `\
    当最小和最大采样lambda状态的采样数之间的比值大于
    ` weight-equil-count-ratio ` 指定的值时, 停止更新扩展系综权重.

` simulated-tempering ` : (no)\
启用或关闭模拟回火. 模拟回火是通过扩展系综采样实现的,
实现时使用不同的温度代替了不同的哈密顿.

` sim-temp-low ` : (300)\
模拟回火的低温值.

` sim-temp-high ` : (300)\
模拟回火的高温值.

` simulated-tempering-scaling ` : (linear)\
控制从lambd向量的 ` temperature-lambda `
部分计算中间lambda对应温度的方式.

-   ` linear `\
    使用 ` temperature-lambda ` 的值对温度进行线性内插, 即, 若
    ` sim-temp-low ` =300, ` sim-temp-high ` =400,
    则lambda=0.5对应的温度为350.
    非线性的温度设定总可以通过不均匀间距的lambda实现.

-   ` geometric `\
    在 ` sim-temp-low ` 和 ` sim-temp-high ` 之间对温度进行几何内插.
    第i个状态的温度为 ` sim-temp-low ` \* ( ` sim-temp-high ` /
    ` sim-temp-low ` )的(i/(ntemps--1))次方. 对恒定热容,
    这种方法应该给出大致相等的交换,
    尽管那些涉及蛋白质折叠的模拟具有很高的热容峰.

-   ` exponential `\
    在 ` sim-temp-low ` 和 ` sim-temp-high ` 之间对温度进行指数内插.
    第i个状态的温度为 ` sim-temp-low ` + ( ` sim-temp-high ` -
    ` sim-temp-low ` )\*((exp( ` temperature-lambdas `
    \[i\])--1)/(exp(1.0)--1)).

### 7.3.25 非平衡MD {#7325-非平衡md}

` acc-grps ` :\
具有恒定加速度的组(如 ` Protein ` ` Sol ` ), ` Protein ` 和 ` Sol `
组中的所有原子都将具有恒定的加速度, 加速度的值在 ` accelerate `
行中指定.

` accelerate ` : (0) \[nm ps ^-2^ \]\
` acc-grps ` 的加速度, 对每个组有x, y和z三个分量(例如,
` 0.1 0.0 0.0 -0.1 0.0 0.0 ` 意味着, 第一组在X方向具有恒定的加速度0.1 nm
ps ^-2^ , 第二组的加速度与第一组相反).

` freezegrps ` :\
群组将被冻结(即其X, Y, 和/或Z位置不会被更新;如
脂质SOL).freezedim指定哪个维度的冻结申请.为了避免
虚假contibrutions的维里和压力, 由于之间完全大部队 冷冻原子,
你需要使用能源集团排除, 这也节省了计算时间.
需要注意的是冷冻原子的坐标不被压耦合算法缩放.

` freezedim ` :\
尺寸为这组freezegrps应该被冻结, 指定Y或N为X, Y
与Z和为每个组(例如YYNNNN意味着, 在第一组中的粒子可以
仅在Z方向移动.在第二组中的粒子可以以任何方向移动).

` cos-acceleration ` : (0) \[nm ps ^-2^ \]\
所述加速度曲线的振幅来计算粘度.加速度为
在X方向和大小是COS-加速度COS(2π的z / boxheight).两
术语被添加到能量的文件: 速度分布和第1 /粘度的振幅.

` deform ` : (0 0 0 0 0 0) \[nm ps ^-1^ \]\
变形对框要素的速度: A(X)B(y)的C(Z)B(X)C(X)C(Y).每一步
为其变形的框元件是非零的计算公式为: 箱(TS)+(叔TS)\*变形,
非对角元素被用于校正周期性.的坐标变换与符合
多地.冷冻自由度都(故意)也改变.时间Ts设定为t时 第一步,
在步骤在其中x和v被写入轨迹保证精确重新启动.
变形可以与semiisotropic或各向异性压力耦合时, 可以使用
适当的可压缩被设置为零.对角元素可以用来对应变
固体.非对角元素可用于剪切固体或液体.

### 7.3.26 电场 {#7326-电场}

` E-x ` ; ` E-y ` ; ` E-z ` :\
如果你想在某个方向上使用电场, 在适当的 ` E-* ` 后输入3个数字.
第一个数字: 余弦的数目, 只实现了单个余弦项(频率为0), 所以输入1;
第二个数字: 电场强度, 以 ` V/nm ` 为单位; 第三个数字: 余弦的相位,
你可以在这里输入任何数字, 因为频率为零的余弦没有相位.

` E-xt ` ; ` E-yt ` ; ` E-zt ` :\
尚未实现

### 混合量子/经典分子动力学

` QMMM ` :

-   ` no `\
    无QM/MM.

-   ` yes `\
    QM/MM模拟. 可以使用不同水平的QM单独对几个组进行描述, 在
    ` QMMM-grps ` 域中指定这些组, 彼此之间以空格隔开.
    各个组使用的从头算方法的水平在 ` QMmethod ` 和 ` QMbasis ` 域中指定.
    使用不同水平的方法对组进行描述只能与ONIOM QM/MM一起使用, 由
    ` QMMMscheme ` 指定.

` QMMM-grps: ` :\
QM水平的组

` QMMMscheme ` :

-   ` normal `\
    正常的QM/MM. 只能对一个 ` QMMM-grps ` 使用从头算方法进行描述,
    方法的水平通过 ` QMmethod ` 和 ` QMbasis ` 指定.
    体系的其余部分处于MM水平. QM和MM两个子体系的相互作用如下:
    MM部分的点电荷包含在QM部分的单电子哈密顿算符中,
    所有的Lennard-Jones相互作用都在MM水平进行描述.

-   ` ONIOM `\
    使用Morokuma及其同事发展的ONIOM方法对子体系之间的相互作用进行描述.
    可以有一个以上的 ` QMMM-grps ` , 每个组可以使用不同级别的QM(
    ` QMmethod ` 和 ` QMbasis ` )进行描述.

` QMmethod ` : (RHF)\
用于计算QM原子的能量和梯度的方法. 可用的方法包括AM1, PM3, RHF, UHF, DFT,
B3LYP, MP2, CASSCF和MMVB. 对CASSCF, 电子数和活化空间的轨道数分别由
` CASelectrons ` 和 ` CASorbitals ` 指定.

` QMbasis ` : (STO--3G)\
用于展开电子波函数的基组. 目前只可使用高斯基组, 即STO--3G, 3--21G,
3--21G *, 3--21+G* , 6--21G, 6--31G, 6--31G *, 6--31+G* 和6--311G.

` QMcharge ` : (0) \[整数\]\
` QMMM-grps ` 的总电荷数, 以 ` e ` 为单位. 在有一个以上 ` QMMM-grps `
的情况下, 需要单独指定每个ONIOM层的总电荷.

` QMmult ` : (1) \[整数\]\
` QMMM-grps ` 的多重度. 在有一个以上 ` QMMM-grps ` 的情况下,
需要单独指定每个ONIOM层的多重度.

` CASorbitals ` : (0) \[整数\]\
进行CASSCF计算时包含在活化空间中的轨道数.

` CASelectrons ` : (0) \[整数\]\
进行CASSCF计算时包含在活化空间中的电子数.

` SH ` :

-   ` no `\
    无势能面跳跃. 体系总处于电子基态.

-   ` yes `\
    在激发态势能面进行QM/MM的MD模拟, 在模拟过程中,
    当体系碰到锥形交叉线时, 强制 **非绝热** 跳跃到基态.
    此选项只能与CASSCF方法联合使用.

### 7.3.27 隐式溶剂 {#7327-隐式溶剂}

` implicit-solvent ` :

-   ` no `\
    不使用隐式溶剂

-   ` GBSA `\
    使用基于广义Born公式的隐式溶剂进行模拟.
    共有三种不同的方法可用以计算Born半径: Still, HCT和OBC,
    模拟时所用的方法可在 ` gb-algorithm ` 行中指定. 非极性溶剂化可通过
    ` sa-algorithm ` 选项指定.

` gb-algorithm ` :

-   ` Still `\
    用Still方法计算Born半径

-   ` HCT `\
    使用Hawkins-Cramer-Truhlar方法计算Born半径

-   ` OBC `\
    使用Onufriev-Bashford-Case方法计算Born半径

` nstgbradii ` : (1) \[步\] \</br\> (重新)计算Born半径的频率.
对于大多数实际模拟, 设置大于1的值会破坏能量守恒并导致轨迹不稳定.

` rgbradii ` : (1.0) \[nm\]\
计算Born半径的截断值. 目前必须与 ` rlist ` 相等

` gb-epsilon-solvent ` : (80)\
隐式溶剂的介电常数

` gb-saltconc ` : (0) \[M\]\
隐式溶剂模型的盐浓度, 目前并未使用

` gb-obc-alpha ` (1); ` gb-obc-beta ` (0.8); ` gb-obc-gamma ` (4.85);\
OBC模型的缩放因子. 默认值为OBC(II)的值. OBC(I)的值分别为0.8, 0和2.91.

` gb-dielectric-offset ` : (0.009) \[nm\]\
计算Born半径时介电偏移的距离,
它是每个原子的中心与相应原子极化能量中心之间的偏移

` sa-algorithm `

-   ` Ace-approximation `\
    使用Ace类型的近似

-   ` None `\
    不计算非极性溶剂化. 对GBSA只计算极性部分

` sa-surface-tension ` : (-1) \[kJ mol ^-1^ nm ^-2^ \]\
SA算法中表面张力的默认值. 默认值为--1. 注意, 如果不改变此默认值,
` grompp ` 将会使用与选择的半径算法相应的值覆盖默认值(Still: 0.0049
kcal/mol/Å ^2^ , HCT/OBC: 0.0054 kcal/mol/Å ^2^ ). 将此值设置为0,
并使用SA算法意味着不计算非极性部分.

### 7.3.28 自适应分辨率模拟 {#7328-自适应分辨率模拟}

` adress: ` (no)\
是否开启AdResS功能.

` adress-type ` : (off)

-   ` Off `\
    AdResS模拟的权重为1, 相当于一个显式(正常)的MD模拟.
    与禁用AdResS的区别在于, 仍会读入并定义AdResS变量.

-   ` Constant `\
    AdResS模拟的权重为常数,权重值由 ` adress-const-wf ` 定义

-   ` XSplit `\
    AdResS模拟时沿x方向劈分模拟盒, 因此基本上权重只是x坐标的函数,
    所有距离都只使用x坐标进行测量.

-   ` Sphere `\
    AdResS模拟的显式区域为球形.

` adress-const-wf ` : (1)\
常权重模拟的权重( ` adress-type=Constant ` )

` adress-ex-width ` : (0)\
显式区域的宽度, 从 ` adress-reference-coords ` 开始测量.

` adress-hy-width ` : (0)\
混合区域的宽度.

` adress-reference-coords ` : (0,0,0)\
显式区域的中心位置. 测量与它的距离时会使用周期性边界条件.

` adress-cg-grp-names ` :\
粗粒能量组的名称. 所有其他能量组都被认为是显式的,
它们之间的相互作用会被自动从粗粒组中排除.

` adress-site ` : (COM)\
用于计算权重的映射点.

-   ` COM `\
    权重由每个电荷组的质心来计算.

-   ` COG `\
    权重由每个电荷组的几何中心来计算.

-   ` Atom `\
    权重由每个电荷组中第一个原子的位置来计算.

-   ` AtomPerAtom `

权重由每个单独的原子的位置来计算.

` adress-interface-correction ` : (off)

-   ` off `\
    不使用任何界面校正.

-   ` thermoforce `\
    使用热力学力的界面校正. 可以使用 ` mdrun ` 的 ` -tabletf `
    选项指定表格. 该表格应包含(作用在分子上的)势能和力, 它们是
    ` adress-reference-coords ` 中距离的函数.

` adress-tf-grp-names `\
若启用 ` adress-interface-correction ` 时, 施加 ` thermoforce `
校正的能量组的名称. 如果没有给出组, 会应用到默认的表.

` adress-ex-forcecap ` : (0)\
在混合区域对力进行平齐, 对大分子有用. 0禁用力平齐.

### 7.3.29 用户自定义项 {#7329-用户自定义项}

` user1-grps ` ; ` user2-grps ` :

` userint1 ` (0); ` userint2 ` (0); ` userint3 ` (0); ` userint4 ` (0)

` userreal1 ` (0); ` userreal2 ` (0); ` userreal3 ` (0); ` userreal4 `
(0)\
如果修改了源代码你就可以使用这些. 你可以传递整数和实数到你的子程序. 检查
` src/include/types/inputrec.h ` 中inputrec的定义.

------------------------------------------------------------------------

------------------------------------------------------------------------


# GROMACS中文手册：第八章　分析





本章将对分析模拟轨迹的各种不同方法进行讨论, 并给出相应的分析程序的名称.
与这些程序相关的输入输出的具体信息, 可以利用
[www.gromacs.org](http://www.gromacs.org/) 的在线手册进行查阅.
输出文件通常都是Grace/Xmgr的图形格式.

首先, 在8.1节对分析中使用的组的概念进行解释.
8.1.2节将解释一个新的概念--动态选择--只有一些分析工具支持这一概念. 然后,
将对不同的分析工具进行讲解.

## 8.1 使用组 {#81-使用组}

` gmx make_ndx, gmx mk_angndx, gmx select `

在第三章, 我们解释了如何在 ` mdrun ` 中使用 **原子组** (参看3.3节).
对大多数分析程序, 你也必须选择原子组.
虽然大多数程序都能产生一些默认的索引组,
但这些程序总是可以从索引文件中读入组. 让我们考虑一个具体的例子,
A和B双组分混合物的模拟. 当我们需要计算A对B的径向分布函数(RDF, Radial
Distribution Function) [ \\(g\_{AB}(r)\\) ]{.math} 时, 我们必须计算

[ \\\[4\\pi r\^2 g\_{AB}(r) = V \\sum\_{i \\in A}\^{N_A} \\sum\_{j \\in
B}\^{N_B} P(r) \\tag{8.1}\\\] ]{.math}

其中, [ \\(V\\) ]{.math} 为体积, [ \\(P(r)\\) ]{.math} 为距离A原子 [
\\(r\\) ]{.math} 处发现B原子的概率.

通过让用户在一个简单的文件中定义组A和B的 **原子编号** ,
我们就能以最通用的方式计算 [ \\(g\_{AB}\\) ]{.math} ,
而无须在RDF程序中对粒子类型做任何假定.

因此, 组可以包含一系列 **原子编号** , 但在一些情况下也可以包含
**分子编号** . 我们还可以利用 **三联原子编号** 指定一系列键角, 利用
**四联原子编号** 指定一系列二面角, 利用 **原子编号对**
指定一系列键或(分子中的)矢量

需要对分析程序指定索引文件的类型. 许多程序都可帮你创建这样的索引文件(
` index.ndx ` ), 它们在创建时使用你输入的构型或拓扑信息.
要创建包含一系列 **原子编号** (如 [ \\(g\_{AB}\\) ]{.math}
例子中)的索引文件, 可以使用 ` gmx make_ndx ` 或 ` gmx select ` .
要创建键角或二面角的索引文件, 可以使用 ` gmx mk_angndx ` . 当然,
你也可以手动创建这些索引文件. 索引文件的通用格式如下:

    [ Oxygen ]
    1  4  7

    [ Hydrogen ]
    2  3  5  6
    8  9

可以看到, 组的名称写在方括号中. 随后的原子编号从1开始, 可以延续任意多行.

每个支持组的工具都会列出所有可选择的组,
供用户通过组的编号或名称进行选择. 实际上, 如果可以与其他的组区分开来,
使用组名称的头几个字母就足够了. 利用Unix shell可以在命令行中选择组名称,
而不是以通常的交互方式. 请查看
[www.gromacs.org](http://www.gromacs.org/) 给出的建议.

### 8.1.1 默认组 {#811-默认组}

当没有为分析工具或 ` grompp ` 提供索引文件时, 会产生一些默认组以供选择:

` System ` : 体系中所有的原子

` Protein ` : 所有的蛋白质原子

` Protein-H ` : 除氢原子外的所有蛋白质原子

` C-alpha ` : [ \\(\\text C\_\\a\\) ]{.math} 原子

` Backbone ` : 蛋白质骨架原子, N, [ \\(\\text C\_\\a\\) ]{.math} 和C

` MainChain ` : 蛋白质主链上的原子: N, [ \\(\\text C\_\\a\\) ]{.math} ,
C和O, 包括C端的氧原子

` MainChain+Cb ` : 蛋白质主链上的原子, 包含 [ \\(\\text C\_\\b\\)
]{.math}

` MainChain+H ` : 蛋白质主链上的原子, 包括骨架氨基氢原子和N端氢原子

` SideChain ` : 蛋白质支链上的原子, 即除N, [ \\(\\text C\_\\a\\)
]{.math} , C, O, 骨架氨基氢原子, C端氧原子, N端氢原子以外的所有原子

` SideChain-H ` : 除氢原子外的蛋白质支链上的原子

` Prot_Masses ` : 除哑质量(创建NH ~3~
基团和色氨酸支链时使用的虚位点)外的蛋白质原子, 请参看5.2.2节. 只有当与
` Protein ` 组不同时, 才包含此组

` Non-Protein ` : 所有的非蛋白质原子

` DNA ` : 所有的DNA原子

` RNA ` : 所有的RNA原子

` Water ` : 水分子(名称如SOL, WAT, HOH等). 参看 ` residuetypes.dat `
文件中的完整列表

` non-Water ` : 不属于 ` Water ` 组的任何粒子

` Ion ` : 匹配 ` residuetypes.dat ` 文件中离子条目的任何名称

` Water_and_Ions ` : ` Water ` 和 ` Ion ` 组的组合

` molecule_name ` : 所有不能被识别为蛋白质, DNA或RNA的残基/分子.
会为每个残基/分子创建一个组

` Other ` : 不属于蛋白质, DNA, RNA的所有原子

不会创建空的组. 大部分组只包含蛋白质原子. 如果一个原子的残基名称存在于
` residuetypes.dat ` 文件中, 并且被视为"蛋白质",
这个原子就被视为蛋白质原子. 决定DNA原子, RNA原子等的方法类似.
如果需要修改这些分类, 你可以从库文件目录复制一份文件到你的工作目录,
然后编辑这个副本.

### 8.1.2 选择 {#812-选择}

` gmx select `

目前, 一些分析工具支持一个扩展的概念 **(动态)选择** ,
它与传统的索引组主要存在三个区别:

-   通过文本指定选择, 而不是从文件中读入固定的原子编号.
    选择使用的语法类似于VMD. 文本可以交互地输入, 也可以过命令行提供,
    或是使用文件.

-   选择并不局限于原子, 也可以是分析的对象, 如一组原子的质心位置.
    一些工具可能并不支持那些非单个原子的选择, 例如, 当它们需要的信息,
    如原子名称或类型之类, 只对单个原子可用时.

-   选择可以是动态的, 即, 对不同的轨迹帧选择不同的原子.
    这样就可以只对体系满足一定的几何条件的那部分进行分析.

作为动态选择的一个简单例子, ` resname ABC and within 2 of resname DEF `
将选择残基名称为ABC, 且距残基DEF中任何一个原子都不超过2 nm的所有原子.

对支持动态选择的工具也可以使用传统的索引文件, 像以前的工具一样:
可以为工具指定一个 ` .ndx ` 文件,
通过组编号或组名称直接从索引文件中选择一个组.
索引组也可以作为更复杂选择的一部分使用.

作为开始, 你可以使用单个结构运行 ` gmx select ` ,
利用交互的提示试验不同的选择. 这个工具提供了一些输出选项, ` -on ` 和
` -ofpdb ` 可以分别将选择的原子写入索引文件和 ` .pdb ` 文件中.
这些选项不允许测试质心位置的选择, 但可以测试其他选择, 并检查结果.

如果想了解选择的详细语法和各个关键词,
对任何支持选择的工具你可以在交互提示下键入 ` help ` , 或使用
` gmx help selections ` 命令. 帮助被划分为不同的子主题,
每个子主题可以通过像 ` help syntax / gmx help selections syntax `
这样的命令查看. 一些单独的选择关键词还有其自己的扩展帮助, 可通过像
` help keywords within ` 这样的命令进行查看.

目前的交互提示没有提供很多的编辑功能, 如果需要它们, 你可以在 ` rlwrap `
下运行程序.

对那些不支持选择语法的工具, 你可以使用 ` gmx select -on `
生成静态的索引组并传递给工具. 但是,
这种作法只能使用那些完全支持动态选择的工具所提供的灵活性中的一小部分(仅仅前面三项中的第一项).

为了利用这些选择的优点, 你也可以编写自己的分析工具,
具的例子请参看安装目录下 ` share/gromacs/template ` 中的
` template.cpp ` 文件.

<figure>
<img src="/GMX/8.1.png" alt="图 8.1 显示水盒子的gmx view窗口" />
<figcaption>图 8.1 显示水盒子的 <code> gmx view </code>
窗口</figcaption>
</figure>

## 8.2 查看你的轨迹 {#82-查看你的轨迹}

` gmx view `

在进行分析之前, 先查看一下你的轨迹通常很有帮助.
GROMACS提供了一个简单的轨迹查看器 ` gmx view ` .
这个查看器的优点是它不需要OpenGL的支持,
有些机器--如一些超级计算机--通常不支持OpenGL.
你也可以利用查看器生成EPS格式的轨迹(图 8.1).
如果你需要更快更花哨的查看器, 有一些程序可以读取GROMACS格式的轨迹,
请查看我们 [主页](http://www.gromacs.org/) 上更新的链接.

## 8.3 通用性质 {#83-通用性质}

` gmx energy, gmx traj `

如果需要分析部分或全部的 **能量** 和其他性质, 如 **总压力** ,
**压力张量** , **密度** , **盒子体积** 和 **盒子尺寸** , 请使用
` gmx energy ` 程序. 可以从一系列能量列表中进行选择, 如势能, 动能或总能,
也可以从对能量单独贡献的部分中进行选择, 如Lennard-Jones或二面角能量.

质心速度定义为

[ \\\[\\bi V\_{com} = {1\\over M} \\sum\_{i=1}\^N m_i \\bi V_i
\\tag{8.2}\\\] ]{.math}

其中 [ \\(M=\\sum\_{i=1}\^N m_i\\) ]{.math} 为体系的总质量. 可以利用程序
` gmx traj -com -ov ` 对质心进行监测.
然而我们建议模拟时在每一步都移除质心的速度(参看第三章)!

<figure>
<img src="/GMX/8.2.png"
alt="图 8.2: gmx rdf中切片的定义: A. $g_{AB}(r)$. B. $g_{AB}(r,\q)$. 切片为灰色, C. $&lt;\r_B&gt;_{local}$ 的归一化. D. $&lt;\r_B&gt;_{local,\q}$ 的归一化. 灰色为归一化体积." />
<figcaption>图 8.2: <code> gmx rdf </code> 中切片的定义: A. <span
class="math"> \(g_{AB}(r)\) </span> . B. <span class="math">
\(g_{AB}(r,\q)\) </span> . 切片为灰色, C. <span class="math">
\(&lt;\r_B&gt;_{local}\) </span> 的归一化. D. <span class="math">
\(&lt;\r_B&gt;_{local,\q}\) </span> 的归一化.
灰色为归一化体积.</figcaption>
</figure>

## 8.4 径向分布函数 {#84-径向分布函数}

` gmx rdf `

A类型粒子与B类型粒子之间的 **径向分布函数** (RDF)或称对关联函数 [
\\(g\_{AB}(r)\\) ]{.math} 的定义为

[ \\\[\\alg g\_{AB}(r) &= { \<\\r_B(r)\> \\over {\<\\r_B\>}\_{local} }
\\\\ &= { 1\\over {\<\\r_B\>}\_{local} } {1\\over N_A} \\sum\_{i \\in
A}\^{N_A} \\sum\_{j \\in B}\^{N_B} {\\delta (r\_{ij}-r) \\over 4\\pi
r\^2} \\tag{8.3} \\ealg\\\] ]{.math}

其中, [ \\(\<\\r_B(r)\>\\) ]{.math} 为距离A粒子 [ \\(r\\) ]{.math}
处B粒子的密度, [ \\(\<\\r_B(r)\>\_{local}\\) ]{.math}
为所有以A离子为中心, 半径 [ \\(r\_{max}\\) ]{.math}
的壳层内B离子的平均密度(图 8.2C)

通常 [ \\(r\_{max}\\) ]{.math} 的值取为盒子长度的一半.
计算时也会对时间进行平均. 具体计算时, 分析程序 ` gmx rdf `
会将体系划分为球形切片(从 [ \\(r\\) ]{.math} 到 [ \\(r+dr\\) ]{.math} ,
图 8.2A), 并生成一个直方图而不是 [ \\(\\d\\) ]{.math} 函数.
SPC水模型氧-氧RDF\[81\]的一个例子如图 8.3.

也可以使用 ` gmx rdf ` 计算角度相关的RDF [ \\(g\_{AB}(r,\\q)\\) ]{.math}
, 其中角度 [ \\(\\q\\) ]{.math} 根据特定的实验室坐标轴 [ \\(\\bi e\\)
]{.math} 进行定义, 参看图8.2B.

[ \\\[\\alg g\_{AB}(r,\\q) &= {1 \\over {\<\\r_B\>}\_{local,\\q} } {1
\\over N_A} \\sum\_{i \\in A}\^{N_A} \\sum\_{j \\in B}\^{N_B}
{\\delta(r\_{ij}-r)\\delta(\\theta\_{ij}-\\theta) \\over 2\\pi r\^2
\\sin(\\theta)} \\tag{8.4} \\\\ \\cos(\\theta\_{ij}) &= {\\bi r\_{ij}
\\cdot \\bi e \\over \\\|r\_{ij}\\\| \\\|e\\\|} \\tag{8.5} \\ealg\\\]
]{.math}

![图8.3 SPC水模型的氧-氧RDF gOO(r)](/GMX/8.3.png)

[ \\(g\_{AB}(r,\\q)\\) ]{.math} 在分析各向异性体系时很有用. **注意**
在这种情况下, 归一化因子 [ \\(\<\\r_B\>\_{local,\\q}\\) ]{.math}
为一直到 [ \\(r\_{max}\\) ]{.math} 的所有从 [ \\(\\q\\) ]{.math} 到
\$\\q+d\\q\$的角度切片的平均密度, 因此与角度相关. 参看图 8.2D

## 8.5 相关函数 {#85-相关函数}

### 8.5.1 相关函数的理论 {#851-相关函数的理论}

文献\[106\]对相关函数的理论作了很好的介绍.
我们在这里只介绍GROMACS代码中对相关函数实现的各种细节. 性质 [ \\(f(t)\\)
]{.math} 的自相关函数(ACF) [ \\(C_f(t)\\) ]{.math} 的定义为

[ \\\[C_f(t) = {\< f(\\xi)f(\\xi+t) \>}\_\\xi \\tag{8.6}\\\] ]{.math}

其中, 等号右边的记号表示对 [ \\(\\x\\) ]{.math} 进行平均,
即对不同时间起点进行平均. 对两种性质 [ \\(f(t)\\) ]{.math} 和 [
\\(g(t)\\) ]{.math} 也可以计算交叉相关函数

[ \\\[C\_{fg}(t) = {\< f(\\xi)g(\\xi+t) \>}\_\\xi \\tag{8.7}\\\]
]{.math}

然而, 在GROMACS中不存在计算相关函数的标准方法( **注意** : 你可以使用
` xmgr ` 程序计算交叉相关). 相关函数对时间的积分为相关时间 [ \\(\\t_f\\)
]{.math} :

[ \\\[\\tau_f = \\int_0\^\\infty C_f(t) \\rmd t \\tag{8.8}\\\] ]{.math}

具体计算时, 相关函数是根据时间间隔为 [ \\(\\D t\\) ]{.math}
的离散数据的计算的, 因此, MD模拟的ACF为

[ \\\[C_f(j \\D t) = {1 \\over N-j} \\sum\_{i=0}\^{N-1-j} f(i\\D t)
f((i+j)\\D t) \\tag{8.9}\\\] ]{.math}

其中, [ \\(N\\) ]{.math} 为计算时所有可用的时间帧.
所得的ACF明显地只适用于具有相同时间间隔 [ \\(\\D t\\) ]{.math} 的时间点.
对许多应用, 由于需要知道ACF短时间的行为(例如, 开始10 ps),
这常常意味着我们保存数据的时间间隔必须比感兴趣的时间尺度短得多.
方程8.9隐含的另一点是, 理论上我们不可能以相同精度计算所有时间点上的ACF,
因为对 [ \\(C_f(\\D t)\\) ]{.math} 我们有 [ \\(N-1\\) ]{.math} 个点,
而对 [ \\(C_f((N-1)\\D t)\\) ]{.math} 只有1个点. 然而,
如果我们只计算长度为 [ \\(M \\D t\\) ]{.math} 的ACF, 其中 [ \\(M\\le
N/2\\) ]{.math} , 我们可以同样的统计精度计算所有的点

[ \\\[C_f(j\\D t) = {1 \\over M} \\sum\_{i=0}\^{N-1-M} f(i\\D t)
f((i+j)\\D t) \\tag{8.10}\\\] ]{.math}

当然, 这里的 [ \\(j \\le M\\) ]{.math} . [ \\(M\\) ]{.math}
有时被视为相关函数的时间延迟. 当决定这样做时, 对非常短的时间间隔( [ \\(j
\\ll M\\) ]{.math} ), 我们故意不使用所有的点,
但这使得我们更容易解释结果. 当从模拟轨迹计算ACF的时候,
不能忽略的另一点是, 通常时间起点 [ \\(\\x\\) ]{.math}
(方程8.6)并不是统计无关的, 这可能使得结果存在偏离.
这可以利用块平均方法进行测试.

在这种方法中, 计算时只包含间距最少为时间延迟的时间起点, 例如, 使用 [
\\(k\\) ]{.math} 乘上间距为 [ \\(M\\D t\\) ]{.math} 的起点(其中 [ \\(kM
\\le N\\) ]{.math} ):

[ \\\[C_f(j\\D t) = {1 \\over k}\\sum\_{i=0}\^{k-1} f(i M\\D t) f((iM+j)
\\D t) \\tag{8.11}\\\] ]{.math}

然而, 利用这种方式, 需要非常长的模拟才能得到高精确度的结果,
因为对ACF有贡献的点的个数少得多.

### 8.5.2 使用FFT计算SCF {#852-使用fft计算scf}

根据方8.9计算ACF的代价正比于 [ \\(N\^2\\) ]{.math} , 计算量很可观. 然而,
通过使用快速Fourier变换计算卷积可以改进计算ACF的代价\[106\].

### 8.5.3 ACF的特殊形式 {#853-acf的特殊形式}

ACF存在一些重要的变形, 例如, 矢量 [ \\(\\bi p\\) ]{.math} 的ACF

[ \\\[C\_{\\bi p}(t) = \\int_0\^\\infty P_n(\\cos \\angle( \\bi p(\\xi),
\\bi p(\\xi+t) ) \\rmd \\xi \\tag{8.12}\\\] ]{.math}

其中 [ \\(P_n(x)\\) ]{.math} 为 [ \\(n\\) ]{.math} 阶Legendre多项式
[\[1\]](#fn:1 "see footnote"){#fnref:1 .footnote} .
这样的相关时间实际上可以NMR或其他弛豫实验中获得.
GROMACS可以使用一阶和二阶Legendre多项式计算相关(方程8.12).
这种方法也可以用于旋转自相关( ` gmx rotacf ` )和偶极自相关(
` gmx dipoles ` ).

为研究扭转角的动力学, 我们可以定义二面角的自相关函数\[153\]

[ \\\[C(t) = {\<\\cos(\\theta(\\tau)-\\theta(\\tau+t))\>}\_{\\tau}
\\tag{8.13}\\\] ]{.math}

**注意** 这不是两个函数的乘积, 像通常的相关函数那样,
但可以将它重写成两个乘积加和的形式:

[ \\\[C\_(t) = {\<\\cos(\\theta(\\tau)) \\cos(\\theta(\\tau+t)) +
\\sin(\\theta(\\tau)) \\sin(\\theta(\\tau+t))}\_{\\tau} \\tag{8.14}\\\]
]{.math}

### 8.5.4 ACF的一些应用 {#854-acf的一些应用}

` gmx velacc ` 程序计算 **速度自相关函数**

[ \\\[C\_{\\bi v}(\\tau) = {\<\\bi v_i(\\tau) \\bi v_i(0)\>}\_{i \\in A}
\\tag{8.15}\\\] ]{.math}

可以利用Green-Kubo关系计算自扩散系数\[106\]

[ \\\[D_A = {1 \\over 3}\\int_0\^\\infty {\<\\bi v_i(t) \\cdot \\bi
v_i(0)\>}\_{i \\in A} \\rmd t \\tag{8.16}\\\] ]{.math}

它是速度自相关函数的积分. 人们普遍相信,
速度自相关函数比均方位移收敛得更快(8.6节),
尽管均方位移也可用于计算扩散常数. 然而, Allen和Tildesley\[106\]警告我们,
不能忽略速度自相关函数的长时间贡献, 因此计算时必须当心.

另一个重要的物理量是偶极相关时间. A类型粒子的 **偶极相关函数** 可利用
` gmx dipoles ` 计算, 其公式为

[ \\\[C\_\\mu(\\tau) = {\<\\mu_i(\\tau) \\mu_i(0)\>}\_{i \\in A}
\\tag{8.17}\\\] ]{.math}

其中 [ \\(\\m_i=\\sum\_{j \\in i} \\bi r_j q_j\\) ]{.math} .
偶极相关时间可以使用方程8.8 计算. 对此的应用请参看\[154\].

液体的粘度与压力张量 [ \\(\\bi P\\) ]{.math} 的相关时间有关联.
` gmx energy ` 可以计算粘度, 但计算结果并不是很精确\[137\],
实际上计算值并没有收敛.

## 8.6 均方位移 {#86-均方位移}

` gmx msd `

为决定A类型粒子的自扩散系数 [ \\(D_A\\) ]{.math} ,
可以使用Einstein关系式\[106\]:

[ \\\[\\lim\_{t \\to \\infty} { \<\\\| \\bi r_i(t)-\\bi r_i(0)
\\\|\^2\>}\_{i \\in A} = 6 D_A t \\tag{8.18}\\\] ]{.math}

可使用 ` gmx msd ` 程序计算 **均方位移** 和 [ \\(D_A\\) ]{.math} .
计算时通常使用一个包含原子编号的索引文件, 计算的MSD对这些原子进行平均.
对含有多个原子的分子, [ \\(\\bi r_i\\) ]{.math} 可取为分子的质心位置.
在这种情况下, 你需要使用包含分子编号的索引文件.
但结果几乎与原子平均的结果完全相同. ` gmx msd `
程序也可用于计算一维或二维的扩散, 这对研究界面间的水平扩散很有用.

SPC水模型均方位移的一个例子如图8.4所示.

![图 8.4 SPC水模型的均方位移](/GMX/8.4.png)

## 8.7 键/距离, 键角和二面角 {#87-键距离-键角和二面角}

` gmx distance, gmx angle, gmx gangle `

为监测分子中特定的 **键** , 或更一般的说法, 不同点之间的距离, 程序
` gmx distace ` 可以计算距离随时间的变化以及距离的分布.
使用传统的索引文件时, 组里面应该包含一些原子编号对, 例如:

    [ bonds_1 ]
    1    2
    3    4
    9   10

    [ bonds_2 ]
    12  13

索引文件也支持选择, 第一行的两个位置定义了第一个距离,
第二个位置对定义了第二个距离, 以此类推.
你可以计算所有残基中CA和CB原子间的距离(假定每个残基或者含有这两类原子,
或者不含有任何一类), 选择的方法是:

` name CA CB `

选择也允许计算更广义的距离. 例如, 要计算两个残基质心之间的距离,
你可以使用

` com of resname AAA plus com of resname BBB `

` gmx angle ` 程序计算 **键角** 和 **二面角** 的时间分布,
还会给出平均键角或二面角. 计算时索引文件中需要包含三联或是四联原子编号:

    [ angles ]
    1    2    3
    2    3    4
    3    4    5

    [ dihedrals ]
    1    2    3    4
    2    3    4    5

对二面角, 你可以使用 "生化约定"( [ \\(\\f=0\\equiv cis\\) ]{.math}
)或"聚合物决定"( [ \\(\\f=0\\equiv trans\\) ]{.math} ), 参考图8.5.

<figure>
<img src="/GMX/8.5.png"
alt="图 8.5 不同的二面角约定: A. 生化约定. B. 聚合物约定." />
<figcaption>图 8.5 不同的二面角约定: A. “生化约定”. B.
“聚合物约定”.</figcaption>
</figure>

<figure>
<img src="/GMX/8.6.png"
alt="图 8.6 gmx gangle的角度选项: A. 两个矢量间的夹角. B. 两个平面间的夹角. C. 矢量和 $z$ 轴间的夹角. D. 矢量和球的法向间的夹角. 也支持其他组合: 平面和矢量可以交换使用." />
<figcaption>图 8.6 <code> gmx gangle </code> 的角度选项: A.
两个矢量间的夹角. B. 两个平面间的夹角. C. 矢量和 <span class="math">
\(z\) </span> 轴间的夹角. D. 矢量和球的法向间的夹角. 也支持其他组合:
平面和矢量可以交换使用.</figcaption>
</figure>

` gmx gangle ` 程序计算角度时支持选择. 这个工具也可用于计算角和二面角,
但不能支持 ` gmx angle ` 的所有选项, 比如自相关或其他时间序列分析. 另外,
它支持两个矢量间的夹角, 矢量与平面, 两个平面(分别由2或3个点定义),
矢量/平面与 [ \\(z\\) ]{.math} 轴,
或矢量/平面与球的法向(由单一位置决定)间的夹角.
此外还支持矢量/平面相对于其第一帧位置的夹角. 对平面, ` gmx gangle `
使用的法向矢量垂直于平面. 参看图8.6 A, B, C中的定义.

## 8.8 回旋半径与距离 {#88-回旋半径与距离}

` gmx gyrate, gmx distance, gmx mindist, gmx mdmat, gmx xpm2ps `

作为结构密实度的粗略表征, 你可以利用 ` gmx gyrate ` 程序计算
**回旋半径** :

[ \\\[R_g = \\left( {\\sum_i \\\| \\bi r_i\\\|\^2 m_i \\over \\sum_i
m_i} \\right)\^{1/2} \\tag{8.19}\\\] ]{.math}

其中 [ \\(m_i\\) ]{.math} 为原子 [ \\(i\\) ]{.math} 的质量, [ \\(\\bi
r_i\\) ]{.math} 为原子 [ \\(i\\) ]{.math} 相对于分子质心的位置.
在表征聚合物溶液和蛋白质时, 回旋半径尤其有用.

有时描绘出两个原子间 **距离** 或是两个原子组(例如:
盐桥中的蛋白质支链)之间 **最小** 距离的图形很有趣,
一些组之间距离的计算可采用下面的方法:

<figure>
<img src="/GMX/8.7.png" alt="图 8.7:多肽的最小距离矩阵" />
<figcaption>图 8.7:多肽的最小距离矩阵[157]</figcaption>
</figure>

-   两个组的 **几何中心之间的距离** 可以使用 ` gmx distance ` 程序计算,
    参看8.7节的论述.

-   不同时刻两个原子组之间的 **最小距离** 可以使用 ` gmx mindist ` 计算.
    它同时也会计算这些组之间在一定半径 [ \\(r\_{max}\\) ]{.math} 内的
    **接触数** .

-   为监测一个(蛋白质)分子中 **氨基酸残基之间的最小距离** , 你可以使用
    ` gmx mdmat ` 程序. 两个残基 [ \\(A_i\\) ]{.math} 和 [ \\(A_j\\)
    ]{.math} 之间的最小距离的定义为任何一对原子( [ \\(i \\in A_i, j \\in
    A_j\\) ]{.math} )之间的最小距离.
    程序将输出一个所有残基之间最小距离的对称矩阵. 你可以使用 ` xv `
    等程序对此矩阵进行可视化. 如果想查看坐标轴和图例或者打印矩阵,
    你可以使用 ` xpm2ps ` 将它转换为PS图片, 如图8.7.

    画出不同时刻的矩阵, 你就可以分析结构的变化和其他一些信息,
    如盐桥的形成.

## 8.9 结构的根均方偏差 {#89-结构的根均方偏差}

` gmx rms, gmx rmsdist `

一个分子中的某些原子相对于参考结构的 **根均方偏差(RMSD)** 可以利用
` gmx rms ` 程序计算, 计算时先使用最小二乘方法

将结构拟合到参考结构( [ \\(t_2=0\\) ]{.math} ), 再根据下式(方程8.20)计算
[ \\(RMSD\\) ]{.math}

[ \\\[RMSD(t_1,t_2) = \\left\[ {1\\over M} \\sum\_{i=1}\^N m_i \\\|\\bi
r_i(t_1)-\\bi r_i(t_2)\\\|\^2 \\right\]\^{1/2} \\tag{8.20}\\\] ]{.math}

其中 [ \\(M=\\sum\_{i=1}\^N m_i\\) ]{.math} , [ \\(\\bi r_i(t)\\)
]{.math} 为原子 [ \\(i\\) ]{.math} 在 [ \\(t\\) ]{.math} 时刻的位置.
**注意** 计算 [ \\(RMSD\\) ]{.math} 时拟合并不需要使用相同的原子. 例如,
蛋白质通常利用骨架原子(N, [ \\(\\text C\_\\a\\) ]{.math} , C)进行拟合,
但 [ \\(RMSD\\) ]{.math} 可以基于骨架原子计算, 也可以基于整个蛋白质计算.

与把结构与 [ \\(t=0\\) ]{.math}
时刻的初始结构(例如一个晶体结构)进行比较不同, 你也可以使用 [
\\(t_2=t_1-\\t\\) ]{.math} 时刻的结构计算方程 8.20. 其结果会给出迁移性与
[ \\(\\t\\) ]{.math} 关系的洞察. 作为 [ \\(t_1\\) ]{.math} 和 [
\\(t_2\\) ]{.math} 函数的 [ \\(RMSD\\) ]{.math} 可以组成一个矩阵,
它给出了一条轨迹的漂亮的图形化解释. 如果轨迹中存在转变,
它们将在矩阵中清楚地显示出来.

作为替代, 也可以使用 ` gmx rmsdist ` 程序计算不拟合的 [ \\(RMSD\\)
]{.math}

[ \\\[RMSD(t) = \\left\[ {1\\over N\^2} \\sum\_{i=1}\^N \\sum\_{j=1}\^N
\\\| \\bi r\_{ij}(t)-\\bi r\_{ij}(0)\\\|\^2 \\right\]\^{1/2}
\\tag{8.21}\\\] ]{.math}

其中, [ \\(t\\) ]{.math} 时刻原子间的距离 [ \\(\\bi r\_{ij}\\) ]{.math}
是与0时刻相同原子之间的距离相比

## 8.10 协方差分析 {#810-协方差分析}

协方差分析也被称为主成分分析或主成分动力学\[158\],
利用它可以发现相关的运动. 它使用原子坐标的协方差矩阵 [ \\(C\\) ]{.math}
进行计算

[ \\\[C\_{ij} = \\left\< M\_{ii}\^{1/2}(x_i-\< x_i \>)
M\_{jj}\^{1/2}(x_j-\< x_j \>) \\right\> \\tag{8.22}\\\] ]{.math}

其中 [ \\(M\\) ]{.math}
为包含原子质量的对角矩阵(质量加权分析)或单位矩阵(非质量加权分析). [
\\(C\\) ]{.math} 是对称的 [ \\(3N \\times 3N\\) ]{.math} 矩阵,
可以利用正交变换矩阵 [ \\(R\\) ]{.math} 对其进行对角化

[ \\\[R\^T C R = \\text{diag}(\\lambda_1, \\lambda_2, \\dots,
\\lambda\_{3N}),\\qquad \\lambda_1 \\ge \\lambda_2 \\ge \\dots \\ge
\\lambda\_{3N} \\tag{8.23}\\\] ]{.math}

[ \\(R\\) ]{.math} 的列就是本征矢量, 也称为主模或基本模. [ \\(R\\)
]{.math} 定义了一个到新坐标系的变换. 将轨迹投影到主模上便得到主成分 [
\\(p_i(t)\\) ]{.math}

[ \\\[\\bi p(t) = R\^T M\^{1/2}(\\bi x(t)-\<\\bi x\>) \\tag{8.24}\\\]
]{.math}

本征值 [ \\(\\l_i\\) ]{.math} 为主成分 [ \\(i\\) ]{.math} 的均方涨落,
头几个主模通常描述了体系聚集的整体运动.
可以利用一个(或多个)主模对轨迹进行过滤. 对一个主模 [ \\(i\\) ]{.math} ,
其方式如下

[ \\\[\\bi x\^f(t)=\< \\bi x \> + M\^{-1/2} R\_{\*i} p_i(t)
\\tag{8.25}\\\] ]{.math}

当对大分子进行分析时, 通常想要移除整体的转动和平动以便仅仅观察内部运动.
这可以通过最小二乘拟合到参考结构实现. 需要注意的是,
参考结构对系综需要具有代表性, 因为参考结构的选择会影响协方差矩阵.

始终都应该检查是否已经很好地定义了主模. 如果第一个主成分类似于半个余弦,
第二个主成分类似于整个余弦, 你可能正在过滤噪声(参见下文).
检查头几个主模相关的一个好方式是计算模拟前半部分和后半部分采样的重叠.
**注意** 这只适用于两部分使用相同的参考结构的情况.

文献\[159\]定义了一个很好的重叠度量. 协方差矩阵的元素正比于位移的平方,
因此需要取矩阵的平方根来检查取样的范围. 可以从本征值 [ \\(\\l_i\\)
]{.math} 和本征矢量计算矩阵的平方根, 本征矢量对应于矩阵 [ \\(R\\)
]{.math} 的列. 对一个对称, 对角占优, 大小为 [ \\(3N \\times 3N\\)
]{.math} 的矩阵 [ \\(A\\) ]{.math} , 其平方根为

[ \\\[A\^{1/2} = R \\text{diag}(\\lambda_1\^{1/2}, \\lambda_2\^{1/2},
\\dots, \\lambda\_{3N}\^{1/2}) R\^T \\tag{8.26}\\\] ]{.math}

容易证明这个矩阵及其自身的乘积为矩阵 [ \\(A\\) ]{.math} .
现在我们可以定义协方差矩阵 [ \\(A\\) ]{.math} 和 [ \\(B\\) ]{.math}
之间的差异 [ \\(d\\) ]{.math}

[ \\\[\\alg d(A,B) &= \\sqrt{\\text{tr} \\left( (A\^{1/2}-B\^{1/2})\^2
\\right)} \\tag{8.27} \\\\ &= \\sqrt{\\text{tr} \\left(
A+B-2A\^{1/2}B\^{1/2} \\right)} \\tag{8.28} \\\\ &= \\left(
\\sum\_{i=1}\^N (\\lambda_i\^A + \\lambda_i\^B) - 2 \\sum\_{i=1}\^N
\\sum\_{j=1}\^N \\sqrt{\\lambda_i\^A \\lambda_j\^B} (R_i\^A \\cdot
R_j\^B)\^2 \\right)\^{1/2} \\tag{8.29} \\ealg\\\] ]{.math}

其中, [ \\(\\text{tr}\\) ]{.math} 为矩阵的迹. 重叠 [ \\(s\\) ]{.math}
的定义为

[ \\\[s(A,B) = 1 - {d(A,B) \\over \\sqrt{\\text{tr} A + \\text{tr} B} }
\\tag{8.30}\\\] ]{.math}

当且仅当矩阵 [ \\(A\\) ]{.math} 和 [ \\(B\\) ]{.math} 全等时, 重叠为1.
当抽样的子空间完全正交时, 重叠为0.

一个常用的度量是协方差矩阵头几个本征矢量子空间的重叠. [ \\(m\\) ]{.math}
个正交矢量 [ \\(\\bi w_1, \\cdots, \\bi w_m\\) ]{.math} 张成的子空间和 [
\\(n\\) ]{.math} 个正交矢量 [ \\(\\bi v_1, \\cdots, \\bi v_n\\) ]{.math}
张成的参考子空间之间的重叠可定量为

[ \\\[\\text{overlap}(\\bi v, \\bi w) = {1\\over n}\\sum\_{i=1}\^n
\\sum\_{j=1}\^m (\\bi v_i \\cdot \\bi w_j)\^2 \\tag{8.31}\\\] ]{.math}

重叠会随着 [ \\(m\\) ]{.math} 的增加而增大, 当集合 [ \\(\\bi v\\)
]{.math} 为集合 [ \\(\\bi w\\) ]{.math} 的子空间时, 重叠为1.
这个方法的缺点在于没有考虑到本征值. 所有本征矢量的权重都相同,
当存在简并的子空间时(本质值相等), 计算的重叠太小.

另一个有用的检查是余弦含量. 已经证明随机扩散的主成分是余弦,
且其周期数等于主成分索引数的一半\[160,159\].
本征值正比于索引数的--2次方. 余弦含量定义为

[ \\\[{2 \\over T}\\left( \\int_0\^T \\cos\\left({i\\pi t \\over
T}\\right) p_i(t) \\rmd t \\right)\^2 \\left( \\int_0\^T p_i\^2(t) \\rmd
t \\right)\^{-1} \\tag{8.32}\\\] ]{.math}

当头几个主成分的余弦含量接近1时, 最大的涨落与势能没有联系,
而是对应于随机扩散.

` gmx covar ` 可以构建并对角化协方差矩阵. 可以利用 ` gmx anaeig `
对主成分和重叠(还有许多其他量)进行绘图和分析. 余弦含量可以利用
` gmx analyze ` 计算.

## 8.11 二面角主成分分析 {#811-二面角主成分分析}

` gmx angle, gmx covar, gmx anaeig `

使用GROMACS可以在二面角空间\[161\]中进行主成分分析. 首先使用
` gmx mk_angndx ` 或其他方法, 在索引文件中定义要计算的二面角, 然后使用
` gmx angle ` 程序及其 ` -or ` 选项产生一个新的 ` .trr ` 文件,
其中包含了每个二面角分别在两个坐标系下的正弦和余弦值. 即, 在 ` .trr `
文件中, 有相应于 [ \\(\\cos(\\f_1)\\) ]{.math} , [ \\(\\sin(\\f_1)\\)
]{.math} , [ \\(\\cos(\\f_2)\\) ]{.math} , [ \\(\\sin(\\f_2)\\) ]{.math}
, [ \\(\\cdots\\) ]{.math} , [ \\(\\cos(\\f_n)\\) ]{.math} , [
\\(\\sin(\\f_n)\\) ]{.math} 的一系列数字, 必要时, 会对数字序列补零.
然后, 你可以使用这个 ` .trr ` 文件作为 ` gmx covar ` 程序的输入,
像通常一样进行主成分分析. 为此, 你需要生成一个参考文件(
` .tpr,.gro,.pdb ` 等), 其中包含与新的 ` .trr ` 文件相同数目的"原子",
即, 对 [ \\(n\\) ]{.math} 个二面角, 你需要 [ \\(2n/3\\) ]{.math}
个原子(如果不是整数就舍去小数部分). 由于哑参考文件中的坐标与 ` .trr `
文件中的信息毫无对应关系, 你需要使用 ` gmx covar ` 程序的 ` -nofit `
选项. 对结果的分析可使用 ` gmx anaeig ` .

## 8.12 氢键 {#812-氢键}

` gmx hbond `

` gmx hbond ` 程序用于分析所有可能的施体D和受体A之间的 **氢键** (HB).
分析时使用几何准则决定氢键的存在与否, 参看图 8.8:

[ \\\[\\begin{split} r &\\le r\_{HB} = 0.35 \\ \\text{nm} \\\\ \\alpha
&\\le \\alpha\_{HB} = 30\^{\\circ} \\end{split} \\tag{8.33}\\\] ]{.math}

参考值 [ \\(r\_{HB}=0.35 \\text{nm}\\) ]{.math}
对应于SPC水模型RDF的第一极小位置(参看图 8.3).

` gmx hbond `
程序以下面的方式分析两组原子(它们必须相同或没有重叠)或指定的施体-氢-受体之间所有可能存在的氢键:

![图8.8 氢键的几何准则](/GMX/8.8.png)

![图 8.9: 水对氢键的插入. (1) 两残基间正常的氢键. (2)
通过一个水分子形成的氢键桥.](/GMX/8.9.png)

-   所有氢键中施体-受体距离的分布

-   所有氢键中氢-施体-受体之间夹角的分布

-   每个时间帧中氢键的总数目

-   残基之间实时的氢键数目, 划分到组 [ \\(n-n+i\\) ]{.math} , 其中 [
    \\(n\\) ]{.math} 和 [ \\(n+i\\) ]{.math} 代表残基编号, [ \\(i\\)
    ]{.math} 从0到6. [ \\(i=6\\) ]{.math} 的组也包括 [ \\(i\>6\\)
    ]{.math} 的所有氢键. 这些组包括 [ \\(n-n+3, n-n+4\\) ]{.math} 和 [
    \\(n-n+5\\) ]{.math} 氢键, 提供了 [ \\(\\a\\) ]{.math} 螺旋, [
    \\(\\b\\) ]{.math} 转角或 [ \\(\\b\\) ]{.math} 股形成的度量.

-   对所有氢键生存函数(0或1)的自相关函数进行平均, 可以计算氢键的寿命

    [ \\\[C(\\tau) = \< s_i(t) s_i(t+\\tau) \> \\tag{8.34}\\\] ]{.math}

    对 [ \\(t\\) ]{.math} 时刻的氢键 [ \\(i\\) ]{.math} , [
    \\(s_i(t)=\\{0,1\\}\\) ]{.math} . [ \\(C(\\t)\\) ]{.math}
    的积分给出了氢键平均寿命 [ \\(\\t\_{HB}\\) ]{.math} 的粗略估计

    [ \\\[\\tau\_{HB} = \\int_0\^\\infty C(\\tau) \\rmd \\tau
    \\tag{8.35}\\\] ]{.math}

    程序会输出积分和完整的自相关函数 [ \\(C(\\t)\\) ]{.math} ,
    以便能够进行更复杂的分析(例如使用多指数拟合)得到 [ \\(\\t\\)
    ]{.math} 的更佳估计值. 参考文献\[162\]给出了一个更完整的分析,
    一个更花哨的选项是氢键动力学的Luzar和Chandler分析\[163, 164\].

-   生成大小为 #HB×#frames 的氢键存在映射图.
    顺序与索引文件中的完全相同(见下文), 但反过来,
    这意味着索引文件中的最后一个三联原子编号相应于存在映射图的第一行.

-   输出包含分析组的索引组, 这些组中所有的施体-氢原子对和受体原子,
    分析组之间氢键中的施体-氢-受体三联对, 所有插入的溶剂分子.

## 8.13 与蛋白质相关的项 {#813-与蛋白质相关的项}

` gmx do_dssp, gmx rama, gmx wheel `

为分析蛋白质结构的变化,
你可以计算回旋半径或随时间变化的最小残基距离(参看8.8节),
或计算RMSD(参看8.9节).

在运行中你也可以观察 **二级结构元素** 的变化, 为此, 你可以使用
` gmx do_dssp ` 程序, 它是商业程序 ` DSSP ` \[165\]的接口界面.
更多的信息请参看 ` DSSP ` 的手册. 图 8.10 给出了一个典型的
` gmx do_dssp ` 输出图.

![图 8.10: 多肽二级结构元素的时间演化分析](/GMX/8.10.png)

另一个重要的蛋白质分析是所谓的 **Ramachandran图** ,
它是结构在蛋白质骨架的两个二面角 [ \\(\\f\\) ]{.math} 和 [ \\(\\y\\)
]{.math} 形成的平面上的投影. 参看图8.11.

<figure>
<img src="/GMX/8.11.png"
alt="图 8.11: 蛋白质骨架的二面角 $\f$ 和 $\y$ 的定义" />
<figcaption>图 8.11: 蛋白质骨架的二面角 <span class="math"> \(\f\)
</span> 和 <span class="math"> \(\y\) </span> 的定义</figcaption>
</figure>

你可以使用 ` gmx rama ` 获得Ramachandran图. 图 8.12是一个典型的输出.

![图 8.12: 一个小蛋白质分子的Ramachandran图](/GMX/8.12.png)

当研究 [ \\(\\a\\) ]{.math} 螺旋时, 多肽的 **旋轮投影** 很有用,
它可用于查看一个多肽是否是两性的. 你可以使用 ` gmx wheel `
程序获得这样的投影图. 图 8.13给出了两个例子.

![图 8.13: HPr N端螺旋的旋轮投影图](/GMX/8.13.png)

## 8.14 与界面相关的项 {#814-与界面相关的项}

` gmx order, gmx density, gmx potential, gmx traj `

当模拟具有长碳尾的分子时, 可以计算它们的平均取向. 有许多不同的序参数,
它们大多数是相关的. ` gmx order ` 程序可利用下面的方程计算序参数

[ \\\[S_z = {3 \\over 2} \<\\cos\^2 \\theta_z\> -{1 \\over 2}
\\tag{8.36}\\\] ]{.math}

其中 [ \\(\\q_z\\) ]{.math} 为模拟盒子的 [ \\(z\\) ]{.math}
轴与待研究的分子轴之间的夹角. 后者被定义为从 [ \\(\\text C\_{n-1}\\)
]{.math} 到 [ \\(\\text C\_{n+1}\\) ]{.math} 的矢量.
可以同样的方式定义参数 [ \\(S_x\\) ]{.math} 和 [ \\(S_y\\) ]{.math} .
尖括号隐含着要对时间和分子进行平均.
序参数可以在1(沿界面法向完全有序)和--1/2(完全垂直于界面法向)之间变化,
值为零时代表取向具有各向同性.

程序可以完成两件事. 它可以分别计算每个 [ \\(\\ce{CH2}\\) ]{.math}
片段的序参数, 对所有三个轴的序参数,
或将盒子划分为切片并计算一个切片内每个片段序参数的平均值.

第一个方法给出了分子从头到尾如何排列的说明,
第二个方法给出了排列和盒子长度的关系.

从一条轨迹中可以计算出穿过界面的静电势( [ \\(\\y\\) ]{.math} ),
通过电荷密度( [ \\(\\r(z)\\) ]{.math} )的双重积分

[ \\\[\\psi(z)-\\psi(-\\infty) = - \\int\_{-\\infty}\^z \\rmd z\'
\\int\_{-\\infty}\^{z\'} \\r(z\'\') \\rmd z\'\'/\\e_0 \\tag{8.37}\\\]
]{.math}

其中, 位置 [ \\(z =-\\infty\\) ]{.math} 在体相中足够远以致场强为零.
使用这种方法, 可以将总的势能"划分"为层和水分子的独立贡献.
` gmx potential ` 程序将盒子划分为切片,
并对每个切片中原子的所有电荷进行加和. 然后程序会积分电荷密度得到电场,
对电场进行积分给出势能. 电荷密度, 电场和势能会写入 ` xvgr ` 输入文件中.

` gmx traj ` 是一个非常简单的分析程序, 它所做的是打印选中原子的坐标,
速度, 或力. 它也可以计算一个或多个分子的质心,
并将质心坐标打印到三个文件中. 这个分析程序本身可能并不是很有用,
但获得了选择的分子或原子的坐标后很利于进行进一步的分析,
不仅仅对于界面体系是这样.

` gmx density ` 程序计算组的质量密度, 并给出沿盒子轴向的密度分布.
对于观察组的分布或穿过界面的原子, 这很有用.

::: footnotes

------------------------------------------------------------------------

1.  ::: {#fn:1}
    [ \\(P_0(x)=1, P_1(x)=x, P_2(x)=(3x\^2-1)/2\\) ]{.math}
    [↩](#fnref:1 "return to article"){.reversefootnote}
    :::
:::

------------------------------------------------------------------------

------------------------------------------------------------------------

![](/jscss/molsimart.png){style="display:table;margin:0 auto;height:150px"}
[个](javascript:scroll(0,0)){#scrollTop}
:::
::: site-header
::: wrap




""
:::
:::

::: wrap
# GROMACS中文手册：附录A　技术细节





## A.1 混合精度或双精度 {#a1-混合精度或双精度}

可以使用混合精度或双精度编译GROMACS.
老版本GROMACS的文档将混合精度称为"单精度",
但选择性地使用双精度已实现很多年了.
对所有变量都使用单精度将导致精度显著降低. 尽管在"混合精度"中,
所有的状态向量, 即粒子坐标, 速度和力, 都是单精度的,
但关键变量仍是双精度的. 后者的一个典型例子是维里,
它是对体系中所有力的加和, 正负可变. 另外, 在代码的许多地方,
通过改变求和顺序或重新组合数学表达式, 我们设法避免对双精度进行算术运算.
默认配置使用混合精度, 但通过为 ` cmake ` 添加选项 ` -DGMX_DOUBLE=on ` ,
可以很容易地启用双精度. 双精度比混合精度慢20%到100%,
具体数字取决于运行机器的架构. 双精度会使用更多的内存和运行输入,
而且能量和全精度轨迹文件的大小几乎是混合模式的两倍.

混合精度的能量精确到最后一位小数, 力的最后一位或两位数字并不重要.
维里的精度比力的要差,
因为维里只比所有原子加和中的各个元素大一个数量级(参见B.1节).
对大多数情况, 这真的不是一个问题,
因为维里的涨落可以比其平均值大两个数量级.
对库仑相互作用使用截断会导致能量, 力和维里出现大的误差.
即便使用反应场或晶格加和方法,
误差也大于或近于因局部使用单精度导致的误差. 由于MD具有混沌性,
具有非常相似起始条件的轨迹也将迅速发散, 混合精度的发散速度高于双精度.

对大多数模拟, 混合精度足够精确. 在某些情况下,
需要使用双精度以获得合理的结果:

-   简正分析, 其中的共轭梯度或l-bfgs最小化, 计算和对角化力常数矩阵
-   长时间的能量守恒, 特别是对于大的体系

## A.2 环境变量 {#a2-环境变量}

可以使用环境变量影响GROMACS程序的运行. 首先, 在 ` GMXRC `
文件中设置的变量对运行和编译GROMACS至关重要.
以下各节列出了其他一些有用的环境变量. 通过在你的shell中设置非空值,
大多数环境变量可以起作用. 如果需要设置其他的值, 参考下面的具体要求.
你应该查看自己所用shell的文档以了解如何为当前shell设置环境变量,
或者如何为以后的shell设置配置文件. 注意,
将环境变量输出到批处理控制系统作业中的要求各不相同,
你应该查看本地文档的详情说明.

**输出控制**

1.  ` GMX_CONSTRAINTVIR ` : 打印能量项中的约束维里和力维里.
2.  ` GMX_MAXBACKUP ` : 当尝试写到具有相同名称的新文件时,
    GROMACS自动备份以前文件的副本. 此变量控制备份的最大数量, 默认为99.
    当设置为0时, 若输出文件已存在, 则无法运行. 当设置为--1时,
    会覆盖所有输出文件, 不进行备份.
3.  ` GMX_NO_QUOTES ` : 如果明确设置了此变量,
    不会在程序结束后打印有趣的引用.
4.  ` GMX_SUPPRESS_DUMP ` : 禁用每步的文件转储,
    当(例如)约束算法失效引起体系崩溃时.
5.  ` GMX_TPI_DUMP ` :
    将相互作用能小于此环境变量设定值的全部构型转储到一个 ` .pdb ` 文件.
6.  ` GMX_VIEW_XPM ` : ` GMX_VIEW_XVG ` , ` GMX_VIEW_EPS ` 和
    ` MX_VIEW_PDB ` , 分别用于自动查看 ` .xvg ` , ` .xpm ` , ` .eps ` 和
    ` .pdb ` 文件类型的命令, 默认为 ` xv ` , ` xmgrace ` , ` ghostview `
    和 ` rasmol ` . 设置为空则禁用自动查看特定的文件类型.
    命令将被分叉运行于后台,
    运行时具有的优先级与GROMACS工具相同(这可能不是你想要的).
    注意不要使用阻断终端的命令(例如 ` vi ` ), 因为可能会运行多个实例.
7.  ` GMX_VIRIAL_TEMPERATURE ` : 打印能量项中的维里温度
8.  ` GMX_LOG_BUFFER ` : 用于文件I/O的缓冲区大小. 如果设置为0,
    所有文件I/O都不使用缓冲, 因此非常慢. 此变量可以方便调试,
    因为它能保证所有文件始终是最新的.
9.  ` GMX_LOGO_COLOR ` : 设置 ` ngmx ` 标志的显示颜色.
10. ` GMX_PRINT_LONGFORMAT ` : 当打印十进制数值时使用长浮点格式.
11. ` GMX_COMPELDUMP ` : 仅用于计算电生理学设置(参见6.6节).
    初始结构转储到 ` .pdb ` 文件,
    这样可以检查多聚体通道的PBC表示是否正确.

**调试**

1.  ` GMX_PRINT_DEBUG_LINES ` : 设置后, 打印调试的行号信息.
2.  ` GMX_DD_NST_DUMP ` : 转储当前DD到PDB文件的间隔步数(默认为0).
    仅对区域分解有效, 因此典型的值为0(从不), 1(每DD相)或 ` nstlist `
    的倍数.
3.  ` GMX_DD_NST_DUMP_GRID ` :
    转储当前DD格点到PDB文件的间隔步数(默认为0). 仅对区域分解有效,
    因此典型的值为0(从不), 1(每DD相)或 ` nstlist ` 的倍数.
4.  ` GMX_DD_DEBUG ` : 每个区域分解的通用调试触发器(默认为0,
    意味着禁用). 目前只检查全局-局部原子索引映射的一致性.
5.  ` GMX_DD_NPULSE ` : 覆盖所用的DD脉冲数(默认0, 意味着不覆盖).
    通常为1或2.

**性能和运行控制**

1.  ` GMX_DO_GALACTIC_DYNAMICS ` :
    设置此环境变量可启用行星模拟(只是为了好玩), 允许在 ` .mdp `
    文件中设置 ` epsilon_r = -1 ` . 正常情况下, ` epsilon_r `
    必须大于零, 以防止出现致命错误. 参见
    [www.gromacs.org](http://www.gromacs.org/)
    上行星模拟的输入文件的例子.
2.  ` GMX_ALLOW_CPT_MISMATCH ` : 设置后, 如果在 ` .tpr `
    文件中的系综设置与 ` .cpt ` 文件中的不匹配, 运行也不会退出.
3.  ` GMX_CUDA_NB_EWALD_TWINCUT ` : 强制使用双程截断内核,
    即使PP-PME负载均衡后 ` rvdw=rcoulomb ` . 会自动切换到双程截断内核,
    所以此变量只能用于校准.
4.  ` GMX_CUDA_NB_ANA_EWALD ` : 强制使用解析的Ewald内核. 只能用于校准.
5.  ` GMX_CUDA_NB_TAB_EWALD ` : 强制使用表格的Ewald内核. 只能用于校准.
6.  ` GMX_CUDA_STREAMSYNC ` :
    在启用ECC功能的GPU上强制使用cudaStreamSynchronize, 由于在API v5.0
    NVIDIA驱动程序(30x.xx以前版本)中存在一个已知的CUDA驱动程序缺陷,
    会导致性能下降. 不能与 ` GMX_NO_CUDA_STREAMSYNC ` 同时设置.
7.  ` GMX_CYCLE_ALL ` : 运行时对所有的代码进行计时. 不兼容线程.
8.  ` GMX_CYCLE_BARRIER ` : 在每个循环启动/停止调用前调用MPI_Barrier.
9.  ` GMX_DD_ORDER_ZYX ` : 设置构造区域分解格胞的顺序为(z, y, x),
    而不是默认的(x, y, z).
10. ` GMX_DD_USE_SENDRECV2 ` : 在约束和vsite通信时, 使用一对
    ` MPI_SendRecv ` 调用代替两个同步的非阻塞调用(默认为0,
    意味着不使用). 对一些MPI实现可能会更快.
11. ` GMX_DLB_BASED_ON_FLOPS ` :
    基于flop计数进行区域域分解的动态负载均衡,
    而不是基于测量到的流逝时间(默认为0, 意味着禁用).
    这使得负载均衡可重复, 对调试很有帮助. 值为1时使用flop;
    对\>1的值将添加(值--1)\*5%的噪声到flop, 以增加不均衡性和标度.
12. ` GMX_DLB_MAX_BOX_SCALING ` :
    每区域分解负载平衡步中所允许的盒子缩放的最大百分比(默认为10)
13. ` GMX_DD_RECORD_LOAD ` : 运行结束时记录DD负载统计报告(默认为1,
    意味着启用)
14. ` GMX_DD_NST_SORT_CHARGE_GROUPS ` :
    重新排序电荷组的间隔步数(默认为1). 只在区域分解中起作用,
    所以典型值应为0(从不), 1(每次区域分解), 或 ` nstlist ` 的倍数.
15. ` GMX_DETAILED_PERF_STATS ` : 设置后, 会打印更详细的性能信息到
    ` .log ` 文件. 输出结果的方式类似于4.5.x版本的性能总结,
    因而可能对那些使用脚本解析 ` .log ` 文件或标准输出的人有用.
16. ` GMX_DISABLE_SIMD_KERNELS ` : 禁用特定架构SIMD优化(SSE2, SSE4.1,
    AVX等)的非键内核, 因而强制使用普通的C内核.
17. ` GMX_DISABLE_CUDA_TIMING ` : 当时间步长较短时,
    对异步执行的GPU运算进行计时会有不可忽略的开销.
    在这种情况下禁用计时能够提高性能.
18. ` GMX_DISABLE_GPU_DETECTION ` : 设置后, 禁用GPU检测, 即使 ` mdrun `
    支持GPU.
19. ` GMX_DISABLE_PINHT ` : 当采用英特尔超线程时,
    禁止将连续线程分配到物理内核. 由 ` mdrun -nopinht ` 控制,
    因而此环境变量可能会被移除.
20. ` GMX_DISRE_ENSEMBLE_SIZE ` : 距离约束系综平均的体系数目. 整数值.
21. ` GMX_EMULATE_GPU ` : 不使用GPU加速函数,
    而是使用算法等价的CPU引用代码模拟GPU运行. 因为CPU代码较慢,
    设置此变量仅用于调试. 如果使用 ` GMX_NO_NONBONDED ` 关闭非键计算,
    会自动触发, 将不会调用非键计算, 但也会跳过CPU-GPU转移.
22. ` GMX_ENX_NO_FATAL ` : 当在 ` .edr ` 文件中遇到损坏的帧时禁止退出,
    允许使用直到损坏的所有帧.
23. ` GMX_FORCE_UPDATE ` : 调用 ` mdrun -rerun ` 时更新力.
24. ` GMX_GPU_ID ` : 与 ` mdrun ` 选项 ` -gpu_id ` 的设置方式相同,
    ` GMX_GPU_ID ` 环境变量允许用户指定不同GPU的ID,
    用于选择集群中不同计算节点上不同的设备. 不能与 ` -gpu_id ` 一起使用.
25. ` GMX_IGNORE_FSYNC_FAILURE_ENV ` : 允许 ` mdrun ` 继续运行,
    即使文件丢失.
26. ` GMX_LJCOMB_TOL ` : 当设置为浮点值时,
    覆盖力场浮点参数的默认容差1e--5.
27. ` GMX_MAX_MPI_THREADS ` : 设置 ` mdrun ` 可以使用的最大MPI线程数.
28. ` GMX_MAXCONSTRWARN ` : 当设置为--1时, 即便产生了很多LINCS警告,
    ` mdrun ` 也不会退出.
29. ` GMX_NB_GENERIC ` : 使用通用的C内核. 如果使用基于组的截断并将
    ` GMX_NO_SOLV_OPT ` 设为true, 就应该设置此变量, 从而禁用溶剂优化.
30. ` GMX_NB_MIN_CI ` : 在GPU上运行时使用的邻居列表平衡参数.
    对小的模拟体系, 为了改进多处理器的负载平衡从而提高性能,
    设置目标配对列表的最小数目. 必须设置为正整数.
    默认值是针对NVIDIA的Fermi和Kepler类型GPU进行优化的,
    所以正常使用时无须改变, 但对于未来的架构可能有用.
31. ` GMX_NBLISTCG ` : 使用基于电荷组的邻居列表和内核.
32. ` GMX_NBNXN_CYCLE ` : 设置后, 打印详细的邻居搜索循环计数.
33. ` GMX_NBNXN_EWALD_ANALYTICAL ` : 强制使用解析Ewald的非键内核, 与
    ` GMX_NBNXN_EWALD_TABLE ` 互斥.
34. ` GMX_NBNXN_EWALD_TABLE ` : 强制使用表格Ewald的非键内核, 与
    ` GMX_NBNXN_EWALD_ANALYTICAL ` 互斥.
35. ` GMX_NBNXN_SIMD_2XNN ` : 强制使用 2x(N+N) SIMD CPU非键内核, 与
    ` GMX_NBNXN_SIMD_4XN ` 互斥.
36. ` GMX_NBNXN_SIMD_4XN ` : 强制使用 4xN SIMD CPU非键内核, 与
    ` GMX_NBNXN_SIMD_2XNN ` 互斥.
37. ` GMX_NO_ALLVSALL ` : 禁用优化的 all-vs-all 内核.
38. ` GMX_NO_CART_REORDER ` : 用于初始化区域分解通信器. 默认等级重排序,
    但可利用此环境变量关闭.
39. ` GMX_NO_CUDA_STREAMSYNC ` : 与 ` GMX_CUDA_STREAMSYNC ` 相反.
    当开启ECC功能的GPU使用V5.0以前版本的CUDA驱动程序API时,
    禁用基于标准cudaStreamSynchronize的GPU等待以提高性能.
40. ` GMX_NO_INT ` , ` GMX_NO_TERM ` , ` GMX_NO_USR1 ` :
    分布禁用对SIGINT, SIGTERM, SIGUSR1信号进行处理.
41. ` GMX_NO_NODECOMM ` : 不使用独立的节点间和节点内的通讯器.
42. ` GMX_NO_NONBONDED ` : 跳过非键计算;
    可用于估计增加GPU加速器到当前硬件设置带来的可能的性能增益-假定完成非键计算的速度足够快,
    同时CPU进行键合力和PME计算.
43. ` GMX_NO_PULLVIR ` : 设置后, 不将维里的贡献添加到COM牵引力.
44. ` GMX_NOCHARGEGROUPS ` : 禁用多原子电荷组, 即,
    分配所有非溶剂分子中的每个原子到其自己的电荷组.
45. ` GMX_NOPREDICT ` : 不预测壳层位置.
46. ​​ ` GMX_NO_SOLV_OPT ` : 关闭溶剂优化; 如果启用了 ` GMX_NB_GENERIC `
    会自动进行.
47. ` GMX_NSCELL_NCG ` : 每个邻区搜索格胞的理想电荷组数被硬编码为10.
    将此环境变量的值设置为任何其它的整数会覆盖硬编码的值.
48. ` GMX_PME_NTHREADS ` : 设置OpenMP或PME的线程数(覆盖 ` mdrun `
    的猜测值).
49. ` GMX_PME_P3M ` : 使用P3M优化的影响函数, 而不是平滑的PME B样条内插.
50. ` GMX_PME_THREAD_DIVISION ` : 在三个维度上以"X Y
    Z"格式对PME线程进行划分.
    每一维度上线程的总和必须等于PME线程的总数(在 ` GMX_PME_NTHREADS `
    之间设置).
51. ` GMX_PMEONEDD ` : 如果x和y方向上区域分解格胞的数目都为1,
    对PME进行一维分解.
52. ` GMX_REQUIRE_SHELL_INIT ` : 需要初始化壳层位置.
53. ` GMX_REQUIRE_TABLES ` : 需要使用表格库仑和van der Waals相互作用.
54. ` GMX_SCSIGMA_MIN ` : 用于软核 [ \\(\\s\\) ]{.math} 的最小值.
    **注意** , 此值在 ` .mdp ` 文件中使用 ` sc-sigma ` 关键词进行设置,
    而此环境变量可用于重现4.5前的版本对此参数的行为.
55. ` GMX_TPIC_MASSES ` : 应包含用于测试粒子插入空腔时的多个质量.
    最后一个原子的质量中心用于插入空腔.
56. ` GMX_USE_GRAPH ` : 对键相互作用使用图形.
57. ` GMX_VERLET_BUFFER_RES ` : Verlet截断方案中缓冲区大小的分辨率.
    默认值为0.001, 但可以被此环境变量覆盖.
58. ` GMX_VERLET_SCHEME ` : 从基于组的方案转换为Verlet截断方案, 即使
    ` .mdp ` 文件中并没有将 ` cutoff_scheme ` 设置为Verlet.
    此变量没有必要存在, 因为 ` mdrun ` 的 ` -testverlet `
    选项具有同样的功能, 保留它只是为了向后兼容.
59. ` MPIRUN ` : ` g_tune_pme ` 使用的 ` mpirun ` 命令.
60. ` MDRUN ` : ` g_tune_pme ` 使用的 ` mdrun ` 命令.
61. ` GMX_NSTLIST ` : 设置 ` nstlist ` 的默认值,
    防止在使用Verlet截断方案启动 ` mdrun ` 时改变.
62. ` GMX_USE_TREEREDUCE ` : 对nbnxn力约化使用树约化.
    在OpenMP线程数很多时可能更快(如果内存位置很重要).

**分析和核心函数**

1.  ` GMX_QM_ACCURACY ` : Gaussian程序L510(MC-SCF)模块的精度.
2.  ` GMX_QM_ORCA_BASENAME ` : ` .tpr ` 文件的前缀,
    用于Orca计算的输入和输出文件名​​.
3.  ` GMX_QM_CPMCSCF ` : 当设置为非零值时,
    Gaussian时QM计算将迭代求解CP-MCSCF方程.
4.  ` GMX_QM_MODIFIED_LINKS_DIR ` : 修改的Gaussian链接的位置.
5.  ` DSSP ` : 为 ` do_dssp ` 所用, 指向 ` dssp `
    可执行程序(不只是其路径).
6.  ` GMX_QM_GAUSS_DIR ` : Gaussian的安装路径.
7.  ` GMX_QM_GAUSS_EXE ` : Gaussian可执行程序的名称.
8.  ` GMX_DIPOLE_SPACING ` : ` g_dipoles ` 所用的间距.
9.  ` GMX_MAXRESRENUM ` : 设置 ` grompp ` 重新编号的残基的最大数目.
    --1表示重新编号所有残基.
10. ` GMX_FFRTP_TER_RENAME ` : 有些力场(例如AMBER),
    对N端和C端残基使用特定的名称(NXXX和CXXX), 像那些正常重命名的
    ` .rtp ` 项一样. 设置此环境变量禁用此类重命名.
11. ` GMX_PATH_GZIP ` : ` gunzip ` 可执行程序的路径, 为 ` g_wham ` 所用.
12. ` GMX_FONT ` : ` ngmx ` 使用的X11字体的名称.
13. ` GMXTIMEUNIT ` : 输出文件中使用的时间单位, 可以为fs, ps, ns, us,
    ms, s, m或h.
14. ` GMX_QM_GAUSSIAN_MEMORY ` : Gaussian QM计算使用的内存.
15. ` MULTIPROT ` : ` multiprot ` 可执行程序的名称, 为程序
    ` do_multiprot ` 所用.
16. ` NCPUS ` : Gaussian QM计算使用的CPU数
17. ` GMX_ORCA_PATH ` : Orca的安装目录.
18. ` GMX_QM_SA_STEP ` : Gaussian QM计算的模拟退火步长.
19. ` GMX_QM_GROUND_STATE ` : 定义Gaussian表面跳跃计算的态.
20. ` GMX_TOTAL ` : ` total ` 可执行程序的名称, 为 ` do_shift `
    程序所用.
21. ` GMX_ENER_VERBOSE ` : 让 ` g_energy ` 和 ` eneconv ` 输出更多信息.
22. ` VMD_PLUGIN_PATH ` : VMD插件的安装路径.
    需要能够读取VMD插件认可的文件格式.
23. ` VMDDIR ` : 安装VMD的基准路径.
24. ` GMX_USE_XMGR ` : 将查看器设置为 ` xmgr ` (不推荐)以代替
    ` xmgrace ` .

## A.3 并行运行GROMACS {#a3-并行运行gromacs}

默认情况下, 将使用内置的线程MPI库编译GROMACS.
在处理单节点上线程之间的通信时, 使用此函数库比使用外部MPI库更高效.
要在多个节点, 例如一个集群上并行运行GROMACS,
你需要使用外部MPI库配置编译GROMACS.
所有的超级计算机都带有为其特定平台优化的MPI库, 也有几个好的免费MPI实现;
OpenMPI通常是一个不错的选择. 注意, MPI和线程MPI支持彼此不兼容.

除​​MPI并行外, GROMACS还支持通过OpenMP的线程并行.
MPI和OpenMP并行可以结合起来使用, 也就是所谓的杂合并行化. 在某些情况下,
杂合并行可提供更好的性能和标度.

请参看 [www.gromacs.org](http://www.gromacs.org/)
上关于不同并行方案使用和性能的详细信息.

## A.4 使用GPU运行GROMACS {#a4-使用gpu运行gromacs}

自4.6版本开始, GROMACS原生支持基于CUDA的GPU. 注意,
GROMACS只将计算最密集的部分, 目前也就是非键相互作用, 分配到GPU上运行,
MD计算的所有其他部分都是在CPU上进行的. 对CUDA代码的要求是,
Nvidia计算能力≥2.0的GPU, 即至少为Fermi类. 在许多情况下, ` cmake `
可自动检测GPU并自动配置GPU支持. 请传递 ` -DGMX_GPU=on ` 选项给 ` cmake `
, 并确认已配置GPU支持, . GPU的实际使用与否在 ` mdrun ` 运行时决定,
取决于是否有(合适的)GPU可用和运行输入设置.
支持GPU的可执行程序也可以只使用CPU进行模拟, 通过使用 ` mdrun -nb cpu `
强制仅使用CPU来运行模拟. 只有使用Verlet截断方案的模拟才能在GPU上运行.
为测试以前的tpr文件在GPU上运行的性能, 可以使用 ` mdrun ` 的
` -testverlet ` 选项, 但因为没有进行 ` grommp ` 的完整参数一致性检查,
你不应该使用此选项进行最终模拟. 在GPU上获得GROMACS的良好性能很容易,
但得到最佳性能很困难. 请查看 [www.gromacs.org](http://www.gromacs.org/)
上关于GPU使用的最新信息.

------------------------------------------------------------------------

------------------------------------------------------------------------

![](/jscss/molsimart.png){style="display:table;margin:0 auto;height:150px"}
[个](javascript:scroll(0,0)){#scrollTop}
:::
::: site-header
::: wrap




""
:::
:::

::: wrap
# GROMACS中文手册：附录B　一些实现细节





在本章中, 我们将介绍一些实现细节. 本章涉及的内容远远称不上完备,
但我们认为有必要澄清一些事情, 否则将很难理解.

## B.1 GROMACS中的单个和维里 {#b1-gromacs中的单个和维里}

维里 [ \\(\\X\\) ]{.math} 可以写成全张量形式:

[ \\\[\\X = -{1\\over2}\\Sum\_{i \< j}\^N \\bi r\_{ij} \\otimes \\bi
F\_{ij} \\tag{B.1}\\\] ]{.math}

其中 [ \\(\\otimes\\) ]{.math} 表示两个向量的 **直积** .
[\[1\]](#fn:1 "see footnote"){#fnref:1 .footnote}
当此在MD程序的内部循环中计算直积时, 需要进行9次乘法运算和9加法运算.
[\[2\]](#fn:2 "see footnote"){#fnref:2 .footnote}

这里将展示如何才能将维里计算从内部循环中抽取出来\[166\].

### B.1.1 维里 {#b11-维里}

对一个周期性体系, 计算维里时必须考虑周期性:

[ \\\[\\X = -{1\\over2}\\Sum\_{i \< j}\^N \\bi r\_{ij}\^n \\otimes \\bi
F\_{ij} \\tag{B.2}\\\] ]{.math}

其中 [ \\(\\bi r\_{ij}\^n\\) ]{.math} 表示从原子 [ \\(j\\) ]{.math}
到原子 [ \\(i\\) ]{.math} **最近映象** 的距离向量.
在这个定义中我们为原子 [ \\(i\\) ]{.math} 的位置向量 [ \\(\\bi r_i\\)
]{.math} 添加一个 **移位向量** [ \\(\\d_i\\) ]{.math} . 差向量 [ \\(\\bi
r\_{ij}\^n\\) ]{.math} 因此等于:

[ \\\[\\bi r\_{ij}\^n = \\bi r_i +\\d_i - \\bi r_j \\tag{B.3}\\\]
]{.math}

或简写为:

[ \\\[\\bi r\_{ij}\^n = \\bi r_i\^n - \\bi r_j \\tag{B.4}\\\] ]{.math}

对一个三斜体系, [ \\(i\\) ]{.math} 有27个可能的映象; 当使用截面八面体时,
有15个可能的映象.

## B.1.2 非键力的维里 {#b12-非键力的维里}

这里给出非键力子程序中单个和维里的推导. 在下面的所有公式中 [ \\(i \\ne
j\\) ]{.math} .

[ \\(\\alg \\X &= -{1\\over2}\\Sum\_{i \< j}\^N \\bi r\_{ij}\^n \\otimes
\\bi F\_{ij} \\tag{B.5} \\\\ &= -{1\\over4} \\Sum\_{i=1}\^N
\\Sum\_{j=1}\^N (\\bi r_i +\\d_i -\\bi r_j) \\otimes \\bi F\_{ij}
\\tag{B.6} \\\\ &= -{1\\over4} \\Sum\_{i=1}\^N \\Sum\_{j=1}\^N (\\bi r_i
+\\d_i ) \\otimes \\bi F\_{ij} - \\bi r_j \\otimes \\bi F\_{ij}
\\tag{B.7} \\\\ &= -{1\\over4} \\left( \\Sum\_{i=1}\^N \\Sum\_{j=1}\^N
(\\bi r_i + \\d_i) \\otimes \\bi F\_{ij} - \\Sum\_{i=1}\^N
\\Sum\_{j=1}\^N \\bi r_j \\otimes \\bi F\_{ij} \\right) \\tag{B.8} \\\\
&= -{1\\over4} \\left( \\Sum\_{i=1}\^N (\\bi r_i +\\d_i) \\otimes
\\Sum\_{j=1}\^N \\bi F\_{ij} - \\Sum\_{j=1}\^N \\bi r_j \\otimes
\\Sum\_{i=1}\^N \\bi F\_{ij} \\right) \\tag{B.9} \\\\ &= -{1\\over4}
\\left( \\Sum\_{i=1}\^N (\\bi r_i +\\d_i) \\otimes \\bi F_i +
\\Sum\_{j=1}\^N \\bi r_j \\otimes \\bi F_j \\right) \\tag{B.10} \\\\ &=
-{1\\over4} \\left( 2\\Sum\_{i=1} \\bi r_i \\otimes \\bi F_i +
\\Sum\_{i=1} \\d_i \\otimes \\bi F_i \\right) \\tag{B.11} \\ealg\\)
]{.math}

在上面这些公式中, 我们引入了

[ \\\[\\bi F_i = \\Sum\_{j=1}\^N \\bi F\_{ij} \\tag{B.12}\\\] ]{.math}

[ \\\[\\bi F_j = \\Sum\_{i=1}\^N \\bi F\_{ji} \\tag{B.13}\\\] ]{.math}

为 [ \\(j\\) ]{.math} 对 [ \\(i\\) ]{.math} 总的作用力.
因为我们使用了牛顿第三定律:

[ \\\[\\bi F\_{ij} = -\\bi F\_{ji} \\tag{B.14}\\\] ]{.math}

在实现时我们必须将含移位 [ \\(\\d_i\\) ]{.math} 的项加倍.

### B.1.3 分子内移位(mol-shift) {#b13-分子内移位mol-shift}

对键合力和SHAKE, 可以创建一个 **mol-shift** 列表, 其中存储了周期性.
我们简单地使用一个数组 ` mshift ` , 其中存储了每个原子在 ` shiftvec `
数组中的索引.

生成此列表的算法可以从图论得到, 将分子中的每个粒子视为图中的节点,
将键视为图的边.

1.  用双向图代表键和原子
2.  令所有原子为白色
3.  使白色原子中的一个原子(原子 [ \\(i\\) ]{.math} )变为黑色,
    并把它放在盒子中心
4.  对 [ \\(i\\) ]{.math} 的每个邻居, 如果它目前为白色, 则将其变为灰色
5.  选择灰色原子中的一个(原子 [ \\(j\\) ]{.math} ),
    相对于它的所有黑色邻居, 给它正确的周期性, 并将其变黑
6.  对 [ \\(j\\) ]{.math} 的每个邻居, 如果它目前为白色, 则将其变为灰色
7.  如果仍然存在任何一个灰色原子, 转到5
8.  如果仍然存在任何一个白色原子, 转到3

使用这种算法, 我们可以

-   优化键合力计算以及SHAKE
-   使用单个和方法从键合力计算维里
-   获得键的双向图表示.

### B.1.4 共价键的维里 {#b14-共价键的维里}

由于共价键力对维里有贡献, 我们有:

[ \\(\\alg b &= \\\| \\bi r\_{ij}\^n \\\| \\tag{B.15} \\\\ V_b &=
{1\\over2} k_b (b-b_0)\^2 \\tag{B.16} \\\\ \\bi F_i &= - \\nabla V_b
\\tag{B.17} \\\\ &= k_b (b-b_0) {\\bi r\_{ij}\^n \\over b} \\tag{B.18}
\\\\ \\bi F_j &= - \\bi F_i \\tag{B.19} \\ealg\\) ]{.math}

来源于键的维里为:

[ \\(\\alg \\X_b &= - {1\\over2} (\\bi r_i\^n \\otimes \\bi F_i + \\bi
r_j \\otimes \\bi F_j ) \\tag{B.20} \\\\ &= - {1\\over2} (\\bi
r\_{ij}\^n \\otimes \\bi F_i) \\tag{B.21} \\ealg\\) ]{.math}

### B.1.5 SHAKE的维里 {#b15-shake的维里}

SHAKE对维里有着重要贡献. 为满足约束, 力 [ \\(\\bi G\\) ]{.math}
作用到"摇动"的粒子上. 如果此力不是来自算法(如在标准SHAKE中),
它可以在后面计算(当使用 **蛙跳算法** 时):

[ \\(\\alg \\D \\bi r_i &= \\bi r_i (t+\\D t) - \[\\bi r_i(t)+ \\bi
v_i(t-{\\D t \\over 2}) \\D t+{\\bi F_i \\over m_i} \\D t\^2\]
\\tag{B.22} \\\\ \\bi G_i &= {m_i \\D \\bi r_i \\over \\D t\^2}
\\tag{B.23} \\ealg\\) ]{.math}

在一般情况下, 上式对我们没有帮助. 只有当不需要使用周期性时(如刚性水),
才可以使用上面的公式, 否则我们必须在SHAKE的内部循环中增加维里的计算.

当 **适用** 时, 可以使用单个和方式计算维里:

[ \\\[\\X = -{1\\over2} \\Sum_i\^{N_c} \\bi r_i \\otimes \\bi F_i
\\tag{B.24}\\\] ]{.math}

其中 [ \\(N_c\\) ]{.math} 为约束原子的数目.

## B.2 优化 {#b2-优化}

在这里, 我们将描述GROMACS使用的一些算法优化, 不包括并行化. 对其中的一个,
1.0/sqrt(x)函数的实现, 我们将在B.3节分开处理. 其他最重要优化的论述如下.

### B.2.1 水的内部循环 {#b21-水的内部循环}

GROMACS使用特殊的内部循环来计算水分子与其它原子的非键相互作用,
使用另一组循环计算水分子之间的相互作用.
这两组循环针对两种类型的水模型进行了高度优化.
对于类似于SPC\[81\]的三位点模型, 即:

1.  分子中有三个原子.
2.  整个分子属于单个电荷组.
3.  第一个原子具有Lennard-Jones(4.1.1节)和库仑(4.1.3节)相互作用.
4.  第二和第三个原子只具有库仑相互作用, 且电荷相等.

这些循环也适用于SPC/E\[167\]和TIP3P\[125\]水模型.
对类似于TIP4P\[125\]的四位点水模型:

1.  分子中有四个原子.
2.  整个分子属于单个电荷组.
3.  第一个原子只具有Lennard-Jones(4.1.1节)相互作用.
4.  第二和第三个原子具有库仑相互作用, 且电荷相等.
5.  第四个原子只具有库仑相互作用.

这些实现方式的好处是, 在单个循环中有更多的浮点运算,
这意味着一些编译器可以更好地调度代码. 然而, 事实证明,
甚至一些最先进的编译器也存在调度问题,
这意味着需要进行手动调整以获得最佳性能. 这可能包括消去相同的子表达,
或移动代码到各处.

### B.2.2 Fortran代码 {#b22-fortran代码}

不幸的是, 在一些平台上Fortran编译器仍好于C编译器. 对于一些机器(例如SGI
Power Challenge)差异可高达3, 对矢量计算机差异可能更大. 因此,
针对英特尔和AMD的x86处理器,
有些占用大量计算时间的子程序被改写为Fortran甚至汇编代码. 在大多数情况下,
当适用时, Fortran或汇编循环会通过 ` configure ` 脚本自动选择,
但你也可以通过设置 ` configure ` 脚本的选项对此进行调整.

## B.3 1.0/sqrt函数的计算 {#b3-10sqrt函数的计算}

### B.3.1 简介 {#b31-简介}

GROMACS项目开始于开发一个 [ \\(1/\\sqrt{x}\\) ]{.math} 的处理器,
用以计算:

[ \\\[Y(x)= {1\\over \\sqrt x} \\tag{B.25}\\\] ]{.math}

随着项目的继续, 英特尔 *i* 860处理器被用于实现GROMACS,
现在几乎已经变成了一个完整的软件项目. [ \\(1/\\sqrt x\\) ]{.math}
处理器的实现采用了一步的Newton-Raphson迭代方案, 为此,
需要查表以提供初始近似值. [ \\(1/\\sqrt x\\) ]{.math}
函数使用了两个几乎独立的表格, 分别用于IEEE浮点表示的指数种子和分数种子.

### B.3.2 通用 {#b32-通用}

根据\[168\] [ \\(1/\\sqrt x\\) ]{.math}
函数可以使用Newton-Raphson迭代方案进行计算. 反函数为:

[ \\\[X(y)= {1\\over y\^2} \\tag{B.26}\\\] ]{.math}

因此不直接计算

[ \\\[Y(a)=q \\tag{B.27}\\\] ]{.math}

而是使用Newton-Raphson方法求解方程

[ \\\[X(q) - a = 0 \\tag{B.28}\\\] ]{.math}

![图 B.1:
IEEE单精度浮点数格式](/GMX//GMX//GMX//GMX//GMX//GMX//GMX//GMX//GMX//GMX//GMX//GMX//GMX//GMX//GMX//GMX/B.1.png)

通过计算:

[ \\\[y\_{n+1}= y_n-{f(y_n) \\over f\'(y_n)} \\tag{B.29}\\\] ]{.math}

进行迭代. 在这种近似下, 绝对误差 [ \\(\\ve\\) ]{.math} 被定义为:

[ \\\[\\ve \\equiv y_n-q \\tag{B.30}\\\] ]{.math}

利用Taylor级数展开来估计误差, 根据\[168\]的方程(3.2)得到:

[ \\\[\\ve\_{n+1} = - {\\ve_n\^2 \\over 2}{f\'\'(y_n) \\over f\'(y_n)}
\\tag{B.31}\\\] ]{.math}

这是绝对误差的估计.

### B.3.3 用于于浮点数 {#b33-用于于浮点数}

IEEE 32位单精度格式的浮点数具有几乎恒定的相对误差 [ \\(\\D x/x =
2\^{-24}\\) ]{.math} . 从前面所述的Taylor级数展开公式(方程B.31)可以看到,
每步迭代的误差是绝对的, 且一般与 [ \\(y\\) ]{.math} 有关.
如果将误差表示为相对误差, 有下面的式子

[ \\\[\\ve\_{r\_{n+1} } \\equiv {\\ve\_{n+1}\\over y} \\tag{B.32}\\\]
]{.math}

并且

[ \\\[\\ve\_{r\_{n+1} } = - ({\\ve_n \\over y})\^2 y {f\'\' \\over 2f\'}
\\tag{B.33}\\\] ]{.math}

对函数 [ \\(f(y)= y\^{-2}\\) ]{.math} , [ \\(yf\'\'/2f\'\\) ]{.math}
项为常数(等于--3/2), 因此相对误差 [ \\(\\ve\_{r_n}\\) ]{.math} 与 [
\\(y\\) ]{.math} 无关.

[ \\\[\\ve\_{r\_{n+1} } = {3\\over2} (\\ve\_{r_n})\^2 \\tag{B.34}\\\]
]{.math}

由此得到的结论是, 函数 [ \\(1/\\sqrt x\\) ]{.math} 可以计算到指定的精度.

### B.3.4 备查表格的要求 {#b34-备查表格的要求}

为了使用前面提到的迭代方案计算函数 [ \\(1/\\sqrt x\\) ]{.math} , 很明显,
解的第一次估计必须足够精确, 这样才能获得精确的结果. 计算的要求是

-   IEEE格式的最大可能精度
-   只使用一次迭代以达到最高速度

第一个要求指出, [ \\(1/\\sqrt x\\) ]{.math} 的结果可能具有的相对误差 [
\\(\\ve_r\\) ]{.math} 等于IEEE 32位单精度浮点数的 [ \\(\\ve_r\\)
]{.math} . 由此可以得出初始近似的 [ \\(1/\\sqrt x\\) ]{.math} ,
对后续步骤重写相对误差的定义(方程B.34):

[ \\\[{\\ve_n \\over y} = \\sqrt{ \\ve\_{r\_{n+1} }{2f\' \\over yf\'\'}
} \\tag{B.35}\\\] ]{.math}

因此对于查表所需的精度为:

[ \\\[{\\D Y\\over Y} = \\sqrt{\\ {2\\over3} 2\^{-24}\\ }
\\tag{B.36}\\\] ]{.math}

这定义了备查表的宽度必须≥13比特.

这样, 备查表的相对误差 [ \\(\\ve\_{r_n}\\) ]{.math} 是已知的,
由此可以计算参数的最大相对误差. 绝对误差 [ \\(\\D x\\) ]{.math} 定义为:

[ \\\[\\D x \\equiv {\\D Y \\over Y\'} \\tag{B.37}\\\] ]{.math}

因此:

[ \\\[{\\D x \\over Y} = {\\D Y \\over Y} (Y\')\^{-1} \\tag{B.38}\\\]
]{.math}

因此:

\$\$ \\D x = \\text{constant} {Y \\over Y'} \\tag{B.39}\$\$

对 [ \\(1/\\sqrt x\\) ]{.math} 函数, 满足 [ \\(Y/Y\'\~x\\) ]{.math} ,
所以 [ \\(\\D x/x=\\text{constant}\\) ]{.math} . 前面提到过,
这是所用浮点表示的性质. 备查表参数需要的精度符合:

[ \\\[{\\D x \\over x} = -2 {\\D Y \\over Y} \\tag{B.40}\\\] ]{.math}

因此, 使用浮点精度(方程B.36):

[ \\\[{\\D x \\over x} = -2 \\sqrt{ {2\\over3}2\^{-24} } \\tag{B.41}\\\]
]{.math}

这定义了备查表的宽度必须≥12比特.

### B.3.5 指数和分数的独立计算 {#b35-指数和分数的独立计算}

所使用的IEEE 32位单精度浮点格式规定, 一个数字由一个指数和一个分数表示.
上一节对每个可能的浮点数规定了备查表的长度和宽度.
精度仅由浮点数的分数部分的大小决定. 由此得到的结论是,
备查表的大小为其长度, 前面已规定, 再乘上指数的大小(2 ^12^ 2 ^8^ , 1Mb).
[ \\(1/\\sqrt x\\) ]{.math} 函数具有指数部分与分数部分无关的性质.
如果使用浮点表示, 这很明显. 定义:

[ \\\[x \\equiv (-1)\^S (2\^{E-127})(1.F) \\tag{B.42}\\\] ]{.math}

参看图 B.1, 其中 [ \\(0 \\le S \\le 1, 0 \\le E \\le 255, 1 \\le 1.F
\\lt 2\\) ]{.math} , [ \\(S, E, F\\) ]{.math} 为整数(规范化条件).
符号位( [ \\(S\\) ]{.math} )可以省略, 因为 [ \\(1/\\sqrt x\\) ]{.math}
只对 [ \\(x\>0\\) ]{.math} 有定义. [ \\(1/\\sqrt x\\) ]{.math}
函数作用于 [ \\(x\\) ]{.math} 得到:

[ \\\[y(x)= {1 \\over \\sqrt x} \\tag{B.43}\\\] ]{.math}

或:

[ \\\[y(x)= {1 \\over \\sqrt{(2\^{E-127})(1.F)} } \\tag{B.44}\\\]
]{.math}

这可以改写为:

[ \\\[y(x)=(2\^{E-127})\^{-1/2} (1.F)\^{-1/2} \\tag{B.45}\\\] ]{.math}

定义:

[ \\\[(2\^{E\'-127}) \\equiv (2\^{E-127})\^{-1/2} \\tag{B.46}\\\]
]{.math}

[ \\\[1.F\' \\equiv (1.F)\^{-1/2} \\tag{B.47}\\\] ]{.math}

这样 [ \\({1\\over\\sqrt 2} \\lt 1.F\' \\le 1\\) ]{.math} 成立,
因此对规范的实数表示非常重要的条件 [ \\(1\\le 1.F\' \\lt 2\\) ]{.math} ,
不再成立. 通过引入一个额外的项, 可以对此进行校正. 将 [ \\(1/\\sqrt x\\)
]{.math} 函数应用于浮点数(方程B.45)改写为:

[ \\\[y(x)=(2\^{ {127-E\\over2}-1})(2(1.F)\^{-1/2}) \\tag{B.48}\\\]
]{.math}

和:

[ \\\[(2\^{E\'-127}) \\equiv (2\^{ {127-E\\over2} -1} ) \\tag{B.49}\\\]
]{.math}

[ \\\[1.F\' \\equiv 2(1.F)\^{-1/2} \\tag{B.50}\\\] ]{.math}

这样 [ \\(\\sqrt 2 \\lt 1.F \\le 2\\) ]{.math} 成立.
这和方程B.42中定义的规范化浮点数的精确有效范围不同. 数值2导致问题.
通过将此值映射到\<2的最近表示, 可以解决这个问题.
这种近似引入的小误差在允许范围内.

指数的整数表示是下一个问题. 计算 [ \\((2\^{ {127-E\\over2} -1})\\)
]{.math} 会引入分数的结果, 如果 [ \\((127 - E)\\) ]{.math} 为奇数.
通过将计算分为奇数部分和偶数部分, 很容易处理这个问题. 对 [ \\((127 -
E)\\) ]{.math} 为偶数的情况, 方程(方程B.49)中的 [ \\(E\'\\) ]{.math}
作为 [ \\(E\\) ]{.math} 的函数, 可以使用整数运算精确地计算出来

[ \\\[E\' = {127 -E \\over 2} + 126 \\tag{B.51}\\\] ]{.math}

对 [ \\((127 - E)\\) ]{.math} 为奇数的情况, 方程(方程B.45)可以改写为:

[ \\\[y(x)=(2\^{ {127-E-1\\over2} }) ({1.F \\over 2})\^{-1/2}
\\tag{B.52}\\\] ]{.math}

因此:

[ \\\[E\' = {126 - E \\over 2} + 127 \\tag{B.53}\\\] ]{.math}

这也可以使用整数运算进行精确计算. **注意** ,
对前面提到的范围分数部分是自动校正的,
因此不需要对指数部分进行额外的校正.

由此得到的结论是:

-   分数和指数的备查表是独立的. 存在两个分数备查表(奇指数和偶指数),
    因此必须使用指数的奇/偶信息(1sb比特)选择适当的表格.
-   指数备查表是一个256 x 8比特的表, 对 **奇数** 和 **偶数**
    进行了初始化.

### B.3.6 实现 {#b36-实现}

可以使用一个小的C程序来产生备查表, 它使用了符合IEEE
32位单精度格式的浮点数和操作. 需要注意的是, 因为需要 **奇/偶** 信息,
分数表是前面指定的两倍大(13比特 i.s.o 12比特).

必须实现方程B.29的函数. 应用到 [ \\(1/\\sqrt x\\) ]{.math} 函数,
方程B.28给出:

[ \\\[f = a -{1\\over y\^2} \\tag{B.54}\\\] ]{.math}

因此:

[ \\\[f\' = {2\\over y\^3} \\tag{B.55}\\\] ]{.math}

因此:

[ \\\[y\_{n+1} = y_n -{a-{1\\over y_n\^2} \\over {2\\over y_n\^3} }
\\tag{B.56}\\\] ]{.math}

或:

[ \\\[y\_{n+1} = {y_n \\over 2} (3 -a y_n\^2) \\tag{B.57}\\\] ]{.math}

其中 [ \\(y_0\\) ]{.math} 可以在备查表中找到, [ \\(y_1\\) ]{.math}
给出了具有最大精度的结果. 显然,
对双精度结果只需要一步额外的迭代(以双精度进行).

::: footnotes

------------------------------------------------------------------------

1.  ::: {#fn:1}
    [ \\((\\bi u \\otimes \\bi v)\^{\\a\\b} = \\bi u\_\\a \\bi v\_\\b\\)
    ]{.math} [↩](#fnref:1 "return to article"){.reversefootnote}
    :::

2.  ::: {#fn:2}
    Lennard-Jones和库仑力时计算大约需要50次浮点运算.
    [↩](#fnref:2 "return to article"){.reversefootnote}
    :::
:::

------------------------------------------------------------------------

------------------------------------------------------------------------

![](/jscss/molsimart.png){style="display:table;margin:0 auto;height:150px"}
[个](javascript:scroll(0,0)){#scrollTop}
:::
::: site-header
::: wrap




""
:::
:::

::: wrap
# GROMACS中文手册：附录C　平均值与涨落





## C.1 平均值计算公式 {#c1-平均值计算公式}

**注意** : 本节来源于参考文献\[169\].

当分析MD轨迹时, 需要计算物理量 [ \\(x\\) ]{.math} 的平均值 [ \\(\< x
\>\\) ]{.math} 和涨落

[ \\\[\\left\< (\\D x)\^2 \\right\>\^{1\\over2} = \\left\< \[x-\< x
\>\]\^2 \\right\>\^{1\\over2} \\tag{C.1}\\\] ]{.math}

[ \\(N_x\\) ]{.math} 个值 [ \\(\\{x_i\\}\\) ]{.math} 的方差 [
\\(\\s_x\\) ]{.math} , 可利用下式进行计算

[ \\\[\\s_x = \\sum\_{i=1}\^{N_x} x_i\^2 - {1 \\over N_x}
\\left(\\sum\_{i=1}\^{N_x} x_i \\right)\^2 \\tag{C.2}\\\] ]{.math}

遗憾的是这个公式在数值上不是很精确, 尤其是当 [ \\(\\s_x\^{1\\over2}\\)
]{.math} 相比 [ \\(x\\) ]{.math} 的值为小时.
下面(等价)的表达式数值上更精确

[ \\\[\\s_x = \\sum\_{i=1}\^{N_x} \[x_i - \< x \>\]\^2 \\tag{C.3}\\\]
]{.math}

其中

[ \\\[\< x \> = {1\\over N_x} \\sum\_{i=1}\^{N_x} x_i \\tag{C.4}\\\]
]{.math}

使用方程C.2和C.4进行计算时, 需要扫描 [ \\(x_i\\) ]{.math} 值序列两次,
第一次确定 [ \\(\< x \>\\) ]{.math} , 第二次计算 [ \\(\\s_x\\) ]{.math}
, 而等式C.1只需要按顺序扫描 [ \\(\\{x_i\\}\\) ]{.math} 序列一次. 然而,
可以将方程C.2改写成另一种形式, 其中含有部分和,
这样就可以使用顺序更新算法. 定义部分和

[ \\\[X\_{n,m} = \\sum\_{i=n}\^m x_i \\tag{C.5}\\\] ]{.math}

和部分方差

[ \\\[\\s\_{n,m} = \\sum\_{i=n}\^m \\left\[ x_i - {X\_{n,m} \\over m-n +
1} \\right\]\^2 \\tag{C.6}\\\] ]{.math}

可以证明

[ \\\[X\_{n,m+k} =X\_{n,m} + X\_{m+1, m+k} \\tag{C.7}\\\] ]{.math}

和

[ \\(\\alg \\s\_{n,m+k} &= \\s\_{n,m}+\\s\_{m+1, m+k} + \\left\[
{X\_{n,m} \\over m-n+1} - {X\_{n,m+k} \\over m+k-n+1} \\right\]\^2 \\\\
&\* {(m-n+1)(m+k-n+1) \\over k} \\ealg \\tag{C.8}\\) ]{.math}

对 [ \\(n=1\\) ]{.math} 可以发现

[ \\\[\\s\_{1,m+k} = \\s\_{1,m} + \\s\_{m+1, m+k} +\\left\[ {X\_{1,m}
\\over m} - {X\_{1,m+k} \\over m+k} \\right\]\^2 {m(m+k) \\over k}
\\tag{C.9}\\\] ]{.math}

并且对 [ \\(n=1, k=1\\) ]{.math} (方程C.8)变为

[ \\(\\alg \\s\_{1,m+1} &= \\s\_{1,m} + \\left\[ {X\_{1,m} \\over m} -
{X\_{1,m+1} \\over m+1} \\right\]\^2 m(m+1) \\tag{C.10} \\\\
&=\\s\_{1,m} + {\[X\_{1,m} - m x\_{m+1}\]\^2 \\over m(m+1)} \\tag{C.11}
\\ealg\\) ]{.math}

其中我们已经使用了关系

[ \\\[X\_{1,m+1} = X\_{1,m} + X\_{m+1} \\tag{C.12}\\\] ]{.math}

利用公式(方程C.11)和(方程C.12), 平均值

[ \\\[\< x \> = {X\_{1, N_x} \\over N_x} \\tag{C.13}\\\] ]{.math}

涨落

[ \\\[\\left\< (\\D x)\^2 \\right\>\^{1\\over2} = \\left\[{\\s\_{1,N_x}
\\over x}\\right\]\^{1\\over2} \\tag{C.14}\\\] ]{.math}

通过扫描一次数据就可以获得.

## C.2 实现 {#c2-实现}

在GROMACS中, 瞬时能量 [ \\(E(m)\\) ]{.math} 连同 [ \\(\\s\_{1,m}\\)
]{.math} 和 [ \\(X\_{1,m}\\) ]{.math} 一起存储在能量文件中.
虽然步数从0开始计数, 但能量和涨落的步数是从1开始计数的, 这意味着,
实现时使用的就是这里给出的方程. 我们在本节给出有些冗长的推导,
是为了以后核查代码和公式时更简单.

### C.2.1 部分模拟 {#c21-部分模拟}

这种情况并不少见, 模拟的第一部分, 例如100 ps, 被用于平衡. 然而,
日志文件中给出的平均值和涨落是基于整个模拟过程进行计算的. 平衡时间,
现在作为模拟的一部分, 在这种情况下 可能使得平均值和涨落无效,
因为这些数字现在由最初趋于平衡的漂移所主导.

根据方程C.7和C.8, 部分轨迹的平均值和标准偏差可利用下式计算:

[ \\\[X\_{m+1,m+k} = X\_{1,m+k} - X\_{1,m} \\tag{C.15}\\\] ]{.math}

[ \\\[\\s\_{m+1,m+k} = \\s\_{1,m+k} - \\s\_{1,m} - \\left\[ {X\_{1,m}
\\over m} - {X\_{1,m+k} \\over m+k} \\right\]\^2 {m(m+k) \\over k}
\\tag{C.16}\\\] ]{.math}

或者, 更一般地( [ \\(p \\ge 1\\) ]{.math} 并且 [ \\(q \\ge p\\) ]{.math}
):

[ \\\[X\_{p,q} = X\_{1,q} - X\_{1,p-1} \\tag{C.17}\\\] ]{.math}

[ \\\[\\s\_{p,q} = \\s\_{1,q} - \\s\_{1,p-1} - \\left\[ {X\_{1,p-1}
\\over p-1} - {X\_{1,q} \\over q} \\right\]\^2 {(p-1)q \\over q-p+1}
\\tag{C.18}\\\] ]{.math}

**注意** , 上面算法的实现并不是非常简单的,
因为没有存储模拟中每一时间步的能量. 因此, 我们必须使用方程C.11和C.12, 从
[ \\(p\\) ]{.math} 时刻的信息来获得 [ \\(X\_{1, p-1}\\) ]{.math} 和 [
\\(\\s\_{1,p-1}\\) ]{.math} :

[ \\\[X\_{1,p-1} = X\_{1,p} - x_p \\tag{C.19}\\\] ]{.math}

[ \\\[\\s\_{1, p-1} = \\s\_{1,p} - {\[X\_{1,p-1} - (p-1) x_p \]\^2
\\over (p-1)p} \\tag{C.20}\\\] ]{.math}

### C.2.2 组合两次模拟 {#c22-组合两次模拟}

另一个经常发生的问题是, 必须组合两次模拟的涨落. 考虑下面的例子:
我们有两次模拟, 进行了 [ \\(n\\) ]{.math} 步的(A)和进行了 [ \\(m\\)
]{.math} 步的(B), 其中的第二次模拟是第一次的延续. 然而,
第二次模拟从1开始编号, 而不是从 [ \\(n+1\\) ]{.math} 开始.
对部分和这没有问题, 我们必须加上A的 [ \\(x\_{1,n}\^A\\) ]{.math} :

[ \\\[X\^{AB}\_{1,n+m} = X\_{1,n}\^A + X\_{1,m}\^B \\tag{C.21}\\\]
]{.math}

当我们想根据两部分计算部分方差时, 必须修正 [ \\(\\D \\s\\) ]{.math}

[ \\\[\\s\^{AB}\_{1,n+m} = \\s\_{1,n}\^A + \\s\_{1,m}\^B + \\D \\s
\\tag{C.22}\\\] ]{.math}

如果我们定义 [ \\(x_i\^{AB}\\) ]{.math} 为组合并重新编号后的数据点, 有:

[ \\\[\\s\_{1,n+m}\^{AB} = \\sum\\limits\_{i=1}\^{n+m}\\left\[
x_i\^{AB} - {X\_{1,n+m}\^{AB} \\over n+m} \\right\]\^2 \\tag{C.23}\\\]
]{.math}

因此

[ \\\[\\sum\\limits\_{i=1}\^{n+m} \\left\[ x_i\^{AB}-{X\_{1,n+m}\^{AB}
\\over n+m}\\right\]\^2=\\sum\\limits\_{i=1}\^n \\left\[ x_i\^A
-{X\_{1,n}\^A \\over n} \\right\]\^2 + \\sum\\limits\_{i=1}\^m \\left\[
x_i\^B - {X\_{1,m}\^B \\over m}\\right\]\^2+ \\D \\s \\tag{C.24}\\\]
]{.math}

或

[ \\(\\alg \\sum\\limits\_{i=1}\^{n+m} \\left\[ (x_i\^{AB})\^2-2
x_i\^{AB} {X\_{1,n+m}\^{AB} \\over n+m} + \\left( {X\_{1,n+m}\^{AB}
\\over n+m}\\right)\^2 \\right\] &- \\\\ \\sum\\limits\_{i=1}\^n
\\left\[ (x_i\^A)\^2-2 x_i\^A {X\_{1,n}\^A \\over n} + \\left(
X\_{1,n}\^A \\right)\^2 \\right\] &- \\\\ \\sum\\limits\_{i=1}\^m
\\left\[ (x_i\^B)\^2-2 x_i\^B {X\_{1,n}\^B \\over n} + \\left(
X\_{1,n}\^B \\right)\^2 \\right\] &= \\D \\s \\tag{C.25} \\ealg\\)
]{.math}

所有的 [ \\(x_i\^2\\) ]{.math} 项都分离出来了, 每一项与加和指标 [
\\(i\\) ]{.math} 无关, 可以简化为:

[ \\(\\alg {\\left(X\_{1,n+m}\^{AB}\\right)\^2 \\over n+m} -
{\\left(X\_{1,n}\^A\\right)\^2 \\over n} -
{\\left(X\_{1,m}\^B\\right)\^2 \\over n+m} &- \\\\ 2 {X\_{1,n+m}\^{AB}
\\over n+m} \\sum\\limits\_{i=1}\^{n+m} x_i\^{AB} + 2 {X\_{1,n}\^A
\\over n} \\Sum\_{i=1}\^n x_i\^A + 2 {X\_{1,m}\^B \\over m}
\\Sum\_{i=1}\^m x_i\^B &= \\D \\s \\tag{C.26} \\ealg\\) ]{.math}

重新组织第二行的三个部分并使用方程C.21, 得到:

[ \\\[\\D \\s= {\\left( m X\_{1,n}\^A - n X\_{1,m}\^B \\right)\^2 \\over
nm(n+m)} \\tag{C.27}\\\] ]{.math}

如果我们通过令 [ \\(m=1\\) ]{.math} 来检查上面的公式, 将回归到方程C.11.

### C.2.3 能量项加和 {#c23-能量项加和}

` g_energy ` 程序还可以将能量项加和在一起, 例如, 势能+动能=总能.
对部分平均是很容易的, 如果我们 [ \\(S\\) ]{.math} 个能量组分 [ \\(s\\)
]{.math} :

[ \\\[X\_{m,n}\^S = \\Sum\_{i=m}\^n \\Sum\_{s=1}\^S x_i\^s =
\\Sum\_{s=1}\^S \\Sum\_{i=m}\^n x_i\^s = \\Sum\_{s=1}\^S X\_{m,n}\^s
\\tag{C.28}\\\] ]{.math}

对于涨落更复杂些, 例如考虑一下势能和动能的涨落互相抵消的情况.
不过我们可以使用相同的方法, 如前面一样:

[ \\\[\\s\_{m,n}\^S = \\Sum\_{s=1}\^S \\s\_{m,n}\^s + \\D \\s
\\tag{C.29}\\\] ]{.math}

我们代入方程C.6:

[ \\\[\\Sum\_{i=m}\^n \\left\[ \\left( \\S\_{s=1}\^S x_i\^s\\right) -
{X\_{m,n}\^S \\over m-n+1} \\right\]\^2 = \\Sum\_{s=1}\^S
\\Sum\_{i=m}\^n \\left\[ (x_i\^s)- {X\_{m,n}\^s \\over
m-n+1}\\right\]\^2 + \\D \\s \\tag{C.30}\\\] ]{.math}

展开得到:

[ \\(\\alg &\\Sum\_{i=m}\^n \\left\[ \\Sum\_{s=1}\^S (x_i\^s)\^2 +
\\left( {X\_{m,n}\^S \\over m-n+1} \\right)\^2 - 2 \\left( {X\_{m,n}\^S
\\over m-n+1} \\Sum\_{s=1}\^S x_i\^s + \\Sum\_{s=1}\^S
\\Sum\_{s\'=s+1}\^S x_i\^s x_i\^{s\'} \\right) \\right\] \\\\ -
&\\Sum\_{s=1}\^S \\Sum\_{i=m}\^n \\left\[ (x_i\^S)\^2 - 2 {X\_{m,n}\^s
\\over m-n+1} x_i\^s + \\left( X\_{m,n}\^s \\over m-n+1 \\right)\^2
\\right\] = \\D \\s \\tag{C.31} \\ealg\\) ]{.math}

含 [ \\((x_i\^s)\^2\\) ]{.math} 的项互相抵消了, 这样我们就可以化简为:

[ \\(\\alg &{\\left(X\_{m,n}\^S\\right)\^2 \\over m-n+1} - 2
{X\_{m,n}\^S \\over m-n+1} \\Sum\_{i=m}\^n \\Sum\_{s=1}\^S x_i\^s - 2
\\Sum\_{i=m}\^n \\Sum\_{s=1}\^S \\Sum\_{s\'=s+1}\^S x_i\^s x_i\^{s\'} -
\\\\ &\\Sum\_{s=1}\^S \\Sum\_{i=m}\^n \\left\[ -2 {X\_{m,n}\^s \\over
m-n+1} x_i\^s + \\left( {X\_{m,n}\^s \\over m-n+1} \\right)\^2
\\right\]= \\D \\s \\tag{C.32} \\ealg\\) ]{.math}

或

[ \\\[-{\\left( X\_{m,n}\^S \\right)\^2 \\over m-n+1} -2 \\Sum\_{i=m}\^n
\\Sum\_{s=1}\^S \\Sum\_{s\'=s+1}\^S x_i\^s x_i\^{s\'} + \\Sum\_{s=1}\^S
{\\left( X\_{m,n}\^s \\right)\^2 \\over m-n+1} = \\D \\s \\tag{C.33}\\\]
]{.math}

如果使用方程C.28展开第一项, 我们得到:

[ \\\[-{\\left( \\S\_{s=1}\^S X\_{m,n}\^s \\right)\^2 \\over m-n+1} -2
\\Sum\_{i=m}\^n \\Sum\_{s=1}\^S \\Sum\_{s\'=s+1}\^S x_i\^s x_i\^{s\'} +
\\Sum\_{s=1}\^S {\\left( X\_{m,n}\^s \\right)\^2 \\over m-n+1} = \\D \\s
\\tag{C.34}\\\] ]{.math}

可以重写为:

[ \\\[-2\\left\[ \\Sum\_{s=1}\^S \\Sum\_{s\'=s+1}\^S X\_{m,n}\^s
X\_{m,n}\^{s\'} + \\Sum\_{i=m}\^n \\Sum\_{s=1}\^S \\Sum\_{s\'=s+1}\^S
x_i\^s x_i\^{s\'} \\right\] = \\D \\s \\tag{C.35}\\\] ]{.math}

或

[ \\\[-2\\left\[ \\Sum\_{s=1}\^S X\_{m,n}\^s \\Sum\_{s\'=s+1}\^S
X\_{m,n}\^{s\'} + \\Sum\_{s=1}\^S \\Sum\_{i=m}\^n x_i\^s
\\Sum\_{s\'=s+1}\^S x_i\^{s\'} \\right\] = \\D \\s \\tag{C.36}\\\]
]{.math}

这给出

[ \\\[-2\\Sum\_{s=1}\^S\\left\[ X\_{m,n}\^s \\Sum\_{s\'=s+1}\^S
\\Sum\_{i=m}\^n x_i\^{s\'} + \\Sum\_{i=m}\^n x_i\^s \\Sum\_{s\'=s+1}\^S
x_i\^{s\'} \\right\] = \\D \\s \\tag{C.37}\\\] ]{.math}

由于我们需要根据所有的数据点 [ \\(i\\) ]{.math} 进行计算,
一般来说这是不可能的. 我们可以对 [ \\(\\s\_{m,n}\^S\\) ]{.math}
进行估计, 仅使用可用的数据点, 并使用方程C.30的左半部分.
尽管可以使用模拟中的所有时间步对平均值进行计算,
涨落的精度却由能量保存的频率所限制. 由于使用程序如xmgr很容易做到,
GROMACS并没有内置此功能.


KALP-15 in DPPC  

##  GROMACS Tutorial

###  Membrane Protein: KALP  15  in DPPC

**Justin A. Lemkul, Ph.D.**  

![](./Images/KALP15_DPPC.png)  

This tutorial will guide the user through the preparation and simulation of a
simple membrane protein, in this case KALP  15  , in a model membrane, DPPC.
The tutorial assumes the user has already successfully completed the , some
other tutorial, or is otherwise well-versed in GROMACS simulation methods and
topology organization. The level of detail in this tutorial will be focused on
membrane protein-specific considerations, and will not provide an exhaustive
explanation of every step, as with the Lysozyme tutorial.

This tutorial assumes you are using GROMACS version 2018 or newer.

**Please note** that the purpose of this tutorial is instructional, to build a
membrane protein system and also to understand GROMACS force field
organization and methods for modification. This tutorial is not an endorsement
or suggestion that you use these specific parameters for your simulation. The
approach taken here works well in the case where one needs to augment a
parameter set with other parameters that have been derived in a consistent
manner. Some force fields already include everything you need, without
modification. For instance, it is unwise to try to literally follow this
approach for a force field like CHARMM36, as it needs no modification. In that
case, you are much better off building the system with .

** As of summer 2023, the required Berger lipid parameters are no longer
available online. The authors themselves have raised issues of their validity
and they are not available. This tutorial will remain online as a reference
until I rewrite it. Please DO NOT proceed and expect the tutorial to work. It
will not.  **

  
  
  
---  
  

 
KALP-15 in DPPC  

##  GROMACS Tutorial

**Step One: Prepare the Topology**

![](./Images/Steps_top_highlight.jpg)

The protein we will be working with is the KALP model peptide, denoted KALP
15  , which has a sequence of: Ac-GKK(LA)  4  LKKA-NH  2  . The protocol
described here is based on a system built by Kandasamy and Larson in a study
of hydrophobic mismatch. The original reference can be found .

The peptide was prepared in-house using the xLeap module of , using ideal
backbone geometry of an α-helix ( = -60°, = -40°). The .pdb file was oriented
along the -axis using editconf -princ, followed by a rotation about the y
axis. Note that in GROMACS-3.3.x, the -princ option oriented the long axis of
the structure (in this case, the helix axis) along the -axis by default, but
this option has changed as of GROMACS-4.0.4, which orients the long axis along
the -axis. If you want to skip the construction of this peptide, the properly
oriented structure can be found .

Execute pdb2gmx by issuing the following command:

    
    
    gmx pdb2gmx -f KALP-15_princ.pdb -o KALP-15_processed.gro -ignh -ter -water spc
    

When prompted, choose the GROMOS96 53A6 parameter set. Choose "None" for the
termini; since we have added acetyl and amide capping groups to the N- and
C-termini, respectively, we do not want pdb2gmx to build the normal amine and
carboxyl groups. Instead, we want pdb2gmx to add connectivity to our capping
groups. The -ignh flag tells pdb2gmx to ignore the H atoms in the input. By
default, xLeap gave us an all-atom structure (since the AMBER force fields use
explicit hydrogen representation). Due to AMBER naming conventions, these H
atoms may not have the same nomenclature as those of the GROMOS96 force field.
If we tell pdb2gmx to ignore all input H atoms, it will add back only those
that it needs.

Now we will need to make some alterations to the topology.

|

|  
  
---|---  
  

 
KALP-15 in DPPC  

##  GROMACS Tutorial

**Step Two: Modify the Topology**

![](./Images/Steps_top_highlight.jpg)

The lipid bilayer we will be simulating is DPPC
(dipalmitoylphosphatidylcholine), so we need parameters for it as well. But if
pdb2gmx is designed to handle only proteins, nucleic acids, and a finite
amount of cofactors, where do we get parameters for this molecule, and how do
we apply them to our system?

For this tutorial, we will use a united-atom force field to describe the
lipids derived by Berger, Edholm, and Jähnig ( ). These parameters can be
combined with a GROMOS representation of the protein.

The so-called "Berger lipids" are somewhat of a hybrid between GROMOS
atomtypes and OPLS partial charges. Since the long alkane chains are poorly
represented by GROMOS bonded parameters, a Ryckaert-Bellemans dihedral
potential is used, and a scaling factor of 0.125 is applied to Lennard-Jones
1-4 interactions. These lipid parameters are distributed by D. Peter Tieleman,
through his . While you are there, download the following files:

  * dppc128.pdb - the structure of a 128-lipid DPPC bilayer 
  * dppc.itp - the ` [moleculetype] ` definition for DPPC 
  * lipid.itp - Berger lipid parameters 

So what exactly is lipid.itp, and how do you use it? Think of this analogy:
gromos53a6.ff/forcefield.itp is to your protein what lipid.itp is to the
lipids. Essentially, lipid.itp contains all the atom types, nonbonded
parameters, and bonded parameters for a large class of lipids, much like how
forcefield.itp, ffnonbonded.itp, and ffbonded.itp function in relation to a
protein. That said, we cannot simply ` #include "lipid.itp" ` within our
topology, since it is at the same level (precedence) as forcefield.itp.

To use the parameters in lipid.itp, we will have to make some changes to our
pre-packaged GROMOS96 53A6 force field files (in $GMXLIB/gromos53a6.ff). Make
a copy of this directory in your working directory called
"gromos53a6_lipid.ff" (assuming you have GROMACS installed in
/usr/local/gromacs):

    
    
    cp -r /usr/local/gromacs/share/gromacs/top/gromos53a6.ff/ ./gromos53a6_lipid.ff
    

Inside this directory, you will find the following files:

    
    
    aminoacids.c.tdb
    aminoacids.hdb
    aminoacids.n.tdb
    aminoacids.r2b
    aminoacids.rtp
    aminoacids.vsd
    atomtypes.atp
    ff_dum.itp
    ffbonded.itp
    ffnonbonded.itp
    forcefield.doc
    forcefield.itp 
    ions.itp
    spc.itp
    spce.itp
    tip3p.itp
    tip4p.itp
    watermodels.dat
    

Next, modify ` forcefield.doc ` to update the description of the force field
parameters in it based on the modifications we will make in this tutorial.
Mine contains something like:

    
    
    GROMOS96 53A6 force field, extended to include Berger lipid parameters
    

The files contained in the gromos53a6_lipid.ff directory constitute the
complete description of the force field. The files serve the following
purposes:

  * aminoacids.c.tdb and aminoacids.n.tdb - These files are read by pdb2gmx and list the available patching actions that can be applied to protein chains 
  * aminoacids.hdb - This file is read by pdb2gmx and contains a database for constructing hydrogen atoms 
  * aminoacids.r2b - This file is read by pdb2gmx and contains translations between conventional residue names and any force field-specific building block names 
  * aminoacids.rtp - This file is read by pdb2gmx and contains all the available protein residues (and some cofactors, water, and ions - typical contents of a coordinate file passed to pdb2gmx) 
  * atomtypes.atp - This file is read by pdb2gmx and contains all the available atom types in the force field 
  * ff_dum.itp - This file contains constants that are used in constructing virtual sites (more on this in a different tutorial, and not relevant for our purposes here 
  * ffbonded.itp - All the parameters for bonded interactions in the force field 
  * ffnonbonded.itp - All the nonbonded (Lennard-Jones) parameters in the force field 
  * ions.itp - Contains ` [moleculetype] ` definitions for all monoatomic ions in the force field 
  * spc.itp, spce.itp, tip3p.itp, and tip4p.itp - Water model topologies (the standard water model for GROMOS96 simulations is SPC) 
  * watermodels.dat - A text file read by pdb2gmx for interactively selecting the water model to be used in the system topology 

Now, to add the lipid parameters into the parent force field, we will need to
copy and paste the entries in the ` [atomtypes], [nonbond_params], ` and `
[pairtypes] ` sections from lipid.itp into the corresponding headings within
ffnonbonded.itp. You will find that the lipid.itp ` [atomtypes] ` section
lacks atomic numbers (the at.num column), so add these in. The newly-modified
lines should be:

    
    
       LO    8    15.9994      0.000     A  2.36400e-03 1.59000e-06 ;carbonyl O, OPLS
      LOM    8    15.9994      0.000     A  2.36400e-03 1.59000e-06 ;carboxyl O, OPLS
      LNL    7    14.0067      0.000     A  3.35300e-03 3.95100e-06 ;Nitrogen, OPLS
       LC    6    12.0110      0.000     A  4.88800e-03 1.35900e-05 ;Carbonyl C, OPLS
      LH1    6    13.0190      0.000     A  4.03100e-03 1.21400e-05 ;CH1, OPLS
      LH2    6    14.0270      0.000     A  7.00200e-03 2.48300e-05 ;CH2, OPLS
       LP   15    30.9738      0.000     A  9.16000e-03 2.50700e-05 ;phosphor, OPLS
      LOS    8    15.9994      0.000     A  2.56300e-03 1.86800e-06 ;ester oxygen, OPLS
      LP2    6    14.0270      0.000     A  5.87400e-03 2.26500e-05 ;RB CH2, Bergers LJ
      LP3    6    15.0350      0.000     A  8.77700e-03 3.38500e-05 ;RB CH3, Bergers LJ
      LC3    6    15.0350      0.000     A  9.35700e-03 3.60900e-05 ;CH3, OPLS
      LC2    6    14.0270      0.000     A  5.94700e-03 1.79000e-05 ;CH2, OPLS
    

In the ` [nonbond_params] ` section, you will find the line ` ";; parameters
for lipid-GROMOS interactions." ` **Delete this line and all of the subsequent
lines in this section** (preserving the section that starts with ` ";; lipid-
SPC/SPCE interactions" ` ). The protein-specific nonbonded combinations are
specific to the deprecated "ffgmx" (a modified GROMOS87) force field. Removing
these lines allows the interactions between the protein and the lipids to be
generated by the standard combination rules of GROMOS96 53A6. Non-bonded
interactions involving atom type HW are also present; since these are all zero
you can delete these lines as well, or otherwise rename HW as H to be
consistent with the GROMOS96 53A6 naming convention. **If you do not rename
these lines or remove them, grompp will later fail with a fatal error.**

Append the contents of the ` [ dihedraltypes ] ` to the corresponding section
of ffbonded.itp. Do not be concerned that these lines look a bit different.
They are Ryckaert-Bellemans dihedrals, which differ in form from the standard
periodic dihedrals used in the default GROMOS96 53A6 force field.

To recap, you must make **all** of the following changes for the force field
to be functional:

  1. Copy ` [atomtypes] ` from lipid.itp to ffnonbonded.itp and add a column for atomic number 
  2. Copy ` [nonbond_params] ` from lipid.itp to ffnonbonded.itp 
  3. Remove the ` ;; parameters for lipid-GROMOS interactions ` and **all subsequent lines** in the ` [nonbond_params] ` section in ffnonbonded.itp 
  4. Remove all lines containing "HW" in ` [nonbond_params] ` or otherwise rename them to "H" 
  5. Copy ` [pairtypes] ` from lipid.itp to ffnonbonded.itp 
  6. Copy ` [dihedraltypes] from lipid.itp to ffbonded.itp `

Finally, change the ` #include ` statement in your topol.top from:

    
    
    #include "gromos53a6.ff/forcefield.itp"
    

to:

    
    
    #include "gromos53a6_lipid.ff/forcefield.itp"
    

Lastly, we need to include the specific parameters for our DPPC molecules. The
process for doing so is quite simple. Just add the line ` #include "dppc.itp"
` in your topol.top, somewhere after the position restraints section for the
protein, which defines the end of the protein ` [moleculetype] ` definition.
Doing so is analogous to adding any other small molecule or solvent into the
topology. In this section and throughout this tutorial, text in  **orange**
will denote lines that you should add, while other text (in black) are lines
that should already be present in the topology prior to the modification
indicated.

    
    
    ; Include Position restraint file
    #ifdef POSRES
    #include "posre.itp"
    #endif
    **; Include DPPC chain topology
    #include "dppc.itp"**
    ; Include water topology
    #include "gromos53a6_lipid.ff/spc.itp"
    

###  Notes on Force Fields

Since the Berger parameters were drawn from aspects of both the GROMOS and
OPLS-UA force fields, it is also possible to use the OPLS-AA force field to
represent your protein and have a compatible model. You will have to make some
modifications to lipid.itp so that it is consistent with OPLS conventions. For
information on how to do this, read the following links:

  
  

Regardless of which setup you choose, you must demonstrate that your model is
reasonable. The particular parameter combinations described here have been
shown to work in-house and according to reports by other users. It is up to
you to convince your audience (i.e., reviewers) that you know what you are
doing and that your model is valid. For instance, if you intend to do long
simulations, it is also known that GROMOS96 53A6 under-stabilizes α-helices
and you may end up with a random coil rather than a correct helix. In this
case, you may want to use the newer GROMOS96 54A7 parameter set, or another
force field entirely.

If you have correctly followed all of the steps above, you will have a fully
functional force field that can be used to process other membrane proteins
with pdb2gmx. Doing so removes the need to manually hack topol.top after the
fact. Placing the new gromos53a6_lipid.ff directory in $GMXLIB will allow you
to use this force field system-wide.

|

|  
  
---|---  
  

 
KALP-15 in DPPC  

##  GROMACS Tutorial

**Step Three: Defining the Unit Cell & Adding Solvent **

![](./Images/Steps_box_highlight.jpg)

Defining a unit cell for a membrane protein is considerably more complicated
than for a protein in water. There are several key steps in building the unit
cell:

  1. Orient the protein and membrane in the same coordinate frame 
  2. Pack the lipids around the protein 
  3. Solvate with water 

  

**1\. Orient the protein and membrane**

We have already aligned the KALP peptide using editconf. The bilayer lies in
the plane, with the normal along the -axis. To remove the effects of
periodicity, use trjconv:

(1) Generate a .tpr file for a DPPC-only system using grompp. You can use any
valid .mdp file and a topology corresponding to pure DPPC. An example .mdp
file can be found and such a topology can be found . Note how simple the
topology is. It includes dppc.itp and spc.itp to read parameters for DPPC and
water; it's that simple! Run grompp:

    
    
    gmx grompp -f minim.mdp -c dppc128.pdb -p topol_dppc.top -o dppc.tpr
    

You may receive a fatal error like , but in this case it is safe to use `
-maxwarn 1 ` with the above command. The reason that doing so is acceptable is
explained . **Please note** that this step is the only one in which `
topol_dppc.top ` will be used. It serves no other purpose and you should not
use it in **any** remaining step in this tutorial.

It is not necessary to run a complete energy minimization procedure on the
bilayer, although you can if you want. The .tpr file contains information
about bonding and periodicity, so it can, in a sense, be used to reconstruct
"broken" molecules.

(2) Use trjconv to remove periodicity (select group 0, "System" for output):

    
    
    gmx trjconv -s dppc.tpr -f dppc128.pdb -o dppc128_whole.gro -pbc mol -ur compact
    

Now, take a look at the last line of this .gro file; it corresponds to the
x/y/z box vectors of the DPPC unit cell. We need to orient the KALP peptide
within this same coordinate frame, and place the center of mass of the peptide
at the center of this box:

    
    
    gmx editconf -f KALP-15_processed.gro -o KALP_newbox.gro -c -box 6.41840 6.44350 6.59650
    

The center of our system now lies at (3.20920, 3.22175, 3.29825), half of each
box vector. This is a GROMACS convention. Note that other systems you wish to
simulate may not be symmetrical with respect to the membrane, and thus the
above command must be modified to something like the following:

    
    
    gmx editconf -f protein.gro -o protein_newbox.gro -box (membrane box vectors) -center 
    

In the above command, represents the center of mass such that the protein is
properly placed. Placement should be based on experimental knowledge of
membrane positioning, or intuition based on the chemical composition of your
particular protein.

  

**2\. Pack the lipids around the protein**

The easiest method I have found so far for packing lipids around an embedded
protein is the InflateGRO methodology ( ), available . **Please note** that I
am distributing my own copy of the original version of InflateGRO, **not**
InflateGRO2 available elsewhere from the authors. Download the linked file and
rename it "inflategro.pl" to continue. First, concatenate the protein and
bilayer structure files:

    
    
    cat KALP_newbox.gro dppc128_whole.gro > system.gro
    

Remove unnecessary lines (the box vectors from the KALP structure, the header
information from the DPPC structure) and update the second line of the
coordinate file (total number of atoms) accordingly.

The authors of the InflateGRO script recommend using a very strong position-
restraining force on protein heavy atoms to ensure that the position of the
protein does not change during EM. Add a new #ifdef statement to your
topology, one that will call a special set of position restraints, such that
your topology now contains a section like:

    
    
    ; Include Position restraint file
    #ifdef POSRES
    #include "posre.itp"
    #endif
    **; Strong position restraints for InflateGRO
    #ifdef STRONG_POSRES
    #include "strong_posre.itp"
    #endif**
    ; Include DPPC chain topology
    #include "dppc.itp"
    
    ; Include water topology
    #include "gromos53a6_lipid.ff/spc.itp"
    

Now, generate this new position restraint file using genrestr:

    
    
    gmx genrestr -f KALP_newbox.gro -o strong_posre.itp -fc 100000 100000 100000
    

In the .mdp file used for the minimizations, add a line "define =
-DSTRONG_POSRES" to make use of these new position restraints. Then, simply
follow the InflateGRO instructions (contained in the script itself), a
procedure that is easily scripted. Scale the lipid positions by a factor of 4:

    
    
    perl inflategro.pl system.gro 4 DPPC 14 system_inflated.gro 5 area.dat
    

Since the InflateGRO script requires a very specific order to its command-line
arguments, a brief explanation is warranted here. They are:

  1. ` system.gro ` \- the input coordinate file name to which scaling will be applied 
  2. ` 4 ` \- the scaling factor to apply. A value > 1 indicates inflation, a value < 1 indicates shrinking/compression 
  3. ` DPPC ` \- the residue name of the lipid to which scaling is applied 
  4. ` 14 ` \- the cutoff radius (in Å) for searching for lipids to delete 
  5. ` system_inflated.gro ` \- the output file name 
  6. ` 5 ` \- grid spacing (also in Å) for area per lipid calculation 
  7. ` area.dat ` \- output file with area per lipid information, useful in assessing the suitability of the structure 

Note how many lipids were deleted and update the ` [molecules] ` directive of
your topology accordingly. Run energy minimization using .mdp file:

    
    
    gmx grompp -f minim_inflategro.mdp -c system_inflated.gro -p topol.top -r system_inflated.gro -o system_inflated_em.tpr
    
    gmx mdrun -deffnm system_inflated_em
    

The output of mdrun will be "broken" molecules that have all atoms in the
central image. As before, reconstruct with trjconv before attempting to use
such coordinates with InflateGRO:

    
    
    gmx trjconv -s system_inflated_em.tpr -f system_inflated_em.gro -o tmp.gro -pbc mol
    mv tmp.gro system_inflated_em.gro
    

At this point, we need to begin packing the lipids around the protein by
applying a scaling factor that is < 1\. A robust approach is to scale down the
lipids by a factor of 0.95, which will require many iterations. The first will
be:

    
    
    perl inflategro.pl system_inflated_em.gro 0.95 DPPC 0 system_shrink1.gro 5 area_shrink1.dat
    

Follow this up by another round of EM. During the "shrinking" steps, be sure
to keep the InflateGRO cutoff value to 0, or else you will continue to delete
lipids! After 26 iterations of scaling down by 0.95, I reached an area per
lipid of ~71 Å  2  , above the experimental value of ~62 Å  2  . Since the
script tends to overestimate the area per lipid, this value is good enough to
continue to equilibration.

If you wish to automate this process, a Bash script for performing the energy
minimization of the inflated system and all subsequent shrinking steps can be
found .

Visually, the entire process looks something like this:

![](Images/inflategro_pack_loop.gif)  

**3\. Solvate with water**

Solvating a protein is a trivial task with gmx solvate. Solvating a membrane
protein system is not so simple, since the solvate program has a tendency to
fill gaps in the lipid acyl chains with water molecules. These water molecules
will be deleted later using a custom Perl script. Proceed with solvation as
normal:

    
    
    gmx solvate -cp system_shrink26_em.gro -cs spc216.gro -o system_solv.gro -p topol.top
    

After solvating, visualize the structure and you will see many water molecules
within the hydrophobic core of the bilayer. Use to delete these water
molecules:

    
    
    perl water_deletor.pl -in system_solv.gro -out system_solv_fix.gro -ref O33 -middle C50 -nwater 3
    

The file names passed to -in and -out are the input and output file names,
respectively. The -ref flag allows the user to set which atom is set as a
"reference" to define the upper and lower boundaries of the membrane. It is
wise to set this atom name to one of the atoms in the ester region of the
phospholipid rather than a headgroup atom, to prevent excessive dehydration.
The -middle flag specifies an atom that is representative of the middle of the
bilayer (along the membrane normal, typically the z-axis) so the reference
atoms can be divided into upper and lower leaflets, thus establishing the
range of z-coordinate values within which water molecules will be deleted. The
value passed to -nwater defines how many atoms constitute a water molecule.
For SPC, there are only three atoms (OW, HW1, and HW2).

The script tells you how many water molecules it deleted and how many water
molecules remain in the system. Update the SOL line in topol.top with this
updated number of water molecules. You may wish to renumber the coordinate
file with gmx genconf, but doing so is not required.

|

|  
  
---|---  
  
  

 
KALP-15 in DPPC  

##  GROMACS Tutorial

**Step Four: Adding Ions**

![](./Images/Steps_ions_highlight.jpg)

Now that we have solvated our system and removed water molecules from the
hydrophobic core of the membrane, it is time to add neutralizing counterions.
At this point, the process for continuing with building our system is nearly
identical to that of the . The .mdp file used can be found .

    
    
    gmx grompp -f ions.mdp -c system_solv_fix.gro -p topol.top -o ions.tpr
    

Since the KALP  15  peptide contains 4 lysine residues, the peptide bears a
net charge of +4 at neutral pH. Use genion to add 4 Cl  \-  ions to neutralize
this charge:

    
    
    gmx genion -s ions.tpr -o system_solv_ions.gro -p topol.top -pname NA -nname CL -neutral
    

![](./Images/KALP15_DPPC.jpg)  
  
|

|  
  
---|---  
  

 
KALP-15 in DPPC  

##  GROMACS Tutorial

**Step Five: Energy Minimization**

![](./Images/Steps_EM_highlight.jpg)

This step is just like in any other simulation. Assemble the binary input
using grompp using input parameter file:

    
    
    gmx grompp -f minim.mdp -c system_solv_ions.gro -p topol.top -o em.tpr
    

Invoke mdrun:

    
    
    gmx mdrun -v -deffnm em
    

As with any other simulation, verify that the values of E  pot  and F  max
are reasonable before continuing. Membrane protein systems can be tricky,
because there are a number of potential problems. If your system is not
converging, consider the following factors:

  1. Intra-headgroup hydrogen bonding, like in PE or PG headgroups. Sometimes simulations collapse because the headgroups fold in on themselves within voids in the solvent. There are several potential solutions to this problem (and others you may encounter):   

    * Use position restraints or freeze groups during equilibration until the solvent is optimized around the lipid headgroups. 
    * Reduce the charges on the H atoms (all the way to zero, if necessary)  Restore the charges before continuing! 
    * Add  [ exclusions ]  within the topology between H and phosphate O atoms  Remove the exclusions before continuing! 
  2. Acyl chain overlap can occur during packing. Run InflateGRO carefully, and do not attempt to over-pack your lipids. 
  3. Protein-lipid overlap. Did you choose an appropriate cut-off value in the initial InflateGRO step? 
  4. Water-headgroup and ion-headgroup overlap. Sometimes genbox and genion are not smart, especially regarding random placement of ions. A CL- next to a phosphate can send the ion (or lipid) careening across the simulation box! 

Now that our system is at an energy minimum, we can begin real dynamics.

|

|  
  
---|---  
  

 
KALP-15 in DPPC  

##  GROMACS Tutorial

**Step Six: Equilibration**

![](./Images/Steps_equil_highlight.jpg)

Equilibration will be conducted much like in the case of a solvated protein.
Generally a short equilibration phase is followed by a longer phase. The
reason for this procedure is that we are now dealing with a heterogenous
system, with both water and DPPC acting as solvent. Such heterogeneity
requires a longer equilibration process. Water has to re-orient around the
lipid headgroups and any exposed parts of the protein, and the lipids have to
orient themselves around the protein as well. Such processes take some time,
and lipid equilibration may take several ns of simulation time.

For membrane protein simulations, we will need to create a special index group
consisting of protein and lipids (explained below). To do this, use make_ndx:

    
    
    gmx make_ndx -f em.gro -o index.ndx
    ...
     > 1 | 13
     > q
    

Entering "1 | 13" at the make_ndx prompt merges the Protein (1) and DPPC (13)
groups. This new group will be used for center-of-mass motion removal and
temperature coupling (more on this shortly).

We will once again start with (with the script found ), calling grompp and
mdrun just as we did at the EM step:

    
    
    gmx grompp -f nvt.mdp -c em.gro -r em.gro -p topol.top -n index.ndx -o nvt.tpr
    
    gmx mdrun -deffnm nvt
    

Most of the parameters we are using are comparable to those in the , with a
few changes:

  * rcoulomb, rvdw = 1.2: We are using a 1.2-nm short-range cutoff for electrostatics, and van der Waals interactions, which differs from the original parametrization. The Berger lipids were parametrized with a 1.0-nm cutoff and GROMOS96 with 0.9 nm for electrostatics and 1.4 nm for van der Waals interactions. The value used here has been employed by the author and verified to produce reasonable physical behavior. The value of rcoulomb is somewhat flexible when using PME, but rvdw is very important for balance in force fields. In any case, it is always an exercise for the user to demonstrate validity of any setup, and it is important to consult the relevant literature regarding force field comparisons and systematic evaluations of cutoff values. 
  * ref_t, gen_temp = 323: We must use a temperature that is above the phase transition temperature of the lipid. For DPPC, 323 K is commonly used. 
  * tc-grps = Protein_DPPC Water_and_ions: The two groups are coupled separately for due to the different rates of diffusion of the two phases. With an aqueous protein, we specify "Protein Non-Protein," with Non-Protein containing solvent and ions. For a membrane protein, Non-Protein would contain the lipids as well, so we must explicitly couple the lipids and aqueous solvent separately. **Do not** couple the ions separately from the solvent; there are insufficient degrees of freedom in an ion-only group to justify a separate temperature coupling group. 
  * A new section pertaining to center-of-mass (COM) motion removal. Since interfacial systems (i.e., membrane-water systems) have a tendency to move laterally, the motion of the bilayer COM and solvent COM must be reset separately. Otherwise, the phases may drift in opposite directions, such that the overall COM for the system is unchanged, but artificial motion is still present. Note that our comm-grps include Protein_DPPC; since the protein is embedded in the membrane, it is essentially part of the membrane. Removing its COM motion separately may lead to spurious collisions. It is for this reason that we do not remove COM motion in separate groups for proteins in water; diffusion occurs in 3 dimensions in these systems. In a bilayer, motion is largely restricted to 2-dimensional motion. 

Again, use gmx energy to confirm that the temperature of the system has
stabilized at 323 K before continuing. The choice of temperature should be
based on the physical properties of the lipid, most notably the phase
transition temperature. Some useful data that has been mined from the
literature regarding area per lipid, phase transition temperatures, and/or
parameter derivation for various lipids is presented here (see below). Please
read the references and understand their implications. This list is not
comprehensive; the references point to examples of literature wherein these
particular lipids were used either for simulation or experimental work. The
user should investigate further citations within these works, or subsequent
papers that have cited these. The list should also **not** be viewed as
comprehensive, as many other lipids have been successfully simulated.
Presented here are some of the more common ones.

|  ** Lipid Name  ** |  ** Area Per Lipid (Å  2  )  ** |  ** Phase Transition
(K)  ** |  ** Reference  **  
---|---|---|---  
  
* * *  
  
DPPC  |  62.9 - 64  |  315  |  J. Nagle (1993) **64** : 1476  
  
* * *  
  
DMPC  |  60.6  |  297  |  Wohlert and Edholm (2006) **125** : 204703  
  
* * *  
  
POPG  |  53  |  269  |  Dickey and Faller (2008) **95** : 2636  
  
* * *  
  
POPA  |  51-52  |  301  |  Dickey and Faller (2008) **95** : 2636  
  
* * *  
  
POPC  |  65.8  |  271  |  Tieleman, et al. (1998) **37** : 17554  
  
* * *  
  
POPE  |  56  |  298  |  Tieleman, et al. (1998) **37** : 17554  
  
* * *  
  
DMTAP  |  71  |  310  |  Gurtovenko, et al. (2004) **86** : 3461  
  
* * *  
  
POPS  |  55  |  300  |  Mukhopadhyay, et al. (2004) **86** : 1601  
  
* * *  
  
Having trouble with your system? Is it crashing during equilibration? Please
see the page.

  

|  
  
---|---  
  

 
KALP-15 in DPPC  

##  GROMACS Tutorial

**Step Seven: Equilibration, Part 2**

![](./Images/Steps_equil_highlight.jpg)

Now that the temperature is stable, we must equilibrate with respect to
pressure. The phase for a membrane protein system is generally somewhat longer
than for a simple aqueous protein, again due to the heterogeneity of the
system; while water will diffuse rapidly, lipid diffusion is comparatively
slow. Here, we will conduct a 1-ns equilibration. The .mdp file can be found .

There are a few changes in this .mdp file worth noting:

  * tcoupl = Nose-Hoover: The Nosé-Hoover thermostat is widely used in membrane simulations because it produces a correct kinetic ensemble and allows for fluctuations that produce more natural dynamics. The Nosé-Hoover thermostat is not appropriate for equilibration, since it allows for such wide fluctuations. Begin with Berendsen or V-rescale, and switch to Nosé-Hoover at the beginning of or production MD. 
  * pcoupltype = semiisotropic: Uniform pressure scaling (isotropic) is not appropriate for membranes. A bilayer should be allowed to deform in the plane independently of the -axis. One can also use anisotropic pressure coupling for membranes, but be aware that substantial skewing of the box vectors can occur over very long simulation timeframes. 
  * There are now two values specified for both compressibility and ref_p, corresponding to values for the and dimensions, respectively. 

Now, proceed with grompp and mdrun, as usual. Since the simulation will be 1
ns in length, it is best to run it in parallel on a cluster. Note that GROMACS
4.5 introduced threading for parallelization, meaning that on a multi-core
workstation, an external MPI library is not required. For network-connected
clusters, MPI is still needed for inter-node communication.

    
    
    gmx grompp -f npt.mdp -c nvt.gro -r nvt.gro -t nvt.cpt -p topol.top -n index.ndx -o npt.tpr
    
    gmx mdrun -deffnm npt
    

Analyze the pressure progression, again using gmx energy. It is also advisable
to verify that the box vectors have stabilized, ensuring a stable lateral area
of the membrane (Box-X and Box-Y).

|

|  
  
---|---  
  
  

 
KALP-15 in DPPC  

##  GROMACS Tutorial

**Step Eight: Production MD**

![](./Images/Steps_MD_highlight.jpg)

Upon completion of the two equilibration phases, the system is now well-
equilibrated at the desired temperature and pressure. We are now ready to
release the position restraints and run production MD for data collection. The
process is much like we have seen before. We will run a 1-ns MD simulation,
the .mdp file for which can be found .

    
    
    gmx grompp -f md.mdp -c npt.gro -t npt.cpt -p topol.top -n index.ndx -o md_0_1.tpr
    

Again, execute mdrun:

    
    
    gmx mdrun -deffnm md_0_1
    

To continue your simulation beyond 1 ns, making use of the checkpointing
feature of GROMACS, refer to the .

|

|  
  
---|---  
  

 
KALP-15 in DPPC  

##  GROMACS Tutorial

**Step Nine: Analysis**

![](./Images/Steps_analysis_highlight.jpg)

There are several types of analyses that are particularly useful for membrane
protein systems. A brief synopsis will be given here. Several parameters that
may be of interest:

  1. Deuterium order parameters of the acyl chains 
  2. Density of the membrane environment 
  3. Area per lipid headgroup 
  4. Bilayer thickness (vertical dimension) 
  5. Lateral diffusion of the lipids 

Other analyses should be considered, such as secondary structure of the
peptide, RMSD, P-N vector orientation, helix tilt, Most of these analyses will
require the use of specialized index groups, generated by make_ndx.

  

**1\. Deuterium Order Parameters**

![](Images/DPPC.png)

For deuterium order parameter analysis, you will need an index group that
contains **only** the carbons along the lipid acyl chains. Each chain must be
considered separately!

    
    
    gmx make_ndx -f md_0_1.tpr -o sn1.ndx
    ...
     > a C34
     > a C36
     > a C37
     > a C38
    ...
     > a C50
     > del 0-21
     > q
    

What we have just done is create an index group for the chain of DPPC by
matching all the atoms in one chain of the lipid with specific atoms names of
carbons in the acyl chain. We then deleted all the unnecessary groups (del
0-21). This process should then be repeated for the chain (carbons C15,
C17-C31 to give "sn2.ndx").

To calculate deuterium order parameters with the normal to the bilayer along
the axis, use the GROMACS order module:

    
    
    gmx order -s md_0_1.tpr -f md_0_1.xtc -n sn1.ndx -d z -od deuter_sn1.xvg
    

Deuterium order parameters can be helpful in verifying whether or not your
membrane entered a gel phase during the simulation. The result of the
calculation will look something like this:

![](Images/plot_kalp_dppc_Scd.png)

Note that the order program, by default, numbers the carbon atoms in each
chain from 1. It is not possible to compute -S  CD  for terminal carbon atoms,
as they lack neighboring atoms from which the local molecular axis is
computed. The order program does not know which segment of the acyl chain has
been chosen, so it simply numbers the output from 1. The plot above was
rendered after re-numbering the output file from 2, reflecting the fact that
we have analyzed all applicable carbon atoms in each chain. As such, there are
no values for carbon 1 (ester carbon) or 16 (terminal methyl) in each
palmitoyl chain.

  

**2\. Density of the Membrane**

One generally sees analysis of membrane density broken down into several
different groups - lipid headgroups, acyl chains (sometimes broken down even
further to glycerol, methylene, and terminal methyl groups), protein, and
solvent. The latter two groups are standard, and do not require any special
manipulation. An index group for the lipid headgroups and acyl chains of DPPC
can be created by entering the following:

    
    
    gmx make_ndx -f md_0_1.tpr -o density_groups.ndx
    ...
     > 13 & a C1 | a C2 | a C3 | a N4 | ... | a O11
     > name 22 Headgroups
     > 13 & a C12 | a C13 | a O14 | a C15 | a O16 | a C32 | a O33 | a C34 | a O35
     > name 23 Glycerol_Ester
     > 13 & ! 22 & ! 23
     > name 24 Acyl_Chains
     > q
    

Now analyze each of these groups separately (note that Protein and SOL are
already included in the index file) using the density module:

    
    
    gmx density -s md_0_1.tpr -f md_0_1.xtc -n density_groups.ndx -o dens_headgroups.xvg -d Z
    

Repeat the process for the other groups you wish to analyze, and the result
will look similar to the following:

![](Images/plot_kalp_dppc_density.png)  

**3\. Area per Lipid Headgroup and Bilayer Thickness**

There is no GROMACS tool capable of calculating area per lipid headgroup in
the presence of a membrane protein. For a pure membrane, this quantity is
simply (Box-X * Box-Y)/(# of lipids per leaflet). The box vectors can be
easily extracted from the .edr file using gmx energy. In the case of an
embedded protein, such as KALP  15  , how much space does the protein occupy?
We have developed a program that addresses this problem, . It calculates area
per lipid headgroup, as well as bilayer thickness as a projection across the
2-D bilayer plane ( ).

Analyzing area per lipid headgroup is a valuable parameter when verifying that
your membrane did not inappropriately enter a gel phase during the simulation.

  

**4\. Lateral Diffusion of Lipids**

GROMACS provides a module called msd to calculate diffusion coefficients. One
of its derivative functions is to calculate lateral diffusion (that is,
diffusion within a plane, rather than in all three spatial dimensions). This
feature is particularly useful for systems containing lipids. To execute msd,
you will need to choose one reference atom per lipid, typically P8 of the DPPC
headgroup. Make an index group for these atoms:

    
    
    gmx make_ndx -f md_0_1.tpr -o p8.ndx
    ...
     > a P8
     > q
    

Now, execute msd:

    
    
    gmx msd -s md_0_1.tpr -f md_0_1.xtc -n p8.ndx -lateral z
    

The simulation performed here is insufficient to obtain a reasonable value for
the self-diffusion coefficient, e.g.:

    
    
    Fitting from 100 to 900 ps
    
    D[        P8] 0.0270 (+/- 0.0267) 1e-5 cm^2/s
    

This value is neither accurate nor precise, but the msd module is illustrated
here for its utility in computing important lipid properties.

|  |  
---|---  
  

 
KALP-15 in DPPC  

##  GROMACS Tutorial

**Summary**

![](./Images/Steps_analysis_highlight.jpg)

You have now hopefully been successful in building and simulating a simple
membrane protein system. Note that 1 ns of simulation is exceptionally short
for any system, especially a membrane protein. Lipid equilibration can take
upwards of 50-100 ns. The timeframe used here is for instructional purposes
only, and the data you generate likely have no physical meaning, since the
timeframe is too short. The .mdp files provided here serve as examples only,
and should not be considered broadly applicable to all systems. Review the
literature and the GROMACS manual for adjustments to these files for
efficiency and accuracy purposes.

**Please be advised** that the GROMOS96 53A6 force field as been recently
shown to understabilize α-helices. That is, if you were to simulate the system
in this tutorial for long enough, the peptide will unfold. This is spurious
behavior and has been corrected in the more recent 54A7 parameter set. I wrote
this tutorial a long time ago, before the deficiencies with 53A6 were known,
but I still believe it serves as a useful example. Combination of Berger lipid
parameters with GROMOS96 parameter sets remains a valid approach, provided
that one understands the possible problems with the protein force fields.

If you have suggestions for improving this tutorial, if you notice a mistake,
or if anything else is unclear, please feel free to . Please note: this is not
an invitation to email me for GROMACS problems. I do not advertise myself as a
private tutor or personal help service. That's what the is for. I may help you
there, but only in the context of providing service to the community as a
whole, not just the end user.

Happy simulating!

|

|  
  
---|---  
  

 
KALP-15 in DPPC  

##  GROMACS Tutorial

###  Membrane Protein: KALP  15  in DPPC

**Justin A. Lemkul, Ph.D.**  

![](./Images/KALP15_DPPC.png)  

This tutorial will guide the user through the preparation and simulation of a
simple membrane protein, in this case KALP  15  , in a model membrane, DPPC.
The tutorial assumes the user has already successfully completed the , some
other tutorial, or is otherwise well-versed in GROMACS simulation methods and
topology organization. The level of detail in this tutorial will be focused on
membrane protein-specific considerations, and will not provide an exhaustive
explanation of every step, as with the Lysozyme tutorial.

This tutorial assumes you are using GROMACS version 2018 or newer.

**Please note** that the purpose of this tutorial is instructional, to build a
membrane protein system and also to understand GROMACS force field
organization and methods for modification. This tutorial is not an endorsement
or suggestion that you use these specific parameters for your simulation. The
approach taken here works well in the case where one needs to augment a
parameter set with other parameters that have been derived in a consistent
manner. Some force fields already include everything you need, without
modification. For instance, it is unwise to try to literally follow this
approach for a force field like CHARMM36, as it needs no modification. In that
case, you are much better off building the system with .

** As of summer 2023, the required Berger lipid parameters are no longer
available online. The authors themselves have raised issues of their validity
and they are not available. This tutorial will remain online as a reference
until I rewrite it. Please DO NOT proceed and expect the tutorial to work. It
will not.  **

  
  
  
---  
  

 
KALP-15 in DPPC  

##  GROMACS Tutorial

**Step One: Prepare the Topology**

![](./Images/Steps_top_highlight.jpg)

The protein we will be working with is the KALP model peptide, denoted KALP
15  , which has a sequence of: Ac-GKK(LA)  4  LKKA-NH  2  . The protocol
described here is based on a system built by Kandasamy and Larson in a study
of hydrophobic mismatch. The original reference can be found .

The peptide was prepared in-house using the xLeap module of , using ideal
backbone geometry of an α-helix ( = -60°, = -40°). The .pdb file was oriented
along the -axis using editconf -princ, followed by a rotation about the y
axis. Note that in GROMACS-3.3.x, the -princ option oriented the long axis of
the structure (in this case, the helix axis) along the -axis by default, but
this option has changed as of GROMACS-4.0.4, which orients the long axis along
the -axis. If you want to skip the construction of this peptide, the properly
oriented structure can be found .

Execute pdb2gmx by issuing the following command:

    
    
    gmx pdb2gmx -f KALP-15_princ.pdb -o KALP-15_processed.gro -ignh -ter -water spc
    

When prompted, choose the GROMOS96 53A6 parameter set. Choose "None" for the
termini; since we have added acetyl and amide capping groups to the N- and
C-termini, respectively, we do not want pdb2gmx to build the normal amine and
carboxyl groups. Instead, we want pdb2gmx to add connectivity to our capping
groups. The -ignh flag tells pdb2gmx to ignore the H atoms in the input. By
default, xLeap gave us an all-atom structure (since the AMBER force fields use
explicit hydrogen representation). Due to AMBER naming conventions, these H
atoms may not have the same nomenclature as those of the GROMOS96 force field.
If we tell pdb2gmx to ignore all input H atoms, it will add back only those
that it needs.

Now we will need to make some alterations to the topology.

|

|  
  
---|---  
  

 
KALP-15 in DPPC  

##  GROMACS Tutorial

**Step Two: Modify the Topology**

![](./Images/Steps_top_highlight.jpg)

The lipid bilayer we will be simulating is DPPC
(dipalmitoylphosphatidylcholine), so we need parameters for it as well. But if
pdb2gmx is designed to handle only proteins, nucleic acids, and a finite
amount of cofactors, where do we get parameters for this molecule, and how do
we apply them to our system?

For this tutorial, we will use a united-atom force field to describe the
lipids derived by Berger, Edholm, and Jähnig ( ). These parameters can be
combined with a GROMOS representation of the protein.

The so-called "Berger lipids" are somewhat of a hybrid between GROMOS
atomtypes and OPLS partial charges. Since the long alkane chains are poorly
represented by GROMOS bonded parameters, a Ryckaert-Bellemans dihedral
potential is used, and a scaling factor of 0.125 is applied to Lennard-Jones
1-4 interactions. These lipid parameters are distributed by D. Peter Tieleman,
through his . While you are there, download the following files:

  * dppc128.pdb - the structure of a 128-lipid DPPC bilayer 
  * dppc.itp - the ` [moleculetype] ` definition for DPPC 
  * lipid.itp - Berger lipid parameters 

So what exactly is lipid.itp, and how do you use it? Think of this analogy:
gromos53a6.ff/forcefield.itp is to your protein what lipid.itp is to the
lipids. Essentially, lipid.itp contains all the atom types, nonbonded
parameters, and bonded parameters for a large class of lipids, much like how
forcefield.itp, ffnonbonded.itp, and ffbonded.itp function in relation to a
protein. That said, we cannot simply ` #include "lipid.itp" ` within our
topology, since it is at the same level (precedence) as forcefield.itp.

To use the parameters in lipid.itp, we will have to make some changes to our
pre-packaged GROMOS96 53A6 force field files (in $GMXLIB/gromos53a6.ff). Make
a copy of this directory in your working directory called
"gromos53a6_lipid.ff" (assuming you have GROMACS installed in
/usr/local/gromacs):

    
    
    cp -r /usr/local/gromacs/share/gromacs/top/gromos53a6.ff/ ./gromos53a6_lipid.ff
    

Inside this directory, you will find the following files:

    
    
    aminoacids.c.tdb
    aminoacids.hdb
    aminoacids.n.tdb
    aminoacids.r2b
    aminoacids.rtp
    aminoacids.vsd
    atomtypes.atp
    ff_dum.itp
    ffbonded.itp
    ffnonbonded.itp
    forcefield.doc
    forcefield.itp 
    ions.itp
    spc.itp
    spce.itp
    tip3p.itp
    tip4p.itp
    watermodels.dat
    

Next, modify ` forcefield.doc ` to update the description of the force field
parameters in it based on the modifications we will make in this tutorial.
Mine contains something like:

    
    
    GROMOS96 53A6 force field, extended to include Berger lipid parameters
    

The files contained in the gromos53a6_lipid.ff directory constitute the
complete description of the force field. The files serve the following
purposes:

  * aminoacids.c.tdb and aminoacids.n.tdb - These files are read by pdb2gmx and list the available patching actions that can be applied to protein chains 
  * aminoacids.hdb - This file is read by pdb2gmx and contains a database for constructing hydrogen atoms 
  * aminoacids.r2b - This file is read by pdb2gmx and contains translations between conventional residue names and any force field-specific building block names 
  * aminoacids.rtp - This file is read by pdb2gmx and contains all the available protein residues (and some cofactors, water, and ions - typical contents of a coordinate file passed to pdb2gmx) 
  * atomtypes.atp - This file is read by pdb2gmx and contains all the available atom types in the force field 
  * ff_dum.itp - This file contains constants that are used in constructing virtual sites (more on this in a different tutorial, and not relevant for our purposes here 
  * ffbonded.itp - All the parameters for bonded interactions in the force field 
  * ffnonbonded.itp - All the nonbonded (Lennard-Jones) parameters in the force field 
  * ions.itp - Contains ` [moleculetype] ` definitions for all monoatomic ions in the force field 
  * spc.itp, spce.itp, tip3p.itp, and tip4p.itp - Water model topologies (the standard water model for GROMOS96 simulations is SPC) 
  * watermodels.dat - A text file read by pdb2gmx for interactively selecting the water model to be used in the system topology 

Now, to add the lipid parameters into the parent force field, we will need to
copy and paste the entries in the ` [atomtypes], [nonbond_params], ` and `
[pairtypes] ` sections from lipid.itp into the corresponding headings within
ffnonbonded.itp. You will find that the lipid.itp ` [atomtypes] ` section
lacks atomic numbers (the at.num column), so add these in. The newly-modified
lines should be:

    
    
       LO    8    15.9994      0.000     A  2.36400e-03 1.59000e-06 ;carbonyl O, OPLS
      LOM    8    15.9994      0.000     A  2.36400e-03 1.59000e-06 ;carboxyl O, OPLS
      LNL    7    14.0067      0.000     A  3.35300e-03 3.95100e-06 ;Nitrogen, OPLS
       LC    6    12.0110      0.000     A  4.88800e-03 1.35900e-05 ;Carbonyl C, OPLS
      LH1    6    13.0190      0.000     A  4.03100e-03 1.21400e-05 ;CH1, OPLS
      LH2    6    14.0270      0.000     A  7.00200e-03 2.48300e-05 ;CH2, OPLS
       LP   15    30.9738      0.000     A  9.16000e-03 2.50700e-05 ;phosphor, OPLS
      LOS    8    15.9994      0.000     A  2.56300e-03 1.86800e-06 ;ester oxygen, OPLS
      LP2    6    14.0270      0.000     A  5.87400e-03 2.26500e-05 ;RB CH2, Bergers LJ
      LP3    6    15.0350      0.000     A  8.77700e-03 3.38500e-05 ;RB CH3, Bergers LJ
      LC3    6    15.0350      0.000     A  9.35700e-03 3.60900e-05 ;CH3, OPLS
      LC2    6    14.0270      0.000     A  5.94700e-03 1.79000e-05 ;CH2, OPLS
    

In the ` [nonbond_params] ` section, you will find the line ` ";; parameters
for lipid-GROMOS interactions." ` **Delete this line and all of the subsequent
lines in this section** (preserving the section that starts with ` ";; lipid-
SPC/SPCE interactions" ` ). The protein-specific nonbonded combinations are
specific to the deprecated "ffgmx" (a modified GROMOS87) force field. Removing
these lines allows the interactions between the protein and the lipids to be
generated by the standard combination rules of GROMOS96 53A6. Non-bonded
interactions involving atom type HW are also present; since these are all zero
you can delete these lines as well, or otherwise rename HW as H to be
consistent with the GROMOS96 53A6 naming convention. **If you do not rename
these lines or remove them, grompp will later fail with a fatal error.**

Append the contents of the ` [ dihedraltypes ] ` to the corresponding section
of ffbonded.itp. Do not be concerned that these lines look a bit different.
They are Ryckaert-Bellemans dihedrals, which differ in form from the standard
periodic dihedrals used in the default GROMOS96 53A6 force field.

To recap, you must make **all** of the following changes for the force field
to be functional:

  1. Copy ` [atomtypes] ` from lipid.itp to ffnonbonded.itp and add a column for atomic number 
  2. Copy ` [nonbond_params] ` from lipid.itp to ffnonbonded.itp 
  3. Remove the ` ;; parameters for lipid-GROMOS interactions ` and **all subsequent lines** in the ` [nonbond_params] ` section in ffnonbonded.itp 
  4. Remove all lines containing "HW" in ` [nonbond_params] ` or otherwise rename them to "H" 
  5. Copy ` [pairtypes] ` from lipid.itp to ffnonbonded.itp 
  6. Copy ` [dihedraltypes] from lipid.itp to ffbonded.itp `

Finally, change the ` #include ` statement in your topol.top from:

    
    
    #include "gromos53a6.ff/forcefield.itp"
    

to:

    
    
    #include "gromos53a6_lipid.ff/forcefield.itp"
    

Lastly, we need to include the specific parameters for our DPPC molecules. The
process for doing so is quite simple. Just add the line ` #include "dppc.itp"
` in your topol.top, somewhere after the position restraints section for the
protein, which defines the end of the protein ` [moleculetype] ` definition.
Doing so is analogous to adding any other small molecule or solvent into the
topology. In this section and throughout this tutorial, text in  **orange**
will denote lines that you should add, while other text (in black) are lines
that should already be present in the topology prior to the modification
indicated.

    
    
    ; Include Position restraint file
    #ifdef POSRES
    #include "posre.itp"
    #endif
    **; Include DPPC chain topology
    #include "dppc.itp"**
    ; Include water topology
    #include "gromos53a6_lipid.ff/spc.itp"
    

###  Notes on Force Fields

Since the Berger parameters were drawn from aspects of both the GROMOS and
OPLS-UA force fields, it is also possible to use the OPLS-AA force field to
represent your protein and have a compatible model. You will have to make some
modifications to lipid.itp so that it is consistent with OPLS conventions. For
information on how to do this, read the following links:

  
  

Regardless of which setup you choose, you must demonstrate that your model is
reasonable. The particular parameter combinations described here have been
shown to work in-house and according to reports by other users. It is up to
you to convince your audience (i.e., reviewers) that you know what you are
doing and that your model is valid. For instance, if you intend to do long
simulations, it is also known that GROMOS96 53A6 under-stabilizes α-helices
and you may end up with a random coil rather than a correct helix. In this
case, you may want to use the newer GROMOS96 54A7 parameter set, or another
force field entirely.

If you have correctly followed all of the steps above, you will have a fully
functional force field that can be used to process other membrane proteins
with pdb2gmx. Doing so removes the need to manually hack topol.top after the
fact. Placing the new gromos53a6_lipid.ff directory in $GMXLIB will allow you
to use this force field system-wide.

|

|  
  
---|---  
  

 
KALP-15 in DPPC  

##  GROMACS Tutorial

**Step Three: Defining the Unit Cell & Adding Solvent **

![](./Images/Steps_box_highlight.jpg)

Defining a unit cell for a membrane protein is considerably more complicated
than for a protein in water. There are several key steps in building the unit
cell:

  1. Orient the protein and membrane in the same coordinate frame 
  2. Pack the lipids around the protein 
  3. Solvate with water 

  

**1\. Orient the protein and membrane**

We have already aligned the KALP peptide using editconf. The bilayer lies in
the plane, with the normal along the -axis. To remove the effects of
periodicity, use trjconv:

(1) Generate a .tpr file for a DPPC-only system using grompp. You can use any
valid .mdp file and a topology corresponding to pure DPPC. An example .mdp
file can be found and such a topology can be found . Note how simple the
topology is. It includes dppc.itp and spc.itp to read parameters for DPPC and
water; it's that simple! Run grompp:

    
    
    gmx grompp -f minim.mdp -c dppc128.pdb -p topol_dppc.top -o dppc.tpr
    

You may receive a fatal error like , but in this case it is safe to use `
-maxwarn 1 ` with the above command. The reason that doing so is acceptable is
explained . **Please note** that this step is the only one in which `
topol_dppc.top ` will be used. It serves no other purpose and you should not
use it in **any** remaining step in this tutorial.

It is not necessary to run a complete energy minimization procedure on the
bilayer, although you can if you want. The .tpr file contains information
about bonding and periodicity, so it can, in a sense, be used to reconstruct
"broken" molecules.

(2) Use trjconv to remove periodicity (select group 0, "System" for output):

    
    
    gmx trjconv -s dppc.tpr -f dppc128.pdb -o dppc128_whole.gro -pbc mol -ur compact
    

Now, take a look at the last line of this .gro file; it corresponds to the
x/y/z box vectors of the DPPC unit cell. We need to orient the KALP peptide
within this same coordinate frame, and place the center of mass of the peptide
at the center of this box:

    
    
    gmx editconf -f KALP-15_processed.gro -o KALP_newbox.gro -c -box 6.41840 6.44350 6.59650
    

The center of our system now lies at (3.20920, 3.22175, 3.29825), half of each
box vector. This is a GROMACS convention. Note that other systems you wish to
simulate may not be symmetrical with respect to the membrane, and thus the
above command must be modified to something like the following:

    
    
    gmx editconf -f protein.gro -o protein_newbox.gro -box (membrane box vectors) -center 
    

In the above command, represents the center of mass such that the protein is
properly placed. Placement should be based on experimental knowledge of
membrane positioning, or intuition based on the chemical composition of your
particular protein.

  

**2\. Pack the lipids around the protein**

The easiest method I have found so far for packing lipids around an embedded
protein is the InflateGRO methodology ( ), available . **Please note** that I
am distributing my own copy of the original version of InflateGRO, **not**
InflateGRO2 available elsewhere from the authors. Download the linked file and
rename it "inflategro.pl" to continue. First, concatenate the protein and
bilayer structure files:

    
    
    cat KALP_newbox.gro dppc128_whole.gro > system.gro
    

Remove unnecessary lines (the box vectors from the KALP structure, the header
information from the DPPC structure) and update the second line of the
coordinate file (total number of atoms) accordingly.

The authors of the InflateGRO script recommend using a very strong position-
restraining force on protein heavy atoms to ensure that the position of the
protein does not change during EM. Add a new #ifdef statement to your
topology, one that will call a special set of position restraints, such that
your topology now contains a section like:

    
    
    ; Include Position restraint file
    #ifdef POSRES
    #include "posre.itp"
    #endif
    **; Strong position restraints for InflateGRO
    #ifdef STRONG_POSRES
    #include "strong_posre.itp"
    #endif**
    ; Include DPPC chain topology
    #include "dppc.itp"
    
    ; Include water topology
    #include "gromos53a6_lipid.ff/spc.itp"
    

Now, generate this new position restraint file using genrestr:

    
    
    gmx genrestr -f KALP_newbox.gro -o strong_posre.itp -fc 100000 100000 100000
    

In the .mdp file used for the minimizations, add a line "define =
-DSTRONG_POSRES" to make use of these new position restraints. Then, simply
follow the InflateGRO instructions (contained in the script itself), a
procedure that is easily scripted. Scale the lipid positions by a factor of 4:

    
    
    perl inflategro.pl system.gro 4 DPPC 14 system_inflated.gro 5 area.dat
    

Since the InflateGRO script requires a very specific order to its command-line
arguments, a brief explanation is warranted here. They are:

  1. ` system.gro ` \- the input coordinate file name to which scaling will be applied 
  2. ` 4 ` \- the scaling factor to apply. A value > 1 indicates inflation, a value < 1 indicates shrinking/compression 
  3. ` DPPC ` \- the residue name of the lipid to which scaling is applied 
  4. ` 14 ` \- the cutoff radius (in Å) for searching for lipids to delete 
  5. ` system_inflated.gro ` \- the output file name 
  6. ` 5 ` \- grid spacing (also in Å) for area per lipid calculation 
  7. ` area.dat ` \- output file with area per lipid information, useful in assessing the suitability of the structure 

Note how many lipids were deleted and update the ` [molecules] ` directive of
your topology accordingly. Run energy minimization using .mdp file:

    
    
    gmx grompp -f minim_inflategro.mdp -c system_inflated.gro -p topol.top -r system_inflated.gro -o system_inflated_em.tpr
    
    gmx mdrun -deffnm system_inflated_em
    

The output of mdrun will be "broken" molecules that have all atoms in the
central image. As before, reconstruct with trjconv before attempting to use
such coordinates with InflateGRO:

    
    
    gmx trjconv -s system_inflated_em.tpr -f system_inflated_em.gro -o tmp.gro -pbc mol
    mv tmp.gro system_inflated_em.gro
    

At this point, we need to begin packing the lipids around the protein by
applying a scaling factor that is < 1\. A robust approach is to scale down the
lipids by a factor of 0.95, which will require many iterations. The first will
be:

    
    
    perl inflategro.pl system_inflated_em.gro 0.95 DPPC 0 system_shrink1.gro 5 area_shrink1.dat
    

Follow this up by another round of EM. During the "shrinking" steps, be sure
to keep the InflateGRO cutoff value to 0, or else you will continue to delete
lipids! After 26 iterations of scaling down by 0.95, I reached an area per
lipid of ~71 Å  2  , above the experimental value of ~62 Å  2  . Since the
script tends to overestimate the area per lipid, this value is good enough to
continue to equilibration.

If you wish to automate this process, a Bash script for performing the energy
minimization of the inflated system and all subsequent shrinking steps can be
found .

Visually, the entire process looks something like this:

![](Images/inflategro_pack_loop.gif)  

**3\. Solvate with water**

Solvating a protein is a trivial task with gmx solvate. Solvating a membrane
protein system is not so simple, since the solvate program has a tendency to
fill gaps in the lipid acyl chains with water molecules. These water molecules
will be deleted later using a custom Perl script. Proceed with solvation as
normal:

    
    
    gmx solvate -cp system_shrink26_em.gro -cs spc216.gro -o system_solv.gro -p topol.top
    

After solvating, visualize the structure and you will see many water molecules
within the hydrophobic core of the bilayer. Use to delete these water
molecules:

    
    
    perl water_deletor.pl -in system_solv.gro -out system_solv_fix.gro -ref O33 -middle C50 -nwater 3
    

The file names passed to -in and -out are the input and output file names,
respectively. The -ref flag allows the user to set which atom is set as a
"reference" to define the upper and lower boundaries of the membrane. It is
wise to set this atom name to one of the atoms in the ester region of the
phospholipid rather than a headgroup atom, to prevent excessive dehydration.
The -middle flag specifies an atom that is representative of the middle of the
bilayer (along the membrane normal, typically the z-axis) so the reference
atoms can be divided into upper and lower leaflets, thus establishing the
range of z-coordinate values within which water molecules will be deleted. The
value passed to -nwater defines how many atoms constitute a water molecule.
For SPC, there are only three atoms (OW, HW1, and HW2).

The script tells you how many water molecules it deleted and how many water
molecules remain in the system. Update the SOL line in topol.top with this
updated number of water molecules. You may wish to renumber the coordinate
file with gmx genconf, but doing so is not required.

|

|  
  
---|---  
  
  

 
KALP-15 in DPPC  

##  GROMACS Tutorial

**Step Four: Adding Ions**

![](./Images/Steps_ions_highlight.jpg)

Now that we have solvated our system and removed water molecules from the
hydrophobic core of the membrane, it is time to add neutralizing counterions.
At this point, the process for continuing with building our system is nearly
identical to that of the . The .mdp file used can be found .

    
    
    gmx grompp -f ions.mdp -c system_solv_fix.gro -p topol.top -o ions.tpr
    

Since the KALP  15  peptide contains 4 lysine residues, the peptide bears a
net charge of +4 at neutral pH. Use genion to add 4 Cl  \-  ions to neutralize
this charge:

    
    
    gmx genion -s ions.tpr -o system_solv_ions.gro -p topol.top -pname NA -nname CL -neutral
    

![](./Images/KALP15_DPPC.jpg)  
  
|

|  
  
---|---  
  

 
KALP-15 in DPPC  

##  GROMACS Tutorial

**Step Five: Energy Minimization**

![](./Images/Steps_EM_highlight.jpg)

This step is just like in any other simulation. Assemble the binary input
using grompp using input parameter file:

    
    
    gmx grompp -f minim.mdp -c system_solv_ions.gro -p topol.top -o em.tpr
    

Invoke mdrun:

    
    
    gmx mdrun -v -deffnm em
    

As with any other simulation, verify that the values of E  pot  and F  max
are reasonable before continuing. Membrane protein systems can be tricky,
because there are a number of potential problems. If your system is not
converging, consider the following factors:

  1. Intra-headgroup hydrogen bonding, like in PE or PG headgroups. Sometimes simulations collapse because the headgroups fold in on themselves within voids in the solvent. There are several potential solutions to this problem (and others you may encounter):   

    * Use position restraints or freeze groups during equilibration until the solvent is optimized around the lipid headgroups. 
    * Reduce the charges on the H atoms (all the way to zero, if necessary)  Restore the charges before continuing! 
    * Add  [ exclusions ]  within the topology between H and phosphate O atoms  Remove the exclusions before continuing! 
  2. Acyl chain overlap can occur during packing. Run InflateGRO carefully, and do not attempt to over-pack your lipids. 
  3. Protein-lipid overlap. Did you choose an appropriate cut-off value in the initial InflateGRO step? 
  4. Water-headgroup and ion-headgroup overlap. Sometimes genbox and genion are not smart, especially regarding random placement of ions. A CL- next to a phosphate can send the ion (or lipid) careening across the simulation box! 

Now that our system is at an energy minimum, we can begin real dynamics.

|

|  
  
---|---  
  

 
KALP-15 in DPPC  

##  GROMACS Tutorial

**Step Six: Equilibration**

![](./Images/Steps_equil_highlight.jpg)

Equilibration will be conducted much like in the case of a solvated protein.
Generally a short equilibration phase is followed by a longer phase. The
reason for this procedure is that we are now dealing with a heterogenous
system, with both water and DPPC acting as solvent. Such heterogeneity
requires a longer equilibration process. Water has to re-orient around the
lipid headgroups and any exposed parts of the protein, and the lipids have to
orient themselves around the protein as well. Such processes take some time,
and lipid equilibration may take several ns of simulation time.

For membrane protein simulations, we will need to create a special index group
consisting of protein and lipids (explained below). To do this, use make_ndx:

    
    
    gmx make_ndx -f em.gro -o index.ndx
    ...
     > 1 | 13
     > q
    

Entering "1 | 13" at the make_ndx prompt merges the Protein (1) and DPPC (13)
groups. This new group will be used for center-of-mass motion removal and
temperature coupling (more on this shortly).

We will once again start with (with the script found ), calling grompp and
mdrun just as we did at the EM step:

    
    
    gmx grompp -f nvt.mdp -c em.gro -r em.gro -p topol.top -n index.ndx -o nvt.tpr
    
    gmx mdrun -deffnm nvt
    

Most of the parameters we are using are comparable to those in the , with a
few changes:

  * rcoulomb, rvdw = 1.2: We are using a 1.2-nm short-range cutoff for electrostatics, and van der Waals interactions, which differs from the original parametrization. The Berger lipids were parametrized with a 1.0-nm cutoff and GROMOS96 with 0.9 nm for electrostatics and 1.4 nm for van der Waals interactions. The value used here has been employed by the author and verified to produce reasonable physical behavior. The value of rcoulomb is somewhat flexible when using PME, but rvdw is very important for balance in force fields. In any case, it is always an exercise for the user to demonstrate validity of any setup, and it is important to consult the relevant literature regarding force field comparisons and systematic evaluations of cutoff values. 
  * ref_t, gen_temp = 323: We must use a temperature that is above the phase transition temperature of the lipid. For DPPC, 323 K is commonly used. 
  * tc-grps = Protein_DPPC Water_and_ions: The two groups are coupled separately for due to the different rates of diffusion of the two phases. With an aqueous protein, we specify "Protein Non-Protein," with Non-Protein containing solvent and ions. For a membrane protein, Non-Protein would contain the lipids as well, so we must explicitly couple the lipids and aqueous solvent separately. **Do not** couple the ions separately from the solvent; there are insufficient degrees of freedom in an ion-only group to justify a separate temperature coupling group. 
  * A new section pertaining to center-of-mass (COM) motion removal. Since interfacial systems (i.e., membrane-water systems) have a tendency to move laterally, the motion of the bilayer COM and solvent COM must be reset separately. Otherwise, the phases may drift in opposite directions, such that the overall COM for the system is unchanged, but artificial motion is still present. Note that our comm-grps include Protein_DPPC; since the protein is embedded in the membrane, it is essentially part of the membrane. Removing its COM motion separately may lead to spurious collisions. It is for this reason that we do not remove COM motion in separate groups for proteins in water; diffusion occurs in 3 dimensions in these systems. In a bilayer, motion is largely restricted to 2-dimensional motion. 

Again, use gmx energy to confirm that the temperature of the system has
stabilized at 323 K before continuing. The choice of temperature should be
based on the physical properties of the lipid, most notably the phase
transition temperature. Some useful data that has been mined from the
literature regarding area per lipid, phase transition temperatures, and/or
parameter derivation for various lipids is presented here (see below). Please
read the references and understand their implications. This list is not
comprehensive; the references point to examples of literature wherein these
particular lipids were used either for simulation or experimental work. The
user should investigate further citations within these works, or subsequent
papers that have cited these. The list should also **not** be viewed as
comprehensive, as many other lipids have been successfully simulated.
Presented here are some of the more common ones.

|  ** Lipid Name  ** |  ** Area Per Lipid (Å  2  )  ** |  ** Phase Transition
(K)  ** |  ** Reference  **  
---|---|---|---  
  
* * *  
  
DPPC  |  62.9 - 64  |  315  |  J. Nagle (1993) **64** : 1476  
  
* * *  
  
DMPC  |  60.6  |  297  |  Wohlert and Edholm (2006) **125** : 204703  
  
* * *  
  
POPG  |  53  |  269  |  Dickey and Faller (2008) **95** : 2636  
  
* * *  
  
POPA  |  51-52  |  301  |  Dickey and Faller (2008) **95** : 2636  
  
* * *  
  
POPC  |  65.8  |  271  |  Tieleman, et al. (1998) **37** : 17554  
  
* * *  
  
POPE  |  56  |  298  |  Tieleman, et al. (1998) **37** : 17554  
  
* * *  
  
DMTAP  |  71  |  310  |  Gurtovenko, et al. (2004) **86** : 3461  
  
* * *  
  
POPS  |  55  |  300  |  Mukhopadhyay, et al. (2004) **86** : 1601  
  
* * *  
  
Having trouble with your system? Is it crashing during equilibration? Please
see the page.

  

|  
  
---|---  
  

 
KALP-15 in DPPC  

##  GROMACS Tutorial

**Step Seven: Equilibration, Part 2**

![](./Images/Steps_equil_highlight.jpg)

Now that the temperature is stable, we must equilibrate with respect to
pressure. The phase for a membrane protein system is generally somewhat longer
than for a simple aqueous protein, again due to the heterogeneity of the
system; while water will diffuse rapidly, lipid diffusion is comparatively
slow. Here, we will conduct a 1-ns equilibration. The .mdp file can be found .

There are a few changes in this .mdp file worth noting:

  * tcoupl = Nose-Hoover: The Nosé-Hoover thermostat is widely used in membrane simulations because it produces a correct kinetic ensemble and allows for fluctuations that produce more natural dynamics. The Nosé-Hoover thermostat is not appropriate for equilibration, since it allows for such wide fluctuations. Begin with Berendsen or V-rescale, and switch to Nosé-Hoover at the beginning of or production MD. 
  * pcoupltype = semiisotropic: Uniform pressure scaling (isotropic) is not appropriate for membranes. A bilayer should be allowed to deform in the plane independently of the -axis. One can also use anisotropic pressure coupling for membranes, but be aware that substantial skewing of the box vectors can occur over very long simulation timeframes. 
  * There are now two values specified for both compressibility and ref_p, corresponding to values for the and dimensions, respectively. 

Now, proceed with grompp and mdrun, as usual. Since the simulation will be 1
ns in length, it is best to run it in parallel on a cluster. Note that GROMACS
4.5 introduced threading for parallelization, meaning that on a multi-core
workstation, an external MPI library is not required. For network-connected
clusters, MPI is still needed for inter-node communication.

    
    
    gmx grompp -f npt.mdp -c nvt.gro -r nvt.gro -t nvt.cpt -p topol.top -n index.ndx -o npt.tpr
    
    gmx mdrun -deffnm npt
    

Analyze the pressure progression, again using gmx energy. It is also advisable
to verify that the box vectors have stabilized, ensuring a stable lateral area
of the membrane (Box-X and Box-Y).

|

|  
  
---|---  
  
  

 
KALP-15 in DPPC  

##  GROMACS Tutorial

**Step Eight: Production MD**

![](./Images/Steps_MD_highlight.jpg)

Upon completion of the two equilibration phases, the system is now well-
equilibrated at the desired temperature and pressure. We are now ready to
release the position restraints and run production MD for data collection. The
process is much like we have seen before. We will run a 1-ns MD simulation,
the .mdp file for which can be found .

    
    
    gmx grompp -f md.mdp -c npt.gro -t npt.cpt -p topol.top -n index.ndx -o md_0_1.tpr
    

Again, execute mdrun:

    
    
    gmx mdrun -deffnm md_0_1
    

To continue your simulation beyond 1 ns, making use of the checkpointing
feature of GROMACS, refer to the .

|

|  
  
---|---  
  

 
KALP-15 in DPPC  

##  GROMACS Tutorial

**Step Nine: Analysis**

![](./Images/Steps_analysis_highlight.jpg)

There are several types of analyses that are particularly useful for membrane
protein systems. A brief synopsis will be given here. Several parameters that
may be of interest:

  1. Deuterium order parameters of the acyl chains 
  2. Density of the membrane environment 
  3. Area per lipid headgroup 
  4. Bilayer thickness (vertical dimension) 
  5. Lateral diffusion of the lipids 

Other analyses should be considered, such as secondary structure of the
peptide, RMSD, P-N vector orientation, helix tilt, Most of these analyses will
require the use of specialized index groups, generated by make_ndx.

  

**1\. Deuterium Order Parameters**

![](Images/DPPC.png)

For deuterium order parameter analysis, you will need an index group that
contains **only** the carbons along the lipid acyl chains. Each chain must be
considered separately!

    
    
    gmx make_ndx -f md_0_1.tpr -o sn1.ndx
    ...
     > a C34
     > a C36
     > a C37
     > a C38
    ...
     > a C50
     > del 0-21
     > q
    

What we have just done is create an index group for the chain of DPPC by
matching all the atoms in one chain of the lipid with specific atoms names of
carbons in the acyl chain. We then deleted all the unnecessary groups (del
0-21). This process should then be repeated for the chain (carbons C15,
C17-C31 to give "sn2.ndx").

To calculate deuterium order parameters with the normal to the bilayer along
the axis, use the GROMACS order module:

    
    
    gmx order -s md_0_1.tpr -f md_0_1.xtc -n sn1.ndx -d z -od deuter_sn1.xvg
    

Deuterium order parameters can be helpful in verifying whether or not your
membrane entered a gel phase during the simulation. The result of the
calculation will look something like this:

![](Images/plot_kalp_dppc_Scd.png)

Note that the order program, by default, numbers the carbon atoms in each
chain from 1. It is not possible to compute -S  CD  for terminal carbon atoms,
as they lack neighboring atoms from which the local molecular axis is
computed. The order program does not know which segment of the acyl chain has
been chosen, so it simply numbers the output from 1. The plot above was
rendered after re-numbering the output file from 2, reflecting the fact that
we have analyzed all applicable carbon atoms in each chain. As such, there are
no values for carbon 1 (ester carbon) or 16 (terminal methyl) in each
palmitoyl chain.

  

**2\. Density of the Membrane**

One generally sees analysis of membrane density broken down into several
different groups - lipid headgroups, acyl chains (sometimes broken down even
further to glycerol, methylene, and terminal methyl groups), protein, and
solvent. The latter two groups are standard, and do not require any special
manipulation. An index group for the lipid headgroups and acyl chains of DPPC
can be created by entering the following:

    
    
    gmx make_ndx -f md_0_1.tpr -o density_groups.ndx
    ...
     > 13 & a C1 | a C2 | a C3 | a N4 | ... | a O11
     > name 22 Headgroups
     > 13 & a C12 | a C13 | a O14 | a C15 | a O16 | a C32 | a O33 | a C34 | a O35
     > name 23 Glycerol_Ester
     > 13 & ! 22 & ! 23
     > name 24 Acyl_Chains
     > q
    

Now analyze each of these groups separately (note that Protein and SOL are
already included in the index file) using the density module:

    
    
    gmx density -s md_0_1.tpr -f md_0_1.xtc -n density_groups.ndx -o dens_headgroups.xvg -d Z
    

Repeat the process for the other groups you wish to analyze, and the result
will look similar to the following:

![](Images/plot_kalp_dppc_density.png)  

**3\. Area per Lipid Headgroup and Bilayer Thickness**

There is no GROMACS tool capable of calculating area per lipid headgroup in
the presence of a membrane protein. For a pure membrane, this quantity is
simply (Box-X * Box-Y)/(# of lipids per leaflet). The box vectors can be
easily extracted from the .edr file using gmx energy. In the case of an
embedded protein, such as KALP  15  , how much space does the protein occupy?
We have developed a program that addresses this problem, . It calculates area
per lipid headgroup, as well as bilayer thickness as a projection across the
2-D bilayer plane ( ).

Analyzing area per lipid headgroup is a valuable parameter when verifying that
your membrane did not inappropriately enter a gel phase during the simulation.

  

**4\. Lateral Diffusion of Lipids**

GROMACS provides a module called msd to calculate diffusion coefficients. One
of its derivative functions is to calculate lateral diffusion (that is,
diffusion within a plane, rather than in all three spatial dimensions). This
feature is particularly useful for systems containing lipids. To execute msd,
you will need to choose one reference atom per lipid, typically P8 of the DPPC
headgroup. Make an index group for these atoms:

    
    
    gmx make_ndx -f md_0_1.tpr -o p8.ndx
    ...
     > a P8
     > q
    

Now, execute msd:

    
    
    gmx msd -s md_0_1.tpr -f md_0_1.xtc -n p8.ndx -lateral z
    

The simulation performed here is insufficient to obtain a reasonable value for
the self-diffusion coefficient, e.g.:

    
    
    Fitting from 100 to 900 ps
    
    D[        P8] 0.0270 (+/- 0.0267) 1e-5 cm^2/s
    

This value is neither accurate nor precise, but the msd module is illustrated
here for its utility in computing important lipid properties.

|  |  
---|---  
  

 
KALP-15 in DPPC  

##  GROMACS Tutorial

**Summary**

![](./Images/Steps_analysis_highlight.jpg)

You have now hopefully been successful in building and simulating a simple
membrane protein system. Note that 1 ns of simulation is exceptionally short
for any system, especially a membrane protein. Lipid equilibration can take
upwards of 50-100 ns. The timeframe used here is for instructional purposes
only, and the data you generate likely have no physical meaning, since the
timeframe is too short. The .mdp files provided here serve as examples only,
and should not be considered broadly applicable to all systems. Review the
literature and the GROMACS manual for adjustments to these files for
efficiency and accuracy purposes.

**Please be advised** that the GROMOS96 53A6 force field as been recently
shown to understabilize α-helices. That is, if you were to simulate the system
in this tutorial for long enough, the peptide will unfold. This is spurious
behavior and has been corrected in the more recent 54A7 parameter set. I wrote
this tutorial a long time ago, before the deficiencies with 53A6 were known,
but I still believe it serves as a useful example. Combination of Berger lipid
parameters with GROMOS96 parameter sets remains a valid approach, provided
that one understands the possible problems with the protein force fields.

If you have suggestions for improving this tutorial, if you notice a mistake,
or if anything else is unclear, please feel free to . Please note: this is not
an invitation to email me for GROMACS problems. I do not advertise myself as a
private tutor or personal help service. That's what the is for. I may help you
there, but only in the context of providing service to the community as a
whole, not just the end user.

Happy simulating!

|

|  
  
---|---  
  

 
KALP-15 




Protein-Ligand Complex  

##  GROMACS Tutorial

###  Protein-Ligand Complex

**Justin A. Lemkul, Ph.D.**  

![](./Images/lysozyme_complex_3htb.png)  

This example will guide a new user through the process of setting up a
simulation system containing a protein (T4 lysozyme L99A/M102Q) in complex
with a ligand. This tutorial focuses specifically on issues related to dealing
with the ligand, assuming that the user is familiar with basic GROMACS
operations and the contents of a topology. If this is not the case, please
refer to before attempting this one.

This tutorial requires a GROMACS version in the 2018.x series.

  
  
  
  
  
---  
  

 
Protein-Ligand Complex  

##  GROMACS Tutorial

**Step One: Prepare the Protein Topology**

![](./Images/Steps_top_highlight.jpg)

We must download the protein structure file we will be working with. For this
tutorial, we will utilize T4 lysozyme L99A/M102Q (PDB code 3HTB). Go to the
website and download the PDB text for the crystal structure.

Once you have downloaded the structure, you can visualize it using a viewing
program such as VMD, Chimera, PyMOL, etc. Once you've had a look at the
molecule, you are going to want to strip out the crystal waters, PO4, and BME.
Note that such a procedure is not universally appropriate (i.e., the case of a
bound active site water molecule). For our intentions here, we do not need
crystal water or other species, which are just crystallization co-solvents. We
will instead focus on the ligand called "JZ4," which is 2-propylphenol.

If you want a clean version of the .pdb file to check your work, you can
download it . The problem we now face is that the JZ4 ligand is not a
recognized entity in any of the force fields provided with GROMACS, so pdb2gmx
will give a fatal error if you were try to pass this file through it.
Topologies can only be assembled automatically if an entry for a building
block is present in the .rtp (residue topology) file for the force field.
Since this is not the case, we will prepare our system topology in two steps:

  1. Prepare the protein topology with pdb2gmx 
  2. Prepare the ligand topology using external tools 

Since we will be preparing these two topologies separately, we must save the
protein and JZ4 ligand into separate coordinate files. Save the JZ4
coordinates like so:

    
    
    grep JZ4 3HTB_clean.pdb > jz4.pdb
    

Then simply delete the JZ4 lines from 3HTB_clean.pdb. At this point, preparing
the protein topology is trivial. The force field we will be using in this
tutorial is CHARMM36, obtained from the . While there, download the latest
CHARMM36 force field tarball and the "cgenff_charmm2gmx.py" conversion script,
which we will use later. Download the version of the conversion script that
corresponds to your installed Python version (Python 2.x or 3.x).

Unarchive the force field tarball in your working directory:

    
    
    tar -zxvf charmm36-jul2022.ff.tgz
    

There should now be a "charmm36-jul2022.ff" subdirectory in your working
directory. Write the topology for the T4 lysozyme with pdb2gmx:

    
    
    gmx pdb2gmx -f 3HTB_clean.pdb -o 3HTB_processed.gro -ter
    

You will be prompted to make 3 selections.

  1. Force field 
  2. Water model 
  3. Terminus type 

    
    
    Select the Force Field:
    From current directory:
     1: CHARMM36 all-atom force field (July 2022)
    From '/usr/local/gromacs/share/gromacs/top':
     2: AMBER03 protein, nucleic AMBER94 (Duan et al., J. Comp. Chem. 24, 1999-2012, 2003)
     3: AMBER94 force field (Cornell et al., JACS 117, 5179-5197, 1995)
     4: AMBER96 protein, nucleic AMBER94 (Kollman et al., Acc. Chem. Res. 29, 461-469, 1996)
     5: AMBER99 protein, nucleic AMBER94 (Wang et al., J. Comp. Chem. 21, 1049-1074, 2000)
     6: AMBER99SB protein, nucleic AMBER94 (Hornak et al., Proteins 65, 712-725, 2006)
     7: AMBER99SB-ILDN protein, nucleic AMBER94 (Lindorff-Larsen et al., Proteins 78, 1950-58, 2010)
     8: AMBERGS force field (Garcia & Sanbonmatsu, PNAS 99, 2782-2787, 2002)
     9: CHARMM27 all-atom force field (CHARM22 plus CMAP for proteins)
    10: GROMOS96 43a1 force field
    11: GROMOS96 43a2 force field (improved alkane dihedrals)
    12: GROMOS96 45a3 force field (Schuler JCC 2001 22 1205)
    13: GROMOS96 53a5 force field (JCC 2004 vol 25 pag 1656)
    14: GROMOS96 53a6 force field (JCC 2004 vol 25 pag 1656)
    15: GROMOS96 54a7 force field (Eur. Biophys. J. (2011), 40,, 843-856, DOI: 10.1007/s00249-011-0700-9)
    16: OPLS-AA/L all-atom force field (2001 aminoacid dihedrals)
    

For this tutorial, choose the CHARMM36 force field (option 1), listed first
under "From current directory" in the list.

Choose the default water model (CHARMM-modified TIP3P) and then choose "NH3+"
and "COO-" for the termini. This interactive selection is necessary due to the
N-terminal residue being methionine (MET), which causes pdb2gmx to choose an
incompatible terminus type that is intended for carbohydrates. You must select
the protein-specific termini, otherwise you will get a fatal error about non-
matching atom names.

|  |  
---|---  
  

 
Protein-Ligand Complex  

##  GROMACS Tutorial

**Step Two: Prepare the Ligand Topology**

![](./Images/Steps_top_highlight.jpg)

We must now deal with the ligand. But how does one come up with parameters for
some species that the force field does not automatically recognize? Proper
treatment of ligands is one of the most challenging tasks in molecular
simulation. Force field authors spend years of their lives deriving self-
consistent force fields, and it is no small task to introduce a new species
into this framework. Force field parameters for any new species must be
derived and validated in a manner that is consistent with the original force
field.

For the OPLS, AMBER, and CHARMM force fields, this derivation often takes the
form of various quantum mechanical calculations. The primary literature for
these force fields describes the required procedure. For GROMOS force fields,
parameterization methodology is less clear, relying on empirical fitting of
condensed-phase behavior. That is, some initial charges and Lennard-Jones
parameters are calculated for each atom type, evaluated for their accuracy,
and refined. While the end result is very satisfactory, i.e. fluids resemble
their real-world counterparts, the derivation process can be laborious and
frustrating.

For this reason, automated tools are greatly preferred. For each force field,
there are methodologies or software programs that purport to give parameters
compatible with various force fields. Not all of them are equally accurate.
For a few examples, refer to the following table:

|

* * *  
  
---  
AMBER  |  |  Parametrizes molecules using GAFF  
|  |  A Python interface to Antechamber, writes GROMACS topologies  
  
* * *  
  
CHARMM  |  |  The official CHARMM General Force Field server  
  
* * *  
  
GROMOS87/GROMOS96  |  |  An automated server for topology generation  
|  |  A newer server for topology generation, uses GROMOS96 54A7  
  
* * *  
  
OPLS-AA  |  |  A server from the Jorgensen group to produce OPLS topologies  
  
* * *  
  
###  Add Hydrogen Atoms to JZ4

In this tutorial, we will be generating the JZ4 topology with the CGenFF
server. Click the link in the table above to visit the site. Register for a
(free) account and activate it. CGenFF requires a Sybyl .mol2 file as its
input, to collect rudimentary atom type information and bonded connectivity.
CHARMM is also an all-atom force field, meaning all H atoms are explicitly
represented. Crystal structures do not typically assign H coordinates, so they
have to be built in. To produce a .mol2 file and add H atoms, use the . Open
jz4.pdb in Avogadro, and from the "Build" menu, choose "Add Hydrogens."
Avogadro will build all of the H atoms onto the JZ4 ligand. Save a .mol2 file
(File -> Save As... and choose Sybyl Mol2 from the drop-down menu) named
"jz4.mol2."

Several corrections must be made to jz4.mol2 before it can be used. Open
jz4.mol2 in your favorite plain-text editor and you will find:

    
    
    @<TRIPOS>MOLECULE
    *****
     22 22 0 0 0
    SMALL
    GASTEIGER
    
    @<TRIPOS>ATOM
          1 C4         24.2940  -24.1240   -0.0710 C.3   167  JZ4167     -0.0650
          2 C7         21.5530  -27.2140   -4.1120 C.ar  167  JZ4167     -0.0613
          3 C8         22.0680  -26.7470   -5.3310 C.ar  167  JZ4167     -0.0583
          4 C9         22.6710  -25.5120   -5.4480 C.ar  167  JZ4167     -0.0199
          5 C10        22.7690  -24.7300   -4.2950 C.ar  167  JZ4167      0.1200
          6 C11        21.6930  -26.4590   -2.9540 C.ar  167  JZ4167     -0.0551
          7 C12        22.2940  -25.1870   -3.0750 C.ar  167  JZ4167     -0.0060
          8 C13        22.4630  -24.4140   -1.8080 C.3   167  JZ4167     -0.0245
          9 C14        23.9250  -24.7040   -1.3940 C.3   167  JZ4167     -0.0518
         10 OAB        23.4120  -23.5360   -4.3420 O.3   167  JZ4167     -0.5065
         11 H          25.3133  -24.3619    0.1509 H       1  UNL1        0.0230
         12 H          23.6591  -24.5327    0.6872 H       1  UNL1        0.0230
         13 H          24.1744  -23.0611   -0.1016 H       1  UNL1        0.0230
         14 H          21.0673  -28.1238   -4.0754 H       1  UNL1        0.0618
         15 H          21.9931  -27.3472   -6.1672 H       1  UNL1        0.0619
         16 H          23.0361  -25.1783   -6.3537 H       1  UNL1        0.0654
         17 H          21.3701  -26.8143   -2.0405 H       1  UNL1        0.0621
         18 H          21.7794  -24.7551   -1.0588 H       1  UNL1        0.0314
         19 H          22.2659  -23.3694   -1.9301 H       1  UNL1        0.0314
         20 H          24.5755  -24.2929   -2.1375 H       1  UNL1        0.0266
         21 H          24.0241  -25.7662   -1.3110 H       1  UNL1        0.0266
         22 H          23.7394  -23.2120   -5.1580 H       1  UNL1        0.2921
    @<TRIPOS>BOND
         1     4     3   ar
         2     4     5   ar
         3     3     2   ar
         4    10     5    1
         5     5     7   ar
         6     2     6   ar
         7     7     6   ar
         8     7     8    1
         9     8     9    1
        10     9     1    1
        11     1    11    1
        12     1    12    1
        13     1    13    1
        14     2    14    1
        15     3    15    1
        16     4    16    1
        17     6    17    1
        18     8    18    1
        19     8    19    1
        20     9    20    1
        21     9    21    1
        22    10    22    1
    

The first change that needs to be made is in the ` MOLECULE ` heading. Replace
"*****" with "JZ4," e.g.:

    
    
    @<TRIPOS>MOLECULE
    **JZ4**
    

Next, fix the residue names and numbers such that they are all the same. This
.mol2 file only contains one molecule, therefore there should only be one
residue name and number specified. After editing, the corrected ATOM section
of jz4.mol2 should read:

    
    
    @<TRIPOS>ATOM
          1 C4         24.2940  -24.1240   -0.0710 C.3     1  JZ4        -0.0650
          2 C7         21.5530  -27.2140   -4.1120 C.ar    1  JZ4        -0.0613
          3 C8         22.0680  -26.7470   -5.3310 C.ar    1  JZ4        -0.0583
          4 C9         22.6710  -25.5120   -5.4480 C.ar    1  JZ4        -0.0199
          5 C10        22.7690  -24.7300   -4.2950 C.ar    1  JZ4         0.1200
          6 C11        21.6930  -26.4590   -2.9540 C.ar    1  JZ4        -0.0551
          7 C12        22.2940  -25.1870   -3.0750 C.ar    1  JZ4        -0.0060
          8 C13        22.4630  -24.4140   -1.8080 C.3     1  JZ4        -0.0245
          9 C14        23.9250  -24.7040   -1.3940 C.3     1  JZ4        -0.0518
         10 OAB        23.4120  -23.5360   -4.3420 O.3     1  JZ4        -0.5065
         11 H          25.3133  -24.3619    0.1509 H       1  JZ4         0.0230
         12 H          23.6591  -24.5327    0.6872 H       1  JZ4         0.0230
         13 H          24.1744  -23.0611   -0.1016 H       1  JZ4         0.0230
         14 H          21.0673  -28.1238   -4.0754 H       1  JZ4         0.0618
         15 H          21.9931  -27.3472   -6.1672 H       1  JZ4         0.0619
         16 H          23.0361  -25.1783   -6.3537 H       1  JZ4         0.0654
         17 H          21.3701  -26.8143   -2.0405 H       1  JZ4         0.0621
         18 H          21.7794  -24.7551   -1.0588 H       1  JZ4         0.0314
         19 H          22.2659  -23.3694   -1.9301 H       1  JZ4         0.0314
         20 H          24.5755  -24.2929   -2.1375 H       1  JZ4         0.0266
         21 H          24.0241  -25.7662   -1.3110 H       1  JZ4         0.0266
         22 H          23.7394  -23.2120   -5.1580 H       1  JZ4         0.2921
    

Last, notice the strange bond order in the ` @<TRIPOS>BOND ` section. All
programs seem to have their own method for generating this list, but not all
are created equal. There will be issues in constructing a correct topology
with matching coordinates if the bonds are not listed in ascending order. To
fix this problem, download the script I have written and execute it:

    
    
    perl sort_mol2_bonds.pl jz4.mol2 jz4_fix.mol2
    

Use "jz4_fix.mol2" in the next step.

###  Generate the JZ4 Topology with CGenFF

The jz4_fix.mol2 file is now ready for use to produce a topology. Visit the
CGenFF server, log into your account, and and click "Upload molecule" at the
top of the page. Upload jz4_fix.mol2 and the CGenFF server will quickly return
a topology in the form of a CHARMM "stream" file (extension .str). Save its
contents from your web browser into a file called "jz4.str." You can also
download a copy of this file .

The CHARMM stream file contains all of the topology information - atom types,
charges, and bonded connectivity. It also has sections for additional bonded
parameters that were generated by analogy for any internal interactions not
covered by the force field. CGenFF also provides penalty scores for each
parameter, that is, an assessment of how reliable the assigned parameter is.
Anything below 10 is considered acceptable for immediate use. Values from 10 -
50 imply that some validation of the topology is warranted, and any penalties
larger than 50 generally require manual reparametrization. This penalty
scoring is one of the most important features of the CGenFF server. Many other
servers generate topologies and are "black boxes," which users are simply left
to trust implicitly. Staking your entire research project on an automatic
program without verification is very dangerous. A poor ligand topology can
lead to significant wasted time and unreliable results. Always validate the
topologies of newly parametrized species! At minimum, check the magnitudes of
charges and the atom types assigned to the ligand against existing moieties in
the force field.

Examine the contents of jz4.str and look at the penalties for the charges and
the new dihedral parameters. All of them are very low, suggesting that this
topology is of very good quality and can be used directly for our simulation.

The JZ4 topology in CHARMM format is all well and good, but it's not useful if
we are trying to run our simulation in GROMACS. Download a suitable version of
the cgenff_charmm2gmx.py script from . The script name will include the
version, _py2 or _py3, but here for simplicity this information is omitted but
you will need to use the actual name of the script that you downloaded for
your Python version. Perform the conversion with:

    
    
    python cgenff_charmm2gmx.py JZ4 jz4_fix.mol2 jz4.str charmm36-jul2022.ff
    

**PLEASE NOTE:** This script requires NetworkX package, and there are very
specific versions that have been tested. Please see the above-linked GitHub
site for version recommendations and the combinations of Python and NetworkX
that have been tested. Deviations from these versions may lead to syntax
issues that may cause the scripts to fail.

**NOTE** the following screen output at the end of the successful conversion:

    
    
    ============ DONE ============
    Conversion complete.
    The molecule topology has been written to jz4.itp
    Additional parameters needed by the molecule are written to jz4.prm, which needs to be included in the system .top
    ============ DONE ============
    

This ligand introduces new bonded parameters that are not part of the existing
force field, and these parameters are written to a file called "jz4.prm,"
which is in the format of a GROMACS .itp file. We will deal with this file
shortly, but it is important to note its existence. The ligand topology is now
written to "jz4.itp," which contains the ligand ` [ moleculetype ] `
definition.

###  Build the Complex

From pdb2gmx, we have a file called "3HTB_processed.gro" that contains the
processed, force field-compliant structure of our protein. We also have
"jz4_ini.pdb" from cgenff_charmm2gmx.py that has all of the necessary H atoms
and matches the atom names in the JZ4 topology. Convert this .pdb file to .gro
format with editconf:

    
    
    gmx editconf -f jz4_ini.pdb -o jz4.gro
    

Copy 3HTB_processed.gro to a new file to be manipulated, for instance, call it
"complex.gro," as the addition of JZ4 to the protein will generate our
protein-ligand complex. Next, simply copy the coordinate section of jz4.gro
and paste it into complex.gro, below the last line of the protein atoms, and
before the box vectors, like so:

    
    
      163ASN      C 1691   0.621  -0.740  -0.126
      163ASN     O1 1692   0.624  -0.616  -0.140
      163ASN     O2 1693   0.683  -0.703  -0.011
       5.99500   5.19182   9.66100   0.00000   0.00000  -2.99750   0.00000   0.00000   0.00000
    

becomes (added text in ** bold green  ** )...

    
    
      163ASN      C 1691   0.621  -0.740  -0.126
      163ASN     O1 1692   0.624  -0.616  -0.140
      163ASN     O2 1693   0.683  -0.703  -0.011
    **1JZ4     C4    1   2.429  -2.412  -0.007
        1JZ4     C7    2   2.155  -2.721  -0.411
        1JZ4     C8    3   2.207  -2.675  -0.533
        1JZ4     C9    4   2.267  -2.551  -0.545
        1JZ4    C10    5   2.277  -2.473  -0.430
        1JZ4    C11    6   2.169  -2.646  -0.295
        1JZ4    C12    7   2.229  -2.519  -0.308
        1JZ4    C13    8   2.246  -2.441  -0.181
        1JZ4    C14    9   2.392  -2.470  -0.139
        1JZ4    OAB   10   2.341  -2.354  -0.434
        1JZ4     H1   11   2.531  -2.436   0.015
        1JZ4     H2   12   2.366  -2.453   0.069
        1JZ4     H3   13   2.417  -2.306  -0.010
        1JZ4     H4   14   2.107  -2.812  -0.407
        1JZ4     H5   15   2.199  -2.735  -0.617
        1JZ4     H6   16   2.304  -2.518  -0.635
        1JZ4     H7   17   2.137  -2.681  -0.204
        1JZ4     H8   18   2.178  -2.476  -0.106
        1JZ4     H9   19   2.227  -2.337  -0.193
        1JZ4    H10   20   2.458  -2.429  -0.214
        1JZ4    H11   21   2.402  -2.577  -0.131
        1JZ4    H12   22   2.374  -2.321  -0.516**
       5.99500   5.19182   9.66100   0.00000   0.00000  -2.99750   0.00000   0.00000   0.00000
    

Since we have added 22 more atoms into the .gro file, increment the second
line of complex.gro to reflect this change. There should be 2636 atoms in the
coordinate file now.

###  Build the Topology

Including the parameters for the JZ4 ligand in the system topology is very
easy. Just insert a line that says ` #include "jz4.itp" ` into topol.top after
the position restraint file is included. The inclusion of position restraints
indicates the end of the "Protein" moleculetype section.

    
    
    ; Include Position restraint file
    #ifdef POSRES
    #include "posre.itp"
    #endif
    
    ; Include water topology
    #include "./charmm36-jul2022.ff/tip3p.itp"
    

becomes...

    
    
    ; Include Position restraint file
    #ifdef POSRES
    #include "posre.itp"
    #endif
    
    **; Include ligand topology
    #include "jz4.itp"**
    
    ; Include water topology
    #include "./charmm36-jul2022.ff/tip3p.itp"
    

The ligand introduces new dihedral parameters, which were written to "jz4.prm"
by the cgenff_charmm2gmx.py script. At the **TOP** of topol.top, insert an `
#include ` statement to add these parameters:

    
    
    ; Include forcefield parameters
    #include "./charmm36-jul2022.ff/forcefield.itp"
    
    **; Include ligand parameters
    #include "jz4.prm"**
    
    [ moleculetype ]
    ; Name            nrexcl
    Protein_chain_A     3
    

The placement of this ` #include ` statement is critical - it must appear
before any ` [ moleculetype ] ` entry because all parameters have to be
defined before any molecules can be constructed. It must also appear **AFTER**
the ` #include ` statement for the parent force field, because all atom types
have to be known before bonded parameters can be introduced that make use of
them.

The last adjustment to be made is in the ` [ molecules ] ` directive. To
account for the fact that there is a new molecule in complex.gro, we have to
add it here, like so:

    
    
    [ molecules ]
    ; Compound        #mols
    Protein_chain_A     1
    **JZ4                 1**
    

The topology and coordinate file are now in agreement with respect to the
contents of the system.

|  
---|---  
  

 
Protein-Ligand Complex  

##  GROMACS Tutorial

**Step Three: Defining the Unit Cell & Adding Solvent **

![](./Images/Steps_box_highlight.jpg)

At this point, the workflow is just like any other MD simulation. We will
define the unit cell and fill it with water.

    
    
    gmx editconf -f complex.gro -o newbox.gro -bt dodecahedron -d 1.0
    
    gmx solvate -cp newbox.gro -cs spc216.gro -p topol.top -o solv.gro
    

Upon visualizing ` solv.gro ` , you may wonder why editconf did not produce
the requested dodecahedral unit cell shape, as the system will look something
like this:

![](./Images/3htb_unit_cell.png)

GROMACS programs always use the most numerically efficient representation of
the coordinates, one that has everything re-wrapped into a triclinic unit
cell. The physical calculations that mdrun performs can be carried out
equivalently with different coordinate wrapping, so the most efficient is
preferred. The desired unit cell shape can be recovered later, following the
generation of a .tpr file.

|  |  
---|---  
  

 
Protein-Ligand Complex  

##  GROMACS Tutorial

**Step Four: Adding Ions**

![](./Images/Steps_ions_highlight.jpg)

We now have a solvated system that contains a charged protein. The output of
pdb2gmx told us that the protein has a net charge of +6 (based on its amino
acid composition). If you missed this information in the pdb2gmx output, look
at the last line of your ` [ atoms ] ` directive in topol.top; it should read
(in part) "qtot 6." Since life does not exist at a net charge, we must add
ions to our system.

Use grompp to assemble a .tpr file, using any .mdp file. I use an .mdp file
for running energy minimization, since they require the fewest parameters and
are thus the easiest to maintain. For example, .

    
    
    gmx grompp -f ions.mdp -c solv.gro -p topol.top -o ions.tpr
    

We now pass our .tpr file to genion:

    
    
    gmx genion -s ions.tpr -o solv_ions.gro -p topol.top -pname NA -nname CL -neutral
    

The names of the ions specified with -pname and -nname were force field-
specific in previous versions of GROMACS, but were standardized in version
4.5. The specified atom names are always the elemental symbol in all capital
letters, along with the ` [ moleculetype ] ` . Residue names may or may not
append the sign of the charge (+/-). Refer to ions.itp for proper nomenclature
if you encounter difficulties.

Your ` [ molecules ] ` directive should now look like:

    
    
    [ molecules ]
    ; Compound        #mols
    Protein_chain_A     1
    JZ4                 1
    SOL             10228
    CL                  6
    

|  |  
---|---  
  
  

 
Protein-Ligand Complex  

##  GROMACS Tutorial

**Step Five: Energy Minimization**

![](./Images/Steps_EM_highlight.jpg)

Now that the system is assembled, create the binary input using grompp using
input parameter file:

    
    
    gmx grompp -f em.mdp -c solv_ions.gro -p topol.top -o em.tpr
    

Make sure you have been updating your topol.top file when running genbox and
genion, or else you will get lots of nasty error messages ("number of
coordinates in coordinate file does not match topology," etc).

We are now ready to invoke mdrun to carry out the EM:

    
    
    gmx mdrun -v -deffnm em
    

For me, the system converged relatively quickly:

    
    
    Steepest Descents converged to Fmax < 1000 in 143 steps
    Potential Energy  = -4.9014547e+05
    Maximum force     =  8.7411469e+02 on atom 27
    Norm of force     =  5.6676244e+01
    

As in the , it is possible to monitor various components of the potential
energy using the energy module. I will not illustrate these principles here.
Have fun.

Now that our system is at an energy minimum, we can begin real dynamics.

|  |  
---|---  
  

 
Protein-Ligand Complex  

##  GROMACS Tutorial

**Step Six: Equilibration**

![](./Images/Steps_equil_highlight.jpg)

Equilibrating our protein-ligand complex will be much like equilibrating any
other system containing a protein in water. There are a few special
considerations, in this case:

  1. Applying restraints to the ligand 
  2. Treatment of temperature coupling groups 

###  Restraining the Ligand

To restrain the ligand, we will need to generate a position restraint topology
for it. First, create an index group for JZ4 that contains only its non-
hydrogen atoms:

    
    
    gmx make_ndx -f jz4.gro -o index_jz4.ndx
    ...
     > 0 & ! a H*
     > q
    

Then, execute the genrestr module and select this newly created index group
(which will be group 3 in the index_jz4.ndx file):

    
    
    gmx genrestr -f jz4.gro -n index_jz4.ndx -o posre_jz4.itp -fc 1000 1000 1000
    

Now, we need to include this information in our topology. We can do this in
several ways, depending upon the conditions we wish to use. If we simply want
to restrain the ligand whenever the protein is also restrained, add the
following lines to your topology in the location indicated:

    
    
    ; Include Position restraint file
    #ifdef POSRES
    #include "posre.itp"
    #endif
    
    ; Include ligand topology
    #include "jz4.itp"
    
    **; Ligand position restraints
    #ifdef POSRES
    #include "posre_jz4.itp"
    #endif**
    
    ; Include water topology
    #include "./charmm36-jul2022.ff/tip3p.itp"
    

Location matters! You must put the call for posre_jz4.itp in the topology as
indicated. The parameters within jz4.itp define a ` [ moleculetype ] `
directive for our ligand. The moleculetype ends with the inclusion of the
water topology (tip3p.itp). Placing the call to posre_jz4.itp anywhere else
will attempt to apply the position restraint parameters to the wrong
moleculetype.

If you want a bit more control during equilibration, i.e. restraining the
protein and ligand independently, you could instead control the inclusion of
the ligand position restraint file in a different #ifdef block, like so:

    
    
    ; Include Position restraint file
    #ifdef POSRES
    #include "posre.itp"
    #endif
    
    ; Include ligand topology
    #include "jz4.itp"
    
    **; Ligand position restraints
    #ifdef POSRES_LIG
    #include "posre_jz4.itp"
    #endif**
    
    ; Include water topology
    #include "./charmm36-jul2022.ff/tip3p.itp"
    

In the latter case, to restrain **both** the protein and the ligand, we would
need to specify ` define = -DPOSRES -DPOSRES_LIG ` in the .mdp file. How you
want to treat your system is up to you. These examples are meant only to
illustrate the flexibility GROMACS provides. For a standard equilibration
procedure, restraining the protein and ligand simultaneously is probably
sufficient. Your own needs may vary.

###  Thermostats

Proper control of temperature coupling is a sensitive issue. Coupling every
moleculetype to its own thermostatting group is a bad idea. For instance, if
you do the following:

    
    
    tc-grps = Protein JZ4 SOL CL
    

Your system will probably blow up, since the temperature coupling algorithms
are not stable enough to control the fluctuations in kinetic energy that
groups with a few atoms (i.e., JZ4 and CL) will produce. ** Do not couple
every single species in your system separately.  **

The typical approach is to set ` tc-grps = Protein Non-Protein ` and carry on.
Unfortunately, the "Non-Protein" group also encompasses JZ4. Since JZ4 and the
protein are physically linked very tightly, it is best to consider them as a
single entity. That is, JZ4 is grouped with the protein for the purposes of
temperature coupling. In the same way, the few Cl  \-  ions we inserted are
considered part of the solvent. To do this, we need a special index group that
merges the protein and JZ4. We accomplish this with the make_ndx module,
supplying any coordinate file of the complete system. Here, I am using em.gro,
the output (minimized) structure of our system:

    
    
    gmx make_ndx -f em.gro -o index.ndx
    ...
      0 System              : 33506 atoms
      1 Protein             :  2614 atoms
      2 Protein-H           :  1301 atoms
      3 C-alpha             :   163 atoms
      4 Backbone            :   489 atoms
      5 MainChain           :   651 atoms
      6 MainChain+Cb        :   803 atoms
      7 MainChain+H         :   813 atoms
      8 SideChain           :  1801 atoms
      9 SideChain-H         :   650 atoms
     10 Prot-Masses         :  2614 atoms
     11 non-Protein         : 30892 atoms
     12 Other               :    22 atoms
     13 JZ4                 :    22 atoms
     14 CL                  :     6 atoms
     15 Water               : 30864 atoms
     16 SOL                 : 30864 atoms
     17 non-Water           :  2642 atoms
     18 Ion                 :     6 atoms
     19 JZ4                 :    22 atoms
     20 CL                  :     6 atoms
     21 Water_and_ions      : 30870 atoms
    

Merge the "Protein" and "JZ4" groups with the following, where ">" indicates
the make_ndx prompt:

    
    
    > 1 | 13
    > q
    

We can now set ` tc-grps = Protein_JZ4 Water_and_ions ` to achieve our desired
"Protein Non-Protein" effect.

Proceed with equilibration using .mdp file.

    
    
    gmx grompp -f nvt.mdp -c em.gro -r em.gro -p topol.top -n index.ndx -o nvt.tpr
    
    gmx mdrun -deffnm nvt
    

|  |  
---|---  
  

 
Protein-Ligand Complex  

##  GROMACS Tutorial

**Step Seven: Equilibration, Part 2**

![](./Images/Steps_equil_highlight.jpg)

Once the simulation is complete, proceed to with .mdp file:

    
    
    gmx grompp -f npt.mdp -c nvt.gro -t nvt.cpt -r nvt.gro -p topol.top -n index.ndx -o npt.tpr
    
    gmx mdrun -deffnm npt
    

|  |  
---|---  
  

 
Protein-Ligand Complex  

##  GROMACS Tutorial

**Step Eight: Production MD**

![](./Images/Steps_MD_highlight.jpg)

Upon completion of the two equilibration phases, the system is now well-
equilibrated at the desired temperature and pressure. We are now ready to
release the position restraints and run production MD for data collection. The
process is just like we have seen before, as we will make use of the
checkpoint file (which in this case now contains preserve pressure coupling
information) to grompp. We will run a 10-ns MD simulation, the script for
which can be found .

    
    
    gmx grompp -f md.mdp -c npt.gro -t npt.cpt -p topol.top -n index.ndx -o md_0_10.tpr
    
    gmx mdrun -deffnm md_0_10
    

|  |  
---|---  
  

 
Protein-Ligand Complex  

##  GROMACS Tutorial

**Step Nine: Analysis**

![](./Images/Steps_analysis_highlight.jpg)

###  Recentering and Rewrapping Coordinates

As in any simulation conducted with periodic boundary conditions, molecules
may appear "broken" or may "jump" back and forth across the box. To recenter
the protein and rewrap the molecules within the unit cell to recover the
desired rhombic dodecahedral shape, invoke trjconv:

    
    
    gmx trjconv -s md_0_10.tpr -f md_0_10.xtc -o md_0_10_center.xtc -center -pbc mol -ur compact
    

Choose "Protein" for centering and "System" for output. Note that centering
complexes (protein-ligand, protein-protein) may be difficult for longer
simulations involving many jumps across periodic boundaries. In those
instances (particularly in protein-protein complexes), it may be necessary to
create a custom index group to use for centering, corresponding to the active
site of one protein or the interfacial residues of one monomer in a complex.

To extract the first frame (t = 0 ns) of the trajectory, use trjconv -dump
with the recentered trajectory:

    
    
    gmx trjconv -s md_0_10.tpr -f md_0_10_center.xtc -o start.pdb -dump 0
    

![](./Images/3htb_t0_rewrap.png)

For even smoother visualization, it may be beneficial to perform rotational
and translational fitting. Execute trjconv as follows:

    
    
    gmx trjconv -s md_0_10.tpr -f md_0_10_center.xtc -o md_0_10_fit.xtc -fit rot+trans
    

Choose "Backbone" to perform least-squares fitting to the protein backbone,
and "System" for output. Note that simultaneous PBC rewrapping and fitting of
the coordinates is mathematically incompatible. Should you wish to perform
fitting (which is useful for visualization, but not necessary for most
analysis routines), carry out these coordinate manipulations separately, as
indicated here.

###  Analyzing Protein-Ligand Interactions and Ligand Dynamics

This tutorial cannot possible cover all analysis methods that you may wish to
perform. A few basic operations will be illustrated here.

The 2-propylphenol ligand can engage in a hydrogen bond with the Gln102 side
chain. The GROMACS hbond module can easily be employed to calculate the number
of hydrogen bonds between any groups of atoms, but in our case, the only
values will be 1 or 0. For a more detailed look at how the ligand is
interacting with Gln102, we will compute the distance between the hydroxyl
group of JZ4 and the carbonyl O atom of Gln102. For a hydrogen bond to be
formed, the typical criterion is that the donor and acceptor atoms will be
separated by a distance ≤ 3.5 Å (0.35 nm). Use the distance module to
calculate the distance over the course of the trajectory, using command-line
selection syntax (see gmx help selections for examples and more syntax).

    
    
    gmx distance -s md_0_10.tpr -f md_0_10_center.xtc -select 'resname "JZ4" and name OAB plus resid 102 and name OE1' -oall
    

The average distance is 0.31 ± 0.05 nm, consistent with the formation of a
hydrogen bond.

The second criterion usually applied in determining the presence of a hydrogen
bond is the angle formed among the donor, hydrogen, and acceptor atoms. There
are different conventions for calculating the angle. In the GROMACS hbond
module, the angle is defined as hydrogen-donor-acceptor, and this angle should
be ≤ 30°. To perform this analysis, first create index groups for the donor
atoms (which must include both the donor heavy atom and the bonded hydrogen)
and the acceptor atom:

    
    
    gmx make_ndx -f em.gro -o index.ndx
    ...
     > 13 & a OAB | a H12
     (creates group 23)
     > 1 & r 102 & a OE1
     (creates group 24)
     > 23 | 24
     > q
    

Analyze the angle formed by these three atoms using the angle module:

    
    
    gmx angle -f md_0_10_center.xtc -n index.ndx -ov angle.xvg
    

Note that angle takes no -s argument, unlike most other GROMACS analysis
modules. Angle calculations do not require mass or periodicity information,
atom names, etc. so the trajectory is processed without a .tpr or coordinate
file. The value returned by the command should be roughly 23 ± 9°. This
outcome may be somewhat unexpected, as the index group we constructed was in
the order of OAB, H12, OE1, which would correspond to the donor-hydrogen-
acceptor distance, which we expect to be close to linear (~180°). Inspect the
contents of the index file and you will find:

    
    
    [ JZ4_&_OAB_H12_Protein_&_r_102_&_OE1 ]
    1616 2624 2636
    

make_ndx has sorted the atom numbers automatically from low to high, thus the
outcome of the calculation is the acceptor-donor-hydrogen angle, the same
angle that the hbond module would have calculated. So the result is consistent
with formation of a hydrogen bond, since it is ≤ 30°. To get the desired angle
of donor-hydrogen-acceptor, we would have to manually edit the index group in
a text file to reorder the atom numbers (2624 2636 1616). Re-running the angle
calculation with this index group yields an average value of 147 ± 11°.

Finally, we may be interested in quantifying how much the ligand binding pose
has changed over the course of the simulation. To compute a heavy-atom RMSD of
just JZ4, create a new index group for it:

    
    
    gmx make_ndx -f em.gro -n index.ndx
    ...
     > 13 & ! a H*
     > name 26 JZ4_Heavy
     > q
    

Execute the rms module, choosing "Backbone" for least-squares fitting and
"JZ4_Heavy" for the RMSD calculation. By doing so, the overall rotation and
translation of the protein is removed via fitting and the RMSD reported is how
much the JZ4 position has varied relative to the protein, which is a good
indicator of how well the binding pose was preserved during the simulation.

    
    
    gmx rms -s em.tpr -f md_0_10_center.xtc -n index.ndx -tu ns -o rmsd_jz4.xvg
    

The calculated RMSD should be about 0.1 nm (1 Å), indicating only a very small
change in the ligand's position.

###  Protein-Ligand Interaction Energy

To quantify the strength of the interaction between JZ4 and T4 lysozyme, it
may be useful to compute the nonbonded interaction energy between these two
species. GROMACS has the ability to decompose the short-range nonbonded
energies between any number of defined groups. It is important to note that
this quantity is **NOT** a free energy or a binding energy. In fact, most
force fields are not parametrized in such a way that this quantity is actually
physically meaningful. CHARMM is parametrized to specifically target quantum
mechanical interaction energies with water, so it is intrinsically balanced
against meaningful quantities, and as such the interaction energy can be
useful.

Calculation of an interaction energy is carried out via the ` energygrps `
keyword in the .mdp file. Despite being an .mdp keyword, interaction energy
calculations should not be considered part of a normal simulation.
Decomposition of the short-range energies is incompatible with running on a
GPU and also slows the calculation down unnecessarily. The mdrun module does
not need to do this extra work to perform a valid simulation. As such, only
compute interaction energies as a part of your analysis, not your dynamics.
Create a new .tpr file from an .mdp file that has ` energygrps = Protein JZ4 `
defined, like :

    
    
    gmx grompp -f ie.mdp -c npt.gro -t npt.cpt -p topol.top -n index.ndx -o ie.tpr
    

Next, invoke mdrun with the -rerun option to recalculate energies from the
existing simulation trajectory:

    
    
    gmx mdrun -deffnm ie -rerun md_0_10.xtc -nb cpu
    

Note the use of -deffnm to read ie.tpr and write all output files to ie.* as
their file names. The -rerun option takes the name of the trajectory for which
you want to recompute energies, and -nb cpu tells mdrun to only attempt to run
on CPU hardware and ignore any GPU that might be available. As stated above,
this type of calculation cannot be performed on a GPU. The rerun should be
very fast, completing in just a few minutes.

Extract the energy terms of interest via the energy module. The terms we are
interested in are Coul-SR:Protein-JZ4 and LJ-SR:Protein-JZ4.

    
    
    gmx energy -f ie.edr -o interaction_energy.xvg
    

The average short-range Coulombic interaction energy is -20.5 ± 7.4 kJ mol  -1
and the short-range Lennard-Jones energy is -99.1 ± 7.2 kJ mol  -1  . It may
be tempting to draw conclusions from the relative magnitudes of these
quantities, but even though CHARMM was parametrized against explicit water
interaction energies, decomposition of interaction energies further into these
components is not necessarily real. There is no way to experimentally verify
these quantities, so it is impossible to know whether they are meaningful. The
**total** interaction energy, however, is useful in this case. That value
(after propagating the error according to the standard formula for addition of
two quantities) is -119.6 ± 10.3 kJ mol  -1  .

|  |  
---|---  
  
  

 
Protein-Ligand Complex  

##  GROMACS Tutorial

**Summary**

![](./Images/Steps_analysis_highlight.jpg)

You have now conducted a molecular dynamics simulation of a protein-ligand
complex with GROMACS. This tutorial should not be viewed as comprehensive.
There are many more types of simulations that one can conduct with GROMACS
(free energy calculations, non-equilibrium MD, and normal modes analysis, just
to name a few). You should also review the literature and the GROMACS manual
for adjustments to the .mdp files provided here for efficiency and accuracy
purposes.

If you have suggestions for improving this tutorial, if you notice a mistake,
or if anything is otherwise unclear, please feel free to . Please note: this
is not an invitation to email me for GROMACS problems. I do not advertise
myself as a private tutor or personal help service. That's what the is for. I
may help you there, but only in the context of providing service to the
community as a whole, not just the end user.

Happy simulating!

|  |  
---|---  
  

 
Protein-Ligand Complex  

##  GROMACS Tutorial

###  Protein-Ligand Complex

**Justin A. Lemkul, Ph.D.**  

![](./Images/lysozyme_complex_3htb.png)  

This example will guide a new user through the process of setting up a
simulation system containing a protein (T4 lysozyme L99A/M102Q) in complex
with a ligand. This tutorial focuses specifically on issues related to dealing
with the ligand, assuming that the user is familiar with basic GROMACS
operations and the contents of a topology. If this is not the case, please
refer to before attempting this one.

This tutorial requires a GROMACS version in the 2018.x series.

  
  
  
  
  
---  
  

 
Protein-Ligand Complex  

##  GROMACS Tutorial

**Step One: Prepare the Protein Topology**

![](./Images/Steps_top_highlight.jpg)

We must download the protein structure file we will be working with. For this
tutorial, we will utilize T4 lysozyme L99A/M102Q (PDB code 3HTB). Go to the
website and download the PDB text for the crystal structure.

Once you have downloaded the structure, you can visualize it using a viewing
program such as VMD, Chimera, PyMOL, etc. Once you've had a look at the
molecule, you are going to want to strip out the crystal waters, PO4, and BME.
Note that such a procedure is not universally appropriate (i.e., the case of a
bound active site water molecule). For our intentions here, we do not need
crystal water or other species, which are just crystallization co-solvents. We
will instead focus on the ligand called "JZ4," which is 2-propylphenol.

If you want a clean version of the .pdb file to check your work, you can
download it . The problem we now face is that the JZ4 ligand is not a
recognized entity in any of the force fields provided with GROMACS, so pdb2gmx
will give a fatal error if you were try to pass this file through it.
Topologies can only be assembled automatically if an entry for a building
block is present in the .rtp (residue topology) file for the force field.
Since this is not the case, we will prepare our system topology in two steps:

  1. Prepare the protein topology with pdb2gmx 
  2. Prepare the ligand topology using external tools 

Since we will be preparing these two topologies separately, we must save the
protein and JZ4 ligand into separate coordinate files. Save the JZ4
coordinates like so:

    
    
    grep JZ4 3HTB_clean.pdb > jz4.pdb
    

Then simply delete the JZ4 lines from 3HTB_clean.pdb. At this point, preparing
the protein topology is trivial. The force field we will be using in this
tutorial is CHARMM36, obtained from the . While there, download the latest
CHARMM36 force field tarball and the "cgenff_charmm2gmx.py" conversion script,
which we will use later. Download the version of the conversion script that
corresponds to your installed Python version (Python 2.x or 3.x).

Unarchive the force field tarball in your working directory:

    
    
    tar -zxvf charmm36-jul2022.ff.tgz
    

There should now be a "charmm36-jul2022.ff" subdirectory in your working
directory. Write the topology for the T4 lysozyme with pdb2gmx:

    
    
    gmx pdb2gmx -f 3HTB_clean.pdb -o 3HTB_processed.gro -ter
    

You will be prompted to make 3 selections.

  1. Force field 
  2. Water model 
  3. Terminus type 

    
    
    Select the Force Field:
    From current directory:
     1: CHARMM36 all-atom force field (July 2022)
    From '/usr/local/gromacs/share/gromacs/top':
     2: AMBER03 protein, nucleic AMBER94 (Duan et al., J. Comp. Chem. 24, 1999-2012, 2003)
     3: AMBER94 force field (Cornell et al., JACS 117, 5179-5197, 1995)
     4: AMBER96 protein, nucleic AMBER94 (Kollman et al., Acc. Chem. Res. 29, 461-469, 1996)
     5: AMBER99 protein, nucleic AMBER94 (Wang et al., J. Comp. Chem. 21, 1049-1074, 2000)
     6: AMBER99SB protein, nucleic AMBER94 (Hornak et al., Proteins 65, 712-725, 2006)
     7: AMBER99SB-ILDN protein, nucleic AMBER94 (Lindorff-Larsen et al., Proteins 78, 1950-58, 2010)
     8: AMBERGS force field (Garcia & Sanbonmatsu, PNAS 99, 2782-2787, 2002)
     9: CHARMM27 all-atom force field (CHARM22 plus CMAP for proteins)
    10: GROMOS96 43a1 force field
    11: GROMOS96 43a2 force field (improved alkane dihedrals)
    12: GROMOS96 45a3 force field (Schuler JCC 2001 22 1205)
    13: GROMOS96 53a5 force field (JCC 2004 vol 25 pag 1656)
    14: GROMOS96 53a6 force field (JCC 2004 vol 25 pag 1656)
    15: GROMOS96 54a7 force field (Eur. Biophys. J. (2011), 40,, 843-856, DOI: 10.1007/s00249-011-0700-9)
    16: OPLS-AA/L all-atom force field (2001 aminoacid dihedrals)
    

For this tutorial, choose the CHARMM36 force field (option 1), listed first
under "From current directory" in the list.

Choose the default water model (CHARMM-modified TIP3P) and then choose "NH3+"
and "COO-" for the termini. This interactive selection is necessary due to the
N-terminal residue being methionine (MET), which causes pdb2gmx to choose an
incompatible terminus type that is intended for carbohydrates. You must select
the protein-specific termini, otherwise you will get a fatal error about non-
matching atom names.

|  |  
---|---  
  

 
Protein-Ligand Complex  

##  GROMACS Tutorial

**Step Two: Prepare the Ligand Topology**

![](./Images/Steps_top_highlight.jpg)

We must now deal with the ligand. But how does one come up with parameters for
some species that the force field does not automatically recognize? Proper
treatment of ligands is one of the most challenging tasks in molecular
simulation. Force field authors spend years of their lives deriving self-
consistent force fields, and it is no small task to introduce a new species
into this framework. Force field parameters for any new species must be
derived and validated in a manner that is consistent with the original force
field.

For the OPLS, AMBER, and CHARMM force fields, this derivation often takes the
form of various quantum mechanical calculations. The primary literature for
these force fields describes the required procedure. For GROMOS force fields,
parameterization methodology is less clear, relying on empirical fitting of
condensed-phase behavior. That is, some initial charges and Lennard-Jones
parameters are calculated for each atom type, evaluated for their accuracy,
and refined. While the end result is very satisfactory, i.e. fluids resemble
their real-world counterparts, the derivation process can be laborious and
frustrating.

For this reason, automated tools are greatly preferred. For each force field,
there are methodologies or software programs that purport to give parameters
compatible with various force fields. Not all of them are equally accurate.
For a few examples, refer to the following table:

|

* * *  
  
---  
AMBER  |  |  Parametrizes molecules using GAFF  
|  |  A Python interface to Antechamber, writes GROMACS topologies  
  
* * *  
  
CHARMM  |  |  The official CHARMM General Force Field server  
  
* * *  
  
GROMOS87/GROMOS96  |  |  An automated server for topology generation  
|  |  A newer server for topology generation, uses GROMOS96 54A7  
  
* * *  
  
OPLS-AA  |  |  A server from the Jorgensen group to produce OPLS topologies  
  
* * *  
  
###  Add Hydrogen Atoms to JZ4

In this tutorial, we will be generating the JZ4 topology with the CGenFF
server. Click the link in the table above to visit the site. Register for a
(free) account and activate it. CGenFF requires a Sybyl .mol2 file as its
input, to collect rudimentary atom type information and bonded connectivity.
CHARMM is also an all-atom force field, meaning all H atoms are explicitly
represented. Crystal structures do not typically assign H coordinates, so they
have to be built in. To produce a .mol2 file and add H atoms, use the . Open
jz4.pdb in Avogadro, and from the "Build" menu, choose "Add Hydrogens."
Avogadro will build all of the H atoms onto the JZ4 ligand. Save a .mol2 file
(File -> Save As... and choose Sybyl Mol2 from the drop-down menu) named
"jz4.mol2."

Several corrections must be made to jz4.mol2 before it can be used. Open
jz4.mol2 in your favorite plain-text editor and you will find:

    
    
    @<TRIPOS>MOLECULE
    *****
     22 22 0 0 0
    SMALL
    GASTEIGER
    
    @<TRIPOS>ATOM
          1 C4         24.2940  -24.1240   -0.0710 C.3   167  JZ4167     -0.0650
          2 C7         21.5530  -27.2140   -4.1120 C.ar  167  JZ4167     -0.0613
          3 C8         22.0680  -26.7470   -5.3310 C.ar  167  JZ4167     -0.0583
          4 C9         22.6710  -25.5120   -5.4480 C.ar  167  JZ4167     -0.0199
          5 C10        22.7690  -24.7300   -4.2950 C.ar  167  JZ4167      0.1200
          6 C11        21.6930  -26.4590   -2.9540 C.ar  167  JZ4167     -0.0551
          7 C12        22.2940  -25.1870   -3.0750 C.ar  167  JZ4167     -0.0060
          8 C13        22.4630  -24.4140   -1.8080 C.3   167  JZ4167     -0.0245
          9 C14        23.9250  -24.7040   -1.3940 C.3   167  JZ4167     -0.0518
         10 OAB        23.4120  -23.5360   -4.3420 O.3   167  JZ4167     -0.5065
         11 H          25.3133  -24.3619    0.1509 H       1  UNL1        0.0230
         12 H          23.6591  -24.5327    0.6872 H       1  UNL1        0.0230
         13 H          24.1744  -23.0611   -0.1016 H       1  UNL1        0.0230
         14 H          21.0673  -28.1238   -4.0754 H       1  UNL1        0.0618
         15 H          21.9931  -27.3472   -6.1672 H       1  UNL1        0.0619
         16 H          23.0361  -25.1783   -6.3537 H       1  UNL1        0.0654
         17 H          21.3701  -26.8143   -2.0405 H       1  UNL1        0.0621
         18 H          21.7794  -24.7551   -1.0588 H       1  UNL1        0.0314
         19 H          22.2659  -23.3694   -1.9301 H       1  UNL1        0.0314
         20 H          24.5755  -24.2929   -2.1375 H       1  UNL1        0.0266
         21 H          24.0241  -25.7662   -1.3110 H       1  UNL1        0.0266
         22 H          23.7394  -23.2120   -5.1580 H       1  UNL1        0.2921
    @<TRIPOS>BOND
         1     4     3   ar
         2     4     5   ar
         3     3     2   ar
         4    10     5    1
         5     5     7   ar
         6     2     6   ar
         7     7     6   ar
         8     7     8    1
         9     8     9    1
        10     9     1    1
        11     1    11    1
        12     1    12    1
        13     1    13    1
        14     2    14    1
        15     3    15    1
        16     4    16    1
        17     6    17    1
        18     8    18    1
        19     8    19    1
        20     9    20    1
        21     9    21    1
        22    10    22    1
    

The first change that needs to be made is in the ` MOLECULE ` heading. Replace
"*****" with "JZ4," e.g.:

    
    
    @<TRIPOS>MOLECULE
    **JZ4**
    

Next, fix the residue names and numbers such that they are all the same. This
.mol2 file only contains one molecule, therefore there should only be one
residue name and number specified. After editing, the corrected ATOM section
of jz4.mol2 should read:

    
    
    @<TRIPOS>ATOM
          1 C4         24.2940  -24.1240   -0.0710 C.3     1  JZ4        -0.0650
          2 C7         21.5530  -27.2140   -4.1120 C.ar    1  JZ4        -0.0613
          3 C8         22.0680  -26.7470   -5.3310 C.ar    1  JZ4        -0.0583
          4 C9         22.6710  -25.5120   -5.4480 C.ar    1  JZ4        -0.0199
          5 C10        22.7690  -24.7300   -4.2950 C.ar    1  JZ4         0.1200
          6 C11        21.6930  -26.4590   -2.9540 C.ar    1  JZ4        -0.0551
          7 C12        22.2940  -25.1870   -3.0750 C.ar    1  JZ4        -0.0060
          8 C13        22.4630  -24.4140   -1.8080 C.3     1  JZ4        -0.0245
          9 C14        23.9250  -24.7040   -1.3940 C.3     1  JZ4        -0.0518
         10 OAB        23.4120  -23.5360   -4.3420 O.3     1  JZ4        -0.5065
         11 H          25.3133  -24.3619    0.1509 H       1  JZ4         0.0230
         12 H          23.6591  -24.5327    0.6872 H       1  JZ4         0.0230
         13 H          24.1744  -23.0611   -0.1016 H       1  JZ4         0.0230
         14 H          21.0673  -28.1238   -4.0754 H       1  JZ4         0.0618
         15 H          21.9931  -27.3472   -6.1672 H       1  JZ4         0.0619
         16 H          23.0361  -25.1783   -6.3537 H       1  JZ4         0.0654
         17 H          21.3701  -26.8143   -2.0405 H       1  JZ4         0.0621
         18 H          21.7794  -24.7551   -1.0588 H       1  JZ4         0.0314
         19 H          22.2659  -23.3694   -1.9301 H       1  JZ4         0.0314
         20 H          24.5755  -24.2929   -2.1375 H       1  JZ4         0.0266
         21 H          24.0241  -25.7662   -1.3110 H       1  JZ4         0.0266
         22 H          23.7394  -23.2120   -5.1580 H       1  JZ4         0.2921
    

Last, notice the strange bond order in the ` @<TRIPOS>BOND ` section. All
programs seem to have their own method for generating this list, but not all
are created equal. There will be issues in constructing a correct topology
with matching coordinates if the bonds are not listed in ascending order. To
fix this problem, download the script I have written and execute it:

    
    
    perl sort_mol2_bonds.pl jz4.mol2 jz4_fix.mol2
    

Use "jz4_fix.mol2" in the next step.

###  Generate the JZ4 Topology with CGenFF

The jz4_fix.mol2 file is now ready for use to produce a topology. Visit the
CGenFF server, log into your account, and and click "Upload molecule" at the
top of the page. Upload jz4_fix.mol2 and the CGenFF server will quickly return
a topology in the form of a CHARMM "stream" file (extension .str). Save its
contents from your web browser into a file called "jz4.str." You can also
download a copy of this file .

The CHARMM stream file contains all of the topology information - atom types,
charges, and bonded connectivity. It also has sections for additional bonded
parameters that were generated by analogy for any internal interactions not
covered by the force field. CGenFF also provides penalty scores for each
parameter, that is, an assessment of how reliable the assigned parameter is.
Anything below 10 is considered acceptable for immediate use. Values from 10 -
50 imply that some validation of the topology is warranted, and any penalties
larger than 50 generally require manual reparametrization. This penalty
scoring is one of the most important features of the CGenFF server. Many other
servers generate topologies and are "black boxes," which users are simply left
to trust implicitly. Staking your entire research project on an automatic
program without verification is very dangerous. A poor ligand topology can
lead to significant wasted time and unreliable results. Always validate the
topologies of newly parametrized species! At minimum, check the magnitudes of
charges and the atom types assigned to the ligand against existing moieties in
the force field.

Examine the contents of jz4.str and look at the penalties for the charges and
the new dihedral parameters. All of them are very low, suggesting that this
topology is of very good quality and can be used directly for our simulation.

The JZ4 topology in CHARMM format is all well and good, but it's not useful if
we are trying to run our simulation in GROMACS. Download a suitable version of
the cgenff_charmm2gmx.py script from . The script name will include the
version, _py2 or _py3, but here for simplicity this information is omitted but
you will need to use the actual name of the script that you downloaded for
your Python version. Perform the conversion with:

    
    
    python cgenff_charmm2gmx.py JZ4 jz4_fix.mol2 jz4.str charmm36-jul2022.ff
    

**PLEASE NOTE:** This script requires NetworkX package, and there are very
specific versions that have been tested. Please see the above-linked GitHub
site for version recommendations and the combinations of Python and NetworkX
that have been tested. Deviations from these versions may lead to syntax
issues that may cause the scripts to fail.

**NOTE** the following screen output at the end of the successful conversion:

    
    
    ============ DONE ============
    Conversion complete.
    The molecule topology has been written to jz4.itp
    Additional parameters needed by the molecule are written to jz4.prm, which needs to be included in the system .top
    ============ DONE ============
    

This ligand introduces new bonded parameters that are not part of the existing
force field, and these parameters are written to a file called "jz4.prm,"
which is in the format of a GROMACS .itp file. We will deal with this file
shortly, but it is important to note its existence. The ligand topology is now
written to "jz4.itp," which contains the ligand ` [ moleculetype ] `
definition.

###  Build the Complex

From pdb2gmx, we have a file called "3HTB_processed.gro" that contains the
processed, force field-compliant structure of our protein. We also have
"jz4_ini.pdb" from cgenff_charmm2gmx.py that has all of the necessary H atoms
and matches the atom names in the JZ4 topology. Convert this .pdb file to .gro
format with editconf:

    
    
    gmx editconf -f jz4_ini.pdb -o jz4.gro
    

Copy 3HTB_processed.gro to a new file to be manipulated, for instance, call it
"complex.gro," as the addition of JZ4 to the protein will generate our
protein-ligand complex. Next, simply copy the coordinate section of jz4.gro
and paste it into complex.gro, below the last line of the protein atoms, and
before the box vectors, like so:

    
    
      163ASN      C 1691   0.621  -0.740  -0.126
      163ASN     O1 1692   0.624  -0.616  -0.140
      163ASN     O2 1693   0.683  -0.703  -0.011
       5.99500   5.19182   9.66100   0.00000   0.00000  -2.99750   0.00000   0.00000   0.00000
    

becomes (added text in ** bold green  ** )...

    
    
      163ASN      C 1691   0.621  -0.740  -0.126
      163ASN     O1 1692   0.624  -0.616  -0.140
      163ASN     O2 1693   0.683  -0.703  -0.011
    **1JZ4     C4    1   2.429  -2.412  -0.007
        1JZ4     C7    2   2.155  -2.721  -0.411
        1JZ4     C8    3   2.207  -2.675  -0.533
        1JZ4     C9    4   2.267  -2.551  -0.545
        1JZ4    C10    5   2.277  -2.473  -0.430
        1JZ4    C11    6   2.169  -2.646  -0.295
        1JZ4    C12    7   2.229  -2.519  -0.308
        1JZ4    C13    8   2.246  -2.441  -0.181
        1JZ4    C14    9   2.392  -2.470  -0.139
        1JZ4    OAB   10   2.341  -2.354  -0.434
        1JZ4     H1   11   2.531  -2.436   0.015
        1JZ4     H2   12   2.366  -2.453   0.069
        1JZ4     H3   13   2.417  -2.306  -0.010
        1JZ4     H4   14   2.107  -2.812  -0.407
        1JZ4     H5   15   2.199  -2.735  -0.617
        1JZ4     H6   16   2.304  -2.518  -0.635
        1JZ4     H7   17   2.137  -2.681  -0.204
        1JZ4     H8   18   2.178  -2.476  -0.106
        1JZ4     H9   19   2.227  -2.337  -0.193
        1JZ4    H10   20   2.458  -2.429  -0.214
        1JZ4    H11   21   2.402  -2.577  -0.131
        1JZ4    H12   22   2.374  -2.321  -0.516**
       5.99500   5.19182   9.66100   0.00000   0.00000  -2.99750   0.00000   0.00000   0.00000
    

Since we have added 22 more atoms into the .gro file, increment the second
line of complex.gro to reflect this change. There should be 2636 atoms in the
coordinate file now.

###  Build the Topology

Including the parameters for the JZ4 ligand in the system topology is very
easy. Just insert a line that says ` #include "jz4.itp" ` into topol.top after
the position restraint file is included. The inclusion of position restraints
indicates the end of the "Protein" moleculetype section.

    
    
    ; Include Position restraint file
    #ifdef POSRES
    #include "posre.itp"
    #endif
    
    ; Include water topology
    #include "./charmm36-jul2022.ff/tip3p.itp"
    

becomes...

    
    
    ; Include Position restraint file
    #ifdef POSRES
    #include "posre.itp"
    #endif
    
    **; Include ligand topology
    #include "jz4.itp"**
    
    ; Include water topology
    #include "./charmm36-jul2022.ff/tip3p.itp"
    

The ligand introduces new dihedral parameters, which were written to "jz4.prm"
by the cgenff_charmm2gmx.py script. At the **TOP** of topol.top, insert an `
#include ` statement to add these parameters:

    
    
    ; Include forcefield parameters
    #include "./charmm36-jul2022.ff/forcefield.itp"
    
    **; Include ligand parameters
    #include "jz4.prm"**
    
    [ moleculetype ]
    ; Name            nrexcl
    Protein_chain_A     3
    

The placement of this ` #include ` statement is critical - it must appear
before any ` [ moleculetype ] ` entry because all parameters have to be
defined before any molecules can be constructed. It must also appear **AFTER**
the ` #include ` statement for the parent force field, because all atom types
have to be known before bonded parameters can be introduced that make use of
them.

The last adjustment to be made is in the ` [ molecules ] ` directive. To
account for the fact that there is a new molecule in complex.gro, we have to
add it here, like so:

    
    
    [ molecules ]
    ; Compound        #mols
    Protein_chain_A     1
    **JZ4                 1**
    

The topology and coordinate file are now in agreement with respect to the
contents of the system.

|  
---|---  
  

 
Protein-Ligand Complex  

##  GROMACS Tutorial

**Step Three: Defining the Unit Cell & Adding Solvent **

![](./Images/Steps_box_highlight.jpg)

At this point, the workflow is just like any other MD simulation. We will
define the unit cell and fill it with water.

    
    
    gmx editconf -f complex.gro -o newbox.gro -bt dodecahedron -d 1.0
    
    gmx solvate -cp newbox.gro -cs spc216.gro -p topol.top -o solv.gro
    

Upon visualizing ` solv.gro ` , you may wonder why editconf did not produce
the requested dodecahedral unit cell shape, as the system will look something
like this:

![](./Images/3htb_unit_cell.png)

GROMACS programs always use the most numerically efficient representation of
the coordinates, one that has everything re-wrapped into a triclinic unit
cell. The physical calculations that mdrun performs can be carried out
equivalently with different coordinate wrapping, so the most efficient is
preferred. The desired unit cell shape can be recovered later, following the
generation of a .tpr file.

|  |  
---|---  
  

 
Protein-Ligand Complex  

##  GROMACS Tutorial

**Step Four: Adding Ions**

![](./Images/Steps_ions_highlight.jpg)

We now have a solvated system that contains a charged protein. The output of
pdb2gmx told us that the protein has a net charge of +6 (based on its amino
acid composition). If you missed this information in the pdb2gmx output, look
at the last line of your ` [ atoms ] ` directive in topol.top; it should read
(in part) "qtot 6." Since life does not exist at a net charge, we must add
ions to our system.

Use grompp to assemble a .tpr file, using any .mdp file. I use an .mdp file
for running energy minimization, since they require the fewest parameters and
are thus the easiest to maintain. For example, .

    
    
    gmx grompp -f ions.mdp -c solv.gro -p topol.top -o ions.tpr
    

We now pass our .tpr file to genion:

    
    
    gmx genion -s ions.tpr -o solv_ions.gro -p topol.top -pname NA -nname CL -neutral
    

The names of the ions specified with -pname and -nname were force field-
specific in previous versions of GROMACS, but were standardized in version
4.5. The specified atom names are always the elemental symbol in all capital
letters, along with the ` [ moleculetype ] ` . Residue names may or may not
append the sign of the charge (+/-). Refer to ions.itp for proper nomenclature
if you encounter difficulties.

Your ` [ molecules ] ` directive should now look like:

    
    
    [ molecules ]
    ; Compound        #mols
    Protein_chain_A     1
    JZ4                 1
    SOL             10228
    CL                  6
    

|  |  
---|---  
  
  

 
Protein-Ligand Complex  

##  GROMACS Tutorial

**Step Five: Energy Minimization**

![](./Images/Steps_EM_highlight.jpg)

Now that the system is assembled, create the binary input using grompp using
input parameter file:

    
    
    gmx grompp -f em.mdp -c solv_ions.gro -p topol.top -o em.tpr
    

Make sure you have been updating your topol.top file when running genbox and
genion, or else you will get lots of nasty error messages ("number of
coordinates in coordinate file does not match topology," etc).

We are now ready to invoke mdrun to carry out the EM:

    
    
    gmx mdrun -v -deffnm em
    

For me, the system converged relatively quickly:

    
    
    Steepest Descents converged to Fmax < 1000 in 143 steps
    Potential Energy  = -4.9014547e+05
    Maximum force     =  8.7411469e+02 on atom 27
    Norm of force     =  5.6676244e+01
    

As in the , it is possible to monitor various components of the potential
energy using the energy module. I will not illustrate these principles here.
Have fun.

Now that our system is at an energy minimum, we can begin real dynamics.

|  |  
---|---  
  

 
Protein-Ligand Complex  

##  GROMACS Tutorial

**Step Six: Equilibration**

![](./Images/Steps_equil_highlight.jpg)

Equilibrating our protein-ligand complex will be much like equilibrating any
other system containing a protein in water. There are a few special
considerations, in this case:

  1. Applying restraints to the ligand 
  2. Treatment of temperature coupling groups 

###  Restraining the Ligand

To restrain the ligand, we will need to generate a position restraint topology
for it. First, create an index group for JZ4 that contains only its non-
hydrogen atoms:

    
    
    gmx make_ndx -f jz4.gro -o index_jz4.ndx
    ...
     > 0 & ! a H*
     > q
    

Then, execute the genrestr module and select this newly created index group
(which will be group 3 in the index_jz4.ndx file):

    
    
    gmx genrestr -f jz4.gro -n index_jz4.ndx -o posre_jz4.itp -fc 1000 1000 1000
    

Now, we need to include this information in our topology. We can do this in
several ways, depending upon the conditions we wish to use. If we simply want
to restrain the ligand whenever the protein is also restrained, add the
following lines to your topology in the location indicated:

    
    
    ; Include Position restraint file
    #ifdef POSRES
    #include "posre.itp"
    #endif
    
    ; Include ligand topology
    #include "jz4.itp"
    
    **; Ligand position restraints
    #ifdef POSRES
    #include "posre_jz4.itp"
    #endif**
    
    ; Include water topology
    #include "./charmm36-jul2022.ff/tip3p.itp"
    

Location matters! You must put the call for posre_jz4.itp in the topology as
indicated. The parameters within jz4.itp define a ` [ moleculetype ] `
directive for our ligand. The moleculetype ends with the inclusion of the
water topology (tip3p.itp). Placing the call to posre_jz4.itp anywhere else
will attempt to apply the position restraint parameters to the wrong
moleculetype.

If you want a bit more control during equilibration, i.e. restraining the
protein and ligand independently, you could instead control the inclusion of
the ligand position restraint file in a different #ifdef block, like so:

    
    
    ; Include Position restraint file
    #ifdef POSRES
    #include "posre.itp"
    #endif
    
    ; Include ligand topology
    #include "jz4.itp"
    
    **; Ligand position restraints
    #ifdef POSRES_LIG
    #include "posre_jz4.itp"
    #endif**
    
    ; Include water topology
    #include "./charmm36-jul2022.ff/tip3p.itp"
    

In the latter case, to restrain **both** the protein and the ligand, we would
need to specify ` define = -DPOSRES -DPOSRES_LIG ` in the .mdp file. How you
want to treat your system is up to you. These examples are meant only to
illustrate the flexibility GROMACS provides. For a standard equilibration
procedure, restraining the protein and ligand simultaneously is probably
sufficient. Your own needs may vary.

###  Thermostats

Proper control of temperature coupling is a sensitive issue. Coupling every
moleculetype to its own thermostatting group is a bad idea. For instance, if
you do the following:

    
    
    tc-grps = Protein JZ4 SOL CL
    

Your system will probably blow up, since the temperature coupling algorithms
are not stable enough to control the fluctuations in kinetic energy that
groups with a few atoms (i.e., JZ4 and CL) will produce. ** Do not couple
every single species in your system separately.  **

The typical approach is to set ` tc-grps = Protein Non-Protein ` and carry on.
Unfortunately, the "Non-Protein" group also encompasses JZ4. Since JZ4 and the
protein are physically linked very tightly, it is best to consider them as a
single entity. That is, JZ4 is grouped with the protein for the purposes of
temperature coupling. In the same way, the few Cl  \-  ions we inserted are
considered part of the solvent. To do this, we need a special index group that
merges the protein and JZ4. We accomplish this with the make_ndx module,
supplying any coordinate file of the complete system. Here, I am using em.gro,
the output (minimized) structure of our system:

    
    
    gmx make_ndx -f em.gro -o index.ndx
    ...
      0 System              : 33506 atoms
      1 Protein             :  2614 atoms
      2 Protein-H           :  1301 atoms
      3 C-alpha             :   163 atoms
      4 Backbone            :   489 atoms
      5 MainChain           :   651 atoms
      6 MainChain+Cb        :   803 atoms
      7 MainChain+H         :   813 atoms
      8 SideChain           :  1801 atoms
      9 SideChain-H         :   650 atoms
     10 Prot-Masses         :  2614 atoms
     11 non-Protein         : 30892 atoms
     12 Other               :    22 atoms
     13 JZ4                 :    22 atoms
     14 CL                  :     6 atoms
     15 Water               : 30864 atoms
     16 SOL                 : 30864 atoms
     17 non-Water           :  2642 atoms
     18 Ion                 :     6 atoms
     19 JZ4                 :    22 atoms
     20 CL                  :     6 atoms
     21 Water_and_ions      : 30870 atoms
    

Merge the "Protein" and "JZ4" groups with the following, where ">" indicates
the make_ndx prompt:

    
    
    > 1 | 13
    > q
    

We can now set ` tc-grps = Protein_JZ4 Water_and_ions ` to achieve our desired
"Protein Non-Protein" effect.

Proceed with equilibration using .mdp file.

    
    
    gmx grompp -f nvt.mdp -c em.gro -r em.gro -p topol.top -n index.ndx -o nvt.tpr
    
    gmx mdrun -deffnm nvt
    

|  |  
---|---  
  

 
Protein-Ligand Complex  

##  GROMACS Tutorial

**Step Seven: Equilibration, Part 2**

![](./Images/Steps_equil_highlight.jpg)

Once the simulation is complete, proceed to with .mdp file:

    
    
    gmx grompp -f npt.mdp -c nvt.gro -t nvt.cpt -r nvt.gro -p topol.top -n index.ndx -o npt.tpr
    
    gmx mdrun -deffnm npt
    

|  |  
---|---  
  

 
Protein-Ligand Complex  

##  GROMACS Tutorial

**Step Eight: Production MD**

![](./Images/Steps_MD_highlight.jpg)

Upon completion of the two equilibration phases, the system is now well-
equilibrated at the desired temperature and pressure. We are now ready to
release the position restraints and run production MD for data collection. The
process is just like we have seen before, as we will make use of the
checkpoint file (which in this case now contains preserve pressure coupling
information) to grompp. We will run a 10-ns MD simulation, the script for
which can be found .

    
    
    gmx grompp -f md.mdp -c npt.gro -t npt.cpt -p topol.top -n index.ndx -o md_0_10.tpr
    
    gmx mdrun -deffnm md_0_10
    

|  |  
---|---  
  

 
Protein-Ligand Complex  

##  GROMACS Tutorial

**Step Nine: Analysis**

![](./Images/Steps_analysis_highlight.jpg)

###  Recentering and Rewrapping Coordinates

As in any simulation conducted with periodic boundary conditions, molecules
may appear "broken" or may "jump" back and forth across the box. To recenter
the protein and rewrap the molecules within the unit cell to recover the
desired rhombic dodecahedral shape, invoke trjconv:

    
    
    gmx trjconv -s md_0_10.tpr -f md_0_10.xtc -o md_0_10_center.xtc -center -pbc mol -ur compact
    

Choose "Protein" for centering and "System" for output. Note that centering
complexes (protein-ligand, protein-protein) may be difficult for longer
simulations involving many jumps across periodic boundaries. In those
instances (particularly in protein-protein complexes), it may be necessary to
create a custom index group to use for centering, corresponding to the active
site of one protein or the interfacial residues of one monomer in a complex.

To extract the first frame (t = 0 ns) of the trajectory, use trjconv -dump
with the recentered trajectory:

    
    
    gmx trjconv -s md_0_10.tpr -f md_0_10_center.xtc -o start.pdb -dump 0
    

![](./Images/3htb_t0_rewrap.png)

For even smoother visualization, it may be beneficial to perform rotational
and translational fitting. Execute trjconv as follows:

    
    
    gmx trjconv -s md_0_10.tpr -f md_0_10_center.xtc -o md_0_10_fit.xtc -fit rot+trans
    

Choose "Backbone" to perform least-squares fitting to the protein backbone,
and "System" for output. Note that simultaneous PBC rewrapping and fitting of
the coordinates is mathematically incompatible. Should you wish to perform
fitting (which is useful for visualization, but not necessary for most
analysis routines), carry out these coordinate manipulations separately, as
indicated here.

###  Analyzing Protein-Ligand Interactions and Ligand Dynamics

This tutorial cannot possible cover all analysis methods that you may wish to
perform. A few basic operations will be illustrated here.

The 2-propylphenol ligand can engage in a hydrogen bond with the Gln102 side
chain. The GROMACS hbond module can easily be employed to calculate the number
of hydrogen bonds between any groups of atoms, but in our case, the only
values will be 1 or 0. For a more detailed look at how the ligand is
interacting with Gln102, we will compute the distance between the hydroxyl
group of JZ4 and the carbonyl O atom of Gln102. For a hydrogen bond to be
formed, the typical criterion is that the donor and acceptor atoms will be
separated by a distance ≤ 3.5 Å (0.35 nm). Use the distance module to
calculate the distance over the course of the trajectory, using command-line
selection syntax (see gmx help selections for examples and more syntax).

    
    
    gmx distance -s md_0_10.tpr -f md_0_10_center.xtc -select 'resname "JZ4" and name OAB plus resid 102 and name OE1' -oall
    

The average distance is 0.31 ± 0.05 nm, consistent with the formation of a
hydrogen bond.

The second criterion usually applied in determining the presence of a hydrogen
bond is the angle formed among the donor, hydrogen, and acceptor atoms. There
are different conventions for calculating the angle. In the GROMACS hbond
module, the angle is defined as hydrogen-donor-acceptor, and this angle should
be ≤ 30°. To perform this analysis, first create index groups for the donor
atoms (which must include both the donor heavy atom and the bonded hydrogen)
and the acceptor atom:

    
    
    gmx make_ndx -f em.gro -o index.ndx
    ...
     > 13 & a OAB | a H12
     (creates group 23)
     > 1 & r 102 & a OE1
     (creates group 24)
     > 23 | 24
     > q
    

Analyze the angle formed by these three atoms using the angle module:

    
    
    gmx angle -f md_0_10_center.xtc -n index.ndx -ov angle.xvg
    

Note that angle takes no -s argument, unlike most other GROMACS analysis
modules. Angle calculations do not require mass or periodicity information,
atom names, etc. so the trajectory is processed without a .tpr or coordinate
file. The value returned by the command should be roughly 23 ± 9°. This
outcome may be somewhat unexpected, as the index group we constructed was in
the order of OAB, H12, OE1, which would correspond to the donor-hydrogen-
acceptor distance, which we expect to be close to linear (~180°). Inspect the
contents of the index file and you will find:

    
    
    [ JZ4_&_OAB_H12_Protein_&_r_102_&_OE1 ]
    1616 2624 2636
    

make_ndx has sorted the atom numbers automatically from low to high, thus the
outcome of the calculation is the acceptor-donor-hydrogen angle, the same
angle that the hbond module would have calculated. So the result is consistent
with formation of a hydrogen bond, since it is ≤ 30°. To get the desired angle
of donor-hydrogen-acceptor, we would have to manually edit the index group in
a text file to reorder the atom numbers (2624 2636 1616). Re-running the angle
calculation with this index group yields an average value of 147 ± 11°.

Finally, we may be interested in quantifying how much the ligand binding pose
has changed over the course of the simulation. To compute a heavy-atom RMSD of
just JZ4, create a new index group for it:

    
    
    gmx make_ndx -f em.gro -n index.ndx
    ...
     > 13 & ! a H*
     > name 26 JZ4_Heavy
     > q
    

Execute the rms module, choosing "Backbone" for least-squares fitting and
"JZ4_Heavy" for the RMSD calculation. By doing so, the overall rotation and
translation of the protein is removed via fitting and the RMSD reported is how
much the JZ4 position has varied relative to the protein, which is a good
indicator of how well the binding pose was preserved during the simulation.

    
    
    gmx rms -s em.tpr -f md_0_10_center.xtc -n index.ndx -tu ns -o rmsd_jz4.xvg
    

The calculated RMSD should be about 0.1 nm (1 Å), indicating only a very small
change in the ligand's position.

###  Protein-Ligand Interaction Energy

To quantify the strength of the interaction between JZ4 and T4 lysozyme, it
may be useful to compute the nonbonded interaction energy between these two
species. GROMACS has the ability to decompose the short-range nonbonded
energies between any number of defined groups. It is important to note that
this quantity is **NOT** a free energy or a binding energy. In fact, most
force fields are not parametrized in such a way that this quantity is actually
physically meaningful. CHARMM is parametrized to specifically target quantum
mechanical interaction energies with water, so it is intrinsically balanced
against meaningful quantities, and as such the interaction energy can be
useful.

Calculation of an interaction energy is carried out via the ` energygrps `
keyword in the .mdp file. Despite being an .mdp keyword, interaction energy
calculations should not be considered part of a normal simulation.
Decomposition of the short-range energies is incompatible with running on a
GPU and also slows the calculation down unnecessarily. The mdrun module does
not need to do this extra work to perform a valid simulation. As such, only
compute interaction energies as a part of your analysis, not your dynamics.
Create a new .tpr file from an .mdp file that has ` energygrps = Protein JZ4 `
defined, like :

    
    
    gmx grompp -f ie.mdp -c npt.gro -t npt.cpt -p topol.top -n index.ndx -o ie.tpr
    

Next, invoke mdrun with the -rerun option to recalculate energies from the
existing simulation trajectory:

    
    
    gmx mdrun -deffnm ie -rerun md_0_10.xtc -nb cpu
    

Note the use of -deffnm to read ie.tpr and write all output files to ie.* as
their file names. The -rerun option takes the name of the trajectory for which
you want to recompute energies, and -nb cpu tells mdrun to only attempt to run
on CPU hardware and ignore any GPU that might be available. As stated above,
this type of calculation cannot be performed on a GPU. The rerun should be
very fast, completing in just a few minutes.

Extract the energy terms of interest via the energy module. The terms we are
interested in are Coul-SR:Protein-JZ4 and LJ-SR:Protein-JZ4.

    
    
    gmx energy -f ie.edr -o interaction_energy.xvg
    

The average short-range Coulombic interaction energy is -20.5 ± 7.4 kJ mol  -1
and the short-range Lennard-Jones energy is -99.1 ± 7.2 kJ mol  -1  . It may
be tempting to draw conclusions from the relative magnitudes of these
quantities, but even though CHARMM was parametrized against explicit water
interaction energies, decomposition of interaction energies further into these
components is not necessarily real. There is no way to experimentally verify
these quantities, so it is impossible to know whether they are meaningful. The
**total** interaction energy, however, is useful in this case. That value
(after propagating the error according to the standard formula for addition of
two quantities) is -119.6 ± 10.3 kJ mol  -1  .

|  |  
---|---  
  
  

 
Protein-Ligand Complex  

##  GROMACS Tutorial

**Summary**

![](./Images/Steps_analysis_highlight.jpg)

You have now conducted a molecular dynamics simulation of a protein-ligand
complex with GROMACS. This tutorial should not be viewed as comprehensive.
There are many more types of simulations that one can conduct with GROMACS
(free energy calculations, non-equilibrium MD, and normal modes analysis, just
to name a few). You should also review the literature and the GROMACS manual
for adjustments to the .mdp files provided here for efficiency and accuracy
purposes.

If you have suggestions for improving this tutorial, if you notice a mistake,
or if anything is otherwise unclear, please feel free to . Please note: this
is not an invitation to email me for GROMACS problems. I do not advertise
myself as a private tutor or personal help service. That's what the is for. I
may help you there, but only in the context of providing service to the
community as a whole, not just the end user.

Happy simulating!

|  |  
---|---  
  

 
Protein-Ligand Co 



Umbrella Sampling  

##  GROMACS Tutorial

###  Umbrella Sampling

**Justin A. Lemkul, Ph.D.**  

![](./Images/pull_start.png)  

This tutorial will guide the user through the process of setting up and
running pulling simulations necessary to calculate binding energy between two
species. The tutorial assumes the user has already successfully completed the
, some other tutorial, or is otherwise well-versed in basic GROMACS simulation
methods and topology organization. Special attention will be paid to the
methods for properly building the system and settings for the pull code
itself.

The binding energy (ΔG  bind  ) is derived from the potential of mean force
(PMF), extracted from a series of umbrella sampling simulations. A series of
initial configurations is generated, each corresponding to a location wherein
the molecule of interest (generally referred to as a "ligand") is harmonically
restrained at increasing center-of-mass (COM) distance from some other group
via an umbrella biasing potential. This restraint allows the ligand to sample
the configurational space in a defined region along a reaction coordinate
defined between the two groups. The windows must allow for slight overlap of
the ligand positions for proper reconstruction of the PMF curve.

The steps for such a procedure (and the ones utilized in this tutorial) are as
follows:  

  1. Generate a series of configurations along a single degree of freedom (reaction coordinate) 
  2. Extract frames from the trajectory in step 1 that correspond to the desired COM spacing 
  3. Run umbrella sampling simulations on each configuration to restrain it within a window corresponding to the chosen COM distance 
  4. Use the Weighted Histogram Analysis Method (WHAM) to extract the PMF and calculate ΔG  bind 

The tutorial assumes that the reader is using GROMACS version 2018 or later.
My original work (from which this workflow was derived) was conducted with
version 4.0.5, but in principle can be applied to any version in the 4.0.x or
4.5.x series. The pull code was completely re-written after version 3.3.3, and
again in version 5.1, so satisfying the tutorial requirement of a 2018.x
version is important.

Before continuing, I ask that you read to understand the context for these
simulations. It is **NOT** appropriate to simply apply the settings utilized
here to any system, as there are specific considerations that will be
discussed later. The intention of this tutorial is to provide the user with a
theoretical understanding of umbrella sampling and a practical example that is
drawn directly from the literature.

  
  
  
  
  
---  
  

 
Umbrella Sampling  

##  GROMACS Tutorial

**Step One: Prepare the Topology**

![](./Images/Steps_top_highlight.jpg)

Generating a molecular topology for an umbrella sampling simulation is just
like any other simulation. Obtain the coordinate file of the structure of
interest, and generate the topology from pdb2gmx. Some systems will require
special consideration (i.e., protein-ligand complexes, membrane proteins,
etc). For protein-ligand systems, please consult , and for membrane proteins,
I recommend on the topic. The principles of umbrella sampling are easily
extendable to these systems, though we will consider only protein molecules in
this tutorial.

The system we will consider here is the dissociation of a single peptide from
the growing end of an Aβ  42  protofibril, and is based on simulations . The
structure file of the wild-type Aβ  42  protofibril used in those simulations,
acetylated at the N-terminus of each chain, can be found . The original PDB
accession code is .

Run the structure through pdb2gmx:

    
    
    gmx pdb2gmx -f 2BEG_model1_capped.pdb -ignh -ter -o complex.gro
    

Choose the GROMOS96 53A6 parameter set, SPC water, "None" for the N-termini,
and "COO-" for the C-termini for each chain. Modify topol_Protein_chain_B.itp
to include the following lines (at the end of the file):

    
    
    #ifdef POSRES_B
    #include "posre_Protein_chain_B.itp"
    #endif
    

We will be using chain B as an immobile reference later on in the pulling
simulations, hence the need to specially position-restrain this chain only,
and none of the others.

|  |  
---|---  
  

 
Umbrella Sampling  

##  GROMACS Tutorial

**Step Two: Define the Unit Cell**

![](./Images/Steps_box_highlight.jpg)

Defining the unit cell for a pulling simulation is not unlike defining the
unit cell for any other simulation. There is, however, one major
consideration. One must allow enough space in the pulling direction to allow
for a continuous pull without interacting with the periodic images of the
system. That is, the minimum image convention must be continually satisfied,
and as well, the pull distance must always be less than one-half the length of
the box vector along which the pulling is being conducted. Why, you may ask?

GROMACS calculates distances while simultaneously taking periodicity into
account. This, if you have a 10-nm box, and you pull over a distance greater
than 5.0 nm, the periodic distance becomes the reference distance for the
pulling, and this distance is actually less than 5.0 nm! This fact will
significantly affect results, since the distance you **think** you are pulling
is not what is **actually** calculated.

We will be pulling a total distance of 5.0 nm in a 12.0-nm box, to avoid the
complications described above. The center of mass of the protofibril will be
placed at (3.280, 2.181, 2.4775) in a box of dimensions 6.560 x 4.362 x 12.
Use editconf to place the protofibril at this location:

    
    
    gmx editconf -f complex.gro -o newbox.gro -center 3.280 2.181 2.4775 -box 6.560 4.362 12
    

You can visualize the location of the protofibril within the box using, for
example, VMD. Load the structure in VMD and open the Tk console. Type the
following (note that > indicates the Tk prompt, not something you actually
type):

    
    
    > pbc box
    

You should see something like the following in the VMD window:

![](./Images/box.jpg) |  |  
---|---  
  

 
Umbrella Sampling  

##  GROMACS Tutorial

**Step Three: Adding Solvent and Ions**

![](./Images/Steps_solv_highlight.jpg)

This step is conducted much like any other simulation. Refer to the for a more
detailed description of what is going on here if you are unsure. First, we
will add water with solvate:

    
    
    gmx solvate -cp newbox.gro -cs spc216.gro -o solv.gro -p topol.top
    

Next, we will add ions using genion, utilizing . We are going to be conducting
these simulations in the presence of 100 mM NaCl, on top of neutralizing
counterions:

    
    
    gmx grompp -f ions.mdp -c solv.gro -p topol.top -o ions.tpr
    gmx genion -s ions.tpr -o solv_ions.gro -p topol.top -pname NA -nname CL -neutral -conc 0.1
    

Select group 13 (SOL) to replace water molecules with ions.

|  |  
---|---  
  

 
Umbrella Sampling  

##  GROMACS Tutorial

**Step Four: Energy Minimization and Equilibration**

![](./Images/Steps_EM_highlight.jpg)

The energy minimization and equilibration steps are going to be conducted just
like any other protein-in-water system. Here, we will perform steepest
descents minimization followed by equilibration. The .mdp file for
minimization can be found , and the one for equilibration can be found .

Invoke grompp and mdrun, as usual:

    
    
    gmx grompp -f minim.mdp -c solv_ions.gro -p topol.top -o em.tpr
    gmx mdrun -v -deffnm em
    
    gmx grompp -f npt.mdp -c em.gro -p topol.top -r em.gro -o npt.tpr
    gmx mdrun -deffnm npt
    

|  |  
---|---  
  

 
Umbrella Sampling  

##  GROMACS Tutorial

**Step Five: Generating Configurations**

![](./Images/Steps_configs_highlight.jpg)

To conduct umbrella sampling, one must generate a series of configurations
along a reaction coordinate, ζ. Some of these configurations will serve as the
starting configurations for the umbrella sampling windows, which are run in
independent simulations. The figure below illustrates these principles. The
top image illustrates the pulling simulation we will run now, conducted in
order to generate a series of configurations along the reaction coordinate.
These configurations are extracted after the simulation is complete (dashed
arrows in between the top and middle images). The middle image corresponds to
the independent simulations conducted within each sampling window, with the
center of mass of the free peptide restrained in that window by an umbrella
biasing potential. The bottom images shows the ideal result as a histogram of
configurations, with neighboring windows overlapping such that a continuous
energy function can later be derived from these simulations.

![](./Images/umbrella_schematic2.jpg)

For this example, the reaction coordinate is the -axis. To generate these
configurations, we must pull peptide A away from the protofibril. We will pull
over the course of 500 ps of MD, saving snapshots every 1 ps. This setup has
been established based on trial-and-error to obtain a reasonable distribution
of configurations. In other systems, it may be necessary to save
configurations more often, or sufficient to save configurations less often.
The idea is to capture enough configurations along the reaction coordinate to
obtain regular spacing of the umbrella sampling windows, in terms of center-
of-mass distance between peptides A and B.

The .mdp file for this pulling can be found . A brief explanation of the
pulling options used is as follows:

    
    
    ; Pull code
    pull                    = yes
    pull_ncoords            = 1         ; only one reaction coordinate
    pull_ngroups            = 2         ; two groups defining one reaction coordinate
    pull_group1_name        = Chain_A
    pull_group2_name        = Chain_B
    pull_coord1_type        = umbrella  ; harmonic potential
    pull_coord1_geometry    = distance  ; simple distance increase
    pull_coord1_dim         = N N Y     ; pull along z
    pull_coord1_groups      = 1 2       ; groups 1 (Chain A) and 2 (Chain B) define the reaction coordinate
    pull_coord1_start       = yes       ; define initial COM distance > 0
    pull_coord1_rate        = 0.01      ; 0.01 nm per ps = 10 nm per ns
    pull_coord1_k           = 1000      ; kJ mol^-1 nm^-2
    

  * ` pull = yes ` : tells grompp to read settings for COM pulling. If omitted, all pull settings are ignored 
  * ` pull_ncoords = 1 ` : defines the number of reaction coordinates that are present in the system. This setting allows for multiple biases to be set simultaneously for the purposes of multi-dimensional free energy calculations, but for our purposes here, only one reaction coordinate exists. 
  * ` pull_ngroups = 2 ` : there are two groups that define the ends of the reaction coordinate. The reaction coordinate is the COM distance between these two groups. 
  * ` pull_group1_name = Chain_A ` and ` pull_group2_name = Chain_B ` : the names of the groups used by the pull code, which are read from the index file. Since there are two groups specified in this system ( ` pull_ngroups = 2 ` on the previous line), then two names must be provided. 
  * ` pull_coord1_type = umbrella ` : using a harmonic potential to pull. **IMPORTANT** : This procedure is **NOT** umbrella sampling. The harmonic potential allows the force to vary according to the nature of the interactions of peptide A with peptide B. That is, the force will build up until certain critical interactions are broken. See our for details. For the purposes of generating the initial configurations for umbrella sampling, you can actually use different combinations of pull settings ( ` pull_coord1_type ` and ` pull_coord1_geometry ` ), but when it comes time for the actual umbrella sampling (in the next step) you **MUST** be using ` pull_coord1_type = umbrella ` . It is very important that you do not apply extremely fast pulling rates or extremely strong force constants, which can seriously deform elements of your system. Please refer to (particularly the Supporting Information) for how we chose to validate the pull rate used. Also note that this is the first setting in which "coord1" appears as part of the keyword name. For every reaction coordinate defined ( ` pull_ncoords ` ), all of the settings shown above are necessary. If there is a second reaction coordinate, the settings would be named "coord2," a third "coord3," and so on. 
  * ` pull_coord1_geometry = distance ` : see the note the in .mdp file; you can also use ` position ` , ` direction ` , or ` direction-periodic ` , but changes will have to be made to other pulling parameters. Doing so is left as an exercise to the user. 
  * ` pull_coord1_dim = N N Y ` : we are applying a bias only in the -dimension. Thus, and are set to "no" (N) and is set to "yes" (Y). 
  * ` pull_coord1_groups ` : the reaction coordinate connects groups 1 and 2. 
  * ` pull_coord1_start = yes ` : the initial COM distance is the reference distance for the first frame. More on this setting in the next phase, during which actual umbrella sampling simulations are carried out 
  * ` pull_coord1_rate = 0.01 ` : the rate at which the imaginary spring attached to our pull groups is elongated. This type of pulling is also called "constant velocity" due to the fact that this rate is fixed. 
  * ` pull_coord1_k = 1000 ` : the force constant on the spring used for pulling. 

Remember that ` #ifdef POSRES_B ` statement we added to topol_B.itp a while
ago? We're going to use it now. By restraining peptide B of the protofibril,
we are able to more easily pull peptide A away. Due to the extensive non-
covalent interactions between chains A and B, if we did not restrain chain B,
we would end up simply towing the whole complex along the simulation box,
which wouldn't accomplish much.

We will need to define some custom index groups for this pulling simulation.
Use make_ndx:

    
    
    gmx make_ndx -f npt.gro
    ...
     > r 1-27
     > name 19 Chain_A
     > r 28-54
     > name 20 Chain_B
     > q
    

Now, run the steered MD simulation:

    
    
    gmx grompp -f md_pull.mdp -c npt.gro -p topol.top -r npt.gro -n index.ndx -t npt.cpt -o pull.tpr
    gmx mdrun -deffnm pull -pf pullf.xvg -px pullx.xvg
    

The process will play out something like the following:

![](Images/movie_smd_loop.gif)

There is no displacement for some time, as the force on the imaginary spring
builds up until it is sufficient to overcome the restoring forces within the
protofibril structure. About halfway through the SMD simulation, chain A
begins to dissociate from chain B. This process is also visible in the force
on the spring over time, stored in pullf.xvg:

![](Images/umbrella_smd_pullf.png)

To prepare the individual umbrella sampling windows, we will need to extract
useful frames from the SMD trajectory. The easiest way I have found to do this
is the following:

  1. Define the spacing of the windows (generally 0.1 - 0.2 nm) 
  2. Extract all the frames from the pulling trajectory that was just produced 
  3. Measure the COM distance of each of these frames between the two groups defining the reaction coordinate 
  4. Use the selected frames for umbrella sampling input 

To extract the frames from your trajectory (traj.xtc), use trjconv (save the
whole system, group 0, when prompted):

    
    
    gmx trjconv -s pull.tpr -f pull.xtc -o conf.gro -sep
    

A series of coordinate files (conf0.gro, conf1.gro, etc) will be produced,
corresponding to each of the frames saved in the continuous pulling
simulation. To iteratively call gmx distance on all of these (501!) frames
that were generated, I have written a Bash script that takes care of this
task. It will print a file called "summary_distances.dat" that contains this
information. The script can be found .

Look at the contents of summary_distances.dat to see the progression of COM
distance between chain A and chain B over time. Make note of the
configurations to be used for umbrella sampling, based on the desired spacing.
That is, if you want 0.2-nm spacing, you might find the following lines in
summary_distances.dat:

    
    
    6     0.500
    ...
    160    0.704
    

You would then use conf6.gro and conf160.gro as the starting configurations of
two adjacent umbrella sampling windows. Make note of all the configurations
you wish to use before continuing. For the purposes of this tutorial,
identifying configurations with 0.2-nm spacing will suffice, although in the
original work a different spacing was used to more thoroughly define the free
energy at the energy minimum.

|  |  
---|---  
  

 
Umbrella Sampling  

##  GROMACS Tutorial

**Step Six: Umbrella Sampling Simulations**

![](./Images/Steps_umbrella_highlight.jpg)

In this example, we will be sampling COM distances from 0.5 - 5.0 nm along the
z-axis using roughly 0.2-nm spacing. The following example commands may or may
not be literally correct (the frame numbers may differ), but will serve as an
example as to how to run grompp on separate coordinate files to generate all
23 inputs (note as well that 23 is the amount of windows required to obtain
0.2-nm spacing over roughly 4.5 nm; in our , 31 asymmetric windows were used).

After having identified the initial configurations of the sampling windows, we
can now prepare the umbrella sampling simulations. We will need to generate a
number of input files in order to conduct each of the necessary simulations.
For example, since we have identified 23 configurations along the reaction
coordinate, that means we will need 23 different input files for 23
independent simulations. Start by running a brief equilibration in each window
using .

First grompp (input conf*.gro file names may differ based on your individual
SMD simulation outcome):

    
    
    gmx grompp -f npt_umbrella.mdp -c conf6.gro -p topol.top -r conf6.gro -n index.ndx -o npt0.tpr
    ...
    gmx grompp -f npt_umbrella.mdp -c conf449.gro -p topol.top -r conf449.gro -n index.ndx -o npt22.tpr
    

Then mdrun:

    
    
    gmx mdrun -deffnm npt0
    ...
    gmx mdrun -deffnm npt22
    

To start umbrella sampling, you will simply have to call grompp to process for
each of the now-equilibrated configurations. Many of the pulling parameters
are the same as in the SMD procedure, with the notable exception of `
pull_coord1_rate ` , which has now been set to zero. We don't want to move the
configuration along the reaction coordinate; instead we want to restrain it
within a defined window of configurational space. Setting ` pull_coord1_start
= yes ` means that the initial COM distance is the reference distance, and we
do not have to define a reference ( ` pull_coord1_init ` ) separately for each
configuration.

    
    
    gmx grompp -f md_umbrella.mdp -c npt0.gro -t npt0.cpt -p topol.top -r npt0.gro -n index.ndx -o umbrella0.tpr
    ...
    gmx grompp -f md_umbrella.mdp -c npt22.gro -t npt22.cpt -p topol.top -r npt22.gro -n index.ndx -o umbrella22.tpr
    

Now, each input file should be passed to mdrun for the actual data collection
simulation. Once all of the simulations are complete, you can proceed to data
analysis.

    
    
    gmx mdrun -deffnm umbrella0
    ...
    gmx mdrun -deffnm umbrella22
    

Mike Harms has contributed a Python script that automates this process,
extracting coordinate files and setting up the grompp and mdrun commands to
streamline this process. You can download his script and associated
documentation . Please if you have any feedback regarding this script or its
use. Thanks for the contribution, Mike!

|  |  
---|---  
  
  

 
Umbrella Sampling  

##  GROMACS Tutorial

**Step Seven: Data Analysis**

![](./Images/Steps_analysis_highlight.jpg)

The most common analysis conducted for umbrella sampling simulations is the
extraction of the potential of mean force (PMF), which will yield the ΔG for
the binding/unbinding process. The value of ΔG is simply the difference
between the highest and lowest values of the PMF curve, as long as the values
of the PMF converge to a stable value at large COM distance. A common method
for extracting PMF is the Weighted Histogram Analysis Method (WHAM), included
in GROMACS as the wham module. The input to wham consists of two files, one
that lists the names of the .tpr files of each window, and the other that
lists the names of either the pullf.xvg or pullx.xvg files from each window.
For example, a simple tpr-files.dat might consist of:

    
    
    umbrella0.tpr
    umbrella1.tpr
    ...
    umbrella22.tpr
    

And analogously for the list of pullf.xvg or pullx.xvg files, in either pullf-
files.dat or pullx-files.dat. Note that the files must have unique names
(i.e., umbrella0_pullf.xvg, umbrella1_pullf.xvg, etc) or else wham will fail.
List the files in pullf-files.dat in the same manner as tpr-files.dat:

    
    
    umbrella0_pullf.xvg
    umbrella1_pullf.xvg
    ...
    umbrella22_pullf.xvg
    

We then run gmx wham:

    
    
    gmx wham -it tpr-files.dat -if pullf-files.dat -o -hist -unit kCal
    

The wham module will then open each of the umbrella*.tpr and
umbrella*_pullf.xvg files sequentially and run the WHAM analysis on them. The
` -unit kCal ` option indicates that the output will be in kcal mol  -1  , but
you can also get results in kJ mol  -1  or k  B  T. The resulting PMF and
corresponding umbrella histograms will look something like:

![](./Images/umbrella_composite_pmf_histo.png)

The result obtained here corresponds to ΔG = 46 kcal mol  -1  , comparable to
our published value of 50.5 kcal mol  -1  . Some difference is expected since
the window spacing was not identical and the starting configuration was
different. Note in particular that there is a defect in the PMF profile around
ξ = 0.8 nm, reflecting a lack of sampling that is apparent in the histograms.
This region of ξ is a high-energy state, and since there was no window
centered on this region of the reaction coordinate, sampling was inadequate.
To fix this problem, carry out an additional simulation with a window centered
at ξ = 0.8 nm. As all of the umbrella sampling window simulations are
independent, the others do not have to be re-run, just include the new
umbrella.tpr and umbrella_pullf.xvg files in your WHAM input and re-run the
WHAM analysis.

  
|  |  
---|---  
  

 
Umbrella Sampling  

##  GROMACS Tutorial

**Summary**

![](./Images/Steps_analysis_highlight.jpg)

You have now hopefully been successful in conducting umbrella sampling
simulations by generating a series of configurations along a reaction
coordinate, running biasing simulations, and extracting the PMF. The .mdp
files provided here serve as examples only, and should not be considered
broadly applicable to all systems. Review the literature and the GROMACS
manual for adjustments to these files for efficiency and accuracy purposes.

If you have suggestions for improving this tutorial, if you notice a mistake,
or if anything else is unclear, please feel free to . Please note: this is not
an invitation to email me for GROMACS problems. I do not advertise myself as a
private tutor or personal help service. That's what the is for. I may help you
there, but only in the context of providing service to the community as a
whole, not just the end user.

Happy simulating!

|  |  
---|---  
  

 
Umbrella Sampling  

##  GROMACS Tutorial

###  Umbrella Sampling

**Justin A. Lemkul, Ph.D.**  

![](./Images/pull_start.png)  

This tutorial will guide the user through the process of setting up and
running pulling simulations necessary to calculate binding energy between two
species. The tutorial assumes the user has already successfully completed the
, some other tutorial, or is otherwise well-versed in basic GROMACS simulation
methods and topology organization. Special attention will be paid to the
methods for properly building the system and settings for the pull code
itself.

The binding energy (ΔG  bind  ) is derived from the potential of mean force
(PMF), extracted from a series of umbrella sampling simulations. A series of
initial configurations is generated, each corresponding to a location wherein
the molecule of interest (generally referred to as a "ligand") is harmonically
restrained at increasing center-of-mass (COM) distance from some other group
via an umbrella biasing potential. This restraint allows the ligand to sample
the configurational space in a defined region along a reaction coordinate
defined between the two groups. The windows must allow for slight overlap of
the ligand positions for proper reconstruction of the PMF curve.

The steps for such a procedure (and the ones utilized in this tutorial) are as
follows:  

  1. Generate a series of configurations along a single degree of freedom (reaction coordinate) 
  2. Extract frames from the trajectory in step 1 that correspond to the desired COM spacing 
  3. Run umbrella sampling simulations on each configuration to restrain it within a window corresponding to the chosen COM distance 
  4. Use the Weighted Histogram Analysis Method (WHAM) to extract the PMF and calculate ΔG  bind 

The tutorial assumes that the reader is using GROMACS version 2018 or later.
My original work (from which this workflow was derived) was conducted with
version 4.0.5, but in principle can be applied to any version in the 4.0.x or
4.5.x series. The pull code was completely re-written after version 3.3.3, and
again in version 5.1, so satisfying the tutorial requirement of a 2018.x
version is important.

Before continuing, I ask that you read to understand the context for these
simulations. It is **NOT** appropriate to simply apply the settings utilized
here to any system, as there are specific considerations that will be
discussed later. The intention of this tutorial is to provide the user with a
theoretical understanding of umbrella sampling and a practical example that is
drawn directly from the literature.

  
  
  
  
  
---  
  

 
Umbrella Sampling  

##  GROMACS Tutorial

**Step One: Prepare the Topology**

![](./Images/Steps_top_highlight.jpg)

Generating a molecular topology for an umbrella sampling simulation is just
like any other simulation. Obtain the coordinate file of the structure of
interest, and generate the topology from pdb2gmx. Some systems will require
special consideration (i.e., protein-ligand complexes, membrane proteins,
etc). For protein-ligand systems, please consult , and for membrane proteins,
I recommend on the topic. The principles of umbrella sampling are easily
extendable to these systems, though we will consider only protein molecules in
this tutorial.

The system we will consider here is the dissociation of a single peptide from
the growing end of an Aβ  42  protofibril, and is based on simulations . The
structure file of the wild-type Aβ  42  protofibril used in those simulations,
acetylated at the N-terminus of each chain, can be found . The original PDB
accession code is .

Run the structure through pdb2gmx:

    
    
    gmx pdb2gmx -f 2BEG_model1_capped.pdb -ignh -ter -o complex.gro
    

Choose the GROMOS96 53A6 parameter set, SPC water, "None" for the N-termini,
and "COO-" for the C-termini for each chain. Modify topol_Protein_chain_B.itp
to include the following lines (at the end of the file):

    
    
    #ifdef POSRES_B
    #include "posre_Protein_chain_B.itp"
    #endif
    

We will be using chain B as an immobile reference later on in the pulling
simulations, hence the need to specially position-restrain this chain only,
and none of the others.

|  |  
---|---  
  

 
Umbrella Sampling  

##  GROMACS Tutorial

**Step Two: Define the Unit Cell**

![](./Images/Steps_box_highlight.jpg)

Defining the unit cell for a pulling simulation is not unlike defining the
unit cell for any other simulation. There is, however, one major
consideration. One must allow enough space in the pulling direction to allow
for a continuous pull without interacting with the periodic images of the
system. That is, the minimum image convention must be continually satisfied,
and as well, the pull distance must always be less than one-half the length of
the box vector along which the pulling is being conducted. Why, you may ask?

GROMACS calculates distances while simultaneously taking periodicity into
account. This, if you have a 10-nm box, and you pull over a distance greater
than 5.0 nm, the periodic distance becomes the reference distance for the
pulling, and this distance is actually less than 5.0 nm! This fact will
significantly affect results, since the distance you **think** you are pulling
is not what is **actually** calculated.

We will be pulling a total distance of 5.0 nm in a 12.0-nm box, to avoid the
complications described above. The center of mass of the protofibril will be
placed at (3.280, 2.181, 2.4775) in a box of dimensions 6.560 x 4.362 x 12.
Use editconf to place the protofibril at this location:

    
    
    gmx editconf -f complex.gro -o newbox.gro -center 3.280 2.181 2.4775 -box 6.560 4.362 12
    

You can visualize the location of the protofibril within the box using, for
example, VMD. Load the structure in VMD and open the Tk console. Type the
following (note that > indicates the Tk prompt, not something you actually
type):

    
    
    > pbc box
    

You should see something like the following in the VMD window:

![](./Images/box.jpg) |  |  
---|---  
  

 
Umbrella Sampling  

##  GROMACS Tutorial

**Step Three: Adding Solvent and Ions**

![](./Images/Steps_solv_highlight.jpg)

This step is conducted much like any other simulation. Refer to the for a more
detailed description of what is going on here if you are unsure. First, we
will add water with solvate:

    
    
    gmx solvate -cp newbox.gro -cs spc216.gro -o solv.gro -p topol.top
    

Next, we will add ions using genion, utilizing . We are going to be conducting
these simulations in the presence of 100 mM NaCl, on top of neutralizing
counterions:

    
    
    gmx grompp -f ions.mdp -c solv.gro -p topol.top -o ions.tpr
    gmx genion -s ions.tpr -o solv_ions.gro -p topol.top -pname NA -nname CL -neutral -conc 0.1
    

Select group 13 (SOL) to replace water molecules with ions.

|  |  
---|---  
  

 
Umbrella Sampling  

##  GROMACS Tutorial

**Step Four: Energy Minimization and Equilibration**

![](./Images/Steps_EM_highlight.jpg)

The energy minimization and equilibration steps are going to be conducted just
like any other protein-in-water system. Here, we will perform steepest
descents minimization followed by equilibration. The .mdp file for
minimization can be found , and the one for equilibration can be found .

Invoke grompp and mdrun, as usual:

    
    
    gmx grompp -f minim.mdp -c solv_ions.gro -p topol.top -o em.tpr
    gmx mdrun -v -deffnm em
    
    gmx grompp -f npt.mdp -c em.gro -p topol.top -r em.gro -o npt.tpr
    gmx mdrun -deffnm npt
    

|  |  
---|---  
  

 
Umbrella Sampling  

##  GROMACS Tutorial

**Step Five: Generating Configurations**

![](./Images/Steps_configs_highlight.jpg)

To conduct umbrella sampling, one must generate a series of configurations
along a reaction coordinate, ζ. Some of these configurations will serve as the
starting configurations for the umbrella sampling windows, which are run in
independent simulations. The figure below illustrates these principles. The
top image illustrates the pulling simulation we will run now, conducted in
order to generate a series of configurations along the reaction coordinate.
These configurations are extracted after the simulation is complete (dashed
arrows in between the top and middle images). The middle image corresponds to
the independent simulations conducted within each sampling window, with the
center of mass of the free peptide restrained in that window by an umbrella
biasing potential. The bottom images shows the ideal result as a histogram of
configurations, with neighboring windows overlapping such that a continuous
energy function can later be derived from these simulations.

![](./Images/umbrella_schematic2.jpg)

For this example, the reaction coordinate is the -axis. To generate these
configurations, we must pull peptide A away from the protofibril. We will pull
over the course of 500 ps of MD, saving snapshots every 1 ps. This setup has
been established based on trial-and-error to obtain a reasonable distribution
of configurations. In other systems, it may be necessary to save
configurations more often, or sufficient to save configurations less often.
The idea is to capture enough configurations along the reaction coordinate to
obtain regular spacing of the umbrella sampling windows, in terms of center-
of-mass distance between peptides A and B.

The .mdp file for this pulling can be found . A brief explanation of the
pulling options used is as follows:

    
    
    ; Pull code
    pull                    = yes
    pull_ncoords            = 1         ; only one reaction coordinate
    pull_ngroups            = 2         ; two groups defining one reaction coordinate
    pull_group1_name        = Chain_A
    pull_group2_name        = Chain_B
    pull_coord1_type        = umbrella  ; harmonic potential
    pull_coord1_geometry    = distance  ; simple distance increase
    pull_coord1_dim         = N N Y     ; pull along z
    pull_coord1_groups      = 1 2       ; groups 1 (Chain A) and 2 (Chain B) define the reaction coordinate
    pull_coord1_start       = yes       ; define initial COM distance > 0
    pull_coord1_rate        = 0.01      ; 0.01 nm per ps = 10 nm per ns
    pull_coord1_k           = 1000      ; kJ mol^-1 nm^-2
    

  * ` pull = yes ` : tells grompp to read settings for COM pulling. If omitted, all pull settings are ignored 
  * ` pull_ncoords = 1 ` : defines the number of reaction coordinates that are present in the system. This setting allows for multiple biases to be set simultaneously for the purposes of multi-dimensional free energy calculations, but for our purposes here, only one reaction coordinate exists. 
  * ` pull_ngroups = 2 ` : there are two groups that define the ends of the reaction coordinate. The reaction coordinate is the COM distance between these two groups. 
  * ` pull_group1_name = Chain_A ` and ` pull_group2_name = Chain_B ` : the names of the groups used by the pull code, which are read from the index file. Since there are two groups specified in this system ( ` pull_ngroups = 2 ` on the previous line), then two names must be provided. 
  * ` pull_coord1_type = umbrella ` : using a harmonic potential to pull. **IMPORTANT** : This procedure is **NOT** umbrella sampling. The harmonic potential allows the force to vary according to the nature of the interactions of peptide A with peptide B. That is, the force will build up until certain critical interactions are broken. See our for details. For the purposes of generating the initial configurations for umbrella sampling, you can actually use different combinations of pull settings ( ` pull_coord1_type ` and ` pull_coord1_geometry ` ), but when it comes time for the actual umbrella sampling (in the next step) you **MUST** be using ` pull_coord1_type = umbrella ` . It is very important that you do not apply extremely fast pulling rates or extremely strong force constants, which can seriously deform elements of your system. Please refer to (particularly the Supporting Information) for how we chose to validate the pull rate used. Also note that this is the first setting in which "coord1" appears as part of the keyword name. For every reaction coordinate defined ( ` pull_ncoords ` ), all of the settings shown above are necessary. If there is a second reaction coordinate, the settings would be named "coord2," a third "coord3," and so on. 
  * ` pull_coord1_geometry = distance ` : see the note the in .mdp file; you can also use ` position ` , ` direction ` , or ` direction-periodic ` , but changes will have to be made to other pulling parameters. Doing so is left as an exercise to the user. 
  * ` pull_coord1_dim = N N Y ` : we are applying a bias only in the -dimension. Thus, and are set to "no" (N) and is set to "yes" (Y). 
  * ` pull_coord1_groups ` : the reaction coordinate connects groups 1 and 2. 
  * ` pull_coord1_start = yes ` : the initial COM distance is the reference distance for the first frame. More on this setting in the next phase, during which actual umbrella sampling simulations are carried out 
  * ` pull_coord1_rate = 0.01 ` : the rate at which the imaginary spring attached to our pull groups is elongated. This type of pulling is also called "constant velocity" due to the fact that this rate is fixed. 
  * ` pull_coord1_k = 1000 ` : the force constant on the spring used for pulling. 

Remember that ` #ifdef POSRES_B ` statement we added to topol_B.itp a while
ago? We're going to use it now. By restraining peptide B of the protofibril,
we are able to more easily pull peptide A away. Due to the extensive non-
covalent interactions between chains A and B, if we did not restrain chain B,
we would end up simply towing the whole complex along the simulation box,
which wouldn't accomplish much.

We will need to define some custom index groups for this pulling simulation.
Use make_ndx:

    
    
    gmx make_ndx -f npt.gro
    ...
     > r 1-27
     > name 19 Chain_A
     > r 28-54
     > name 20 Chain_B
     > q
    

Now, run the steered MD simulation:

    
    
    gmx grompp -f md_pull.mdp -c npt.gro -p topol.top -r npt.gro -n index.ndx -t npt.cpt -o pull.tpr
    gmx mdrun -deffnm pull -pf pullf.xvg -px pullx.xvg
    

The process will play out something like the following:

![](Images/movie_smd_loop.gif)

There is no displacement for some time, as the force on the imaginary spring
builds up until it is sufficient to overcome the restoring forces within the
protofibril structure. About halfway through the SMD simulation, chain A
begins to dissociate from chain B. This process is also visible in the force
on the spring over time, stored in pullf.xvg:

![](Images/umbrella_smd_pullf.png)

To prepare the individual umbrella sampling windows, we will need to extract
useful frames from the SMD trajectory. The easiest way I have found to do this
is the following:

  1. Define the spacing of the windows (generally 0.1 - 0.2 nm) 
  2. Extract all the frames from the pulling trajectory that was just produced 
  3. Measure the COM distance of each of these frames between the two groups defining the reaction coordinate 
  4. Use the selected frames for umbrella sampling input 

To extract the frames from your trajectory (traj.xtc), use trjconv (save the
whole system, group 0, when prompted):

    
    
    gmx trjconv -s pull.tpr -f pull.xtc -o conf.gro -sep
    

A series of coordinate files (conf0.gro, conf1.gro, etc) will be produced,
corresponding to each of the frames saved in the continuous pulling
simulation. To iteratively call gmx distance on all of these (501!) frames
that were generated, I have written a Bash script that takes care of this
task. It will print a file called "summary_distances.dat" that contains this
information. The script can be found .

Look at the contents of summary_distances.dat to see the progression of COM
distance between chain A and chain B over time. Make note of the
configurations to be used for umbrella sampling, based on the desired spacing.
That is, if you want 0.2-nm spacing, you might find the following lines in
summary_distances.dat:

    
    
    6     0.500
    ...
    160    0.704
    

You would then use conf6.gro and conf160.gro as the starting configurations of
two adjacent umbrella sampling windows. Make note of all the configurations
you wish to use before continuing. For the purposes of this tutorial,
identifying configurations with 0.2-nm spacing will suffice, although in the
original work a different spacing was used to more thoroughly define the free
energy at the energy minimum.

|  |  
---|---  
  

 
Umbrella Sampling  

##  GROMACS Tutorial

**Step Six: Umbrella Sampling Simulations**

![](./Images/Steps_umbrella_highlight.jpg)

In this example, we will be sampling COM distances from 0.5 - 5.0 nm along the
z-axis using roughly 0.2-nm spacing. The following example commands may or may
not be literally correct (the frame numbers may differ), but will serve as an
example as to how to run grompp on separate coordinate files to generate all
23 inputs (note as well that 23 is the amount of windows required to obtain
0.2-nm spacing over roughly 4.5 nm; in our , 31 asymmetric windows were used).

After having identified the initial configurations of the sampling windows, we
can now prepare the umbrella sampling simulations. We will need to generate a
number of input files in order to conduct each of the necessary simulations.
For example, since we have identified 23 configurations along the reaction
coordinate, that means we will need 23 different input files for 23
independent simulations. Start by running a brief equilibration in each window
using .

First grompp (input conf*.gro file names may differ based on your individual
SMD simulation outcome):

    
    
    gmx grompp -f npt_umbrella.mdp -c conf6.gro -p topol.top -r conf6.gro -n index.ndx -o npt0.tpr
    ...
    gmx grompp -f npt_umbrella.mdp -c conf449.gro -p topol.top -r conf449.gro -n index.ndx -o npt22.tpr
    

Then mdrun:

    
    
    gmx mdrun -deffnm npt0
    ...
    gmx mdrun -deffnm npt22
    

To start umbrella sampling, you will simply have to call grompp to process for
each of the now-equilibrated configurations. Many of the pulling parameters
are the same as in the SMD procedure, with the notable exception of `
pull_coord1_rate ` , which has now been set to zero. We don't want to move the
configuration along the reaction coordinate; instead we want to restrain it
within a defined window of configurational space. Setting ` pull_coord1_start
= yes ` means that the initial COM distance is the reference distance, and we
do not have to define a reference ( ` pull_coord1_init ` ) separately for each
configuration.

    
    
    gmx grompp -f md_umbrella.mdp -c npt0.gro -t npt0.cpt -p topol.top -r npt0.gro -n index.ndx -o umbrella0.tpr
    ...
    gmx grompp -f md_umbrella.mdp -c npt22.gro -t npt22.cpt -p topol.top -r npt22.gro -n index.ndx -o umbrella22.tpr
    

Now, each input file should be passed to mdrun for the actual data collection
simulation. Once all of the simulations are complete, you can proceed to data
analysis.

    
    
    gmx mdrun -deffnm umbrella0
    ...
    gmx mdrun -deffnm umbrella22
    

Mike Harms has contributed a Python script that automates this process,
extracting coordinate files and setting up the grompp and mdrun commands to
streamline this process. You can download his script and associated
documentation . Please if you have any feedback regarding this script or its
use. Thanks for the contribution, Mike!

|  |  
---|---  
  
  

 
Umbrella Sampling  

##  GROMACS Tutorial

**Step Seven: Data Analysis**

![](./Images/Steps_analysis_highlight.jpg)

The most common analysis conducted for umbrella sampling simulations is the
extraction of the potential of mean force (PMF), which will yield the ΔG for
the binding/unbinding process. The value of ΔG is simply the difference
between the highest and lowest values of the PMF curve, as long as the values
of the PMF converge to a stable value at large COM distance. A common method
for extracting PMF is the Weighted Histogram Analysis Method (WHAM), included
in GROMACS as the wham module. The input to wham consists of two files, one
that lists the names of the .tpr files of each window, and the other that
lists the names of either the pullf.xvg or pullx.xvg files from each window.
For example, a simple tpr-files.dat might consist of:

    
    
    umbrella0.tpr
    umbrella1.tpr
    ...
    umbrella22.tpr
    

And analogously for the list of pullf.xvg or pullx.xvg files, in either pullf-
files.dat or pullx-files.dat. Note that the files must have unique names
(i.e., umbrella0_pullf.xvg, umbrella1_pullf.xvg, etc) or else wham will fail.
List the files in pullf-files.dat in the same manner as tpr-files.dat:

    
    
    umbrella0_pullf.xvg
    umbrella1_pullf.xvg
    ...
    umbrella22_pullf.xvg
    

We then run gmx wham:

    
    
    gmx wham -it tpr-files.dat -if pullf-files.dat -o -hist -unit kCal
    

The wham module will then open each of the umbrella*.tpr and
umbrella*_pullf.xvg files sequentially and run the WHAM analysis on them. The
` -unit kCal ` option indicates that the output will be in kcal mol  -1  , but
you can also get results in kJ mol  -1  or k  B  T. The resulting PMF and
corresponding umbrella histograms will look something like:

![](./Images/umbrella_composite_pmf_histo.png)

The result obtained here corresponds to ΔG = 46 kcal mol  -1  , comparable to
our published value of 50.5 kcal mol  -1  . Some difference is expected since
the window spacing was not identical and the starting configuration was
different. Note in particular that there is a defect in the PMF profile around
ξ = 0.8 nm, reflecting a lack of sampling that is apparent in the histograms.
This region of ξ is a high-energy state, and since there was no window
centered on this region of the reaction coordinate, sampling was inadequate.
To fix this problem, carry out an additional simulation with a window centered
at ξ = 0.8 nm. As all of the umbrella sampling window simulations are
independent, the others do not have to be re-run, just include the new
umbrella.tpr and umbrella_pullf.xvg files in your WHAM input and re-run the
WHAM analysis.

  
|  |  
---|---  
  

 
Umbrella Sampling  

##  GROMACS Tutorial

**Summary**

![](./Images/Steps_analysis_highlight.jpg)

You have now hopefully been successful in conducting umbrella sampling
simulations by generating a series of configurations along a reaction
coordinate, running biasing simulations, and extracting the PMF. The .mdp
files provided here serve as examples only, and should not be considered
broadly applicable to all systems. Review the literature and the GROMACS
manual for adjustments to these files for efficiency and accuracy purposes.

If you have suggestions for improving this tutorial, if you notice a mistake,
or if anything else is unclear, please feel free to . Please note: this is not
an invitation to email me for GROMACS problems. I do not advertise myself as a
private tutor or personal help service. That's what the is for. I may help you
there, but only in the context of providing service to the community as a
whole, not just the end user.

Happy simulating!

|  |  
---|---  
  

 
Umbrella Sampling  

##  GROMACS Tutorial

###  Umbrella Sampling

**Justin A. Lemkul, Ph.D.**  

![](./Images/pull_start.png)  

Thi 
